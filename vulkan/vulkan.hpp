// Copyright (c) 2015-2018 The Khronos Group Inc.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// ---- Exceptions to the Apache 2.0 License: ----
// 
// As an exception, if you use this Software to generate code and portions of
// this Software are embedded into the generated code as a result, you may
// redistribute such product without providing attribution as would otherwise
// be required by Sections 4(a), 4(b) and 4(d) of the License.
// 
// In addition, if you combine or link code generated by this Software with
// software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
// ("`Combined Software`") and if a court of competent jurisdiction determines
// that the patent provision (Section 3), the indemnity provision (Section 9)
// or other Section of the License conflicts with the conditions of the
// applicable GPL or LGPL license, you may retroactively and prospectively
// choose to deem waived or otherwise exclude such Section(s) of the License,
// but only in their entirety and only with respect to the Combined Software.
//     

// This header is generated from the Khronos Vulkan XML API Registry.

#ifndef VULKAN_HPP
#define VULKAN_HPP

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <initializer_list>
#include <string>
#include <system_error>
#include <tuple>
#include <type_traits>
#include <vulkan/vulkan.h>
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
# include <memory>
# include <vector>
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#if !defined(VULKAN_HPP_ASSERT)
# include <cassert>
# define VULKAN_HPP_ASSERT   assert
#endif

// <tuple> includes <sys/sysmacros.h> through some other header
// this results in major(x) being resolved to gnu_dev_major(x)
// which is an expression in a constructor initializer list.
#if defined(major)
  #undef major
#endif
#if defined(minor)
  #undef minor
#endif

// Windows defines MemoryBarrier which is deprecated and collides
// with the vk::MemoryBarrier struct.
#ifdef MemoryBarrier
  #undef MemoryBarrier
#endif

static_assert( VK_HEADER_VERSION ==  85 , "Wrong VK_HEADER_VERSION!" );

// 32-bit vulkan is not typesafe for handles, so don't allow copy constructors on this platform by default.
// To enable this feature on 32-bit platforms please define VULKAN_HPP_TYPESAFE_CONVERSION
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
# if !defined( VULKAN_HPP_TYPESAFE_CONVERSION )
#  define VULKAN_HPP_TYPESAFE_CONVERSION
# endif
#endif

#if !defined(VULKAN_HPP_HAS_UNRESTRICTED_UNIONS)
# if defined(__clang__)
#  if __has_feature(cxx_unrestricted_unions)
#   define VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
#  endif
# elif defined(__GNUC__)
#  define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
#  if 40600 <= GCC_VERSION
#   define VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
#  endif
# elif defined(_MSC_VER)
#  if 1900 <= _MSC_VER
#   define VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
#  endif
# endif
#endif

#if !defined(VULKAN_HPP_INLINE)
# if defined(__clang___)
#  if __has_attribute(always_inline)
#   define VULKAN_HPP_INLINE __attribute__((always_inline)) __inline__
#  else
#    define VULKAN_HPP_INLINE inline
#  endif
# elif defined(__GNUC__)
#  define VULKAN_HPP_INLINE __attribute__((always_inline)) __inline__
# elif defined(_MSC_VER)
#  define VULKAN_HPP_INLINE inline
# else
#  define VULKAN_HPP_INLINE inline
# endif
#endif

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
# define VULKAN_HPP_TYPESAFE_EXPLICIT
#else
# define VULKAN_HPP_TYPESAFE_EXPLICIT explicit
#endif

#if defined(_MSC_VER) && (_MSC_VER <= 1800)
# define VULKAN_HPP_CONSTEXPR
#else
# define VULKAN_HPP_CONSTEXPR constexpr
#endif


#if !defined(VULKAN_HPP_NAMESPACE)
#define VULKAN_HPP_NAMESPACE vk
#endif

#define VULKAN_HPP_STRINGIFY2(text) #text
#define VULKAN_HPP_STRINGIFY(text) VULKAN_HPP_STRINGIFY2(text)
#define VULKAN_HPP_NAMESPACE_STRING VULKAN_HPP_STRINGIFY(VULKAN_HPP_NAMESPACE)

namespace VULKAN_HPP_NAMESPACE
{

  template <typename FlagBitsType> struct FlagTraits
  {
    enum { allFlags = 0 };
  };

  template <typename BitType, typename MaskType = VkFlags>
  class Flags
  {
  public:
    VULKAN_HPP_CONSTEXPR Flags()
      : m_mask(0)
    {
    }

    Flags(BitType bit)
      : m_mask(static_cast<MaskType>(bit))
    {
    }

    Flags(Flags<BitType> const& rhs)
      : m_mask(rhs.m_mask)
    {
    }

    explicit Flags(MaskType flags)
      : m_mask(flags)
    {
    }

    Flags<BitType> & operator=(Flags<BitType> const& rhs)
    {
      m_mask = rhs.m_mask;
      return *this;
    }

    Flags<BitType> & operator|=(Flags<BitType> const& rhs)
    {
      m_mask |= rhs.m_mask;
      return *this;
    }

    Flags<BitType> & operator&=(Flags<BitType> const& rhs)
    {
      m_mask &= rhs.m_mask;
      return *this;
    }

    Flags<BitType> & operator^=(Flags<BitType> const& rhs)
    {
      m_mask ^= rhs.m_mask;
      return *this;
    }

    Flags<BitType> operator|(Flags<BitType> const& rhs) const
    {
      Flags<BitType> result(*this);
      result |= rhs;
      return result;
    }

    Flags<BitType> operator&(Flags<BitType> const& rhs) const
    {
      Flags<BitType> result(*this);
      result &= rhs;
      return result;
    }

    Flags<BitType> operator^(Flags<BitType> const& rhs) const
    {
      Flags<BitType> result(*this);
      result ^= rhs;
      return result;
    }

    bool operator!() const
    {
      return !m_mask;
    }

    Flags<BitType> operator~() const
    {
      Flags<BitType> result(*this);
      result.m_mask ^= FlagTraits<BitType>::allFlags;
      return result;
    }

    bool operator==(Flags<BitType> const& rhs) const
    {
      return m_mask == rhs.m_mask;
    }

    bool operator!=(Flags<BitType> const& rhs) const
    {
      return m_mask != rhs.m_mask;
    }

    explicit operator bool() const
    {
      return !!m_mask;
    }

    explicit operator MaskType() const
    {
        return m_mask;
    }

  private:
    MaskType  m_mask;
  };

  template <typename BitType>
  Flags<BitType> operator|(BitType bit, Flags<BitType> const& flags)
  {
    return flags | bit;
  }

  template <typename BitType>
  Flags<BitType> operator&(BitType bit, Flags<BitType> const& flags)
  {
    return flags & bit;
  }

  template <typename BitType>
  Flags<BitType> operator^(BitType bit, Flags<BitType> const& flags)
  {
    return flags ^ bit;
  }


  template <typename RefType>
  class Optional
  {
  public:
    Optional(RefType & reference) { m_ptr = &reference; }
    Optional(RefType * ptr) { m_ptr = ptr; }
    Optional(std::nullptr_t) { m_ptr = nullptr; }

    operator RefType*() const { return m_ptr; }
    RefType const* operator->() const { return m_ptr; }
    explicit operator bool() const { return !!m_ptr; }

  private:
    RefType *m_ptr;
  };

#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename T>
  class ArrayProxy
  {
  public:
    VULKAN_HPP_CONSTEXPR ArrayProxy(std::nullptr_t)
      : m_count(0)
      , m_ptr(nullptr)
    {}

    ArrayProxy(T & ptr)
      : m_count(1)
      , m_ptr(&ptr)
    {}

    ArrayProxy(uint32_t count, T * ptr)
      : m_count(count)
      , m_ptr(ptr)
    {}

    template <size_t N>
    ArrayProxy(std::array<typename std::remove_const<T>::type, N> & data)
      : m_count(N)
      , m_ptr(data.data())
    {}

    template <size_t N>
    ArrayProxy(std::array<typename std::remove_const<T>::type, N> const& data)
      : m_count(N)
      , m_ptr(data.data())
    {}

    template <class Allocator = std::allocator<typename std::remove_const<T>::type>>
    ArrayProxy(std::vector<typename std::remove_const<T>::type, Allocator> & data)
      : m_count(static_cast<uint32_t>(data.size()))
      , m_ptr(data.data())
    {}

    template <class Allocator = std::allocator<typename std::remove_const<T>::type>>
    ArrayProxy(std::vector<typename std::remove_const<T>::type, Allocator> const& data)
      : m_count(static_cast<uint32_t>(data.size()))
      , m_ptr(data.data())
    {}

    ArrayProxy(std::initializer_list<T> const& data)
      : m_count(static_cast<uint32_t>(data.end() - data.begin()))
      , m_ptr(data.begin())
    {}

    const T * begin() const
    {
      return m_ptr;
    }

    const T * end() const
    {
      return m_ptr + m_count;
    }

    const T & front() const
    {
      VULKAN_HPP_ASSERT(m_count && m_ptr);
      return *m_ptr;
    }

    const T & back() const
    {
      VULKAN_HPP_ASSERT(m_count && m_ptr);
      return *(m_ptr + m_count - 1);
    }

    bool empty() const
    {
      return (m_count == 0);
    }

    uint32_t size() const
    {
      return m_count;
    }

    T * data() const
    {
      return m_ptr;
    }

  private:
    uint32_t  m_count;
    T *       m_ptr;
  };
#endif

#ifndef VULKAN_HPP_NO_SMART_HANDLE

  template <typename Type, typename Dispatch> class UniqueHandleTraits;

  template <typename Type, typename Dispatch>
  class UniqueHandle : public UniqueHandleTraits<Type,Dispatch>::deleter
  {
  private:
    using Deleter = typename UniqueHandleTraits<Type,Dispatch>::deleter;
  public:
    explicit UniqueHandle( Type const& value = Type(), Deleter const& deleter = Deleter() )
      : Deleter( deleter)
      , m_value( value )
    {}

    UniqueHandle( UniqueHandle const& ) = delete;

    UniqueHandle( UniqueHandle && other )
      : Deleter( std::move( static_cast<Deleter&>( other ) ) )
      , m_value( other.release() )
    {}

    ~UniqueHandle()
    {
      if ( m_value ) this->destroy( m_value );
    }

    UniqueHandle & operator=( UniqueHandle const& ) = delete;

    UniqueHandle & operator=( UniqueHandle && other )
    {
      reset( other.release() );
      *static_cast<Deleter*>(this) = std::move( static_cast<Deleter&>(other) );
      return *this;
    }

    explicit operator bool() const
    {
      return m_value.operator bool();
    }

    Type const* operator->() const
    {
      return &m_value;
    }

    Type * operator->()
    {
      return &m_value;
    }

    Type const& operator*() const
    {
      return m_value;
    }

    Type & operator*()
    {
      return m_value;
    }

    const Type & get() const
    {
      return m_value;
    }
    
    Type & get()
    {
      return m_value;
    }

    void reset( Type const& value = Type() )
    {
      if ( m_value != value )
      {
        if ( m_value ) this->destroy( m_value );
        m_value = value;
      }
    }

    Type release()
    {
      Type value = m_value;
      m_value = nullptr;
      return value;
    }

    void swap( UniqueHandle<Type,Dispatch> & rhs )
    {
      std::swap(m_value, rhs.m_value);
      std::swap(static_cast<Deleter&>(*this), static_cast<Deleter&>(rhs));
    }

  private:
    Type    m_value;
  };

  template <typename Type, typename Dispatch>
  VULKAN_HPP_INLINE void swap( UniqueHandle<Type,Dispatch> & lhs, UniqueHandle<Type,Dispatch> & rhs )
  {
    lhs.swap( rhs );
  }
#endif



  template <typename X, typename Y> struct isStructureChainValid { enum { value = false }; };

  template <typename P, typename T>
  struct TypeList
  {
    using list = P;
    using last = T;
  };

  template <typename List, typename X>
  struct extendCheck
  {
    static const bool valid = isStructureChainValid<typename List::last, X>::value || extendCheck<typename List::list,X>::valid;
  };

  template <typename T, typename X>
  struct extendCheck<TypeList<void,T>,X>
  {
    static const bool valid = isStructureChainValid<T, X>::value;
  };

  template <typename X>
  struct extendCheck<void,X>
  {
    static const bool valid = true;
  };

  template <class Element>
  class StructureChainElement
  {
  public:
    explicit operator Element&() { return value; }
    explicit operator const Element&() const { return value; }
  private:
    Element value;
  };

  template<typename ...StructureElements>
  class StructureChain : private StructureChainElement<StructureElements>...
  {
  public:
    StructureChain()
    {
      link<void, StructureElements...>();  
    }

    StructureChain(StructureChain const &rhs)
    {
      linkAndCopy<void, StructureElements...>(rhs);
    }

    StructureChain(StructureElements const &... elems)
    {
      linkAndCopyElements<void, StructureElements...>(elems...);
    }

    StructureChain& operator=(StructureChain const &rhs)
    {
      linkAndCopy<void, StructureElements...>(rhs);
      return *this;
    }

    template<typename ClassType> ClassType& get() { return static_cast<ClassType&>(*this);}

  private:
    template<typename List, typename X>
    void link()
    {
      static_assert(extendCheck<List, X>::valid, "The structure chain is not valid!");
    }

    template<typename List, typename X, typename Y, typename ...Z>
    void link()
    {
      static_assert(extendCheck<List,X>::valid, "The structure chain is not valid!");
      X& x = static_cast<X&>(*this);
      Y& y = static_cast<Y&>(*this);
      x.pNext = &y;
      link<TypeList<List, X>, Y, Z...>();
    }

    template<typename List, typename X>
    void linkAndCopy(StructureChain const &rhs)
    {
      static_assert(extendCheck<List, X>::valid, "The structure chain is not valid!");
      static_cast<X&>(*this) = static_cast<X const &>(rhs);
    }

    template<typename List, typename X, typename Y, typename ...Z>
    void linkAndCopy(StructureChain const &rhs)
    {
      static_assert(extendCheck<List, X>::valid, "The structure chain is not valid!");
      X& x = static_cast<X&>(*this);
      Y& y = static_cast<Y&>(*this);
      x = static_cast<X const &>(rhs);
      x.pNext = &y;
      linkAndCopy<TypeList<List, X>, Y, Z...>(rhs);
    }

    template<typename List, typename X>
    void linkAndCopyElements(X const &xelem)
    {
      static_assert(extendCheck<List, X>::valid, "The structure chain is not valid!");
      static_cast<X&>(*this) = xelem;
    }

    template<typename List, typename X, typename Y, typename ...Z>
    void linkAndCopyElements(X const &xelem, Y const &yelem, Z const &... zelem)
    {
      static_assert(extendCheck<List, X>::valid, "The structure chain is not valid!");
      X& x = static_cast<X&>(*this);
      Y& y = static_cast<Y&>(*this);
      x = xelem;
      x.pNext = &y;
      linkAndCopyElements<TypeList<List, X>, Y, Z...>(yelem, zelem...);
    }
  };

  enum class Result
  {
    eSuccess = VK_SUCCESS,
    eNotReady = VK_NOT_READY,
    eTimeout = VK_TIMEOUT,
    eEventSet = VK_EVENT_SET,
    eEventReset = VK_EVENT_RESET,
    eIncomplete = VK_INCOMPLETE,
    eErrorOutOfHostMemory = VK_ERROR_OUT_OF_HOST_MEMORY,
    eErrorOutOfDeviceMemory = VK_ERROR_OUT_OF_DEVICE_MEMORY,
    eErrorInitializationFailed = VK_ERROR_INITIALIZATION_FAILED,
    eErrorDeviceLost = VK_ERROR_DEVICE_LOST,
    eErrorMemoryMapFailed = VK_ERROR_MEMORY_MAP_FAILED,
    eErrorLayerNotPresent = VK_ERROR_LAYER_NOT_PRESENT,
    eErrorExtensionNotPresent = VK_ERROR_EXTENSION_NOT_PRESENT,
    eErrorFeatureNotPresent = VK_ERROR_FEATURE_NOT_PRESENT,
    eErrorIncompatibleDriver = VK_ERROR_INCOMPATIBLE_DRIVER,
    eErrorTooManyObjects = VK_ERROR_TOO_MANY_OBJECTS,
    eErrorFormatNotSupported = VK_ERROR_FORMAT_NOT_SUPPORTED,
    eErrorFragmentedPool = VK_ERROR_FRAGMENTED_POOL,
    eErrorOutOfPoolMemory = VK_ERROR_OUT_OF_POOL_MEMORY,
    eErrorOutOfPoolMemoryKHR = VK_ERROR_OUT_OF_POOL_MEMORY,
    eErrorInvalidExternalHandle = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    eErrorInvalidExternalHandleKHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    eErrorSurfaceLostKHR = VK_ERROR_SURFACE_LOST_KHR,
    eErrorNativeWindowInUseKHR = VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
    eSuboptimalKHR = VK_SUBOPTIMAL_KHR,
    eErrorOutOfDateKHR = VK_ERROR_OUT_OF_DATE_KHR,
    eErrorIncompatibleDisplayKHR = VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
    eErrorValidationFailedEXT = VK_ERROR_VALIDATION_FAILED_EXT,
    eErrorInvalidShaderNV = VK_ERROR_INVALID_SHADER_NV,
    eErrorFragmentationEXT = VK_ERROR_FRAGMENTATION_EXT,
    eErrorNotPermittedEXT = VK_ERROR_NOT_PERMITTED_EXT
  };

  VULKAN_HPP_INLINE std::string to_string(Result value)
  {
    switch (value)
    {
    case Result::eSuccess: return "Success";
    case Result::eNotReady: return "NotReady";
    case Result::eTimeout: return "Timeout";
    case Result::eEventSet: return "EventSet";
    case Result::eEventReset: return "EventReset";
    case Result::eIncomplete: return "Incomplete";
    case Result::eErrorOutOfHostMemory: return "ErrorOutOfHostMemory";
    case Result::eErrorOutOfDeviceMemory: return "ErrorOutOfDeviceMemory";
    case Result::eErrorInitializationFailed: return "ErrorInitializationFailed";
    case Result::eErrorDeviceLost: return "ErrorDeviceLost";
    case Result::eErrorMemoryMapFailed: return "ErrorMemoryMapFailed";
    case Result::eErrorLayerNotPresent: return "ErrorLayerNotPresent";
    case Result::eErrorExtensionNotPresent: return "ErrorExtensionNotPresent";
    case Result::eErrorFeatureNotPresent: return "ErrorFeatureNotPresent";
    case Result::eErrorIncompatibleDriver: return "ErrorIncompatibleDriver";
    case Result::eErrorTooManyObjects: return "ErrorTooManyObjects";
    case Result::eErrorFormatNotSupported: return "ErrorFormatNotSupported";
    case Result::eErrorFragmentedPool: return "ErrorFragmentedPool";
    case Result::eErrorOutOfPoolMemory: return "ErrorOutOfPoolMemory";
    case Result::eErrorInvalidExternalHandle: return "ErrorInvalidExternalHandle";
    case Result::eErrorSurfaceLostKHR: return "ErrorSurfaceLostKHR";
    case Result::eErrorNativeWindowInUseKHR: return "ErrorNativeWindowInUseKHR";
    case Result::eSuboptimalKHR: return "SuboptimalKHR";
    case Result::eErrorOutOfDateKHR: return "ErrorOutOfDateKHR";
    case Result::eErrorIncompatibleDisplayKHR: return "ErrorIncompatibleDisplayKHR";
    case Result::eErrorValidationFailedEXT: return "ErrorValidationFailedEXT";
    case Result::eErrorInvalidShaderNV: return "ErrorInvalidShaderNV";
    case Result::eErrorFragmentationEXT: return "ErrorFragmentationEXT";
    case Result::eErrorNotPermittedEXT: return "ErrorNotPermittedEXT";
    default: return "invalid";
    }
  }

#ifndef VULKAN_HPP_NO_EXCEPTIONS
#if defined(_MSC_VER) && (_MSC_VER == 1800)
# define noexcept _NOEXCEPT
#endif

  class ErrorCategoryImpl : public std::error_category
  {
    public:
    virtual const char* name() const noexcept override { return VULKAN_HPP_NAMESPACE_STRING"::Result"; }
    virtual std::string message(int ev) const override { return to_string(static_cast<Result>(ev)); }
  };

#if defined(_MSC_VER) && (_MSC_VER == 1800)
# undef noexcept
#endif

  VULKAN_HPP_INLINE const std::error_category& errorCategory()
  {
    static ErrorCategoryImpl instance;
    return instance;
  }

  VULKAN_HPP_INLINE std::error_code make_error_code(Result e)
  {
    return std::error_code(static_cast<int>(e), errorCategory());
  }

  VULKAN_HPP_INLINE std::error_condition make_error_condition(Result e)
  {
    return std::error_condition(static_cast<int>(e), errorCategory());
  }

#if defined(_MSC_VER) && (_MSC_VER == 1800)
# define noexcept _NOEXCEPT
#endif

  class Error
  {
    public:
    virtual ~Error() = default;

    virtual const char* what() const noexcept = 0;
  };

  class LogicError : public Error, public std::logic_error
  {
    public:
    explicit LogicError( const std::string& what )
      : Error(), std::logic_error(what) {}
    explicit LogicError( char const * what )
      : Error(), std::logic_error(what) {}
    virtual ~LogicError() = default;

    virtual const char* what() const noexcept { return std::logic_error::what(); }
  };

  class SystemError : public Error, public std::system_error
  {
    public:
    SystemError( std::error_code ec )
      : Error(), std::system_error(ec) {}
    SystemError( std::error_code ec, std::string const& what )
      : Error(), std::system_error(ec, what) {}
    SystemError( std::error_code ec, char const * what )
      : Error(), std::system_error(ec, what) {}
    SystemError( int ev, std::error_category const& ecat )
      : Error(), std::system_error(ev, ecat) {}
    SystemError( int ev, std::error_category const& ecat, std::string const& what)
      : Error(), std::system_error(ev, ecat, what) {}
    SystemError( int ev, std::error_category const& ecat, char const * what)
      : Error(), std::system_error(ev, ecat, what) {}
    virtual ~SystemError() = default;

    virtual const char* what() const noexcept { return std::system_error::what(); }
  };

#if defined(_MSC_VER) && (_MSC_VER == 1800)
# undef noexcept
#endif

  class OutOfHostMemoryError : public SystemError
  {
  public:
    OutOfHostMemoryError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorOutOfHostMemory ), message ) {}
    OutOfHostMemoryError( char const * message )
      : SystemError( make_error_code( Result::eErrorOutOfHostMemory ), message ) {}
  };
  class OutOfDeviceMemoryError : public SystemError
  {
  public:
    OutOfDeviceMemoryError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorOutOfDeviceMemory ), message ) {}
    OutOfDeviceMemoryError( char const * message )
      : SystemError( make_error_code( Result::eErrorOutOfDeviceMemory ), message ) {}
  };
  class InitializationFailedError : public SystemError
  {
  public:
    InitializationFailedError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorInitializationFailed ), message ) {}
    InitializationFailedError( char const * message )
      : SystemError( make_error_code( Result::eErrorInitializationFailed ), message ) {}
  };
  class DeviceLostError : public SystemError
  {
  public:
    DeviceLostError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorDeviceLost ), message ) {}
    DeviceLostError( char const * message )
      : SystemError( make_error_code( Result::eErrorDeviceLost ), message ) {}
  };
  class MemoryMapFailedError : public SystemError
  {
  public:
    MemoryMapFailedError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorMemoryMapFailed ), message ) {}
    MemoryMapFailedError( char const * message )
      : SystemError( make_error_code( Result::eErrorMemoryMapFailed ), message ) {}
  };
  class LayerNotPresentError : public SystemError
  {
  public:
    LayerNotPresentError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorLayerNotPresent ), message ) {}
    LayerNotPresentError( char const * message )
      : SystemError( make_error_code( Result::eErrorLayerNotPresent ), message ) {}
  };
  class ExtensionNotPresentError : public SystemError
  {
  public:
    ExtensionNotPresentError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorExtensionNotPresent ), message ) {}
    ExtensionNotPresentError( char const * message )
      : SystemError( make_error_code( Result::eErrorExtensionNotPresent ), message ) {}
  };
  class FeatureNotPresentError : public SystemError
  {
  public:
    FeatureNotPresentError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorFeatureNotPresent ), message ) {}
    FeatureNotPresentError( char const * message )
      : SystemError( make_error_code( Result::eErrorFeatureNotPresent ), message ) {}
  };
  class IncompatibleDriverError : public SystemError
  {
  public:
    IncompatibleDriverError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorIncompatibleDriver ), message ) {}
    IncompatibleDriverError( char const * message )
      : SystemError( make_error_code( Result::eErrorIncompatibleDriver ), message ) {}
  };
  class TooManyObjectsError : public SystemError
  {
  public:
    TooManyObjectsError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorTooManyObjects ), message ) {}
    TooManyObjectsError( char const * message )
      : SystemError( make_error_code( Result::eErrorTooManyObjects ), message ) {}
  };
  class FormatNotSupportedError : public SystemError
  {
  public:
    FormatNotSupportedError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorFormatNotSupported ), message ) {}
    FormatNotSupportedError( char const * message )
      : SystemError( make_error_code( Result::eErrorFormatNotSupported ), message ) {}
  };
  class FragmentedPoolError : public SystemError
  {
  public:
    FragmentedPoolError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorFragmentedPool ), message ) {}
    FragmentedPoolError( char const * message )
      : SystemError( make_error_code( Result::eErrorFragmentedPool ), message ) {}
  };
  class OutOfPoolMemoryError : public SystemError
  {
  public:
    OutOfPoolMemoryError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorOutOfPoolMemory ), message ) {}
    OutOfPoolMemoryError( char const * message )
      : SystemError( make_error_code( Result::eErrorOutOfPoolMemory ), message ) {}
  };
  class InvalidExternalHandleError : public SystemError
  {
  public:
    InvalidExternalHandleError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorInvalidExternalHandle ), message ) {}
    InvalidExternalHandleError( char const * message )
      : SystemError( make_error_code( Result::eErrorInvalidExternalHandle ), message ) {}
  };
  class SurfaceLostKHRError : public SystemError
  {
  public:
    SurfaceLostKHRError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorSurfaceLostKHR ), message ) {}
    SurfaceLostKHRError( char const * message )
      : SystemError( make_error_code( Result::eErrorSurfaceLostKHR ), message ) {}
  };
  class NativeWindowInUseKHRError : public SystemError
  {
  public:
    NativeWindowInUseKHRError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorNativeWindowInUseKHR ), message ) {}
    NativeWindowInUseKHRError( char const * message )
      : SystemError( make_error_code( Result::eErrorNativeWindowInUseKHR ), message ) {}
  };
  class OutOfDateKHRError : public SystemError
  {
  public:
    OutOfDateKHRError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorOutOfDateKHR ), message ) {}
    OutOfDateKHRError( char const * message )
      : SystemError( make_error_code( Result::eErrorOutOfDateKHR ), message ) {}
  };
  class IncompatibleDisplayKHRError : public SystemError
  {
  public:
    IncompatibleDisplayKHRError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorIncompatibleDisplayKHR ), message ) {}
    IncompatibleDisplayKHRError( char const * message )
      : SystemError( make_error_code( Result::eErrorIncompatibleDisplayKHR ), message ) {}
  };
  class ValidationFailedEXTError : public SystemError
  {
  public:
    ValidationFailedEXTError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorValidationFailedEXT ), message ) {}
    ValidationFailedEXTError( char const * message )
      : SystemError( make_error_code( Result::eErrorValidationFailedEXT ), message ) {}
  };
  class InvalidShaderNVError : public SystemError
  {
  public:
    InvalidShaderNVError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorInvalidShaderNV ), message ) {}
    InvalidShaderNVError( char const * message )
      : SystemError( make_error_code( Result::eErrorInvalidShaderNV ), message ) {}
  };
  class FragmentationEXTError : public SystemError
  {
  public:
    FragmentationEXTError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorFragmentationEXT ), message ) {}
    FragmentationEXTError( char const * message )
      : SystemError( make_error_code( Result::eErrorFragmentationEXT ), message ) {}
  };
  class NotPermittedEXTError : public SystemError
  {
  public:
    NotPermittedEXTError( std::string const& message )
      : SystemError( make_error_code( Result::eErrorNotPermittedEXT ), message ) {}
    NotPermittedEXTError( char const * message )
      : SystemError( make_error_code( Result::eErrorNotPermittedEXT ), message ) {}
  };

  VULKAN_HPP_INLINE void throwResultException( Result result, char const * message )
  {
    switch ( result )
    {
    case Result::eErrorOutOfHostMemory: throw OutOfHostMemoryError ( message );
    case Result::eErrorOutOfDeviceMemory: throw OutOfDeviceMemoryError ( message );
    case Result::eErrorInitializationFailed: throw InitializationFailedError ( message );
    case Result::eErrorDeviceLost: throw DeviceLostError ( message );
    case Result::eErrorMemoryMapFailed: throw MemoryMapFailedError ( message );
    case Result::eErrorLayerNotPresent: throw LayerNotPresentError ( message );
    case Result::eErrorExtensionNotPresent: throw ExtensionNotPresentError ( message );
    case Result::eErrorFeatureNotPresent: throw FeatureNotPresentError ( message );
    case Result::eErrorIncompatibleDriver: throw IncompatibleDriverError ( message );
    case Result::eErrorTooManyObjects: throw TooManyObjectsError ( message );
    case Result::eErrorFormatNotSupported: throw FormatNotSupportedError ( message );
    case Result::eErrorFragmentedPool: throw FragmentedPoolError ( message );
    case Result::eErrorOutOfPoolMemory: throw OutOfPoolMemoryError ( message );
    case Result::eErrorInvalidExternalHandle: throw InvalidExternalHandleError ( message );
    case Result::eErrorSurfaceLostKHR: throw SurfaceLostKHRError ( message );
    case Result::eErrorNativeWindowInUseKHR: throw NativeWindowInUseKHRError ( message );
    case Result::eErrorOutOfDateKHR: throw OutOfDateKHRError ( message );
    case Result::eErrorIncompatibleDisplayKHR: throw IncompatibleDisplayKHRError ( message );
    case Result::eErrorValidationFailedEXT: throw ValidationFailedEXTError ( message );
    case Result::eErrorInvalidShaderNV: throw InvalidShaderNVError ( message );
    case Result::eErrorFragmentationEXT: throw FragmentationEXTError ( message );
    case Result::eErrorNotPermittedEXT: throw NotPermittedEXTError ( message );
    default: throw SystemError( make_error_code( result ) );
    }
  }
#endif
} // namespace VULKAN_HPP_NAMESPACE

namespace std
{
  template <>
  struct is_error_code_enum<VULKAN_HPP_NAMESPACE::Result> : public true_type
  {};
}

namespace VULKAN_HPP_NAMESPACE
{

  template <typename T>
  struct ResultValue
  {
    ResultValue( Result r, T & v )
      : result( r )
      , value( v )
    {}

    ResultValue( Result r, T && v )
      : result( r )
      , value( std::move( v ) )
    {}

    Result  result;
    T       value;

    operator std::tuple<Result&, T&>() { return std::tuple<Result&, T&>(result, value); }
  };

  template <typename T>
  struct ResultValueType
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    typedef ResultValue<T>  type;
#else
    typedef T               type;
#endif
  };

  template <>
  struct ResultValueType<void>
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    typedef Result type;
#else
    typedef void   type;
#endif
  };

  VULKAN_HPP_INLINE ResultValueType<void>::type createResultValue( Result result, char const * message )
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( result == Result::eSuccess );
    return result;
#else
    if ( result != Result::eSuccess )
    {
      throwResultException( result, message );
    }
#endif
  }

  template <typename T>
  VULKAN_HPP_INLINE typename ResultValueType<T>::type createResultValue( Result result, T & data, char const * message )
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( result == Result::eSuccess );
    return ResultValue<T>( result, data );
#else
    if ( result != Result::eSuccess )
    {
      throwResultException( result, message );
    }
    return std::move( data );
#endif
  }

  VULKAN_HPP_INLINE Result createResultValue( Result result, char const * message, std::initializer_list<Result> successCodes )
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( std::find( successCodes.begin(), successCodes.end(), result ) != successCodes.end() );
#else
    if ( std::find( successCodes.begin(), successCodes.end(), result ) == successCodes.end() )
    {
      throwResultException( result, message );
    }
#endif
    return result;
  }

  template <typename T>
  VULKAN_HPP_INLINE ResultValue<T> createResultValue( Result result, T & data, char const * message, std::initializer_list<Result> successCodes )
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( std::find( successCodes.begin(), successCodes.end(), result ) != successCodes.end() );
#else
    if ( std::find( successCodes.begin(), successCodes.end(), result ) == successCodes.end() )
    {
      throwResultException( result, message );
    }
#endif
    return ResultValue<T>( result, data );
  }

#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template <typename T, typename D>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<T,D>>::type createResultValue( Result result, T & data, char const * message, typename UniqueHandleTraits<T,D>::deleter const& deleter )
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( result == Result::eSuccess );
    return ResultValue<UniqueHandle<T,D>>( result, UniqueHandle<T,D>(data, deleter) );
#else
    if ( result != Result::eSuccess )
    {
      throwResultException( result, message );
    }
    return UniqueHandle<T,D>(data, deleter);
#endif
  }
#endif

class DispatchLoaderStatic
{
public:
  VkResult vkAcquireNextImage2KHR( VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex  ) const
  {
    return ::vkAcquireNextImage2KHR( device, pAcquireInfo, pImageIndex);
  }
  VkResult vkAcquireNextImageKHR( VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex  ) const
  {
    return ::vkAcquireNextImageKHR( device, swapchain, timeout, semaphore, fence, pImageIndex);
  }
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
  VkResult vkAcquireXlibDisplayEXT( VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display  ) const
  {
    return ::vkAcquireXlibDisplayEXT( physicalDevice, dpy, display);
  }
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/
  VkResult vkAllocateCommandBuffers( VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers  ) const
  {
    return ::vkAllocateCommandBuffers( device, pAllocateInfo, pCommandBuffers);
  }
  VkResult vkAllocateDescriptorSets( VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets  ) const
  {
    return ::vkAllocateDescriptorSets( device, pAllocateInfo, pDescriptorSets);
  }
  VkResult vkAllocateMemory( VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory  ) const
  {
    return ::vkAllocateMemory( device, pAllocateInfo, pAllocator, pMemory);
  }
  VkResult vkBeginCommandBuffer( VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo  ) const
  {
    return ::vkBeginCommandBuffer( commandBuffer, pBeginInfo);
  }
  VkResult vkBindAccelerationStructureMemoryNVX( VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNVX* pBindInfos  ) const
  {
    return ::vkBindAccelerationStructureMemoryNVX( device, bindInfoCount, pBindInfos);
  }
  VkResult vkBindBufferMemory( VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset  ) const
  {
    return ::vkBindBufferMemory( device, buffer, memory, memoryOffset);
  }
  VkResult vkBindBufferMemory2( VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos  ) const
  {
    return ::vkBindBufferMemory2( device, bindInfoCount, pBindInfos);
  }
  VkResult vkBindBufferMemory2KHR( VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos  ) const
  {
    return ::vkBindBufferMemory2KHR( device, bindInfoCount, pBindInfos);
  }
  VkResult vkBindImageMemory( VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset  ) const
  {
    return ::vkBindImageMemory( device, image, memory, memoryOffset);
  }
  VkResult vkBindImageMemory2( VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos  ) const
  {
    return ::vkBindImageMemory2( device, bindInfoCount, pBindInfos);
  }
  VkResult vkBindImageMemory2KHR( VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos  ) const
  {
    return ::vkBindImageMemory2KHR( device, bindInfoCount, pBindInfos);
  }
  void vkCmdBeginConditionalRenderingEXT( VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin  ) const
  {
    return ::vkCmdBeginConditionalRenderingEXT( commandBuffer, pConditionalRenderingBegin);
  }
  void vkCmdBeginDebugUtilsLabelEXT( VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo  ) const
  {
    return ::vkCmdBeginDebugUtilsLabelEXT( commandBuffer, pLabelInfo);
  }
  void vkCmdBeginQuery( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags  ) const
  {
    return ::vkCmdBeginQuery( commandBuffer, queryPool, query, flags);
  }
  void vkCmdBeginRenderPass( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents  ) const
  {
    return ::vkCmdBeginRenderPass( commandBuffer, pRenderPassBegin, contents);
  }
  void vkCmdBeginRenderPass2KHR( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfoKHR* pSubpassBeginInfo  ) const
  {
    return ::vkCmdBeginRenderPass2KHR( commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
  }
  void vkCmdBindDescriptorSets( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets  ) const
  {
    return ::vkCmdBindDescriptorSets( commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
  }
  void vkCmdBindIndexBuffer( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType  ) const
  {
    return ::vkCmdBindIndexBuffer( commandBuffer, buffer, offset, indexType);
  }
  void vkCmdBindPipeline( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline  ) const
  {
    return ::vkCmdBindPipeline( commandBuffer, pipelineBindPoint, pipeline);
  }
  void vkCmdBindShadingRateImageNV( VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout  ) const
  {
    return ::vkCmdBindShadingRateImageNV( commandBuffer, imageView, imageLayout);
  }
  void vkCmdBindVertexBuffers( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets  ) const
  {
    return ::vkCmdBindVertexBuffers( commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
  }
  void vkCmdBlitImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter  ) const
  {
    return ::vkCmdBlitImage( commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
  }
  void vkCmdBuildAccelerationStructureNVX( VkCommandBuffer cmdBuf, VkAccelerationStructureTypeNVX type, uint32_t instanceCount, VkBuffer instanceData, VkDeviceSize instanceOffset, uint32_t geometryCount, const VkGeometryNVX* pGeometries, VkBuildAccelerationStructureFlagsNVX flags, VkBool32 update, VkAccelerationStructureNVX dst, VkAccelerationStructureNVX src, VkBuffer scratch, VkDeviceSize scratchOffset  ) const
  {
    return ::vkCmdBuildAccelerationStructureNVX( cmdBuf, type, instanceCount, instanceData, instanceOffset, geometryCount, pGeometries, flags, update, dst, src, scratch, scratchOffset);
  }
  void vkCmdClearAttachments( VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects  ) const
  {
    return ::vkCmdClearAttachments( commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
  }
  void vkCmdClearColorImage( VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges  ) const
  {
    return ::vkCmdClearColorImage( commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
  }
  void vkCmdClearDepthStencilImage( VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges  ) const
  {
    return ::vkCmdClearDepthStencilImage( commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
  }
  void vkCmdCopyAccelerationStructureNVX( VkCommandBuffer cmdBuf, VkAccelerationStructureNVX dst, VkAccelerationStructureNVX src, VkCopyAccelerationStructureModeNVX mode  ) const
  {
    return ::vkCmdCopyAccelerationStructureNVX( cmdBuf, dst, src, mode);
  }
  void vkCmdCopyBuffer( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions  ) const
  {
    return ::vkCmdCopyBuffer( commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
  }
  void vkCmdCopyBufferToImage( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions  ) const
  {
    return ::vkCmdCopyBufferToImage( commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
  }
  void vkCmdCopyImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions  ) const
  {
    return ::vkCmdCopyImage( commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
  }
  void vkCmdCopyImageToBuffer( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions  ) const
  {
    return ::vkCmdCopyImageToBuffer( commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
  }
  void vkCmdCopyQueryPoolResults( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags  ) const
  {
    return ::vkCmdCopyQueryPoolResults( commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
  }
  void vkCmdDebugMarkerBeginEXT( VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo  ) const
  {
    return ::vkCmdDebugMarkerBeginEXT( commandBuffer, pMarkerInfo);
  }
  void vkCmdDebugMarkerEndEXT( VkCommandBuffer commandBuffer  ) const
  {
    return ::vkCmdDebugMarkerEndEXT( commandBuffer);
  }
  void vkCmdDebugMarkerInsertEXT( VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo  ) const
  {
    return ::vkCmdDebugMarkerInsertEXT( commandBuffer, pMarkerInfo);
  }
  void vkCmdDispatch( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ  ) const
  {
    return ::vkCmdDispatch( commandBuffer, groupCountX, groupCountY, groupCountZ);
  }
  void vkCmdDispatchBase( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ  ) const
  {
    return ::vkCmdDispatchBase( commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
  }
  void vkCmdDispatchBaseKHR( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ  ) const
  {
    return ::vkCmdDispatchBaseKHR( commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
  }
  void vkCmdDispatchIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset  ) const
  {
    return ::vkCmdDispatchIndirect( commandBuffer, buffer, offset);
  }
  void vkCmdDraw( VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance  ) const
  {
    return ::vkCmdDraw( commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
  }
  void vkCmdDrawIndexed( VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance  ) const
  {
    return ::vkCmdDrawIndexed( commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
  }
  void vkCmdDrawIndexedIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride  ) const
  {
    return ::vkCmdDrawIndexedIndirect( commandBuffer, buffer, offset, drawCount, stride);
  }
  void vkCmdDrawIndexedIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride  ) const
  {
    return ::vkCmdDrawIndexedIndirectCountAMD( commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }
  void vkCmdDrawIndexedIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride  ) const
  {
    return ::vkCmdDrawIndexedIndirectCountKHR( commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }
  void vkCmdDrawIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride  ) const
  {
    return ::vkCmdDrawIndirect( commandBuffer, buffer, offset, drawCount, stride);
  }
  void vkCmdDrawIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride  ) const
  {
    return ::vkCmdDrawIndirectCountAMD( commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }
  void vkCmdDrawIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride  ) const
  {
    return ::vkCmdDrawIndirectCountKHR( commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }
  void vkCmdDrawMeshTasksIndirectCountNV( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride  ) const
  {
    return ::vkCmdDrawMeshTasksIndirectCountNV( commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }
  void vkCmdDrawMeshTasksIndirectNV( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride  ) const
  {
    return ::vkCmdDrawMeshTasksIndirectNV( commandBuffer, buffer, offset, drawCount, stride);
  }
  void vkCmdDrawMeshTasksNV( VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask  ) const
  {
    return ::vkCmdDrawMeshTasksNV( commandBuffer, taskCount, firstTask);
  }
  void vkCmdEndConditionalRenderingEXT( VkCommandBuffer commandBuffer  ) const
  {
    return ::vkCmdEndConditionalRenderingEXT( commandBuffer);
  }
  void vkCmdEndDebugUtilsLabelEXT( VkCommandBuffer commandBuffer  ) const
  {
    return ::vkCmdEndDebugUtilsLabelEXT( commandBuffer);
  }
  void vkCmdEndQuery( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query  ) const
  {
    return ::vkCmdEndQuery( commandBuffer, queryPool, query);
  }
  void vkCmdEndRenderPass( VkCommandBuffer commandBuffer  ) const
  {
    return ::vkCmdEndRenderPass( commandBuffer);
  }
  void vkCmdEndRenderPass2KHR( VkCommandBuffer commandBuffer, const VkSubpassEndInfoKHR* pSubpassEndInfo  ) const
  {
    return ::vkCmdEndRenderPass2KHR( commandBuffer, pSubpassEndInfo);
  }
  void vkCmdExecuteCommands( VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers  ) const
  {
    return ::vkCmdExecuteCommands( commandBuffer, commandBufferCount, pCommandBuffers);
  }
  void vkCmdFillBuffer( VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data  ) const
  {
    return ::vkCmdFillBuffer( commandBuffer, dstBuffer, dstOffset, size, data);
  }
  void vkCmdInsertDebugUtilsLabelEXT( VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo  ) const
  {
    return ::vkCmdInsertDebugUtilsLabelEXT( commandBuffer, pLabelInfo);
  }
  void vkCmdNextSubpass( VkCommandBuffer commandBuffer, VkSubpassContents contents  ) const
  {
    return ::vkCmdNextSubpass( commandBuffer, contents);
  }
  void vkCmdNextSubpass2KHR( VkCommandBuffer commandBuffer, const VkSubpassBeginInfoKHR* pSubpassBeginInfo, const VkSubpassEndInfoKHR* pSubpassEndInfo  ) const
  {
    return ::vkCmdNextSubpass2KHR( commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
  }
  void vkCmdPipelineBarrier( VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers  ) const
  {
    return ::vkCmdPipelineBarrier( commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
  }
  void vkCmdProcessCommandsNVX( VkCommandBuffer commandBuffer, const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo  ) const
  {
    return ::vkCmdProcessCommandsNVX( commandBuffer, pProcessCommandsInfo);
  }
  void vkCmdPushConstants( VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues  ) const
  {
    return ::vkCmdPushConstants( commandBuffer, layout, stageFlags, offset, size, pValues);
  }
  void vkCmdPushDescriptorSetKHR( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites  ) const
  {
    return ::vkCmdPushDescriptorSetKHR( commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
  }
  void vkCmdPushDescriptorSetWithTemplateKHR( VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData  ) const
  {
    return ::vkCmdPushDescriptorSetWithTemplateKHR( commandBuffer, descriptorUpdateTemplate, layout, set, pData);
  }
  void vkCmdReserveSpaceForCommandsNVX( VkCommandBuffer commandBuffer, const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo  ) const
  {
    return ::vkCmdReserveSpaceForCommandsNVX( commandBuffer, pReserveSpaceInfo);
  }
  void vkCmdResetEvent( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask  ) const
  {
    return ::vkCmdResetEvent( commandBuffer, event, stageMask);
  }
  void vkCmdResetQueryPool( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount  ) const
  {
    return ::vkCmdResetQueryPool( commandBuffer, queryPool, firstQuery, queryCount);
  }
  void vkCmdResolveImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions  ) const
  {
    return ::vkCmdResolveImage( commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
  }
  void vkCmdSetBlendConstants( VkCommandBuffer commandBuffer, const float blendConstants[4]  ) const
  {
    return ::vkCmdSetBlendConstants( commandBuffer, blendConstants);
  }
  void vkCmdSetCheckpointNV( VkCommandBuffer commandBuffer, const void* pCheckpointMarker  ) const
  {
    return ::vkCmdSetCheckpointNV( commandBuffer, pCheckpointMarker);
  }
  void vkCmdSetCoarseSampleOrderNV( VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders  ) const
  {
    return ::vkCmdSetCoarseSampleOrderNV( commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
  }
  void vkCmdSetDepthBias( VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor  ) const
  {
    return ::vkCmdSetDepthBias( commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
  }
  void vkCmdSetDepthBounds( VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds  ) const
  {
    return ::vkCmdSetDepthBounds( commandBuffer, minDepthBounds, maxDepthBounds);
  }
  void vkCmdSetDeviceMask( VkCommandBuffer commandBuffer, uint32_t deviceMask  ) const
  {
    return ::vkCmdSetDeviceMask( commandBuffer, deviceMask);
  }
  void vkCmdSetDeviceMaskKHR( VkCommandBuffer commandBuffer, uint32_t deviceMask  ) const
  {
    return ::vkCmdSetDeviceMaskKHR( commandBuffer, deviceMask);
  }
  void vkCmdSetDiscardRectangleEXT( VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles  ) const
  {
    return ::vkCmdSetDiscardRectangleEXT( commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
  }
  void vkCmdSetEvent( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask  ) const
  {
    return ::vkCmdSetEvent( commandBuffer, event, stageMask);
  }
  void vkCmdSetExclusiveScissorNV( VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors  ) const
  {
    return ::vkCmdSetExclusiveScissorNV( commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
  }
  void vkCmdSetLineWidth( VkCommandBuffer commandBuffer, float lineWidth  ) const
  {
    return ::vkCmdSetLineWidth( commandBuffer, lineWidth);
  }
  void vkCmdSetSampleLocationsEXT( VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo  ) const
  {
    return ::vkCmdSetSampleLocationsEXT( commandBuffer, pSampleLocationsInfo);
  }
  void vkCmdSetScissor( VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors  ) const
  {
    return ::vkCmdSetScissor( commandBuffer, firstScissor, scissorCount, pScissors);
  }
  void vkCmdSetStencilCompareMask( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask  ) const
  {
    return ::vkCmdSetStencilCompareMask( commandBuffer, faceMask, compareMask);
  }
  void vkCmdSetStencilReference( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference  ) const
  {
    return ::vkCmdSetStencilReference( commandBuffer, faceMask, reference);
  }
  void vkCmdSetStencilWriteMask( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask  ) const
  {
    return ::vkCmdSetStencilWriteMask( commandBuffer, faceMask, writeMask);
  }
  void vkCmdSetViewport( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports  ) const
  {
    return ::vkCmdSetViewport( commandBuffer, firstViewport, viewportCount, pViewports);
  }
  void vkCmdSetViewportShadingRatePaletteNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes  ) const
  {
    return ::vkCmdSetViewportShadingRatePaletteNV( commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
  }
  void vkCmdSetViewportWScalingNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings  ) const
  {
    return ::vkCmdSetViewportWScalingNV( commandBuffer, firstViewport, viewportCount, pViewportWScalings);
  }
  void vkCmdTraceRaysNVX( VkCommandBuffer cmdBuf, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, uint32_t width, uint32_t height  ) const
  {
    return ::vkCmdTraceRaysNVX( cmdBuf, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, width, height);
  }
  void vkCmdUpdateBuffer( VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData  ) const
  {
    return ::vkCmdUpdateBuffer( commandBuffer, dstBuffer, dstOffset, dataSize, pData);
  }
  void vkCmdWaitEvents( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers  ) const
  {
    return ::vkCmdWaitEvents( commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
  }
  void vkCmdWriteAccelerationStructurePropertiesNVX( VkCommandBuffer cmdBuf, VkAccelerationStructureNVX accelerationStructure, VkQueryType queryType, VkQueryPool queryPool, uint32_t query  ) const
  {
    return ::vkCmdWriteAccelerationStructurePropertiesNVX( cmdBuf, accelerationStructure, queryType, queryPool, query);
  }
  void vkCmdWriteBufferMarkerAMD( VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker  ) const
  {
    return ::vkCmdWriteBufferMarkerAMD( commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
  }
  void vkCmdWriteTimestamp( VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query  ) const
  {
    return ::vkCmdWriteTimestamp( commandBuffer, pipelineStage, queryPool, query);
  }
  VkResult vkCompileDeferredNVX( VkDevice device, VkPipeline pipeline, uint32_t shader  ) const
  {
    return ::vkCompileDeferredNVX( device, pipeline, shader);
  }
  VkResult vkCreateAccelerationStructureNVX( VkDevice device, const VkAccelerationStructureCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureNVX* pAccelerationStructure  ) const
  {
    return ::vkCreateAccelerationStructureNVX( device, pCreateInfo, pAllocator, pAccelerationStructure);
  }
#ifdef VK_USE_PLATFORM_ANDROID_KHR
  VkResult vkCreateAndroidSurfaceKHR( VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateAndroidSurfaceKHR( instance, pCreateInfo, pAllocator, pSurface);
  }
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
  VkResult vkCreateBuffer( VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer  ) const
  {
    return ::vkCreateBuffer( device, pCreateInfo, pAllocator, pBuffer);
  }
  VkResult vkCreateBufferView( VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView  ) const
  {
    return ::vkCreateBufferView( device, pCreateInfo, pAllocator, pView);
  }
  VkResult vkCreateCommandPool( VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool  ) const
  {
    return ::vkCreateCommandPool( device, pCreateInfo, pAllocator, pCommandPool);
  }
  VkResult vkCreateComputePipelines( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines  ) const
  {
    return ::vkCreateComputePipelines( device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
  }
  VkResult vkCreateDebugReportCallbackEXT( VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback  ) const
  {
    return ::vkCreateDebugReportCallbackEXT( instance, pCreateInfo, pAllocator, pCallback);
  }
  VkResult vkCreateDebugUtilsMessengerEXT( VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger  ) const
  {
    return ::vkCreateDebugUtilsMessengerEXT( instance, pCreateInfo, pAllocator, pMessenger);
  }
  VkResult vkCreateDescriptorPool( VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool  ) const
  {
    return ::vkCreateDescriptorPool( device, pCreateInfo, pAllocator, pDescriptorPool);
  }
  VkResult vkCreateDescriptorSetLayout( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout  ) const
  {
    return ::vkCreateDescriptorSetLayout( device, pCreateInfo, pAllocator, pSetLayout);
  }
  VkResult vkCreateDescriptorUpdateTemplate( VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate  ) const
  {
    return ::vkCreateDescriptorUpdateTemplate( device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
  }
  VkResult vkCreateDescriptorUpdateTemplateKHR( VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate  ) const
  {
    return ::vkCreateDescriptorUpdateTemplateKHR( device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
  }
  VkResult vkCreateDevice( VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice  ) const
  {
    return ::vkCreateDevice( physicalDevice, pCreateInfo, pAllocator, pDevice);
  }
  VkResult vkCreateDisplayModeKHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode  ) const
  {
    return ::vkCreateDisplayModeKHR( physicalDevice, display, pCreateInfo, pAllocator, pMode);
  }
  VkResult vkCreateDisplayPlaneSurfaceKHR( VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateDisplayPlaneSurfaceKHR( instance, pCreateInfo, pAllocator, pSurface);
  }
  VkResult vkCreateEvent( VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent  ) const
  {
    return ::vkCreateEvent( device, pCreateInfo, pAllocator, pEvent);
  }
  VkResult vkCreateFence( VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence  ) const
  {
    return ::vkCreateFence( device, pCreateInfo, pAllocator, pFence);
  }
  VkResult vkCreateFramebuffer( VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer  ) const
  {
    return ::vkCreateFramebuffer( device, pCreateInfo, pAllocator, pFramebuffer);
  }
  VkResult vkCreateGraphicsPipelines( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines  ) const
  {
    return ::vkCreateGraphicsPipelines( device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
  }
#ifdef VK_USE_PLATFORM_IOS_MVK
  VkResult vkCreateIOSSurfaceMVK( VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateIOSSurfaceMVK( instance, pCreateInfo, pAllocator, pSurface);
  }
#endif /*VK_USE_PLATFORM_IOS_MVK*/
  VkResult vkCreateImage( VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage  ) const
  {
    return ::vkCreateImage( device, pCreateInfo, pAllocator, pImage);
  }
  VkResult vkCreateImageView( VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView  ) const
  {
    return ::vkCreateImageView( device, pCreateInfo, pAllocator, pView);
  }
  VkResult vkCreateIndirectCommandsLayoutNVX( VkDevice device, const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout  ) const
  {
    return ::vkCreateIndirectCommandsLayoutNVX( device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
  }
  VkResult vkCreateInstance( const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance  ) const
  {
    return ::vkCreateInstance( pCreateInfo, pAllocator, pInstance);
  }
#ifdef VK_USE_PLATFORM_MACOS_MVK
  VkResult vkCreateMacOSSurfaceMVK( VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateMacOSSurfaceMVK( instance, pCreateInfo, pAllocator, pSurface);
  }
#endif /*VK_USE_PLATFORM_MACOS_MVK*/
#ifdef VK_USE_PLATFORM_MIR_KHR
  VkResult vkCreateMirSurfaceKHR( VkInstance instance, const VkMirSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateMirSurfaceKHR( instance, pCreateInfo, pAllocator, pSurface);
  }
#endif /*VK_USE_PLATFORM_MIR_KHR*/
  VkResult vkCreateObjectTableNVX( VkDevice device, const VkObjectTableCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkObjectTableNVX* pObjectTable  ) const
  {
    return ::vkCreateObjectTableNVX( device, pCreateInfo, pAllocator, pObjectTable);
  }
  VkResult vkCreatePipelineCache( VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache  ) const
  {
    return ::vkCreatePipelineCache( device, pCreateInfo, pAllocator, pPipelineCache);
  }
  VkResult vkCreatePipelineLayout( VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout  ) const
  {
    return ::vkCreatePipelineLayout( device, pCreateInfo, pAllocator, pPipelineLayout);
  }
  VkResult vkCreateQueryPool( VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool  ) const
  {
    return ::vkCreateQueryPool( device, pCreateInfo, pAllocator, pQueryPool);
  }
  VkResult vkCreateRaytracingPipelinesNVX( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRaytracingPipelineCreateInfoNVX* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines  ) const
  {
    return ::vkCreateRaytracingPipelinesNVX( device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
  }
  VkResult vkCreateRenderPass( VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass  ) const
  {
    return ::vkCreateRenderPass( device, pCreateInfo, pAllocator, pRenderPass);
  }
  VkResult vkCreateRenderPass2KHR( VkDevice device, const VkRenderPassCreateInfo2KHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass  ) const
  {
    return ::vkCreateRenderPass2KHR( device, pCreateInfo, pAllocator, pRenderPass);
  }
  VkResult vkCreateSampler( VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler  ) const
  {
    return ::vkCreateSampler( device, pCreateInfo, pAllocator, pSampler);
  }
  VkResult vkCreateSamplerYcbcrConversion( VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion  ) const
  {
    return ::vkCreateSamplerYcbcrConversion( device, pCreateInfo, pAllocator, pYcbcrConversion);
  }
  VkResult vkCreateSamplerYcbcrConversionKHR( VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion  ) const
  {
    return ::vkCreateSamplerYcbcrConversionKHR( device, pCreateInfo, pAllocator, pYcbcrConversion);
  }
  VkResult vkCreateSemaphore( VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore  ) const
  {
    return ::vkCreateSemaphore( device, pCreateInfo, pAllocator, pSemaphore);
  }
  VkResult vkCreateShaderModule( VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule  ) const
  {
    return ::vkCreateShaderModule( device, pCreateInfo, pAllocator, pShaderModule);
  }
  VkResult vkCreateSharedSwapchainsKHR( VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains  ) const
  {
    return ::vkCreateSharedSwapchainsKHR( device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
  }
  VkResult vkCreateSwapchainKHR( VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain  ) const
  {
    return ::vkCreateSwapchainKHR( device, pCreateInfo, pAllocator, pSwapchain);
  }
  VkResult vkCreateValidationCacheEXT( VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache  ) const
  {
    return ::vkCreateValidationCacheEXT( device, pCreateInfo, pAllocator, pValidationCache);
  }
#ifdef VK_USE_PLATFORM_VI_NN
  VkResult vkCreateViSurfaceNN( VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateViSurfaceNN( instance, pCreateInfo, pAllocator, pSurface);
  }
#endif /*VK_USE_PLATFORM_VI_NN*/
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  VkResult vkCreateWaylandSurfaceKHR( VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateWaylandSurfaceKHR( instance, pCreateInfo, pAllocator, pSurface);
  }
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
  VkResult vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateWin32SurfaceKHR( instance, pCreateInfo, pAllocator, pSurface);
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_XCB_KHR
  VkResult vkCreateXcbSurfaceKHR( VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateXcbSurfaceKHR( instance, pCreateInfo, pAllocator, pSurface);
  }
#endif /*VK_USE_PLATFORM_XCB_KHR*/
#ifdef VK_USE_PLATFORM_XLIB_KHR
  VkResult vkCreateXlibSurfaceKHR( VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface  ) const
  {
    return ::vkCreateXlibSurfaceKHR( instance, pCreateInfo, pAllocator, pSurface);
  }
#endif /*VK_USE_PLATFORM_XLIB_KHR*/
  VkResult vkDebugMarkerSetObjectNameEXT( VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo  ) const
  {
    return ::vkDebugMarkerSetObjectNameEXT( device, pNameInfo);
  }
  VkResult vkDebugMarkerSetObjectTagEXT( VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo  ) const
  {
    return ::vkDebugMarkerSetObjectTagEXT( device, pTagInfo);
  }
  void vkDebugReportMessageEXT( VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage  ) const
  {
    return ::vkDebugReportMessageEXT( instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
  }
  void vkDestroyAccelerationStructureNVX( VkDevice device, VkAccelerationStructureNVX accelerationStructure, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyAccelerationStructureNVX( device, accelerationStructure, pAllocator);
  }
  void vkDestroyBuffer( VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyBuffer( device, buffer, pAllocator);
  }
  void vkDestroyBufferView( VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyBufferView( device, bufferView, pAllocator);
  }
  void vkDestroyCommandPool( VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyCommandPool( device, commandPool, pAllocator);
  }
  void vkDestroyDebugReportCallbackEXT( VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyDebugReportCallbackEXT( instance, callback, pAllocator);
  }
  void vkDestroyDebugUtilsMessengerEXT( VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyDebugUtilsMessengerEXT( instance, messenger, pAllocator);
  }
  void vkDestroyDescriptorPool( VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyDescriptorPool( device, descriptorPool, pAllocator);
  }
  void vkDestroyDescriptorSetLayout( VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyDescriptorSetLayout( device, descriptorSetLayout, pAllocator);
  }
  void vkDestroyDescriptorUpdateTemplate( VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyDescriptorUpdateTemplate( device, descriptorUpdateTemplate, pAllocator);
  }
  void vkDestroyDescriptorUpdateTemplateKHR( VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyDescriptorUpdateTemplateKHR( device, descriptorUpdateTemplate, pAllocator);
  }
  void vkDestroyDevice( VkDevice device, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyDevice( device, pAllocator);
  }
  void vkDestroyEvent( VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyEvent( device, event, pAllocator);
  }
  void vkDestroyFence( VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyFence( device, fence, pAllocator);
  }
  void vkDestroyFramebuffer( VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyFramebuffer( device, framebuffer, pAllocator);
  }
  void vkDestroyImage( VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyImage( device, image, pAllocator);
  }
  void vkDestroyImageView( VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyImageView( device, imageView, pAllocator);
  }
  void vkDestroyIndirectCommandsLayoutNVX( VkDevice device, VkIndirectCommandsLayoutNVX indirectCommandsLayout, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyIndirectCommandsLayoutNVX( device, indirectCommandsLayout, pAllocator);
  }
  void vkDestroyInstance( VkInstance instance, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyInstance( instance, pAllocator);
  }
  void vkDestroyObjectTableNVX( VkDevice device, VkObjectTableNVX objectTable, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyObjectTableNVX( device, objectTable, pAllocator);
  }
  void vkDestroyPipeline( VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyPipeline( device, pipeline, pAllocator);
  }
  void vkDestroyPipelineCache( VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyPipelineCache( device, pipelineCache, pAllocator);
  }
  void vkDestroyPipelineLayout( VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyPipelineLayout( device, pipelineLayout, pAllocator);
  }
  void vkDestroyQueryPool( VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyQueryPool( device, queryPool, pAllocator);
  }
  void vkDestroyRenderPass( VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyRenderPass( device, renderPass, pAllocator);
  }
  void vkDestroySampler( VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroySampler( device, sampler, pAllocator);
  }
  void vkDestroySamplerYcbcrConversion( VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroySamplerYcbcrConversion( device, ycbcrConversion, pAllocator);
  }
  void vkDestroySamplerYcbcrConversionKHR( VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroySamplerYcbcrConversionKHR( device, ycbcrConversion, pAllocator);
  }
  void vkDestroySemaphore( VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroySemaphore( device, semaphore, pAllocator);
  }
  void vkDestroyShaderModule( VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyShaderModule( device, shaderModule, pAllocator);
  }
  void vkDestroySurfaceKHR( VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroySurfaceKHR( instance, surface, pAllocator);
  }
  void vkDestroySwapchainKHR( VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroySwapchainKHR( device, swapchain, pAllocator);
  }
  void vkDestroyValidationCacheEXT( VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkDestroyValidationCacheEXT( device, validationCache, pAllocator);
  }
  VkResult vkDeviceWaitIdle( VkDevice device  ) const
  {
    return ::vkDeviceWaitIdle( device);
  }
  VkResult vkDisplayPowerControlEXT( VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo  ) const
  {
    return ::vkDisplayPowerControlEXT( device, display, pDisplayPowerInfo);
  }
  VkResult vkEndCommandBuffer( VkCommandBuffer commandBuffer  ) const
  {
    return ::vkEndCommandBuffer( commandBuffer);
  }
  VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties  ) const
  {
    return ::vkEnumerateDeviceExtensionProperties( physicalDevice, pLayerName, pPropertyCount, pProperties);
  }
  VkResult vkEnumerateDeviceLayerProperties( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties  ) const
  {
    return ::vkEnumerateDeviceLayerProperties( physicalDevice, pPropertyCount, pProperties);
  }
  VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties  ) const
  {
    return ::vkEnumerateInstanceExtensionProperties( pLayerName, pPropertyCount, pProperties);
  }
  VkResult vkEnumerateInstanceLayerProperties( uint32_t* pPropertyCount, VkLayerProperties* pProperties  ) const
  {
    return ::vkEnumerateInstanceLayerProperties( pPropertyCount, pProperties);
  }
  VkResult vkEnumerateInstanceVersion( uint32_t* pApiVersion  ) const
  {
    return ::vkEnumerateInstanceVersion( pApiVersion);
  }
  VkResult vkEnumeratePhysicalDeviceGroups( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties  ) const
  {
    return ::vkEnumeratePhysicalDeviceGroups( instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
  }
  VkResult vkEnumeratePhysicalDeviceGroupsKHR( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties  ) const
  {
    return ::vkEnumeratePhysicalDeviceGroupsKHR( instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
  }
  VkResult vkEnumeratePhysicalDevices( VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices  ) const
  {
    return ::vkEnumeratePhysicalDevices( instance, pPhysicalDeviceCount, pPhysicalDevices);
  }
  VkResult vkFlushMappedMemoryRanges( VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges  ) const
  {
    return ::vkFlushMappedMemoryRanges( device, memoryRangeCount, pMemoryRanges);
  }
  void vkFreeCommandBuffers( VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers  ) const
  {
    return ::vkFreeCommandBuffers( device, commandPool, commandBufferCount, pCommandBuffers);
  }
  VkResult vkFreeDescriptorSets( VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets  ) const
  {
    return ::vkFreeDescriptorSets( device, descriptorPool, descriptorSetCount, pDescriptorSets);
  }
  void vkFreeMemory( VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator  ) const
  {
    return ::vkFreeMemory( device, memory, pAllocator);
  }
  VkResult vkGetAccelerationStructureHandleNVX( VkDevice device, VkAccelerationStructureNVX accelerationStructure, size_t dataSize, void* pData  ) const
  {
    return ::vkGetAccelerationStructureHandleNVX( device, accelerationStructure, dataSize, pData);
  }
  void vkGetAccelerationStructureMemoryRequirementsNVX( VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNVX* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements  ) const
  {
    return ::vkGetAccelerationStructureMemoryRequirementsNVX( device, pInfo, pMemoryRequirements);
  }
  void vkGetAccelerationStructureScratchMemoryRequirementsNVX( VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNVX* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements  ) const
  {
    return ::vkGetAccelerationStructureScratchMemoryRequirementsNVX( device, pInfo, pMemoryRequirements);
  }
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  VkResult vkGetAndroidHardwareBufferPropertiesANDROID( VkDevice device, const struct AHardwareBuffer* buffer, VkAndroidHardwareBufferPropertiesANDROID* pProperties  ) const
  {
    return ::vkGetAndroidHardwareBufferPropertiesANDROID( device, buffer, pProperties);
  }
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
  void vkGetBufferMemoryRequirements( VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements  ) const
  {
    return ::vkGetBufferMemoryRequirements( device, buffer, pMemoryRequirements);
  }
  void vkGetBufferMemoryRequirements2( VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements  ) const
  {
    return ::vkGetBufferMemoryRequirements2( device, pInfo, pMemoryRequirements);
  }
  void vkGetBufferMemoryRequirements2KHR( VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements  ) const
  {
    return ::vkGetBufferMemoryRequirements2KHR( device, pInfo, pMemoryRequirements);
  }
  void vkGetDescriptorSetLayoutSupport( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport  ) const
  {
    return ::vkGetDescriptorSetLayoutSupport( device, pCreateInfo, pSupport);
  }
  void vkGetDescriptorSetLayoutSupportKHR( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport  ) const
  {
    return ::vkGetDescriptorSetLayoutSupportKHR( device, pCreateInfo, pSupport);
  }
  void vkGetDeviceGroupPeerMemoryFeatures( VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures  ) const
  {
    return ::vkGetDeviceGroupPeerMemoryFeatures( device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
  }
  void vkGetDeviceGroupPeerMemoryFeaturesKHR( VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures  ) const
  {
    return ::vkGetDeviceGroupPeerMemoryFeaturesKHR( device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
  }
  VkResult vkGetDeviceGroupPresentCapabilitiesKHR( VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities  ) const
  {
    return ::vkGetDeviceGroupPresentCapabilitiesKHR( device, pDeviceGroupPresentCapabilities);
  }
  VkResult vkGetDeviceGroupSurfacePresentModesKHR( VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes  ) const
  {
    return ::vkGetDeviceGroupSurfacePresentModesKHR( device, surface, pModes);
  }
  void vkGetDeviceMemoryCommitment( VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes  ) const
  {
    return ::vkGetDeviceMemoryCommitment( device, memory, pCommittedMemoryInBytes);
  }
  PFN_vkVoidFunction vkGetDeviceProcAddr( VkDevice device, const char* pName  ) const
  {
    return ::vkGetDeviceProcAddr( device, pName);
  }
  void vkGetDeviceQueue( VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue  ) const
  {
    return ::vkGetDeviceQueue( device, queueFamilyIndex, queueIndex, pQueue);
  }
  void vkGetDeviceQueue2( VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue  ) const
  {
    return ::vkGetDeviceQueue2( device, pQueueInfo, pQueue);
  }
  VkResult vkGetDisplayModeProperties2KHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties  ) const
  {
    return ::vkGetDisplayModeProperties2KHR( physicalDevice, display, pPropertyCount, pProperties);
  }
  VkResult vkGetDisplayModePropertiesKHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties  ) const
  {
    return ::vkGetDisplayModePropertiesKHR( physicalDevice, display, pPropertyCount, pProperties);
  }
  VkResult vkGetDisplayPlaneCapabilities2KHR( VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities  ) const
  {
    return ::vkGetDisplayPlaneCapabilities2KHR( physicalDevice, pDisplayPlaneInfo, pCapabilities);
  }
  VkResult vkGetDisplayPlaneCapabilitiesKHR( VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities  ) const
  {
    return ::vkGetDisplayPlaneCapabilitiesKHR( physicalDevice, mode, planeIndex, pCapabilities);
  }
  VkResult vkGetDisplayPlaneSupportedDisplaysKHR( VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays  ) const
  {
    return ::vkGetDisplayPlaneSupportedDisplaysKHR( physicalDevice, planeIndex, pDisplayCount, pDisplays);
  }
  VkResult vkGetEventStatus( VkDevice device, VkEvent event  ) const
  {
    return ::vkGetEventStatus( device, event);
  }
  VkResult vkGetFenceFdKHR( VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd  ) const
  {
    return ::vkGetFenceFdKHR( device, pGetFdInfo, pFd);
  }
  VkResult vkGetFenceStatus( VkDevice device, VkFence fence  ) const
  {
    return ::vkGetFenceStatus( device, fence);
  }
#ifdef VK_USE_PLATFORM_WIN32_KHR
  VkResult vkGetFenceWin32HandleKHR( VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle  ) const
  {
    return ::vkGetFenceWin32HandleKHR( device, pGetWin32HandleInfo, pHandle);
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
  void vkGetImageMemoryRequirements( VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements  ) const
  {
    return ::vkGetImageMemoryRequirements( device, image, pMemoryRequirements);
  }
  void vkGetImageMemoryRequirements2( VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements  ) const
  {
    return ::vkGetImageMemoryRequirements2( device, pInfo, pMemoryRequirements);
  }
  void vkGetImageMemoryRequirements2KHR( VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements  ) const
  {
    return ::vkGetImageMemoryRequirements2KHR( device, pInfo, pMemoryRequirements);
  }
  void vkGetImageSparseMemoryRequirements( VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements  ) const
  {
    return ::vkGetImageSparseMemoryRequirements( device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }
  void vkGetImageSparseMemoryRequirements2( VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements  ) const
  {
    return ::vkGetImageSparseMemoryRequirements2( device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }
  void vkGetImageSparseMemoryRequirements2KHR( VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements  ) const
  {
    return ::vkGetImageSparseMemoryRequirements2KHR( device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }
  void vkGetImageSubresourceLayout( VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout  ) const
  {
    return ::vkGetImageSubresourceLayout( device, image, pSubresource, pLayout);
  }
  PFN_vkVoidFunction vkGetInstanceProcAddr( VkInstance instance, const char* pName  ) const
  {
    return ::vkGetInstanceProcAddr( instance, pName);
  }
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  VkResult vkGetMemoryAndroidHardwareBufferANDROID( VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo, struct AHardwareBuffer** pBuffer  ) const
  {
    return ::vkGetMemoryAndroidHardwareBufferANDROID( device, pInfo, pBuffer);
  }
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
  VkResult vkGetMemoryFdKHR( VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd  ) const
  {
    return ::vkGetMemoryFdKHR( device, pGetFdInfo, pFd);
  }
  VkResult vkGetMemoryFdPropertiesKHR( VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties  ) const
  {
    return ::vkGetMemoryFdPropertiesKHR( device, handleType, fd, pMemoryFdProperties);
  }
  VkResult vkGetMemoryHostPointerPropertiesEXT( VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties  ) const
  {
    return ::vkGetMemoryHostPointerPropertiesEXT( device, handleType, pHostPointer, pMemoryHostPointerProperties);
  }
#ifdef VK_USE_PLATFORM_WIN32_KHR
  VkResult vkGetMemoryWin32HandleKHR( VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle  ) const
  {
    return ::vkGetMemoryWin32HandleKHR( device, pGetWin32HandleInfo, pHandle);
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_NV
  VkResult vkGetMemoryWin32HandleNV( VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle  ) const
  {
    return ::vkGetMemoryWin32HandleNV( device, memory, handleType, pHandle);
  }
#endif /*VK_USE_PLATFORM_WIN32_NV*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
  VkResult vkGetMemoryWin32HandlePropertiesKHR( VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties  ) const
  {
    return ::vkGetMemoryWin32HandlePropertiesKHR( device, handleType, handle, pMemoryWin32HandleProperties);
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
  VkResult vkGetPastPresentationTimingGOOGLE( VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings  ) const
  {
    return ::vkGetPastPresentationTimingGOOGLE( device, swapchain, pPresentationTimingCount, pPresentationTimings);
  }
  VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceDisplayPlaneProperties2KHR( physicalDevice, pPropertyCount, pProperties);
  }
  VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceDisplayPlanePropertiesKHR( physicalDevice, pPropertyCount, pProperties);
  }
  VkResult vkGetPhysicalDeviceDisplayProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceDisplayProperties2KHR( physicalDevice, pPropertyCount, pProperties);
  }
  VkResult vkGetPhysicalDeviceDisplayPropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceDisplayPropertiesKHR( physicalDevice, pPropertyCount, pProperties);
  }
  void vkGetPhysicalDeviceExternalBufferProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties  ) const
  {
    return ::vkGetPhysicalDeviceExternalBufferProperties( physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
  }
  void vkGetPhysicalDeviceExternalBufferPropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties  ) const
  {
    return ::vkGetPhysicalDeviceExternalBufferPropertiesKHR( physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
  }
  void vkGetPhysicalDeviceExternalFenceProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties  ) const
  {
    return ::vkGetPhysicalDeviceExternalFenceProperties( physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
  }
  void vkGetPhysicalDeviceExternalFencePropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties  ) const
  {
    return ::vkGetPhysicalDeviceExternalFencePropertiesKHR( physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
  }
  VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties  ) const
  {
    return ::vkGetPhysicalDeviceExternalImageFormatPropertiesNV( physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
  }
  void vkGetPhysicalDeviceExternalSemaphoreProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties  ) const
  {
    return ::vkGetPhysicalDeviceExternalSemaphoreProperties( physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
  }
  void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties  ) const
  {
    return ::vkGetPhysicalDeviceExternalSemaphorePropertiesKHR( physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
  }
  void vkGetPhysicalDeviceFeatures( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures  ) const
  {
    return ::vkGetPhysicalDeviceFeatures( physicalDevice, pFeatures);
  }
  void vkGetPhysicalDeviceFeatures2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures  ) const
  {
    return ::vkGetPhysicalDeviceFeatures2( physicalDevice, pFeatures);
  }
  void vkGetPhysicalDeviceFeatures2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures  ) const
  {
    return ::vkGetPhysicalDeviceFeatures2KHR( physicalDevice, pFeatures);
  }
  void vkGetPhysicalDeviceFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties  ) const
  {
    return ::vkGetPhysicalDeviceFormatProperties( physicalDevice, format, pFormatProperties);
  }
  void vkGetPhysicalDeviceFormatProperties2( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties  ) const
  {
    return ::vkGetPhysicalDeviceFormatProperties2( physicalDevice, format, pFormatProperties);
  }
  void vkGetPhysicalDeviceFormatProperties2KHR( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties  ) const
  {
    return ::vkGetPhysicalDeviceFormatProperties2KHR( physicalDevice, format, pFormatProperties);
  }
  void vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX( VkPhysicalDevice physicalDevice, VkDeviceGeneratedCommandsFeaturesNVX* pFeatures, VkDeviceGeneratedCommandsLimitsNVX* pLimits  ) const
  {
    return ::vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX( physicalDevice, pFeatures, pLimits);
  }
  VkResult vkGetPhysicalDeviceImageFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties  ) const
  {
    return ::vkGetPhysicalDeviceImageFormatProperties( physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
  }
  VkResult vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties  ) const
  {
    return ::vkGetPhysicalDeviceImageFormatProperties2( physicalDevice, pImageFormatInfo, pImageFormatProperties);
  }
  VkResult vkGetPhysicalDeviceImageFormatProperties2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties  ) const
  {
    return ::vkGetPhysicalDeviceImageFormatProperties2KHR( physicalDevice, pImageFormatInfo, pImageFormatProperties);
  }
  void vkGetPhysicalDeviceMemoryProperties( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties  ) const
  {
    return ::vkGetPhysicalDeviceMemoryProperties( physicalDevice, pMemoryProperties);
  }
  void vkGetPhysicalDeviceMemoryProperties2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties  ) const
  {
    return ::vkGetPhysicalDeviceMemoryProperties2( physicalDevice, pMemoryProperties);
  }
  void vkGetPhysicalDeviceMemoryProperties2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties  ) const
  {
    return ::vkGetPhysicalDeviceMemoryProperties2KHR( physicalDevice, pMemoryProperties);
  }
#ifdef VK_USE_PLATFORM_MIR_KHR
  VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, MirConnection* connection  ) const
  {
    return ::vkGetPhysicalDeviceMirPresentationSupportKHR( physicalDevice, queueFamilyIndex, connection);
  }
#endif /*VK_USE_PLATFORM_MIR_KHR*/
  void vkGetPhysicalDeviceMultisamplePropertiesEXT( VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties  ) const
  {
    return ::vkGetPhysicalDeviceMultisamplePropertiesEXT( physicalDevice, samples, pMultisampleProperties);
  }
  VkResult vkGetPhysicalDevicePresentRectanglesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects  ) const
  {
    return ::vkGetPhysicalDevicePresentRectanglesKHR( physicalDevice, surface, pRectCount, pRects);
  }
  void vkGetPhysicalDeviceProperties( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceProperties( physicalDevice, pProperties);
  }
  void vkGetPhysicalDeviceProperties2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceProperties2( physicalDevice, pProperties);
  }
  void vkGetPhysicalDeviceProperties2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceProperties2KHR( physicalDevice, pProperties);
  }
  void vkGetPhysicalDeviceQueueFamilyProperties( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties  ) const
  {
    return ::vkGetPhysicalDeviceQueueFamilyProperties( physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
  }
  void vkGetPhysicalDeviceQueueFamilyProperties2( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties  ) const
  {
    return ::vkGetPhysicalDeviceQueueFamilyProperties2( physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
  }
  void vkGetPhysicalDeviceQueueFamilyProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties  ) const
  {
    return ::vkGetPhysicalDeviceQueueFamilyProperties2KHR( physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
  }
  void vkGetPhysicalDeviceSparseImageFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceSparseImageFormatProperties( physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
  }
  void vkGetPhysicalDeviceSparseImageFormatProperties2( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceSparseImageFormatProperties2( physicalDevice, pFormatInfo, pPropertyCount, pProperties);
  }
  void vkGetPhysicalDeviceSparseImageFormatProperties2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties  ) const
  {
    return ::vkGetPhysicalDeviceSparseImageFormatProperties2KHR( physicalDevice, pFormatInfo, pPropertyCount, pProperties);
  }
  VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities  ) const
  {
    return ::vkGetPhysicalDeviceSurfaceCapabilities2EXT( physicalDevice, surface, pSurfaceCapabilities);
  }
  VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities  ) const
  {
    return ::vkGetPhysicalDeviceSurfaceCapabilities2KHR( physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
  }
  VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities  ) const
  {
    return ::vkGetPhysicalDeviceSurfaceCapabilitiesKHR( physicalDevice, surface, pSurfaceCapabilities);
  }
  VkResult vkGetPhysicalDeviceSurfaceFormats2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats  ) const
  {
    return ::vkGetPhysicalDeviceSurfaceFormats2KHR( physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
  }
  VkResult vkGetPhysicalDeviceSurfaceFormatsKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats  ) const
  {
    return ::vkGetPhysicalDeviceSurfaceFormatsKHR( physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
  }
  VkResult vkGetPhysicalDeviceSurfacePresentModesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes  ) const
  {
    return ::vkGetPhysicalDeviceSurfacePresentModesKHR( physicalDevice, surface, pPresentModeCount, pPresentModes);
  }
  VkResult vkGetPhysicalDeviceSurfaceSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported  ) const
  {
    return ::vkGetPhysicalDeviceSurfaceSupportKHR( physicalDevice, queueFamilyIndex, surface, pSupported);
  }
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display  ) const
  {
    return ::vkGetPhysicalDeviceWaylandPresentationSupportKHR( physicalDevice, queueFamilyIndex, display);
  }
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
  VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex  ) const
  {
    return ::vkGetPhysicalDeviceWin32PresentationSupportKHR( physicalDevice, queueFamilyIndex);
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_XCB_KHR
  VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id  ) const
  {
    return ::vkGetPhysicalDeviceXcbPresentationSupportKHR( physicalDevice, queueFamilyIndex, connection, visual_id);
  }
#endif /*VK_USE_PLATFORM_XCB_KHR*/
#ifdef VK_USE_PLATFORM_XLIB_KHR
  VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID  ) const
  {
    return ::vkGetPhysicalDeviceXlibPresentationSupportKHR( physicalDevice, queueFamilyIndex, dpy, visualID);
  }
#endif /*VK_USE_PLATFORM_XLIB_KHR*/
  VkResult vkGetPipelineCacheData( VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData  ) const
  {
    return ::vkGetPipelineCacheData( device, pipelineCache, pDataSize, pData);
  }
  VkResult vkGetQueryPoolResults( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags  ) const
  {
    return ::vkGetQueryPoolResults( device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
  }
  void vkGetQueueCheckpointDataNV( VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData  ) const
  {
    return ::vkGetQueueCheckpointDataNV( queue, pCheckpointDataCount, pCheckpointData);
  }
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
  VkResult vkGetRandROutputDisplayEXT( VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput, VkDisplayKHR* pDisplay  ) const
  {
    return ::vkGetRandROutputDisplayEXT( physicalDevice, dpy, rrOutput, pDisplay);
  }
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/
  VkResult vkGetRaytracingShaderHandlesNVX( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData  ) const
  {
    return ::vkGetRaytracingShaderHandlesNVX( device, pipeline, firstGroup, groupCount, dataSize, pData);
  }
  VkResult vkGetRefreshCycleDurationGOOGLE( VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties  ) const
  {
    return ::vkGetRefreshCycleDurationGOOGLE( device, swapchain, pDisplayTimingProperties);
  }
  void vkGetRenderAreaGranularity( VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity  ) const
  {
    return ::vkGetRenderAreaGranularity( device, renderPass, pGranularity);
  }
  VkResult vkGetSemaphoreFdKHR( VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd  ) const
  {
    return ::vkGetSemaphoreFdKHR( device, pGetFdInfo, pFd);
  }
#ifdef VK_USE_PLATFORM_WIN32_KHR
  VkResult vkGetSemaphoreWin32HandleKHR( VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle  ) const
  {
    return ::vkGetSemaphoreWin32HandleKHR( device, pGetWin32HandleInfo, pHandle);
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
  VkResult vkGetShaderInfoAMD( VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo  ) const
  {
    return ::vkGetShaderInfoAMD( device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
  }
  VkResult vkGetSwapchainCounterEXT( VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue  ) const
  {
    return ::vkGetSwapchainCounterEXT( device, swapchain, counter, pCounterValue);
  }
  VkResult vkGetSwapchainImagesKHR( VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages  ) const
  {
    return ::vkGetSwapchainImagesKHR( device, swapchain, pSwapchainImageCount, pSwapchainImages);
  }
  VkResult vkGetSwapchainStatusKHR( VkDevice device, VkSwapchainKHR swapchain  ) const
  {
    return ::vkGetSwapchainStatusKHR( device, swapchain);
  }
  VkResult vkGetValidationCacheDataEXT( VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData  ) const
  {
    return ::vkGetValidationCacheDataEXT( device, validationCache, pDataSize, pData);
  }
  VkResult vkImportFenceFdKHR( VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo  ) const
  {
    return ::vkImportFenceFdKHR( device, pImportFenceFdInfo);
  }
#ifdef VK_USE_PLATFORM_WIN32_KHR
  VkResult vkImportFenceWin32HandleKHR( VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo  ) const
  {
    return ::vkImportFenceWin32HandleKHR( device, pImportFenceWin32HandleInfo);
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
  VkResult vkImportSemaphoreFdKHR( VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo  ) const
  {
    return ::vkImportSemaphoreFdKHR( device, pImportSemaphoreFdInfo);
  }
#ifdef VK_USE_PLATFORM_WIN32_KHR
  VkResult vkImportSemaphoreWin32HandleKHR( VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo  ) const
  {
    return ::vkImportSemaphoreWin32HandleKHR( device, pImportSemaphoreWin32HandleInfo);
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
  VkResult vkInvalidateMappedMemoryRanges( VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges  ) const
  {
    return ::vkInvalidateMappedMemoryRanges( device, memoryRangeCount, pMemoryRanges);
  }
  VkResult vkMapMemory( VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData  ) const
  {
    return ::vkMapMemory( device, memory, offset, size, flags, ppData);
  }
  VkResult vkMergePipelineCaches( VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches  ) const
  {
    return ::vkMergePipelineCaches( device, dstCache, srcCacheCount, pSrcCaches);
  }
  VkResult vkMergeValidationCachesEXT( VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches  ) const
  {
    return ::vkMergeValidationCachesEXT( device, dstCache, srcCacheCount, pSrcCaches);
  }
  void vkQueueBeginDebugUtilsLabelEXT( VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo  ) const
  {
    return ::vkQueueBeginDebugUtilsLabelEXT( queue, pLabelInfo);
  }
  VkResult vkQueueBindSparse( VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence  ) const
  {
    return ::vkQueueBindSparse( queue, bindInfoCount, pBindInfo, fence);
  }
  void vkQueueEndDebugUtilsLabelEXT( VkQueue queue  ) const
  {
    return ::vkQueueEndDebugUtilsLabelEXT( queue);
  }
  void vkQueueInsertDebugUtilsLabelEXT( VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo  ) const
  {
    return ::vkQueueInsertDebugUtilsLabelEXT( queue, pLabelInfo);
  }
  VkResult vkQueuePresentKHR( VkQueue queue, const VkPresentInfoKHR* pPresentInfo  ) const
  {
    return ::vkQueuePresentKHR( queue, pPresentInfo);
  }
  VkResult vkQueueSubmit( VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence  ) const
  {
    return ::vkQueueSubmit( queue, submitCount, pSubmits, fence);
  }
  VkResult vkQueueWaitIdle( VkQueue queue  ) const
  {
    return ::vkQueueWaitIdle( queue);
  }
  VkResult vkRegisterDeviceEventEXT( VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence  ) const
  {
    return ::vkRegisterDeviceEventEXT( device, pDeviceEventInfo, pAllocator, pFence);
  }
  VkResult vkRegisterDisplayEventEXT( VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence  ) const
  {
    return ::vkRegisterDisplayEventEXT( device, display, pDisplayEventInfo, pAllocator, pFence);
  }
  VkResult vkRegisterObjectsNVX( VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectTableEntryNVX* const* ppObjectTableEntries, const uint32_t* pObjectIndices  ) const
  {
    return ::vkRegisterObjectsNVX( device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
  }
  VkResult vkReleaseDisplayEXT( VkPhysicalDevice physicalDevice, VkDisplayKHR display  ) const
  {
    return ::vkReleaseDisplayEXT( physicalDevice, display);
  }
  VkResult vkResetCommandBuffer( VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags  ) const
  {
    return ::vkResetCommandBuffer( commandBuffer, flags);
  }
  VkResult vkResetCommandPool( VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags  ) const
  {
    return ::vkResetCommandPool( device, commandPool, flags);
  }
  VkResult vkResetDescriptorPool( VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags  ) const
  {
    return ::vkResetDescriptorPool( device, descriptorPool, flags);
  }
  VkResult vkResetEvent( VkDevice device, VkEvent event  ) const
  {
    return ::vkResetEvent( device, event);
  }
  VkResult vkResetFences( VkDevice device, uint32_t fenceCount, const VkFence* pFences  ) const
  {
    return ::vkResetFences( device, fenceCount, pFences);
  }
  VkResult vkSetDebugUtilsObjectNameEXT( VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo  ) const
  {
    return ::vkSetDebugUtilsObjectNameEXT( device, pNameInfo);
  }
  VkResult vkSetDebugUtilsObjectTagEXT( VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo  ) const
  {
    return ::vkSetDebugUtilsObjectTagEXT( device, pTagInfo);
  }
  VkResult vkSetEvent( VkDevice device, VkEvent event  ) const
  {
    return ::vkSetEvent( device, event);
  }
  void vkSetHdrMetadataEXT( VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata  ) const
  {
    return ::vkSetHdrMetadataEXT( device, swapchainCount, pSwapchains, pMetadata);
  }
  void vkSubmitDebugUtilsMessageEXT( VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData  ) const
  {
    return ::vkSubmitDebugUtilsMessageEXT( instance, messageSeverity, messageTypes, pCallbackData);
  }
  void vkTrimCommandPool( VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags  ) const
  {
    return ::vkTrimCommandPool( device, commandPool, flags);
  }
  void vkTrimCommandPoolKHR( VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags  ) const
  {
    return ::vkTrimCommandPoolKHR( device, commandPool, flags);
  }
  void vkUnmapMemory( VkDevice device, VkDeviceMemory memory  ) const
  {
    return ::vkUnmapMemory( device, memory);
  }
  VkResult vkUnregisterObjectsNVX( VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectEntryTypeNVX* pObjectEntryTypes, const uint32_t* pObjectIndices  ) const
  {
    return ::vkUnregisterObjectsNVX( device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
  }
  void vkUpdateDescriptorSetWithTemplate( VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData  ) const
  {
    return ::vkUpdateDescriptorSetWithTemplate( device, descriptorSet, descriptorUpdateTemplate, pData);
  }
  void vkUpdateDescriptorSetWithTemplateKHR( VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData  ) const
  {
    return ::vkUpdateDescriptorSetWithTemplateKHR( device, descriptorSet, descriptorUpdateTemplate, pData);
  }
  void vkUpdateDescriptorSets( VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies  ) const
  {
    return ::vkUpdateDescriptorSets( device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
  }
  VkResult vkWaitForFences( VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout  ) const
  {
    return ::vkWaitForFences( device, fenceCount, pFences, waitAll, timeout);
  }
};

  struct AllocationCallbacks;

  template <typename OwnerType, typename Dispatch>
  class ObjectDestroy
  {
    public:
      ObjectDestroy( OwnerType owner = OwnerType(), Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &dispatch = Dispatch() )
        : m_owner( owner )
        , m_allocator( allocator )
        , m_dispatch( &dispatch )
      {}

      OwnerType getOwner() const { return m_owner; }
      Optional<const AllocationCallbacks> getAllocator() const { return m_allocator; }

    protected:
      template <typename T>
      void destroy(T t)
      {
        m_owner.destroy( t, m_allocator, *m_dispatch );
      }

    private:
      OwnerType m_owner;
      Optional<const AllocationCallbacks> m_allocator;
      Dispatch const* m_dispatch;
  };

  class NoParent;

  template <typename Dispatch>
  class ObjectDestroy<NoParent,Dispatch>
  {
    public:
      ObjectDestroy( Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &dispatch = Dispatch() )
        : m_allocator( allocator )
        , m_dispatch( &dispatch )
      {}

      Optional<const AllocationCallbacks> getAllocator() const { return m_allocator; }

    protected:
      template <typename T>
      void destroy(T t)
      {
        t.destroy( m_allocator, *m_dispatch );
      }

    private:
      Optional<const AllocationCallbacks> m_allocator;
      Dispatch const* m_dispatch;
  };

  template <typename OwnerType, typename Dispatch>
  class ObjectFree
  {
    public:
      ObjectFree( OwnerType owner = OwnerType(), Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &dispatch = Dispatch() )
        : m_owner( owner )
        , m_allocator( allocator )
        , m_dispatch( &dispatch )
      {}

      OwnerType getOwner() const { return m_owner; }
      Optional<const AllocationCallbacks> getAllocator() const { return m_allocator; }

    protected:
      template <typename T>
      void destroy(T t)
      {
        m_owner.free( t, m_allocator, *m_dispatch );
      }

    private:
      OwnerType m_owner;
      Optional<const AllocationCallbacks> m_allocator;
      Dispatch const* m_dispatch;
  };

  template <typename OwnerType, typename PoolType, typename Dispatch>
  class PoolFree
  {
    public:
      PoolFree( OwnerType owner = OwnerType(), PoolType pool = PoolType(), Dispatch const &dispatch = Dispatch() )
        : m_owner( owner )
        , m_pool( pool )
        , m_dispatch( &dispatch )
      {}

      OwnerType getOwner() const { return m_owner; }
      PoolType getPool() const { return m_pool; }

    protected:
      template <typename T>
      void destroy(T t)
      {
        m_owner.free( m_pool, t, *m_dispatch );
      }

    private:
      OwnerType m_owner;
      PoolType m_pool;
      Dispatch const* m_dispatch;
  };

  using SampleMask = uint32_t;

  using Bool32 = uint32_t;

  using DeviceSize = uint64_t;

  enum class FramebufferCreateFlagBits
  {
  };

  using FramebufferCreateFlags = Flags<FramebufferCreateFlagBits, VkFramebufferCreateFlags>;

  enum class QueryPoolCreateFlagBits
  {
  };

  using QueryPoolCreateFlags = Flags<QueryPoolCreateFlagBits, VkQueryPoolCreateFlags>;

  enum class RenderPassCreateFlagBits
  {
  };

  using RenderPassCreateFlags = Flags<RenderPassCreateFlagBits, VkRenderPassCreateFlags>;

  enum class SamplerCreateFlagBits
  {
  };

  using SamplerCreateFlags = Flags<SamplerCreateFlagBits, VkSamplerCreateFlags>;

  enum class PipelineLayoutCreateFlagBits
  {
  };

  using PipelineLayoutCreateFlags = Flags<PipelineLayoutCreateFlagBits, VkPipelineLayoutCreateFlags>;

  enum class PipelineCacheCreateFlagBits
  {
  };

  using PipelineCacheCreateFlags = Flags<PipelineCacheCreateFlagBits, VkPipelineCacheCreateFlags>;

  enum class PipelineDepthStencilStateCreateFlagBits
  {
  };

  using PipelineDepthStencilStateCreateFlags = Flags<PipelineDepthStencilStateCreateFlagBits, VkPipelineDepthStencilStateCreateFlags>;

  enum class PipelineDynamicStateCreateFlagBits
  {
  };

  using PipelineDynamicStateCreateFlags = Flags<PipelineDynamicStateCreateFlagBits, VkPipelineDynamicStateCreateFlags>;

  enum class PipelineColorBlendStateCreateFlagBits
  {
  };

  using PipelineColorBlendStateCreateFlags = Flags<PipelineColorBlendStateCreateFlagBits, VkPipelineColorBlendStateCreateFlags>;

  enum class PipelineMultisampleStateCreateFlagBits
  {
  };

  using PipelineMultisampleStateCreateFlags = Flags<PipelineMultisampleStateCreateFlagBits, VkPipelineMultisampleStateCreateFlags>;

  enum class PipelineRasterizationStateCreateFlagBits
  {
  };

  using PipelineRasterizationStateCreateFlags = Flags<PipelineRasterizationStateCreateFlagBits, VkPipelineRasterizationStateCreateFlags>;

  enum class PipelineViewportStateCreateFlagBits
  {
  };

  using PipelineViewportStateCreateFlags = Flags<PipelineViewportStateCreateFlagBits, VkPipelineViewportStateCreateFlags>;

  enum class PipelineTessellationStateCreateFlagBits
  {
  };

  using PipelineTessellationStateCreateFlags = Flags<PipelineTessellationStateCreateFlagBits, VkPipelineTessellationStateCreateFlags>;

  enum class PipelineInputAssemblyStateCreateFlagBits
  {
  };

  using PipelineInputAssemblyStateCreateFlags = Flags<PipelineInputAssemblyStateCreateFlagBits, VkPipelineInputAssemblyStateCreateFlags>;

  enum class PipelineVertexInputStateCreateFlagBits
  {
  };

  using PipelineVertexInputStateCreateFlags = Flags<PipelineVertexInputStateCreateFlagBits, VkPipelineVertexInputStateCreateFlags>;

  enum class PipelineShaderStageCreateFlagBits
  {
  };

  using PipelineShaderStageCreateFlags = Flags<PipelineShaderStageCreateFlagBits, VkPipelineShaderStageCreateFlags>;

  enum class BufferViewCreateFlagBits
  {
  };

  using BufferViewCreateFlags = Flags<BufferViewCreateFlagBits, VkBufferViewCreateFlags>;

  enum class InstanceCreateFlagBits
  {
  };

  using InstanceCreateFlags = Flags<InstanceCreateFlagBits, VkInstanceCreateFlags>;

  enum class DeviceCreateFlagBits
  {
  };

  using DeviceCreateFlags = Flags<DeviceCreateFlagBits, VkDeviceCreateFlags>;

  enum class ImageViewCreateFlagBits
  {
  };

  using ImageViewCreateFlags = Flags<ImageViewCreateFlagBits, VkImageViewCreateFlags>;

  enum class SemaphoreCreateFlagBits
  {
  };

  using SemaphoreCreateFlags = Flags<SemaphoreCreateFlagBits, VkSemaphoreCreateFlags>;

  enum class ShaderModuleCreateFlagBits
  {
  };

  using ShaderModuleCreateFlags = Flags<ShaderModuleCreateFlagBits, VkShaderModuleCreateFlags>;

  enum class EventCreateFlagBits
  {
  };

  using EventCreateFlags = Flags<EventCreateFlagBits, VkEventCreateFlags>;

  enum class MemoryMapFlagBits
  {
  };

  using MemoryMapFlags = Flags<MemoryMapFlagBits, VkMemoryMapFlags>;

  enum class DescriptorPoolResetFlagBits
  {
  };

  using DescriptorPoolResetFlags = Flags<DescriptorPoolResetFlagBits, VkDescriptorPoolResetFlags>;

  enum class DescriptorUpdateTemplateCreateFlagBits
  {
  };

  using DescriptorUpdateTemplateCreateFlags = Flags<DescriptorUpdateTemplateCreateFlagBits, VkDescriptorUpdateTemplateCreateFlags>;

  using DescriptorUpdateTemplateCreateFlagsKHR = DescriptorUpdateTemplateCreateFlags;

  enum class DisplayModeCreateFlagBitsKHR
  {
  };

  using DisplayModeCreateFlagsKHR = Flags<DisplayModeCreateFlagBitsKHR, VkDisplayModeCreateFlagsKHR>;

  enum class DisplaySurfaceCreateFlagBitsKHR
  {
  };

  using DisplaySurfaceCreateFlagsKHR = Flags<DisplaySurfaceCreateFlagBitsKHR, VkDisplaySurfaceCreateFlagsKHR>;

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  enum class AndroidSurfaceCreateFlagBitsKHR
  {
  };
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  using AndroidSurfaceCreateFlagsKHR = Flags<AndroidSurfaceCreateFlagBitsKHR, VkAndroidSurfaceCreateFlagsKHR>;
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#ifdef VK_USE_PLATFORM_MIR_KHR
  enum class MirSurfaceCreateFlagBitsKHR
  {
  };
#endif /*VK_USE_PLATFORM_MIR_KHR*/

#ifdef VK_USE_PLATFORM_MIR_KHR
  using MirSurfaceCreateFlagsKHR = Flags<MirSurfaceCreateFlagBitsKHR, VkMirSurfaceCreateFlagsKHR>;
#endif /*VK_USE_PLATFORM_MIR_KHR*/

#ifdef VK_USE_PLATFORM_VI_NN
  enum class ViSurfaceCreateFlagBitsNN
  {
  };
#endif /*VK_USE_PLATFORM_VI_NN*/

#ifdef VK_USE_PLATFORM_VI_NN
  using ViSurfaceCreateFlagsNN = Flags<ViSurfaceCreateFlagBitsNN, VkViSurfaceCreateFlagsNN>;
#endif /*VK_USE_PLATFORM_VI_NN*/

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  enum class WaylandSurfaceCreateFlagBitsKHR
  {
  };
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  using WaylandSurfaceCreateFlagsKHR = Flags<WaylandSurfaceCreateFlagBitsKHR, VkWaylandSurfaceCreateFlagsKHR>;
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  enum class Win32SurfaceCreateFlagBitsKHR
  {
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  using Win32SurfaceCreateFlagsKHR = Flags<Win32SurfaceCreateFlagBitsKHR, VkWin32SurfaceCreateFlagsKHR>;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_XLIB_KHR
  enum class XlibSurfaceCreateFlagBitsKHR
  {
  };
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#ifdef VK_USE_PLATFORM_XLIB_KHR
  using XlibSurfaceCreateFlagsKHR = Flags<XlibSurfaceCreateFlagBitsKHR, VkXlibSurfaceCreateFlagsKHR>;
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#ifdef VK_USE_PLATFORM_XCB_KHR
  enum class XcbSurfaceCreateFlagBitsKHR
  {
  };
#endif /*VK_USE_PLATFORM_XCB_KHR*/

#ifdef VK_USE_PLATFORM_XCB_KHR
  using XcbSurfaceCreateFlagsKHR = Flags<XcbSurfaceCreateFlagBitsKHR, VkXcbSurfaceCreateFlagsKHR>;
#endif /*VK_USE_PLATFORM_XCB_KHR*/

#ifdef VK_USE_PLATFORM_IOS_MVK
  enum class IOSSurfaceCreateFlagBitsMVK
  {
  };
#endif /*VK_USE_PLATFORM_IOS_MVK*/

#ifdef VK_USE_PLATFORM_IOS_MVK
  using IOSSurfaceCreateFlagsMVK = Flags<IOSSurfaceCreateFlagBitsMVK, VkIOSSurfaceCreateFlagsMVK>;
#endif /*VK_USE_PLATFORM_IOS_MVK*/

#ifdef VK_USE_PLATFORM_MACOS_MVK
  enum class MacOSSurfaceCreateFlagBitsMVK
  {
  };
#endif /*VK_USE_PLATFORM_MACOS_MVK*/

#ifdef VK_USE_PLATFORM_MACOS_MVK
  using MacOSSurfaceCreateFlagsMVK = Flags<MacOSSurfaceCreateFlagBitsMVK, VkMacOSSurfaceCreateFlagsMVK>;
#endif /*VK_USE_PLATFORM_MACOS_MVK*/

  enum class CommandPoolTrimFlagBits
  {
  };

  using CommandPoolTrimFlags = Flags<CommandPoolTrimFlagBits, VkCommandPoolTrimFlags>;

  using CommandPoolTrimFlagsKHR = CommandPoolTrimFlags;

  enum class PipelineViewportSwizzleStateCreateFlagBitsNV
  {
  };

  using PipelineViewportSwizzleStateCreateFlagsNV = Flags<PipelineViewportSwizzleStateCreateFlagBitsNV, VkPipelineViewportSwizzleStateCreateFlagsNV>;

  enum class PipelineDiscardRectangleStateCreateFlagBitsEXT
  {
  };

  using PipelineDiscardRectangleStateCreateFlagsEXT = Flags<PipelineDiscardRectangleStateCreateFlagBitsEXT, VkPipelineDiscardRectangleStateCreateFlagsEXT>;

  enum class PipelineCoverageToColorStateCreateFlagBitsNV
  {
  };

  using PipelineCoverageToColorStateCreateFlagsNV = Flags<PipelineCoverageToColorStateCreateFlagBitsNV, VkPipelineCoverageToColorStateCreateFlagsNV>;

  enum class PipelineCoverageModulationStateCreateFlagBitsNV
  {
  };

  using PipelineCoverageModulationStateCreateFlagsNV = Flags<PipelineCoverageModulationStateCreateFlagBitsNV, VkPipelineCoverageModulationStateCreateFlagsNV>;

  enum class ValidationCacheCreateFlagBitsEXT
  {
  };

  using ValidationCacheCreateFlagsEXT = Flags<ValidationCacheCreateFlagBitsEXT, VkValidationCacheCreateFlagsEXT>;

  enum class DebugUtilsMessengerCreateFlagBitsEXT
  {
  };

  using DebugUtilsMessengerCreateFlagsEXT = Flags<DebugUtilsMessengerCreateFlagBitsEXT, VkDebugUtilsMessengerCreateFlagsEXT>;

  enum class DebugUtilsMessengerCallbackDataFlagBitsEXT
  {
  };

  using DebugUtilsMessengerCallbackDataFlagsEXT = Flags<DebugUtilsMessengerCallbackDataFlagBitsEXT, VkDebugUtilsMessengerCallbackDataFlagsEXT>;

  enum class PipelineRasterizationConservativeStateCreateFlagBitsEXT
  {
  };

  using PipelineRasterizationConservativeStateCreateFlagsEXT = Flags<PipelineRasterizationConservativeStateCreateFlagBitsEXT, VkPipelineRasterizationConservativeStateCreateFlagsEXT>;

  class DeviceMemory
  {
  public:
    VULKAN_HPP_CONSTEXPR DeviceMemory()
      : m_deviceMemory(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR DeviceMemory( std::nullptr_t )
      : m_deviceMemory(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DeviceMemory( VkDeviceMemory deviceMemory )
      : m_deviceMemory( deviceMemory )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    DeviceMemory & operator=(VkDeviceMemory deviceMemory)
    {
      m_deviceMemory = deviceMemory;
      return *this; 
    }
#endif

    DeviceMemory & operator=( std::nullptr_t )
    {
      m_deviceMemory = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( DeviceMemory const & rhs ) const
    {
      return m_deviceMemory == rhs.m_deviceMemory;
    }

    bool operator!=(DeviceMemory const & rhs ) const
    {
      return m_deviceMemory != rhs.m_deviceMemory;
    }

    bool operator<(DeviceMemory const & rhs ) const
    {
      return m_deviceMemory < rhs.m_deviceMemory;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDeviceMemory() const
    {
      return m_deviceMemory;
    }

    explicit operator bool() const
    {
      return m_deviceMemory != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_deviceMemory == VK_NULL_HANDLE;
    }

  private:
    VkDeviceMemory m_deviceMemory;
  };

  static_assert( sizeof( DeviceMemory ) == sizeof( VkDeviceMemory ), "handle and wrapper have different size!" );

  class CommandPool
  {
  public:
    VULKAN_HPP_CONSTEXPR CommandPool()
      : m_commandPool(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR CommandPool( std::nullptr_t )
      : m_commandPool(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT CommandPool( VkCommandPool commandPool )
      : m_commandPool( commandPool )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    CommandPool & operator=(VkCommandPool commandPool)
    {
      m_commandPool = commandPool;
      return *this; 
    }
#endif

    CommandPool & operator=( std::nullptr_t )
    {
      m_commandPool = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( CommandPool const & rhs ) const
    {
      return m_commandPool == rhs.m_commandPool;
    }

    bool operator!=(CommandPool const & rhs ) const
    {
      return m_commandPool != rhs.m_commandPool;
    }

    bool operator<(CommandPool const & rhs ) const
    {
      return m_commandPool < rhs.m_commandPool;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkCommandPool() const
    {
      return m_commandPool;
    }

    explicit operator bool() const
    {
      return m_commandPool != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_commandPool == VK_NULL_HANDLE;
    }

  private:
    VkCommandPool m_commandPool;
  };

  static_assert( sizeof( CommandPool ) == sizeof( VkCommandPool ), "handle and wrapper have different size!" );

  class Buffer
  {
  public:
    VULKAN_HPP_CONSTEXPR Buffer()
      : m_buffer(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Buffer( std::nullptr_t )
      : m_buffer(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Buffer( VkBuffer buffer )
      : m_buffer( buffer )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Buffer & operator=(VkBuffer buffer)
    {
      m_buffer = buffer;
      return *this; 
    }
#endif

    Buffer & operator=( std::nullptr_t )
    {
      m_buffer = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Buffer const & rhs ) const
    {
      return m_buffer == rhs.m_buffer;
    }

    bool operator!=(Buffer const & rhs ) const
    {
      return m_buffer != rhs.m_buffer;
    }

    bool operator<(Buffer const & rhs ) const
    {
      return m_buffer < rhs.m_buffer;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkBuffer() const
    {
      return m_buffer;
    }

    explicit operator bool() const
    {
      return m_buffer != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_buffer == VK_NULL_HANDLE;
    }

  private:
    VkBuffer m_buffer;
  };

  static_assert( sizeof( Buffer ) == sizeof( VkBuffer ), "handle and wrapper have different size!" );

  class BufferView
  {
  public:
    VULKAN_HPP_CONSTEXPR BufferView()
      : m_bufferView(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR BufferView( std::nullptr_t )
      : m_bufferView(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT BufferView( VkBufferView bufferView )
      : m_bufferView( bufferView )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    BufferView & operator=(VkBufferView bufferView)
    {
      m_bufferView = bufferView;
      return *this; 
    }
#endif

    BufferView & operator=( std::nullptr_t )
    {
      m_bufferView = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( BufferView const & rhs ) const
    {
      return m_bufferView == rhs.m_bufferView;
    }

    bool operator!=(BufferView const & rhs ) const
    {
      return m_bufferView != rhs.m_bufferView;
    }

    bool operator<(BufferView const & rhs ) const
    {
      return m_bufferView < rhs.m_bufferView;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkBufferView() const
    {
      return m_bufferView;
    }

    explicit operator bool() const
    {
      return m_bufferView != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_bufferView == VK_NULL_HANDLE;
    }

  private:
    VkBufferView m_bufferView;
  };

  static_assert( sizeof( BufferView ) == sizeof( VkBufferView ), "handle and wrapper have different size!" );

  class Image
  {
  public:
    VULKAN_HPP_CONSTEXPR Image()
      : m_image(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Image( std::nullptr_t )
      : m_image(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Image( VkImage image )
      : m_image( image )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Image & operator=(VkImage image)
    {
      m_image = image;
      return *this; 
    }
#endif

    Image & operator=( std::nullptr_t )
    {
      m_image = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Image const & rhs ) const
    {
      return m_image == rhs.m_image;
    }

    bool operator!=(Image const & rhs ) const
    {
      return m_image != rhs.m_image;
    }

    bool operator<(Image const & rhs ) const
    {
      return m_image < rhs.m_image;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkImage() const
    {
      return m_image;
    }

    explicit operator bool() const
    {
      return m_image != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_image == VK_NULL_HANDLE;
    }

  private:
    VkImage m_image;
  };

  static_assert( sizeof( Image ) == sizeof( VkImage ), "handle and wrapper have different size!" );

  class ImageView
  {
  public:
    VULKAN_HPP_CONSTEXPR ImageView()
      : m_imageView(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR ImageView( std::nullptr_t )
      : m_imageView(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT ImageView( VkImageView imageView )
      : m_imageView( imageView )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    ImageView & operator=(VkImageView imageView)
    {
      m_imageView = imageView;
      return *this; 
    }
#endif

    ImageView & operator=( std::nullptr_t )
    {
      m_imageView = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( ImageView const & rhs ) const
    {
      return m_imageView == rhs.m_imageView;
    }

    bool operator!=(ImageView const & rhs ) const
    {
      return m_imageView != rhs.m_imageView;
    }

    bool operator<(ImageView const & rhs ) const
    {
      return m_imageView < rhs.m_imageView;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkImageView() const
    {
      return m_imageView;
    }

    explicit operator bool() const
    {
      return m_imageView != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_imageView == VK_NULL_HANDLE;
    }

  private:
    VkImageView m_imageView;
  };

  static_assert( sizeof( ImageView ) == sizeof( VkImageView ), "handle and wrapper have different size!" );

  class ShaderModule
  {
  public:
    VULKAN_HPP_CONSTEXPR ShaderModule()
      : m_shaderModule(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR ShaderModule( std::nullptr_t )
      : m_shaderModule(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT ShaderModule( VkShaderModule shaderModule )
      : m_shaderModule( shaderModule )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    ShaderModule & operator=(VkShaderModule shaderModule)
    {
      m_shaderModule = shaderModule;
      return *this; 
    }
#endif

    ShaderModule & operator=( std::nullptr_t )
    {
      m_shaderModule = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( ShaderModule const & rhs ) const
    {
      return m_shaderModule == rhs.m_shaderModule;
    }

    bool operator!=(ShaderModule const & rhs ) const
    {
      return m_shaderModule != rhs.m_shaderModule;
    }

    bool operator<(ShaderModule const & rhs ) const
    {
      return m_shaderModule < rhs.m_shaderModule;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkShaderModule() const
    {
      return m_shaderModule;
    }

    explicit operator bool() const
    {
      return m_shaderModule != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_shaderModule == VK_NULL_HANDLE;
    }

  private:
    VkShaderModule m_shaderModule;
  };

  static_assert( sizeof( ShaderModule ) == sizeof( VkShaderModule ), "handle and wrapper have different size!" );

  class Pipeline
  {
  public:
    VULKAN_HPP_CONSTEXPR Pipeline()
      : m_pipeline(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Pipeline( std::nullptr_t )
      : m_pipeline(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Pipeline( VkPipeline pipeline )
      : m_pipeline( pipeline )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Pipeline & operator=(VkPipeline pipeline)
    {
      m_pipeline = pipeline;
      return *this; 
    }
#endif

    Pipeline & operator=( std::nullptr_t )
    {
      m_pipeline = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Pipeline const & rhs ) const
    {
      return m_pipeline == rhs.m_pipeline;
    }

    bool operator!=(Pipeline const & rhs ) const
    {
      return m_pipeline != rhs.m_pipeline;
    }

    bool operator<(Pipeline const & rhs ) const
    {
      return m_pipeline < rhs.m_pipeline;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPipeline() const
    {
      return m_pipeline;
    }

    explicit operator bool() const
    {
      return m_pipeline != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_pipeline == VK_NULL_HANDLE;
    }

  private:
    VkPipeline m_pipeline;
  };

  static_assert( sizeof( Pipeline ) == sizeof( VkPipeline ), "handle and wrapper have different size!" );

  class PipelineLayout
  {
  public:
    VULKAN_HPP_CONSTEXPR PipelineLayout()
      : m_pipelineLayout(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR PipelineLayout( std::nullptr_t )
      : m_pipelineLayout(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT PipelineLayout( VkPipelineLayout pipelineLayout )
      : m_pipelineLayout( pipelineLayout )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    PipelineLayout & operator=(VkPipelineLayout pipelineLayout)
    {
      m_pipelineLayout = pipelineLayout;
      return *this; 
    }
#endif

    PipelineLayout & operator=( std::nullptr_t )
    {
      m_pipelineLayout = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( PipelineLayout const & rhs ) const
    {
      return m_pipelineLayout == rhs.m_pipelineLayout;
    }

    bool operator!=(PipelineLayout const & rhs ) const
    {
      return m_pipelineLayout != rhs.m_pipelineLayout;
    }

    bool operator<(PipelineLayout const & rhs ) const
    {
      return m_pipelineLayout < rhs.m_pipelineLayout;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPipelineLayout() const
    {
      return m_pipelineLayout;
    }

    explicit operator bool() const
    {
      return m_pipelineLayout != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_pipelineLayout == VK_NULL_HANDLE;
    }

  private:
    VkPipelineLayout m_pipelineLayout;
  };

  static_assert( sizeof( PipelineLayout ) == sizeof( VkPipelineLayout ), "handle and wrapper have different size!" );

  class Sampler
  {
  public:
    VULKAN_HPP_CONSTEXPR Sampler()
      : m_sampler(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Sampler( std::nullptr_t )
      : m_sampler(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Sampler( VkSampler sampler )
      : m_sampler( sampler )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Sampler & operator=(VkSampler sampler)
    {
      m_sampler = sampler;
      return *this; 
    }
#endif

    Sampler & operator=( std::nullptr_t )
    {
      m_sampler = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Sampler const & rhs ) const
    {
      return m_sampler == rhs.m_sampler;
    }

    bool operator!=(Sampler const & rhs ) const
    {
      return m_sampler != rhs.m_sampler;
    }

    bool operator<(Sampler const & rhs ) const
    {
      return m_sampler < rhs.m_sampler;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSampler() const
    {
      return m_sampler;
    }

    explicit operator bool() const
    {
      return m_sampler != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_sampler == VK_NULL_HANDLE;
    }

  private:
    VkSampler m_sampler;
  };

  static_assert( sizeof( Sampler ) == sizeof( VkSampler ), "handle and wrapper have different size!" );

  class DescriptorSet
  {
  public:
    VULKAN_HPP_CONSTEXPR DescriptorSet()
      : m_descriptorSet(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR DescriptorSet( std::nullptr_t )
      : m_descriptorSet(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DescriptorSet( VkDescriptorSet descriptorSet )
      : m_descriptorSet( descriptorSet )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    DescriptorSet & operator=(VkDescriptorSet descriptorSet)
    {
      m_descriptorSet = descriptorSet;
      return *this; 
    }
#endif

    DescriptorSet & operator=( std::nullptr_t )
    {
      m_descriptorSet = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( DescriptorSet const & rhs ) const
    {
      return m_descriptorSet == rhs.m_descriptorSet;
    }

    bool operator!=(DescriptorSet const & rhs ) const
    {
      return m_descriptorSet != rhs.m_descriptorSet;
    }

    bool operator<(DescriptorSet const & rhs ) const
    {
      return m_descriptorSet < rhs.m_descriptorSet;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDescriptorSet() const
    {
      return m_descriptorSet;
    }

    explicit operator bool() const
    {
      return m_descriptorSet != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_descriptorSet == VK_NULL_HANDLE;
    }

  private:
    VkDescriptorSet m_descriptorSet;
  };

  static_assert( sizeof( DescriptorSet ) == sizeof( VkDescriptorSet ), "handle and wrapper have different size!" );

  class DescriptorSetLayout
  {
  public:
    VULKAN_HPP_CONSTEXPR DescriptorSetLayout()
      : m_descriptorSetLayout(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR DescriptorSetLayout( std::nullptr_t )
      : m_descriptorSetLayout(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DescriptorSetLayout( VkDescriptorSetLayout descriptorSetLayout )
      : m_descriptorSetLayout( descriptorSetLayout )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    DescriptorSetLayout & operator=(VkDescriptorSetLayout descriptorSetLayout)
    {
      m_descriptorSetLayout = descriptorSetLayout;
      return *this; 
    }
#endif

    DescriptorSetLayout & operator=( std::nullptr_t )
    {
      m_descriptorSetLayout = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( DescriptorSetLayout const & rhs ) const
    {
      return m_descriptorSetLayout == rhs.m_descriptorSetLayout;
    }

    bool operator!=(DescriptorSetLayout const & rhs ) const
    {
      return m_descriptorSetLayout != rhs.m_descriptorSetLayout;
    }

    bool operator<(DescriptorSetLayout const & rhs ) const
    {
      return m_descriptorSetLayout < rhs.m_descriptorSetLayout;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDescriptorSetLayout() const
    {
      return m_descriptorSetLayout;
    }

    explicit operator bool() const
    {
      return m_descriptorSetLayout != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_descriptorSetLayout == VK_NULL_HANDLE;
    }

  private:
    VkDescriptorSetLayout m_descriptorSetLayout;
  };

  static_assert( sizeof( DescriptorSetLayout ) == sizeof( VkDescriptorSetLayout ), "handle and wrapper have different size!" );

  class DescriptorPool
  {
  public:
    VULKAN_HPP_CONSTEXPR DescriptorPool()
      : m_descriptorPool(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR DescriptorPool( std::nullptr_t )
      : m_descriptorPool(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DescriptorPool( VkDescriptorPool descriptorPool )
      : m_descriptorPool( descriptorPool )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    DescriptorPool & operator=(VkDescriptorPool descriptorPool)
    {
      m_descriptorPool = descriptorPool;
      return *this; 
    }
#endif

    DescriptorPool & operator=( std::nullptr_t )
    {
      m_descriptorPool = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( DescriptorPool const & rhs ) const
    {
      return m_descriptorPool == rhs.m_descriptorPool;
    }

    bool operator!=(DescriptorPool const & rhs ) const
    {
      return m_descriptorPool != rhs.m_descriptorPool;
    }

    bool operator<(DescriptorPool const & rhs ) const
    {
      return m_descriptorPool < rhs.m_descriptorPool;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDescriptorPool() const
    {
      return m_descriptorPool;
    }

    explicit operator bool() const
    {
      return m_descriptorPool != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_descriptorPool == VK_NULL_HANDLE;
    }

  private:
    VkDescriptorPool m_descriptorPool;
  };

  static_assert( sizeof( DescriptorPool ) == sizeof( VkDescriptorPool ), "handle and wrapper have different size!" );

  class Fence
  {
  public:
    VULKAN_HPP_CONSTEXPR Fence()
      : m_fence(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Fence( std::nullptr_t )
      : m_fence(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Fence( VkFence fence )
      : m_fence( fence )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Fence & operator=(VkFence fence)
    {
      m_fence = fence;
      return *this; 
    }
#endif

    Fence & operator=( std::nullptr_t )
    {
      m_fence = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Fence const & rhs ) const
    {
      return m_fence == rhs.m_fence;
    }

    bool operator!=(Fence const & rhs ) const
    {
      return m_fence != rhs.m_fence;
    }

    bool operator<(Fence const & rhs ) const
    {
      return m_fence < rhs.m_fence;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkFence() const
    {
      return m_fence;
    }

    explicit operator bool() const
    {
      return m_fence != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_fence == VK_NULL_HANDLE;
    }

  private:
    VkFence m_fence;
  };

  static_assert( sizeof( Fence ) == sizeof( VkFence ), "handle and wrapper have different size!" );

  class Semaphore
  {
  public:
    VULKAN_HPP_CONSTEXPR Semaphore()
      : m_semaphore(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Semaphore( std::nullptr_t )
      : m_semaphore(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Semaphore( VkSemaphore semaphore )
      : m_semaphore( semaphore )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Semaphore & operator=(VkSemaphore semaphore)
    {
      m_semaphore = semaphore;
      return *this; 
    }
#endif

    Semaphore & operator=( std::nullptr_t )
    {
      m_semaphore = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Semaphore const & rhs ) const
    {
      return m_semaphore == rhs.m_semaphore;
    }

    bool operator!=(Semaphore const & rhs ) const
    {
      return m_semaphore != rhs.m_semaphore;
    }

    bool operator<(Semaphore const & rhs ) const
    {
      return m_semaphore < rhs.m_semaphore;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSemaphore() const
    {
      return m_semaphore;
    }

    explicit operator bool() const
    {
      return m_semaphore != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_semaphore == VK_NULL_HANDLE;
    }

  private:
    VkSemaphore m_semaphore;
  };

  static_assert( sizeof( Semaphore ) == sizeof( VkSemaphore ), "handle and wrapper have different size!" );

  class Event
  {
  public:
    VULKAN_HPP_CONSTEXPR Event()
      : m_event(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Event( std::nullptr_t )
      : m_event(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Event( VkEvent event )
      : m_event( event )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Event & operator=(VkEvent event)
    {
      m_event = event;
      return *this; 
    }
#endif

    Event & operator=( std::nullptr_t )
    {
      m_event = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Event const & rhs ) const
    {
      return m_event == rhs.m_event;
    }

    bool operator!=(Event const & rhs ) const
    {
      return m_event != rhs.m_event;
    }

    bool operator<(Event const & rhs ) const
    {
      return m_event < rhs.m_event;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkEvent() const
    {
      return m_event;
    }

    explicit operator bool() const
    {
      return m_event != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_event == VK_NULL_HANDLE;
    }

  private:
    VkEvent m_event;
  };

  static_assert( sizeof( Event ) == sizeof( VkEvent ), "handle and wrapper have different size!" );

  class QueryPool
  {
  public:
    VULKAN_HPP_CONSTEXPR QueryPool()
      : m_queryPool(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR QueryPool( std::nullptr_t )
      : m_queryPool(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT QueryPool( VkQueryPool queryPool )
      : m_queryPool( queryPool )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    QueryPool & operator=(VkQueryPool queryPool)
    {
      m_queryPool = queryPool;
      return *this; 
    }
#endif

    QueryPool & operator=( std::nullptr_t )
    {
      m_queryPool = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( QueryPool const & rhs ) const
    {
      return m_queryPool == rhs.m_queryPool;
    }

    bool operator!=(QueryPool const & rhs ) const
    {
      return m_queryPool != rhs.m_queryPool;
    }

    bool operator<(QueryPool const & rhs ) const
    {
      return m_queryPool < rhs.m_queryPool;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkQueryPool() const
    {
      return m_queryPool;
    }

    explicit operator bool() const
    {
      return m_queryPool != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_queryPool == VK_NULL_HANDLE;
    }

  private:
    VkQueryPool m_queryPool;
  };

  static_assert( sizeof( QueryPool ) == sizeof( VkQueryPool ), "handle and wrapper have different size!" );

  class Framebuffer
  {
  public:
    VULKAN_HPP_CONSTEXPR Framebuffer()
      : m_framebuffer(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Framebuffer( std::nullptr_t )
      : m_framebuffer(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Framebuffer( VkFramebuffer framebuffer )
      : m_framebuffer( framebuffer )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Framebuffer & operator=(VkFramebuffer framebuffer)
    {
      m_framebuffer = framebuffer;
      return *this; 
    }
#endif

    Framebuffer & operator=( std::nullptr_t )
    {
      m_framebuffer = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Framebuffer const & rhs ) const
    {
      return m_framebuffer == rhs.m_framebuffer;
    }

    bool operator!=(Framebuffer const & rhs ) const
    {
      return m_framebuffer != rhs.m_framebuffer;
    }

    bool operator<(Framebuffer const & rhs ) const
    {
      return m_framebuffer < rhs.m_framebuffer;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkFramebuffer() const
    {
      return m_framebuffer;
    }

    explicit operator bool() const
    {
      return m_framebuffer != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_framebuffer == VK_NULL_HANDLE;
    }

  private:
    VkFramebuffer m_framebuffer;
  };

  static_assert( sizeof( Framebuffer ) == sizeof( VkFramebuffer ), "handle and wrapper have different size!" );

  class RenderPass
  {
  public:
    VULKAN_HPP_CONSTEXPR RenderPass()
      : m_renderPass(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR RenderPass( std::nullptr_t )
      : m_renderPass(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT RenderPass( VkRenderPass renderPass )
      : m_renderPass( renderPass )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    RenderPass & operator=(VkRenderPass renderPass)
    {
      m_renderPass = renderPass;
      return *this; 
    }
#endif

    RenderPass & operator=( std::nullptr_t )
    {
      m_renderPass = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( RenderPass const & rhs ) const
    {
      return m_renderPass == rhs.m_renderPass;
    }

    bool operator!=(RenderPass const & rhs ) const
    {
      return m_renderPass != rhs.m_renderPass;
    }

    bool operator<(RenderPass const & rhs ) const
    {
      return m_renderPass < rhs.m_renderPass;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkRenderPass() const
    {
      return m_renderPass;
    }

    explicit operator bool() const
    {
      return m_renderPass != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_renderPass == VK_NULL_HANDLE;
    }

  private:
    VkRenderPass m_renderPass;
  };

  static_assert( sizeof( RenderPass ) == sizeof( VkRenderPass ), "handle and wrapper have different size!" );

  class PipelineCache
  {
  public:
    VULKAN_HPP_CONSTEXPR PipelineCache()
      : m_pipelineCache(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR PipelineCache( std::nullptr_t )
      : m_pipelineCache(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT PipelineCache( VkPipelineCache pipelineCache )
      : m_pipelineCache( pipelineCache )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    PipelineCache & operator=(VkPipelineCache pipelineCache)
    {
      m_pipelineCache = pipelineCache;
      return *this; 
    }
#endif

    PipelineCache & operator=( std::nullptr_t )
    {
      m_pipelineCache = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( PipelineCache const & rhs ) const
    {
      return m_pipelineCache == rhs.m_pipelineCache;
    }

    bool operator!=(PipelineCache const & rhs ) const
    {
      return m_pipelineCache != rhs.m_pipelineCache;
    }

    bool operator<(PipelineCache const & rhs ) const
    {
      return m_pipelineCache < rhs.m_pipelineCache;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPipelineCache() const
    {
      return m_pipelineCache;
    }

    explicit operator bool() const
    {
      return m_pipelineCache != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_pipelineCache == VK_NULL_HANDLE;
    }

  private:
    VkPipelineCache m_pipelineCache;
  };

  static_assert( sizeof( PipelineCache ) == sizeof( VkPipelineCache ), "handle and wrapper have different size!" );

  class ObjectTableNVX
  {
  public:
    VULKAN_HPP_CONSTEXPR ObjectTableNVX()
      : m_objectTableNVX(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR ObjectTableNVX( std::nullptr_t )
      : m_objectTableNVX(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT ObjectTableNVX( VkObjectTableNVX objectTableNVX )
      : m_objectTableNVX( objectTableNVX )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    ObjectTableNVX & operator=(VkObjectTableNVX objectTableNVX)
    {
      m_objectTableNVX = objectTableNVX;
      return *this; 
    }
#endif

    ObjectTableNVX & operator=( std::nullptr_t )
    {
      m_objectTableNVX = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( ObjectTableNVX const & rhs ) const
    {
      return m_objectTableNVX == rhs.m_objectTableNVX;
    }

    bool operator!=(ObjectTableNVX const & rhs ) const
    {
      return m_objectTableNVX != rhs.m_objectTableNVX;
    }

    bool operator<(ObjectTableNVX const & rhs ) const
    {
      return m_objectTableNVX < rhs.m_objectTableNVX;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkObjectTableNVX() const
    {
      return m_objectTableNVX;
    }

    explicit operator bool() const
    {
      return m_objectTableNVX != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_objectTableNVX == VK_NULL_HANDLE;
    }

  private:
    VkObjectTableNVX m_objectTableNVX;
  };

  static_assert( sizeof( ObjectTableNVX ) == sizeof( VkObjectTableNVX ), "handle and wrapper have different size!" );

  class IndirectCommandsLayoutNVX
  {
  public:
    VULKAN_HPP_CONSTEXPR IndirectCommandsLayoutNVX()
      : m_indirectCommandsLayoutNVX(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR IndirectCommandsLayoutNVX( std::nullptr_t )
      : m_indirectCommandsLayoutNVX(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT IndirectCommandsLayoutNVX( VkIndirectCommandsLayoutNVX indirectCommandsLayoutNVX )
      : m_indirectCommandsLayoutNVX( indirectCommandsLayoutNVX )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    IndirectCommandsLayoutNVX & operator=(VkIndirectCommandsLayoutNVX indirectCommandsLayoutNVX)
    {
      m_indirectCommandsLayoutNVX = indirectCommandsLayoutNVX;
      return *this; 
    }
#endif

    IndirectCommandsLayoutNVX & operator=( std::nullptr_t )
    {
      m_indirectCommandsLayoutNVX = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( IndirectCommandsLayoutNVX const & rhs ) const
    {
      return m_indirectCommandsLayoutNVX == rhs.m_indirectCommandsLayoutNVX;
    }

    bool operator!=(IndirectCommandsLayoutNVX const & rhs ) const
    {
      return m_indirectCommandsLayoutNVX != rhs.m_indirectCommandsLayoutNVX;
    }

    bool operator<(IndirectCommandsLayoutNVX const & rhs ) const
    {
      return m_indirectCommandsLayoutNVX < rhs.m_indirectCommandsLayoutNVX;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkIndirectCommandsLayoutNVX() const
    {
      return m_indirectCommandsLayoutNVX;
    }

    explicit operator bool() const
    {
      return m_indirectCommandsLayoutNVX != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_indirectCommandsLayoutNVX == VK_NULL_HANDLE;
    }

  private:
    VkIndirectCommandsLayoutNVX m_indirectCommandsLayoutNVX;
  };

  static_assert( sizeof( IndirectCommandsLayoutNVX ) == sizeof( VkIndirectCommandsLayoutNVX ), "handle and wrapper have different size!" );

  class DescriptorUpdateTemplate
  {
  public:
    VULKAN_HPP_CONSTEXPR DescriptorUpdateTemplate()
      : m_descriptorUpdateTemplate(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR DescriptorUpdateTemplate( std::nullptr_t )
      : m_descriptorUpdateTemplate(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DescriptorUpdateTemplate( VkDescriptorUpdateTemplate descriptorUpdateTemplate )
      : m_descriptorUpdateTemplate( descriptorUpdateTemplate )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    DescriptorUpdateTemplate & operator=(VkDescriptorUpdateTemplate descriptorUpdateTemplate)
    {
      m_descriptorUpdateTemplate = descriptorUpdateTemplate;
      return *this; 
    }
#endif

    DescriptorUpdateTemplate & operator=( std::nullptr_t )
    {
      m_descriptorUpdateTemplate = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( DescriptorUpdateTemplate const & rhs ) const
    {
      return m_descriptorUpdateTemplate == rhs.m_descriptorUpdateTemplate;
    }

    bool operator!=(DescriptorUpdateTemplate const & rhs ) const
    {
      return m_descriptorUpdateTemplate != rhs.m_descriptorUpdateTemplate;
    }

    bool operator<(DescriptorUpdateTemplate const & rhs ) const
    {
      return m_descriptorUpdateTemplate < rhs.m_descriptorUpdateTemplate;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDescriptorUpdateTemplate() const
    {
      return m_descriptorUpdateTemplate;
    }

    explicit operator bool() const
    {
      return m_descriptorUpdateTemplate != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_descriptorUpdateTemplate == VK_NULL_HANDLE;
    }

  private:
    VkDescriptorUpdateTemplate m_descriptorUpdateTemplate;
  };

  static_assert( sizeof( DescriptorUpdateTemplate ) == sizeof( VkDescriptorUpdateTemplate ), "handle and wrapper have different size!" );

  using DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;

  class SamplerYcbcrConversion
  {
  public:
    VULKAN_HPP_CONSTEXPR SamplerYcbcrConversion()
      : m_samplerYcbcrConversion(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR SamplerYcbcrConversion( std::nullptr_t )
      : m_samplerYcbcrConversion(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT SamplerYcbcrConversion( VkSamplerYcbcrConversion samplerYcbcrConversion )
      : m_samplerYcbcrConversion( samplerYcbcrConversion )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    SamplerYcbcrConversion & operator=(VkSamplerYcbcrConversion samplerYcbcrConversion)
    {
      m_samplerYcbcrConversion = samplerYcbcrConversion;
      return *this; 
    }
#endif

    SamplerYcbcrConversion & operator=( std::nullptr_t )
    {
      m_samplerYcbcrConversion = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( SamplerYcbcrConversion const & rhs ) const
    {
      return m_samplerYcbcrConversion == rhs.m_samplerYcbcrConversion;
    }

    bool operator!=(SamplerYcbcrConversion const & rhs ) const
    {
      return m_samplerYcbcrConversion != rhs.m_samplerYcbcrConversion;
    }

    bool operator<(SamplerYcbcrConversion const & rhs ) const
    {
      return m_samplerYcbcrConversion < rhs.m_samplerYcbcrConversion;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSamplerYcbcrConversion() const
    {
      return m_samplerYcbcrConversion;
    }

    explicit operator bool() const
    {
      return m_samplerYcbcrConversion != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_samplerYcbcrConversion == VK_NULL_HANDLE;
    }

  private:
    VkSamplerYcbcrConversion m_samplerYcbcrConversion;
  };

  static_assert( sizeof( SamplerYcbcrConversion ) == sizeof( VkSamplerYcbcrConversion ), "handle and wrapper have different size!" );

  using SamplerYcbcrConversionKHR = SamplerYcbcrConversion;

  class ValidationCacheEXT
  {
  public:
    VULKAN_HPP_CONSTEXPR ValidationCacheEXT()
      : m_validationCacheEXT(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR ValidationCacheEXT( std::nullptr_t )
      : m_validationCacheEXT(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT ValidationCacheEXT( VkValidationCacheEXT validationCacheEXT )
      : m_validationCacheEXT( validationCacheEXT )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    ValidationCacheEXT & operator=(VkValidationCacheEXT validationCacheEXT)
    {
      m_validationCacheEXT = validationCacheEXT;
      return *this; 
    }
#endif

    ValidationCacheEXT & operator=( std::nullptr_t )
    {
      m_validationCacheEXT = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( ValidationCacheEXT const & rhs ) const
    {
      return m_validationCacheEXT == rhs.m_validationCacheEXT;
    }

    bool operator!=(ValidationCacheEXT const & rhs ) const
    {
      return m_validationCacheEXT != rhs.m_validationCacheEXT;
    }

    bool operator<(ValidationCacheEXT const & rhs ) const
    {
      return m_validationCacheEXT < rhs.m_validationCacheEXT;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkValidationCacheEXT() const
    {
      return m_validationCacheEXT;
    }

    explicit operator bool() const
    {
      return m_validationCacheEXT != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_validationCacheEXT == VK_NULL_HANDLE;
    }

  private:
    VkValidationCacheEXT m_validationCacheEXT;
  };

  static_assert( sizeof( ValidationCacheEXT ) == sizeof( VkValidationCacheEXT ), "handle and wrapper have different size!" );

  class AccelerationStructureNVX
  {
  public:
    VULKAN_HPP_CONSTEXPR AccelerationStructureNVX()
      : m_accelerationStructureNVX(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR AccelerationStructureNVX( std::nullptr_t )
      : m_accelerationStructureNVX(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT AccelerationStructureNVX( VkAccelerationStructureNVX accelerationStructureNVX )
      : m_accelerationStructureNVX( accelerationStructureNVX )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    AccelerationStructureNVX & operator=(VkAccelerationStructureNVX accelerationStructureNVX)
    {
      m_accelerationStructureNVX = accelerationStructureNVX;
      return *this; 
    }
#endif

    AccelerationStructureNVX & operator=( std::nullptr_t )
    {
      m_accelerationStructureNVX = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( AccelerationStructureNVX const & rhs ) const
    {
      return m_accelerationStructureNVX == rhs.m_accelerationStructureNVX;
    }

    bool operator!=(AccelerationStructureNVX const & rhs ) const
    {
      return m_accelerationStructureNVX != rhs.m_accelerationStructureNVX;
    }

    bool operator<(AccelerationStructureNVX const & rhs ) const
    {
      return m_accelerationStructureNVX < rhs.m_accelerationStructureNVX;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkAccelerationStructureNVX() const
    {
      return m_accelerationStructureNVX;
    }

    explicit operator bool() const
    {
      return m_accelerationStructureNVX != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_accelerationStructureNVX == VK_NULL_HANDLE;
    }

  private:
    VkAccelerationStructureNVX m_accelerationStructureNVX;
  };

  static_assert( sizeof( AccelerationStructureNVX ) == sizeof( VkAccelerationStructureNVX ), "handle and wrapper have different size!" );

  class DisplayKHR
  {
  public:
    VULKAN_HPP_CONSTEXPR DisplayKHR()
      : m_displayKHR(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR DisplayKHR( std::nullptr_t )
      : m_displayKHR(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DisplayKHR( VkDisplayKHR displayKHR )
      : m_displayKHR( displayKHR )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    DisplayKHR & operator=(VkDisplayKHR displayKHR)
    {
      m_displayKHR = displayKHR;
      return *this; 
    }
#endif

    DisplayKHR & operator=( std::nullptr_t )
    {
      m_displayKHR = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( DisplayKHR const & rhs ) const
    {
      return m_displayKHR == rhs.m_displayKHR;
    }

    bool operator!=(DisplayKHR const & rhs ) const
    {
      return m_displayKHR != rhs.m_displayKHR;
    }

    bool operator<(DisplayKHR const & rhs ) const
    {
      return m_displayKHR < rhs.m_displayKHR;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDisplayKHR() const
    {
      return m_displayKHR;
    }

    explicit operator bool() const
    {
      return m_displayKHR != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_displayKHR == VK_NULL_HANDLE;
    }

  private:
    VkDisplayKHR m_displayKHR;
  };

  static_assert( sizeof( DisplayKHR ) == sizeof( VkDisplayKHR ), "handle and wrapper have different size!" );

  class DisplayModeKHR
  {
  public:
    VULKAN_HPP_CONSTEXPR DisplayModeKHR()
      : m_displayModeKHR(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR DisplayModeKHR( std::nullptr_t )
      : m_displayModeKHR(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DisplayModeKHR( VkDisplayModeKHR displayModeKHR )
      : m_displayModeKHR( displayModeKHR )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    DisplayModeKHR & operator=(VkDisplayModeKHR displayModeKHR)
    {
      m_displayModeKHR = displayModeKHR;
      return *this; 
    }
#endif

    DisplayModeKHR & operator=( std::nullptr_t )
    {
      m_displayModeKHR = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( DisplayModeKHR const & rhs ) const
    {
      return m_displayModeKHR == rhs.m_displayModeKHR;
    }

    bool operator!=(DisplayModeKHR const & rhs ) const
    {
      return m_displayModeKHR != rhs.m_displayModeKHR;
    }

    bool operator<(DisplayModeKHR const & rhs ) const
    {
      return m_displayModeKHR < rhs.m_displayModeKHR;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDisplayModeKHR() const
    {
      return m_displayModeKHR;
    }

    explicit operator bool() const
    {
      return m_displayModeKHR != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_displayModeKHR == VK_NULL_HANDLE;
    }

  private:
    VkDisplayModeKHR m_displayModeKHR;
  };

  static_assert( sizeof( DisplayModeKHR ) == sizeof( VkDisplayModeKHR ), "handle and wrapper have different size!" );

  class SurfaceKHR
  {
  public:
    VULKAN_HPP_CONSTEXPR SurfaceKHR()
      : m_surfaceKHR(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR SurfaceKHR( std::nullptr_t )
      : m_surfaceKHR(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT SurfaceKHR( VkSurfaceKHR surfaceKHR )
      : m_surfaceKHR( surfaceKHR )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    SurfaceKHR & operator=(VkSurfaceKHR surfaceKHR)
    {
      m_surfaceKHR = surfaceKHR;
      return *this; 
    }
#endif

    SurfaceKHR & operator=( std::nullptr_t )
    {
      m_surfaceKHR = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( SurfaceKHR const & rhs ) const
    {
      return m_surfaceKHR == rhs.m_surfaceKHR;
    }

    bool operator!=(SurfaceKHR const & rhs ) const
    {
      return m_surfaceKHR != rhs.m_surfaceKHR;
    }

    bool operator<(SurfaceKHR const & rhs ) const
    {
      return m_surfaceKHR < rhs.m_surfaceKHR;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSurfaceKHR() const
    {
      return m_surfaceKHR;
    }

    explicit operator bool() const
    {
      return m_surfaceKHR != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_surfaceKHR == VK_NULL_HANDLE;
    }

  private:
    VkSurfaceKHR m_surfaceKHR;
  };

  static_assert( sizeof( SurfaceKHR ) == sizeof( VkSurfaceKHR ), "handle and wrapper have different size!" );

  class SwapchainKHR
  {
  public:
    VULKAN_HPP_CONSTEXPR SwapchainKHR()
      : m_swapchainKHR(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR SwapchainKHR( std::nullptr_t )
      : m_swapchainKHR(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT SwapchainKHR( VkSwapchainKHR swapchainKHR )
      : m_swapchainKHR( swapchainKHR )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    SwapchainKHR & operator=(VkSwapchainKHR swapchainKHR)
    {
      m_swapchainKHR = swapchainKHR;
      return *this; 
    }
#endif

    SwapchainKHR & operator=( std::nullptr_t )
    {
      m_swapchainKHR = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( SwapchainKHR const & rhs ) const
    {
      return m_swapchainKHR == rhs.m_swapchainKHR;
    }

    bool operator!=(SwapchainKHR const & rhs ) const
    {
      return m_swapchainKHR != rhs.m_swapchainKHR;
    }

    bool operator<(SwapchainKHR const & rhs ) const
    {
      return m_swapchainKHR < rhs.m_swapchainKHR;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSwapchainKHR() const
    {
      return m_swapchainKHR;
    }

    explicit operator bool() const
    {
      return m_swapchainKHR != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_swapchainKHR == VK_NULL_HANDLE;
    }

  private:
    VkSwapchainKHR m_swapchainKHR;
  };

  static_assert( sizeof( SwapchainKHR ) == sizeof( VkSwapchainKHR ), "handle and wrapper have different size!" );

  class DebugReportCallbackEXT
  {
  public:
    VULKAN_HPP_CONSTEXPR DebugReportCallbackEXT()
      : m_debugReportCallbackEXT(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR DebugReportCallbackEXT( std::nullptr_t )
      : m_debugReportCallbackEXT(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DebugReportCallbackEXT( VkDebugReportCallbackEXT debugReportCallbackEXT )
      : m_debugReportCallbackEXT( debugReportCallbackEXT )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    DebugReportCallbackEXT & operator=(VkDebugReportCallbackEXT debugReportCallbackEXT)
    {
      m_debugReportCallbackEXT = debugReportCallbackEXT;
      return *this; 
    }
#endif

    DebugReportCallbackEXT & operator=( std::nullptr_t )
    {
      m_debugReportCallbackEXT = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( DebugReportCallbackEXT const & rhs ) const
    {
      return m_debugReportCallbackEXT == rhs.m_debugReportCallbackEXT;
    }

    bool operator!=(DebugReportCallbackEXT const & rhs ) const
    {
      return m_debugReportCallbackEXT != rhs.m_debugReportCallbackEXT;
    }

    bool operator<(DebugReportCallbackEXT const & rhs ) const
    {
      return m_debugReportCallbackEXT < rhs.m_debugReportCallbackEXT;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDebugReportCallbackEXT() const
    {
      return m_debugReportCallbackEXT;
    }

    explicit operator bool() const
    {
      return m_debugReportCallbackEXT != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_debugReportCallbackEXT == VK_NULL_HANDLE;
    }

  private:
    VkDebugReportCallbackEXT m_debugReportCallbackEXT;
  };

  static_assert( sizeof( DebugReportCallbackEXT ) == sizeof( VkDebugReportCallbackEXT ), "handle and wrapper have different size!" );

  class DebugUtilsMessengerEXT
  {
  public:
    VULKAN_HPP_CONSTEXPR DebugUtilsMessengerEXT()
      : m_debugUtilsMessengerEXT(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR DebugUtilsMessengerEXT( std::nullptr_t )
      : m_debugUtilsMessengerEXT(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DebugUtilsMessengerEXT( VkDebugUtilsMessengerEXT debugUtilsMessengerEXT )
      : m_debugUtilsMessengerEXT( debugUtilsMessengerEXT )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    DebugUtilsMessengerEXT & operator=(VkDebugUtilsMessengerEXT debugUtilsMessengerEXT)
    {
      m_debugUtilsMessengerEXT = debugUtilsMessengerEXT;
      return *this; 
    }
#endif

    DebugUtilsMessengerEXT & operator=( std::nullptr_t )
    {
      m_debugUtilsMessengerEXT = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( DebugUtilsMessengerEXT const & rhs ) const
    {
      return m_debugUtilsMessengerEXT == rhs.m_debugUtilsMessengerEXT;
    }

    bool operator!=(DebugUtilsMessengerEXT const & rhs ) const
    {
      return m_debugUtilsMessengerEXT != rhs.m_debugUtilsMessengerEXT;
    }

    bool operator<(DebugUtilsMessengerEXT const & rhs ) const
    {
      return m_debugUtilsMessengerEXT < rhs.m_debugUtilsMessengerEXT;
    }



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDebugUtilsMessengerEXT() const
    {
      return m_debugUtilsMessengerEXT;
    }

    explicit operator bool() const
    {
      return m_debugUtilsMessengerEXT != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_debugUtilsMessengerEXT == VK_NULL_HANDLE;
    }

  private:
    VkDebugUtilsMessengerEXT m_debugUtilsMessengerEXT;
  };

  static_assert( sizeof( DebugUtilsMessengerEXT ) == sizeof( VkDebugUtilsMessengerEXT ), "handle and wrapper have different size!" );

  struct Offset2D
  {
    operator VkOffset2D const&() const
    {
      return *reinterpret_cast<const VkOffset2D*>(this);
    }

    operator VkOffset2D &()
    {
      return *reinterpret_cast<VkOffset2D*>(this);
    }

    bool operator==( Offset2D const& rhs ) const
    {
      return ( x == rhs.x )
          && ( y == rhs.y );
    }

    bool operator!=( Offset2D const& rhs ) const
    {
      return !operator==( rhs );
    }

    int32_t x = 0;
    int32_t y = 0;
  };
  static_assert( sizeof( Offset2D ) == sizeof( VkOffset2D ), "struct and wrapper have different size!" );
  static_assert( offsetof( Offset2D, x ) == offsetof( VkOffset2D, x ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Offset2D, y ) == offsetof( VkOffset2D, y ), "struct member and wrapper member have different offset!" );

  struct Offset3D
  {
    operator VkOffset3D const&() const
    {
      return *reinterpret_cast<const VkOffset3D*>(this);
    }

    operator VkOffset3D &()
    {
      return *reinterpret_cast<VkOffset3D*>(this);
    }

    bool operator==( Offset3D const& rhs ) const
    {
      return ( x == rhs.x )
          && ( y == rhs.y )
          && ( z == rhs.z );
    }

    bool operator!=( Offset3D const& rhs ) const
    {
      return !operator==( rhs );
    }

    int32_t x = 0;
    int32_t y = 0;
    int32_t z = 0;
  };
  static_assert( sizeof( Offset3D ) == sizeof( VkOffset3D ), "struct and wrapper have different size!" );
  static_assert( offsetof( Offset3D, x ) == offsetof( VkOffset3D, x ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Offset3D, y ) == offsetof( VkOffset3D, y ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Offset3D, z ) == offsetof( VkOffset3D, z ), "struct member and wrapper member have different offset!" );

  struct Extent2D
  {
    operator VkExtent2D const&() const
    {
      return *reinterpret_cast<const VkExtent2D*>(this);
    }

    operator VkExtent2D &()
    {
      return *reinterpret_cast<VkExtent2D*>(this);
    }

    bool operator==( Extent2D const& rhs ) const
    {
      return ( width == rhs.width )
          && ( height == rhs.height );
    }

    bool operator!=( Extent2D const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t width = 0;
    uint32_t height = 0;
  };
  static_assert( sizeof( Extent2D ) == sizeof( VkExtent2D ), "struct and wrapper have different size!" );
  static_assert( offsetof( Extent2D, width ) == offsetof( VkExtent2D, width ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Extent2D, height ) == offsetof( VkExtent2D, height ), "struct member and wrapper member have different offset!" );

  struct Extent3D
  {
    operator VkExtent3D const&() const
    {
      return *reinterpret_cast<const VkExtent3D*>(this);
    }

    operator VkExtent3D &()
    {
      return *reinterpret_cast<VkExtent3D*>(this);
    }

    bool operator==( Extent3D const& rhs ) const
    {
      return ( width == rhs.width )
          && ( height == rhs.height )
          && ( depth == rhs.depth );
    }

    bool operator!=( Extent3D const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t width = 0;
    uint32_t height = 0;
    uint32_t depth = 0;
  };
  static_assert( sizeof( Extent3D ) == sizeof( VkExtent3D ), "struct and wrapper have different size!" );
  static_assert( offsetof( Extent3D, width ) == offsetof( VkExtent3D, width ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Extent3D, height ) == offsetof( VkExtent3D, height ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Extent3D, depth ) == offsetof( VkExtent3D, depth ), "struct member and wrapper member have different offset!" );

  struct Viewport
  {
    operator VkViewport const&() const
    {
      return *reinterpret_cast<const VkViewport*>(this);
    }

    operator VkViewport &()
    {
      return *reinterpret_cast<VkViewport*>(this);
    }

    bool operator==( Viewport const& rhs ) const
    {
      return ( x == rhs.x )
          && ( y == rhs.y )
          && ( width == rhs.width )
          && ( height == rhs.height )
          && ( minDepth == rhs.minDepth )
          && ( maxDepth == rhs.maxDepth );
    }

    bool operator!=( Viewport const& rhs ) const
    {
      return !operator==( rhs );
    }

    float x = 0;
    float y = 0;
    float width = 0;
    float height = 0;
    float minDepth = 0;
    float maxDepth = 0;
  };
  static_assert( sizeof( Viewport ) == sizeof( VkViewport ), "struct and wrapper have different size!" );
  static_assert( offsetof( Viewport, x ) == offsetof( VkViewport, x ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Viewport, y ) == offsetof( VkViewport, y ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Viewport, width ) == offsetof( VkViewport, width ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Viewport, height ) == offsetof( VkViewport, height ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Viewport, minDepth ) == offsetof( VkViewport, minDepth ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Viewport, maxDepth ) == offsetof( VkViewport, maxDepth ), "struct member and wrapper member have different offset!" );

  struct Rect2D
  {
    operator VkRect2D const&() const
    {
      return *reinterpret_cast<const VkRect2D*>(this);
    }

    operator VkRect2D &()
    {
      return *reinterpret_cast<VkRect2D*>(this);
    }

    bool operator==( Rect2D const& rhs ) const
    {
      return ( offset == rhs.offset )
          && ( extent == rhs.extent );
    }

    bool operator!=( Rect2D const& rhs ) const
    {
      return !operator==( rhs );
    }

    Offset2D offset = Offset2D();
    Extent2D extent = Extent2D();
  };
  static_assert( sizeof( Rect2D ) == sizeof( VkRect2D ), "struct and wrapper have different size!" );
  static_assert( offsetof( Rect2D, offset ) == offsetof( VkRect2D, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Rect2D, extent ) == offsetof( VkRect2D, extent ), "struct member and wrapper member have different offset!" );

  struct ClearRect
  {
    operator VkClearRect const&() const
    {
      return *reinterpret_cast<const VkClearRect*>(this);
    }

    operator VkClearRect &()
    {
      return *reinterpret_cast<VkClearRect*>(this);
    }

    bool operator==( ClearRect const& rhs ) const
    {
      return ( rect == rhs.rect )
          && ( baseArrayLayer == rhs.baseArrayLayer )
          && ( layerCount == rhs.layerCount );
    }

    bool operator!=( ClearRect const& rhs ) const
    {
      return !operator==( rhs );
    }

    Rect2D rect = Rect2D();
    uint32_t baseArrayLayer = 0;
    uint32_t layerCount = 0;
  };
  static_assert( sizeof( ClearRect ) == sizeof( VkClearRect ), "struct and wrapper have different size!" );
  static_assert( offsetof( ClearRect, rect ) == offsetof( VkClearRect, rect ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ClearRect, baseArrayLayer ) == offsetof( VkClearRect, baseArrayLayer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ClearRect, layerCount ) == offsetof( VkClearRect, layerCount ), "struct member and wrapper member have different offset!" );

  struct ExtensionProperties
  {
    operator VkExtensionProperties const&() const
    {
      return *reinterpret_cast<const VkExtensionProperties*>(this);
    }

    operator VkExtensionProperties &()
    {
      return *reinterpret_cast<VkExtensionProperties*>(this);
    }

    bool operator==( ExtensionProperties const& rhs ) const
    {
      return ( extensionName == rhs.extensionName )
          && ( specVersion == rhs.specVersion );
    }

    bool operator!=( ExtensionProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    std::array<char, VK_MAX_EXTENSION_NAME_SIZE> extensionName = { { 0 } };
    uint32_t specVersion = 0;
  };
  static_assert( sizeof( ExtensionProperties ) == sizeof( VkExtensionProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExtensionProperties, extensionName ) == offsetof( VkExtensionProperties, extensionName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExtensionProperties, specVersion ) == offsetof( VkExtensionProperties, specVersion ), "struct member and wrapper member have different offset!" );

  struct LayerProperties
  {
    operator VkLayerProperties const&() const
    {
      return *reinterpret_cast<const VkLayerProperties*>(this);
    }

    operator VkLayerProperties &()
    {
      return *reinterpret_cast<VkLayerProperties*>(this);
    }

    bool operator==( LayerProperties const& rhs ) const
    {
      return ( layerName == rhs.layerName )
          && ( specVersion == rhs.specVersion )
          && ( implementationVersion == rhs.implementationVersion )
          && ( description == rhs.description );
    }

    bool operator!=( LayerProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    std::array<char, VK_MAX_EXTENSION_NAME_SIZE> layerName = { { 0 } };
    uint32_t specVersion = 0;
    uint32_t implementationVersion = 0;
    std::array<char, VK_MAX_DESCRIPTION_SIZE> description = { { 0 } };
  };
  static_assert( sizeof( LayerProperties ) == sizeof( VkLayerProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( LayerProperties, layerName ) == offsetof( VkLayerProperties, layerName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( LayerProperties, specVersion ) == offsetof( VkLayerProperties, specVersion ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( LayerProperties, implementationVersion ) == offsetof( VkLayerProperties, implementationVersion ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( LayerProperties, description ) == offsetof( VkLayerProperties, description ), "struct member and wrapper member have different offset!" );

  struct AllocationCallbacks
  {
    operator VkAllocationCallbacks const&() const
    {
      return *reinterpret_cast<const VkAllocationCallbacks*>(this);
    }

    operator VkAllocationCallbacks &()
    {
      return *reinterpret_cast<VkAllocationCallbacks*>(this);
    }

    bool operator==( AllocationCallbacks const& rhs ) const
    {
      return ( pUserData == rhs.pUserData )
          && ( pfnAllocation == rhs.pfnAllocation )
          && ( pfnReallocation == rhs.pfnReallocation )
          && ( pfnFree == rhs.pfnFree )
          && ( pfnInternalAllocation == rhs.pfnInternalAllocation )
          && ( pfnInternalFree == rhs.pfnInternalFree );
    }

    bool operator!=( AllocationCallbacks const& rhs ) const
    {
      return !operator==( rhs );
    }

    void* pUserData = nullptr;
    PFN_vkAllocationFunction pfnAllocation = nullptr;
    PFN_vkReallocationFunction pfnReallocation = nullptr;
    PFN_vkFreeFunction pfnFree = nullptr;
    PFN_vkInternalAllocationNotification pfnInternalAllocation = nullptr;
    PFN_vkInternalFreeNotification pfnInternalFree = nullptr;
  };
  static_assert( sizeof( AllocationCallbacks ) == sizeof( VkAllocationCallbacks ), "struct and wrapper have different size!" );
  static_assert( offsetof( AllocationCallbacks, pUserData ) == offsetof( VkAllocationCallbacks, pUserData ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AllocationCallbacks, pfnAllocation ) == offsetof( VkAllocationCallbacks, pfnAllocation ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AllocationCallbacks, pfnReallocation ) == offsetof( VkAllocationCallbacks, pfnReallocation ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AllocationCallbacks, pfnFree ) == offsetof( VkAllocationCallbacks, pfnFree ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AllocationCallbacks, pfnInternalAllocation ) == offsetof( VkAllocationCallbacks, pfnInternalAllocation ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AllocationCallbacks, pfnInternalFree ) == offsetof( VkAllocationCallbacks, pfnInternalFree ), "struct member and wrapper member have different offset!" );

  struct MemoryRequirements
  {
    operator VkMemoryRequirements const&() const
    {
      return *reinterpret_cast<const VkMemoryRequirements*>(this);
    }

    operator VkMemoryRequirements &()
    {
      return *reinterpret_cast<VkMemoryRequirements*>(this);
    }

    bool operator==( MemoryRequirements const& rhs ) const
    {
      return ( size == rhs.size )
          && ( alignment == rhs.alignment )
          && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( MemoryRequirements const& rhs ) const
    {
      return !operator==( rhs );
    }

    DeviceSize size = 0;
    DeviceSize alignment = 0;
    uint32_t memoryTypeBits = 0;
  };
  static_assert( sizeof( MemoryRequirements ) == sizeof( VkMemoryRequirements ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryRequirements, size ) == offsetof( VkMemoryRequirements, size ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryRequirements, alignment ) == offsetof( VkMemoryRequirements, alignment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryRequirements, memoryTypeBits ) == offsetof( VkMemoryRequirements, memoryTypeBits ), "struct member and wrapper member have different offset!" );

  struct DescriptorBufferInfo
  {
    operator VkDescriptorBufferInfo const&() const
    {
      return *reinterpret_cast<const VkDescriptorBufferInfo*>(this);
    }

    operator VkDescriptorBufferInfo &()
    {
      return *reinterpret_cast<VkDescriptorBufferInfo*>(this);
    }

    bool operator==( DescriptorBufferInfo const& rhs ) const
    {
      return ( buffer == rhs.buffer )
          && ( offset == rhs.offset )
          && ( range == rhs.range );
    }

    bool operator!=( DescriptorBufferInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    Buffer buffer = Buffer();
    DeviceSize offset = 0;
    DeviceSize range = 0;
  };
  static_assert( sizeof( DescriptorBufferInfo ) == sizeof( VkDescriptorBufferInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorBufferInfo, buffer ) == offsetof( VkDescriptorBufferInfo, buffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorBufferInfo, offset ) == offsetof( VkDescriptorBufferInfo, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorBufferInfo, range ) == offsetof( VkDescriptorBufferInfo, range ), "struct member and wrapper member have different offset!" );

  struct SubresourceLayout
  {
    operator VkSubresourceLayout const&() const
    {
      return *reinterpret_cast<const VkSubresourceLayout*>(this);
    }

    operator VkSubresourceLayout &()
    {
      return *reinterpret_cast<VkSubresourceLayout*>(this);
    }

    bool operator==( SubresourceLayout const& rhs ) const
    {
      return ( offset == rhs.offset )
          && ( size == rhs.size )
          && ( rowPitch == rhs.rowPitch )
          && ( arrayPitch == rhs.arrayPitch )
          && ( depthPitch == rhs.depthPitch );
    }

    bool operator!=( SubresourceLayout const& rhs ) const
    {
      return !operator==( rhs );
    }

    DeviceSize offset = 0;
    DeviceSize size = 0;
    DeviceSize rowPitch = 0;
    DeviceSize arrayPitch = 0;
    DeviceSize depthPitch = 0;
  };
  static_assert( sizeof( SubresourceLayout ) == sizeof( VkSubresourceLayout ), "struct and wrapper have different size!" );
  static_assert( offsetof( SubresourceLayout, offset ) == offsetof( VkSubresourceLayout, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubresourceLayout, size ) == offsetof( VkSubresourceLayout, size ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubresourceLayout, rowPitch ) == offsetof( VkSubresourceLayout, rowPitch ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubresourceLayout, arrayPitch ) == offsetof( VkSubresourceLayout, arrayPitch ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubresourceLayout, depthPitch ) == offsetof( VkSubresourceLayout, depthPitch ), "struct member and wrapper member have different offset!" );

  struct BufferCopy
  {
    operator VkBufferCopy const&() const
    {
      return *reinterpret_cast<const VkBufferCopy*>(this);
    }

    operator VkBufferCopy &()
    {
      return *reinterpret_cast<VkBufferCopy*>(this);
    }

    bool operator==( BufferCopy const& rhs ) const
    {
      return ( srcOffset == rhs.srcOffset )
          && ( dstOffset == rhs.dstOffset )
          && ( size == rhs.size );
    }

    bool operator!=( BufferCopy const& rhs ) const
    {
      return !operator==( rhs );
    }

    DeviceSize srcOffset = 0;
    DeviceSize dstOffset = 0;
    DeviceSize size = 0;
  };
  static_assert( sizeof( BufferCopy ) == sizeof( VkBufferCopy ), "struct and wrapper have different size!" );
  static_assert( offsetof( BufferCopy, srcOffset ) == offsetof( VkBufferCopy, srcOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferCopy, dstOffset ) == offsetof( VkBufferCopy, dstOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferCopy, size ) == offsetof( VkBufferCopy, size ), "struct member and wrapper member have different offset!" );

  struct SpecializationMapEntry
  {
    operator VkSpecializationMapEntry const&() const
    {
      return *reinterpret_cast<const VkSpecializationMapEntry*>(this);
    }

    operator VkSpecializationMapEntry &()
    {
      return *reinterpret_cast<VkSpecializationMapEntry*>(this);
    }

    bool operator==( SpecializationMapEntry const& rhs ) const
    {
      return ( constantID == rhs.constantID )
          && ( offset == rhs.offset )
          && ( size == rhs.size );
    }

    bool operator!=( SpecializationMapEntry const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t constantID = 0;
    uint32_t offset = 0;
    size_t size = 0;
  };
  static_assert( sizeof( SpecializationMapEntry ) == sizeof( VkSpecializationMapEntry ), "struct and wrapper have different size!" );
  static_assert( offsetof( SpecializationMapEntry, constantID ) == offsetof( VkSpecializationMapEntry, constantID ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SpecializationMapEntry, offset ) == offsetof( VkSpecializationMapEntry, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SpecializationMapEntry, size ) == offsetof( VkSpecializationMapEntry, size ), "struct member and wrapper member have different offset!" );

  struct SpecializationInfo
  {
    operator VkSpecializationInfo const&() const
    {
      return *reinterpret_cast<const VkSpecializationInfo*>(this);
    }

    operator VkSpecializationInfo &()
    {
      return *reinterpret_cast<VkSpecializationInfo*>(this);
    }

    bool operator==( SpecializationInfo const& rhs ) const
    {
      return ( mapEntryCount == rhs.mapEntryCount )
          && ( pMapEntries == rhs.pMapEntries )
          && ( dataSize == rhs.dataSize )
          && ( pData == rhs.pData );
    }

    bool operator!=( SpecializationInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t mapEntryCount = 0;
    const SpecializationMapEntry* pMapEntries = nullptr;
    size_t dataSize = 0;
    const void* pData = nullptr;
  };
  static_assert( sizeof( SpecializationInfo ) == sizeof( VkSpecializationInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( SpecializationInfo, mapEntryCount ) == offsetof( VkSpecializationInfo, mapEntryCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SpecializationInfo, pMapEntries ) == offsetof( VkSpecializationInfo, pMapEntries ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SpecializationInfo, dataSize ) == offsetof( VkSpecializationInfo, dataSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SpecializationInfo, pData ) == offsetof( VkSpecializationInfo, pData ), "struct member and wrapper member have different offset!" );

  union ClearColorValue
  {
    ClearColorValue( const std::array<float,4>& float32_ = { {0} } )
    {
      memcpy( &float32, float32_.data(), 4 * sizeof( float ) );
    }

    ClearColorValue( const std::array<int32_t,4>& int32_ )
    {
      memcpy( &int32, int32_.data(), 4 * sizeof( int32_t ) );
    }

    ClearColorValue( const std::array<uint32_t,4>& uint32_ )
    {
      memcpy( &uint32, uint32_.data(), 4 * sizeof( uint32_t ) );
    }

    ClearColorValue& setFloat32( std::array<float,4> float32_ )
    {
      memcpy( &float32, float32_.data(), 4 * sizeof( float ) );
      return *this;
    }

    ClearColorValue& setInt32( std::array<int32_t,4> int32_ )
    {
      memcpy( &int32, int32_.data(), 4 * sizeof( int32_t ) );
      return *this;
    }

    ClearColorValue& setUint32( std::array<uint32_t,4> uint32_ )
    {
      memcpy( &uint32, uint32_.data(), 4 * sizeof( uint32_t ) );
      return *this;
    }

    operator VkClearColorValue const&() const
    {
      return *reinterpret_cast<const VkClearColorValue*>(this);
    }

    operator VkClearColorValue &()
    {
      return *reinterpret_cast<VkClearColorValue*>(this);
    }

    float float32[4];
    int32_t int32[4];
    uint32_t uint32[4];
  };

  struct ClearDepthStencilValue
  {
    operator VkClearDepthStencilValue const&() const
    {
      return *reinterpret_cast<const VkClearDepthStencilValue*>(this);
    }

    operator VkClearDepthStencilValue &()
    {
      return *reinterpret_cast<VkClearDepthStencilValue*>(this);
    }

    bool operator==( ClearDepthStencilValue const& rhs ) const
    {
      return ( depth == rhs.depth )
          && ( stencil == rhs.stencil );
    }

    bool operator!=( ClearDepthStencilValue const& rhs ) const
    {
      return !operator==( rhs );
    }

    float depth = 0;
    uint32_t stencil = 0;
  };
  static_assert( sizeof( ClearDepthStencilValue ) == sizeof( VkClearDepthStencilValue ), "struct and wrapper have different size!" );
  static_assert( offsetof( ClearDepthStencilValue, depth ) == offsetof( VkClearDepthStencilValue, depth ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ClearDepthStencilValue, stencil ) == offsetof( VkClearDepthStencilValue, stencil ), "struct member and wrapper member have different offset!" );

  union ClearValue
  {
    ClearValue( ClearColorValue color_ = ClearColorValue() )
    {
      color = color_;
    }

    ClearValue( ClearDepthStencilValue depthStencil_ )
    {
      depthStencil = depthStencil_;
    }

    ClearValue& setColor( ClearColorValue color_ )
    {
      color = color_;
      return *this;
    }

    ClearValue& setDepthStencil( ClearDepthStencilValue depthStencil_ )
    {
      depthStencil = depthStencil_;
      return *this;
    }

    operator VkClearValue const&() const
    {
      return *reinterpret_cast<const VkClearValue*>(this);
    }

    operator VkClearValue &()
    {
      return *reinterpret_cast<VkClearValue*>(this);
    }

#ifdef VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
    ClearColorValue color;
    ClearDepthStencilValue depthStencil;
#else
    VkClearColorValue color;
    VkClearDepthStencilValue depthStencil;
#endif  // VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
  };

  struct PhysicalDeviceFeatures
  {
    operator VkPhysicalDeviceFeatures const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceFeatures*>(this);
    }

    operator VkPhysicalDeviceFeatures &()
    {
      return *reinterpret_cast<VkPhysicalDeviceFeatures*>(this);
    }

    bool operator==( PhysicalDeviceFeatures const& rhs ) const
    {
      return ( robustBufferAccess == rhs.robustBufferAccess )
          && ( fullDrawIndexUint32 == rhs.fullDrawIndexUint32 )
          && ( imageCubeArray == rhs.imageCubeArray )
          && ( independentBlend == rhs.independentBlend )
          && ( geometryShader == rhs.geometryShader )
          && ( tessellationShader == rhs.tessellationShader )
          && ( sampleRateShading == rhs.sampleRateShading )
          && ( dualSrcBlend == rhs.dualSrcBlend )
          && ( logicOp == rhs.logicOp )
          && ( multiDrawIndirect == rhs.multiDrawIndirect )
          && ( drawIndirectFirstInstance == rhs.drawIndirectFirstInstance )
          && ( depthClamp == rhs.depthClamp )
          && ( depthBiasClamp == rhs.depthBiasClamp )
          && ( fillModeNonSolid == rhs.fillModeNonSolid )
          && ( depthBounds == rhs.depthBounds )
          && ( wideLines == rhs.wideLines )
          && ( largePoints == rhs.largePoints )
          && ( alphaToOne == rhs.alphaToOne )
          && ( multiViewport == rhs.multiViewport )
          && ( samplerAnisotropy == rhs.samplerAnisotropy )
          && ( textureCompressionETC2 == rhs.textureCompressionETC2 )
          && ( textureCompressionASTC_LDR == rhs.textureCompressionASTC_LDR )
          && ( textureCompressionBC == rhs.textureCompressionBC )
          && ( occlusionQueryPrecise == rhs.occlusionQueryPrecise )
          && ( pipelineStatisticsQuery == rhs.pipelineStatisticsQuery )
          && ( vertexPipelineStoresAndAtomics == rhs.vertexPipelineStoresAndAtomics )
          && ( fragmentStoresAndAtomics == rhs.fragmentStoresAndAtomics )
          && ( shaderTessellationAndGeometryPointSize == rhs.shaderTessellationAndGeometryPointSize )
          && ( shaderImageGatherExtended == rhs.shaderImageGatherExtended )
          && ( shaderStorageImageExtendedFormats == rhs.shaderStorageImageExtendedFormats )
          && ( shaderStorageImageMultisample == rhs.shaderStorageImageMultisample )
          && ( shaderStorageImageReadWithoutFormat == rhs.shaderStorageImageReadWithoutFormat )
          && ( shaderStorageImageWriteWithoutFormat == rhs.shaderStorageImageWriteWithoutFormat )
          && ( shaderUniformBufferArrayDynamicIndexing == rhs.shaderUniformBufferArrayDynamicIndexing )
          && ( shaderSampledImageArrayDynamicIndexing == rhs.shaderSampledImageArrayDynamicIndexing )
          && ( shaderStorageBufferArrayDynamicIndexing == rhs.shaderStorageBufferArrayDynamicIndexing )
          && ( shaderStorageImageArrayDynamicIndexing == rhs.shaderStorageImageArrayDynamicIndexing )
          && ( shaderClipDistance == rhs.shaderClipDistance )
          && ( shaderCullDistance == rhs.shaderCullDistance )
          && ( shaderFloat64 == rhs.shaderFloat64 )
          && ( shaderInt64 == rhs.shaderInt64 )
          && ( shaderInt16 == rhs.shaderInt16 )
          && ( shaderResourceResidency == rhs.shaderResourceResidency )
          && ( shaderResourceMinLod == rhs.shaderResourceMinLod )
          && ( sparseBinding == rhs.sparseBinding )
          && ( sparseResidencyBuffer == rhs.sparseResidencyBuffer )
          && ( sparseResidencyImage2D == rhs.sparseResidencyImage2D )
          && ( sparseResidencyImage3D == rhs.sparseResidencyImage3D )
          && ( sparseResidency2Samples == rhs.sparseResidency2Samples )
          && ( sparseResidency4Samples == rhs.sparseResidency4Samples )
          && ( sparseResidency8Samples == rhs.sparseResidency8Samples )
          && ( sparseResidency16Samples == rhs.sparseResidency16Samples )
          && ( sparseResidencyAliased == rhs.sparseResidencyAliased )
          && ( variableMultisampleRate == rhs.variableMultisampleRate )
          && ( inheritedQueries == rhs.inheritedQueries );
    }

    bool operator!=( PhysicalDeviceFeatures const& rhs ) const
    {
      return !operator==( rhs );
    }

    Bool32 robustBufferAccess = 0;
    Bool32 fullDrawIndexUint32 = 0;
    Bool32 imageCubeArray = 0;
    Bool32 independentBlend = 0;
    Bool32 geometryShader = 0;
    Bool32 tessellationShader = 0;
    Bool32 sampleRateShading = 0;
    Bool32 dualSrcBlend = 0;
    Bool32 logicOp = 0;
    Bool32 multiDrawIndirect = 0;
    Bool32 drawIndirectFirstInstance = 0;
    Bool32 depthClamp = 0;
    Bool32 depthBiasClamp = 0;
    Bool32 fillModeNonSolid = 0;
    Bool32 depthBounds = 0;
    Bool32 wideLines = 0;
    Bool32 largePoints = 0;
    Bool32 alphaToOne = 0;
    Bool32 multiViewport = 0;
    Bool32 samplerAnisotropy = 0;
    Bool32 textureCompressionETC2 = 0;
    Bool32 textureCompressionASTC_LDR = 0;
    Bool32 textureCompressionBC = 0;
    Bool32 occlusionQueryPrecise = 0;
    Bool32 pipelineStatisticsQuery = 0;
    Bool32 vertexPipelineStoresAndAtomics = 0;
    Bool32 fragmentStoresAndAtomics = 0;
    Bool32 shaderTessellationAndGeometryPointSize = 0;
    Bool32 shaderImageGatherExtended = 0;
    Bool32 shaderStorageImageExtendedFormats = 0;
    Bool32 shaderStorageImageMultisample = 0;
    Bool32 shaderStorageImageReadWithoutFormat = 0;
    Bool32 shaderStorageImageWriteWithoutFormat = 0;
    Bool32 shaderUniformBufferArrayDynamicIndexing = 0;
    Bool32 shaderSampledImageArrayDynamicIndexing = 0;
    Bool32 shaderStorageBufferArrayDynamicIndexing = 0;
    Bool32 shaderStorageImageArrayDynamicIndexing = 0;
    Bool32 shaderClipDistance = 0;
    Bool32 shaderCullDistance = 0;
    Bool32 shaderFloat64 = 0;
    Bool32 shaderInt64 = 0;
    Bool32 shaderInt16 = 0;
    Bool32 shaderResourceResidency = 0;
    Bool32 shaderResourceMinLod = 0;
    Bool32 sparseBinding = 0;
    Bool32 sparseResidencyBuffer = 0;
    Bool32 sparseResidencyImage2D = 0;
    Bool32 sparseResidencyImage3D = 0;
    Bool32 sparseResidency2Samples = 0;
    Bool32 sparseResidency4Samples = 0;
    Bool32 sparseResidency8Samples = 0;
    Bool32 sparseResidency16Samples = 0;
    Bool32 sparseResidencyAliased = 0;
    Bool32 variableMultisampleRate = 0;
    Bool32 inheritedQueries = 0;
  };
  static_assert( sizeof( PhysicalDeviceFeatures ) == sizeof( VkPhysicalDeviceFeatures ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceFeatures, robustBufferAccess ) == offsetof( VkPhysicalDeviceFeatures, robustBufferAccess ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, fullDrawIndexUint32 ) == offsetof( VkPhysicalDeviceFeatures, fullDrawIndexUint32 ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, imageCubeArray ) == offsetof( VkPhysicalDeviceFeatures, imageCubeArray ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, independentBlend ) == offsetof( VkPhysicalDeviceFeatures, independentBlend ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, geometryShader ) == offsetof( VkPhysicalDeviceFeatures, geometryShader ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, tessellationShader ) == offsetof( VkPhysicalDeviceFeatures, tessellationShader ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sampleRateShading ) == offsetof( VkPhysicalDeviceFeatures, sampleRateShading ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, dualSrcBlend ) == offsetof( VkPhysicalDeviceFeatures, dualSrcBlend ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, logicOp ) == offsetof( VkPhysicalDeviceFeatures, logicOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, multiDrawIndirect ) == offsetof( VkPhysicalDeviceFeatures, multiDrawIndirect ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, drawIndirectFirstInstance ) == offsetof( VkPhysicalDeviceFeatures, drawIndirectFirstInstance ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, depthClamp ) == offsetof( VkPhysicalDeviceFeatures, depthClamp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, depthBiasClamp ) == offsetof( VkPhysicalDeviceFeatures, depthBiasClamp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, fillModeNonSolid ) == offsetof( VkPhysicalDeviceFeatures, fillModeNonSolid ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, depthBounds ) == offsetof( VkPhysicalDeviceFeatures, depthBounds ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, wideLines ) == offsetof( VkPhysicalDeviceFeatures, wideLines ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, largePoints ) == offsetof( VkPhysicalDeviceFeatures, largePoints ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, alphaToOne ) == offsetof( VkPhysicalDeviceFeatures, alphaToOne ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, multiViewport ) == offsetof( VkPhysicalDeviceFeatures, multiViewport ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, samplerAnisotropy ) == offsetof( VkPhysicalDeviceFeatures, samplerAnisotropy ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, textureCompressionETC2 ) == offsetof( VkPhysicalDeviceFeatures, textureCompressionETC2 ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, textureCompressionASTC_LDR ) == offsetof( VkPhysicalDeviceFeatures, textureCompressionASTC_LDR ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, textureCompressionBC ) == offsetof( VkPhysicalDeviceFeatures, textureCompressionBC ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, occlusionQueryPrecise ) == offsetof( VkPhysicalDeviceFeatures, occlusionQueryPrecise ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, pipelineStatisticsQuery ) == offsetof( VkPhysicalDeviceFeatures, pipelineStatisticsQuery ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, vertexPipelineStoresAndAtomics ) == offsetof( VkPhysicalDeviceFeatures, vertexPipelineStoresAndAtomics ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, fragmentStoresAndAtomics ) == offsetof( VkPhysicalDeviceFeatures, fragmentStoresAndAtomics ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderTessellationAndGeometryPointSize ) == offsetof( VkPhysicalDeviceFeatures, shaderTessellationAndGeometryPointSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderImageGatherExtended ) == offsetof( VkPhysicalDeviceFeatures, shaderImageGatherExtended ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderStorageImageExtendedFormats ) == offsetof( VkPhysicalDeviceFeatures, shaderStorageImageExtendedFormats ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderStorageImageMultisample ) == offsetof( VkPhysicalDeviceFeatures, shaderStorageImageMultisample ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderStorageImageReadWithoutFormat ) == offsetof( VkPhysicalDeviceFeatures, shaderStorageImageReadWithoutFormat ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderStorageImageWriteWithoutFormat ) == offsetof( VkPhysicalDeviceFeatures, shaderStorageImageWriteWithoutFormat ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderUniformBufferArrayDynamicIndexing ) == offsetof( VkPhysicalDeviceFeatures, shaderUniformBufferArrayDynamicIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderSampledImageArrayDynamicIndexing ) == offsetof( VkPhysicalDeviceFeatures, shaderSampledImageArrayDynamicIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderStorageBufferArrayDynamicIndexing ) == offsetof( VkPhysicalDeviceFeatures, shaderStorageBufferArrayDynamicIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderStorageImageArrayDynamicIndexing ) == offsetof( VkPhysicalDeviceFeatures, shaderStorageImageArrayDynamicIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderClipDistance ) == offsetof( VkPhysicalDeviceFeatures, shaderClipDistance ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderCullDistance ) == offsetof( VkPhysicalDeviceFeatures, shaderCullDistance ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderFloat64 ) == offsetof( VkPhysicalDeviceFeatures, shaderFloat64 ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderInt64 ) == offsetof( VkPhysicalDeviceFeatures, shaderInt64 ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderInt16 ) == offsetof( VkPhysicalDeviceFeatures, shaderInt16 ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderResourceResidency ) == offsetof( VkPhysicalDeviceFeatures, shaderResourceResidency ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, shaderResourceMinLod ) == offsetof( VkPhysicalDeviceFeatures, shaderResourceMinLod ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sparseBinding ) == offsetof( VkPhysicalDeviceFeatures, sparseBinding ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sparseResidencyBuffer ) == offsetof( VkPhysicalDeviceFeatures, sparseResidencyBuffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sparseResidencyImage2D ) == offsetof( VkPhysicalDeviceFeatures, sparseResidencyImage2D ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sparseResidencyImage3D ) == offsetof( VkPhysicalDeviceFeatures, sparseResidencyImage3D ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sparseResidency2Samples ) == offsetof( VkPhysicalDeviceFeatures, sparseResidency2Samples ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sparseResidency4Samples ) == offsetof( VkPhysicalDeviceFeatures, sparseResidency4Samples ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sparseResidency8Samples ) == offsetof( VkPhysicalDeviceFeatures, sparseResidency8Samples ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sparseResidency16Samples ) == offsetof( VkPhysicalDeviceFeatures, sparseResidency16Samples ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, sparseResidencyAliased ) == offsetof( VkPhysicalDeviceFeatures, sparseResidencyAliased ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, variableMultisampleRate ) == offsetof( VkPhysicalDeviceFeatures, variableMultisampleRate ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures, inheritedQueries ) == offsetof( VkPhysicalDeviceFeatures, inheritedQueries ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceSparseProperties
  {
    operator VkPhysicalDeviceSparseProperties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceSparseProperties*>(this);
    }

    operator VkPhysicalDeviceSparseProperties &()
    {
      return *reinterpret_cast<VkPhysicalDeviceSparseProperties*>(this);
    }

    bool operator==( PhysicalDeviceSparseProperties const& rhs ) const
    {
      return ( residencyStandard2DBlockShape == rhs.residencyStandard2DBlockShape )
          && ( residencyStandard2DMultisampleBlockShape == rhs.residencyStandard2DMultisampleBlockShape )
          && ( residencyStandard3DBlockShape == rhs.residencyStandard3DBlockShape )
          && ( residencyAlignedMipSize == rhs.residencyAlignedMipSize )
          && ( residencyNonResidentStrict == rhs.residencyNonResidentStrict );
    }

    bool operator!=( PhysicalDeviceSparseProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    Bool32 residencyStandard2DBlockShape = 0;
    Bool32 residencyStandard2DMultisampleBlockShape = 0;
    Bool32 residencyStandard3DBlockShape = 0;
    Bool32 residencyAlignedMipSize = 0;
    Bool32 residencyNonResidentStrict = 0;
  };
  static_assert( sizeof( PhysicalDeviceSparseProperties ) == sizeof( VkPhysicalDeviceSparseProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceSparseProperties, residencyStandard2DBlockShape ) == offsetof( VkPhysicalDeviceSparseProperties, residencyStandard2DBlockShape ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSparseProperties, residencyStandard2DMultisampleBlockShape ) == offsetof( VkPhysicalDeviceSparseProperties, residencyStandard2DMultisampleBlockShape ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSparseProperties, residencyStandard3DBlockShape ) == offsetof( VkPhysicalDeviceSparseProperties, residencyStandard3DBlockShape ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSparseProperties, residencyAlignedMipSize ) == offsetof( VkPhysicalDeviceSparseProperties, residencyAlignedMipSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSparseProperties, residencyNonResidentStrict ) == offsetof( VkPhysicalDeviceSparseProperties, residencyNonResidentStrict ), "struct member and wrapper member have different offset!" );

  struct DrawIndirectCommand
  {
    operator VkDrawIndirectCommand const&() const
    {
      return *reinterpret_cast<const VkDrawIndirectCommand*>(this);
    }

    operator VkDrawIndirectCommand &()
    {
      return *reinterpret_cast<VkDrawIndirectCommand*>(this);
    }

    bool operator==( DrawIndirectCommand const& rhs ) const
    {
      return ( vertexCount == rhs.vertexCount )
          && ( instanceCount == rhs.instanceCount )
          && ( firstVertex == rhs.firstVertex )
          && ( firstInstance == rhs.firstInstance );
    }

    bool operator!=( DrawIndirectCommand const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t vertexCount = 0;
    uint32_t instanceCount = 0;
    uint32_t firstVertex = 0;
    uint32_t firstInstance = 0;
  };
  static_assert( sizeof( DrawIndirectCommand ) == sizeof( VkDrawIndirectCommand ), "struct and wrapper have different size!" );
  static_assert( offsetof( DrawIndirectCommand, vertexCount ) == offsetof( VkDrawIndirectCommand, vertexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DrawIndirectCommand, instanceCount ) == offsetof( VkDrawIndirectCommand, instanceCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DrawIndirectCommand, firstVertex ) == offsetof( VkDrawIndirectCommand, firstVertex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DrawIndirectCommand, firstInstance ) == offsetof( VkDrawIndirectCommand, firstInstance ), "struct member and wrapper member have different offset!" );

  struct DrawIndexedIndirectCommand
  {
    operator VkDrawIndexedIndirectCommand const&() const
    {
      return *reinterpret_cast<const VkDrawIndexedIndirectCommand*>(this);
    }

    operator VkDrawIndexedIndirectCommand &()
    {
      return *reinterpret_cast<VkDrawIndexedIndirectCommand*>(this);
    }

    bool operator==( DrawIndexedIndirectCommand const& rhs ) const
    {
      return ( indexCount == rhs.indexCount )
          && ( instanceCount == rhs.instanceCount )
          && ( firstIndex == rhs.firstIndex )
          && ( vertexOffset == rhs.vertexOffset )
          && ( firstInstance == rhs.firstInstance );
    }

    bool operator!=( DrawIndexedIndirectCommand const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t indexCount = 0;
    uint32_t instanceCount = 0;
    uint32_t firstIndex = 0;
    int32_t vertexOffset = 0;
    uint32_t firstInstance = 0;
  };
  static_assert( sizeof( DrawIndexedIndirectCommand ) == sizeof( VkDrawIndexedIndirectCommand ), "struct and wrapper have different size!" );
  static_assert( offsetof( DrawIndexedIndirectCommand, indexCount ) == offsetof( VkDrawIndexedIndirectCommand, indexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DrawIndexedIndirectCommand, instanceCount ) == offsetof( VkDrawIndexedIndirectCommand, instanceCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DrawIndexedIndirectCommand, firstIndex ) == offsetof( VkDrawIndexedIndirectCommand, firstIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DrawIndexedIndirectCommand, vertexOffset ) == offsetof( VkDrawIndexedIndirectCommand, vertexOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DrawIndexedIndirectCommand, firstInstance ) == offsetof( VkDrawIndexedIndirectCommand, firstInstance ), "struct member and wrapper member have different offset!" );

  struct DispatchIndirectCommand
  {
    operator VkDispatchIndirectCommand const&() const
    {
      return *reinterpret_cast<const VkDispatchIndirectCommand*>(this);
    }

    operator VkDispatchIndirectCommand &()
    {
      return *reinterpret_cast<VkDispatchIndirectCommand*>(this);
    }

    bool operator==( DispatchIndirectCommand const& rhs ) const
    {
      return ( x == rhs.x )
          && ( y == rhs.y )
          && ( z == rhs.z );
    }

    bool operator!=( DispatchIndirectCommand const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t x = 0;
    uint32_t y = 0;
    uint32_t z = 0;
  };
  static_assert( sizeof( DispatchIndirectCommand ) == sizeof( VkDispatchIndirectCommand ), "struct and wrapper have different size!" );
  static_assert( offsetof( DispatchIndirectCommand, x ) == offsetof( VkDispatchIndirectCommand, x ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DispatchIndirectCommand, y ) == offsetof( VkDispatchIndirectCommand, y ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DispatchIndirectCommand, z ) == offsetof( VkDispatchIndirectCommand, z ), "struct member and wrapper member have different offset!" );

  struct DisplayPlanePropertiesKHR
  {
    operator VkDisplayPlanePropertiesKHR const&() const
    {
      return *reinterpret_cast<const VkDisplayPlanePropertiesKHR*>(this);
    }

    operator VkDisplayPlanePropertiesKHR &()
    {
      return *reinterpret_cast<VkDisplayPlanePropertiesKHR*>(this);
    }

    bool operator==( DisplayPlanePropertiesKHR const& rhs ) const
    {
      return ( currentDisplay == rhs.currentDisplay )
          && ( currentStackIndex == rhs.currentStackIndex );
    }

    bool operator!=( DisplayPlanePropertiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    DisplayKHR currentDisplay = DisplayKHR();
    uint32_t currentStackIndex = 0;
  };
  static_assert( sizeof( DisplayPlanePropertiesKHR ) == sizeof( VkDisplayPlanePropertiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayPlanePropertiesKHR, currentDisplay ) == offsetof( VkDisplayPlanePropertiesKHR, currentDisplay ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlanePropertiesKHR, currentStackIndex ) == offsetof( VkDisplayPlanePropertiesKHR, currentStackIndex ), "struct member and wrapper member have different offset!" );

  struct DisplayModeParametersKHR
  {
    operator VkDisplayModeParametersKHR const&() const
    {
      return *reinterpret_cast<const VkDisplayModeParametersKHR*>(this);
    }

    operator VkDisplayModeParametersKHR &()
    {
      return *reinterpret_cast<VkDisplayModeParametersKHR*>(this);
    }

    bool operator==( DisplayModeParametersKHR const& rhs ) const
    {
      return ( visibleRegion == rhs.visibleRegion )
          && ( refreshRate == rhs.refreshRate );
    }

    bool operator!=( DisplayModeParametersKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    Extent2D visibleRegion = Extent2D();
    uint32_t refreshRate = 0;
  };
  static_assert( sizeof( DisplayModeParametersKHR ) == sizeof( VkDisplayModeParametersKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayModeParametersKHR, visibleRegion ) == offsetof( VkDisplayModeParametersKHR, visibleRegion ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayModeParametersKHR, refreshRate ) == offsetof( VkDisplayModeParametersKHR, refreshRate ), "struct member and wrapper member have different offset!" );

  struct DisplayModePropertiesKHR
  {
    operator VkDisplayModePropertiesKHR const&() const
    {
      return *reinterpret_cast<const VkDisplayModePropertiesKHR*>(this);
    }

    operator VkDisplayModePropertiesKHR &()
    {
      return *reinterpret_cast<VkDisplayModePropertiesKHR*>(this);
    }

    bool operator==( DisplayModePropertiesKHR const& rhs ) const
    {
      return ( displayMode == rhs.displayMode )
          && ( parameters == rhs.parameters );
    }

    bool operator!=( DisplayModePropertiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    DisplayModeKHR displayMode = DisplayModeKHR();
    DisplayModeParametersKHR parameters = DisplayModeParametersKHR();
  };
  static_assert( sizeof( DisplayModePropertiesKHR ) == sizeof( VkDisplayModePropertiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayModePropertiesKHR, displayMode ) == offsetof( VkDisplayModePropertiesKHR, displayMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayModePropertiesKHR, parameters ) == offsetof( VkDisplayModePropertiesKHR, parameters ), "struct member and wrapper member have different offset!" );

  struct RectLayerKHR
  {
    operator VkRectLayerKHR const&() const
    {
      return *reinterpret_cast<const VkRectLayerKHR*>(this);
    }

    operator VkRectLayerKHR &()
    {
      return *reinterpret_cast<VkRectLayerKHR*>(this);
    }

    bool operator==( RectLayerKHR const& rhs ) const
    {
      return ( offset == rhs.offset )
          && ( extent == rhs.extent )
          && ( layer == rhs.layer );
    }

    bool operator!=( RectLayerKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    Offset2D offset = Offset2D();
    Extent2D extent = Extent2D();
    uint32_t layer = 0;
  };
  static_assert( sizeof( RectLayerKHR ) == sizeof( VkRectLayerKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( RectLayerKHR, offset ) == offsetof( VkRectLayerKHR, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RectLayerKHR, extent ) == offsetof( VkRectLayerKHR, extent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RectLayerKHR, layer ) == offsetof( VkRectLayerKHR, layer ), "struct member and wrapper member have different offset!" );

  struct PresentRegionKHR
  {
    operator VkPresentRegionKHR const&() const
    {
      return *reinterpret_cast<const VkPresentRegionKHR*>(this);
    }

    operator VkPresentRegionKHR &()
    {
      return *reinterpret_cast<VkPresentRegionKHR*>(this);
    }

    bool operator==( PresentRegionKHR const& rhs ) const
    {
      return ( rectangleCount == rhs.rectangleCount )
          && ( pRectangles == rhs.pRectangles );
    }

    bool operator!=( PresentRegionKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t rectangleCount = 0;
    const RectLayerKHR* pRectangles = nullptr;
  };
  static_assert( sizeof( PresentRegionKHR ) == sizeof( VkPresentRegionKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( PresentRegionKHR, rectangleCount ) == offsetof( VkPresentRegionKHR, rectangleCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentRegionKHR, pRectangles ) == offsetof( VkPresentRegionKHR, pRectangles ), "struct member and wrapper member have different offset!" );

  struct XYColorEXT
  {
    operator VkXYColorEXT const&() const
    {
      return *reinterpret_cast<const VkXYColorEXT*>(this);
    }

    operator VkXYColorEXT &()
    {
      return *reinterpret_cast<VkXYColorEXT*>(this);
    }

    bool operator==( XYColorEXT const& rhs ) const
    {
      return ( x == rhs.x )
          && ( y == rhs.y );
    }

    bool operator!=( XYColorEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    float x = 0;
    float y = 0;
  };
  static_assert( sizeof( XYColorEXT ) == sizeof( VkXYColorEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( XYColorEXT, x ) == offsetof( VkXYColorEXT, x ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( XYColorEXT, y ) == offsetof( VkXYColorEXT, y ), "struct member and wrapper member have different offset!" );

  struct RefreshCycleDurationGOOGLE
  {
    operator VkRefreshCycleDurationGOOGLE const&() const
    {
      return *reinterpret_cast<const VkRefreshCycleDurationGOOGLE*>(this);
    }

    operator VkRefreshCycleDurationGOOGLE &()
    {
      return *reinterpret_cast<VkRefreshCycleDurationGOOGLE*>(this);
    }

    bool operator==( RefreshCycleDurationGOOGLE const& rhs ) const
    {
      return ( refreshDuration == rhs.refreshDuration );
    }

    bool operator!=( RefreshCycleDurationGOOGLE const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint64_t refreshDuration = 0;
  };
  static_assert( sizeof( RefreshCycleDurationGOOGLE ) == sizeof( VkRefreshCycleDurationGOOGLE ), "struct and wrapper have different size!" );
  static_assert( offsetof( RefreshCycleDurationGOOGLE, refreshDuration ) == offsetof( VkRefreshCycleDurationGOOGLE, refreshDuration ), "struct member and wrapper member have different offset!" );

  struct PastPresentationTimingGOOGLE
  {
    operator VkPastPresentationTimingGOOGLE const&() const
    {
      return *reinterpret_cast<const VkPastPresentationTimingGOOGLE*>(this);
    }

    operator VkPastPresentationTimingGOOGLE &()
    {
      return *reinterpret_cast<VkPastPresentationTimingGOOGLE*>(this);
    }

    bool operator==( PastPresentationTimingGOOGLE const& rhs ) const
    {
      return ( presentID == rhs.presentID )
          && ( desiredPresentTime == rhs.desiredPresentTime )
          && ( actualPresentTime == rhs.actualPresentTime )
          && ( earliestPresentTime == rhs.earliestPresentTime )
          && ( presentMargin == rhs.presentMargin );
    }

    bool operator!=( PastPresentationTimingGOOGLE const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t presentID = 0;
    uint64_t desiredPresentTime = 0;
    uint64_t actualPresentTime = 0;
    uint64_t earliestPresentTime = 0;
    uint64_t presentMargin = 0;
  };
  static_assert( sizeof( PastPresentationTimingGOOGLE ) == sizeof( VkPastPresentationTimingGOOGLE ), "struct and wrapper have different size!" );
  static_assert( offsetof( PastPresentationTimingGOOGLE, presentID ) == offsetof( VkPastPresentationTimingGOOGLE, presentID ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PastPresentationTimingGOOGLE, desiredPresentTime ) == offsetof( VkPastPresentationTimingGOOGLE, desiredPresentTime ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PastPresentationTimingGOOGLE, actualPresentTime ) == offsetof( VkPastPresentationTimingGOOGLE, actualPresentTime ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PastPresentationTimingGOOGLE, earliestPresentTime ) == offsetof( VkPastPresentationTimingGOOGLE, earliestPresentTime ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PastPresentationTimingGOOGLE, presentMargin ) == offsetof( VkPastPresentationTimingGOOGLE, presentMargin ), "struct member and wrapper member have different offset!" );

  struct PresentTimeGOOGLE
  {
    operator VkPresentTimeGOOGLE const&() const
    {
      return *reinterpret_cast<const VkPresentTimeGOOGLE*>(this);
    }

    operator VkPresentTimeGOOGLE &()
    {
      return *reinterpret_cast<VkPresentTimeGOOGLE*>(this);
    }

    bool operator==( PresentTimeGOOGLE const& rhs ) const
    {
      return ( presentID == rhs.presentID )
          && ( desiredPresentTime == rhs.desiredPresentTime );
    }

    bool operator!=( PresentTimeGOOGLE const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t presentID = 0;
    uint64_t desiredPresentTime = 0;
  };
  static_assert( sizeof( PresentTimeGOOGLE ) == sizeof( VkPresentTimeGOOGLE ), "struct and wrapper have different size!" );
  static_assert( offsetof( PresentTimeGOOGLE, presentID ) == offsetof( VkPresentTimeGOOGLE, presentID ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentTimeGOOGLE, desiredPresentTime ) == offsetof( VkPresentTimeGOOGLE, desiredPresentTime ), "struct member and wrapper member have different offset!" );

  struct ViewportWScalingNV
  {
    operator VkViewportWScalingNV const&() const
    {
      return *reinterpret_cast<const VkViewportWScalingNV*>(this);
    }

    operator VkViewportWScalingNV &()
    {
      return *reinterpret_cast<VkViewportWScalingNV*>(this);
    }

    bool operator==( ViewportWScalingNV const& rhs ) const
    {
      return ( xcoeff == rhs.xcoeff )
          && ( ycoeff == rhs.ycoeff );
    }

    bool operator!=( ViewportWScalingNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    float xcoeff = 0;
    float ycoeff = 0;
  };
  static_assert( sizeof( ViewportWScalingNV ) == sizeof( VkViewportWScalingNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( ViewportWScalingNV, xcoeff ) == offsetof( VkViewportWScalingNV, xcoeff ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ViewportWScalingNV, ycoeff ) == offsetof( VkViewportWScalingNV, ycoeff ), "struct member and wrapper member have different offset!" );

  struct SampleLocationEXT
  {
    operator VkSampleLocationEXT const&() const
    {
      return *reinterpret_cast<const VkSampleLocationEXT*>(this);
    }

    operator VkSampleLocationEXT &()
    {
      return *reinterpret_cast<VkSampleLocationEXT*>(this);
    }

    bool operator==( SampleLocationEXT const& rhs ) const
    {
      return ( x == rhs.x )
          && ( y == rhs.y );
    }

    bool operator!=( SampleLocationEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    float x = 0;
    float y = 0;
  };
  static_assert( sizeof( SampleLocationEXT ) == sizeof( VkSampleLocationEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( SampleLocationEXT, x ) == offsetof( VkSampleLocationEXT, x ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SampleLocationEXT, y ) == offsetof( VkSampleLocationEXT, y ), "struct member and wrapper member have different offset!" );

  struct ShaderResourceUsageAMD
  {
    operator VkShaderResourceUsageAMD const&() const
    {
      return *reinterpret_cast<const VkShaderResourceUsageAMD*>(this);
    }

    operator VkShaderResourceUsageAMD &()
    {
      return *reinterpret_cast<VkShaderResourceUsageAMD*>(this);
    }

    bool operator==( ShaderResourceUsageAMD const& rhs ) const
    {
      return ( numUsedVgprs == rhs.numUsedVgprs )
          && ( numUsedSgprs == rhs.numUsedSgprs )
          && ( ldsSizePerLocalWorkGroup == rhs.ldsSizePerLocalWorkGroup )
          && ( ldsUsageSizeInBytes == rhs.ldsUsageSizeInBytes )
          && ( scratchMemUsageInBytes == rhs.scratchMemUsageInBytes );
    }

    bool operator!=( ShaderResourceUsageAMD const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t numUsedVgprs = 0;
    uint32_t numUsedSgprs = 0;
    uint32_t ldsSizePerLocalWorkGroup = 0;
    size_t ldsUsageSizeInBytes = 0;
    size_t scratchMemUsageInBytes = 0;
  };
  static_assert( sizeof( ShaderResourceUsageAMD ) == sizeof( VkShaderResourceUsageAMD ), "struct and wrapper have different size!" );
  static_assert( offsetof( ShaderResourceUsageAMD, numUsedVgprs ) == offsetof( VkShaderResourceUsageAMD, numUsedVgprs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderResourceUsageAMD, numUsedSgprs ) == offsetof( VkShaderResourceUsageAMD, numUsedSgprs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderResourceUsageAMD, ldsSizePerLocalWorkGroup ) == offsetof( VkShaderResourceUsageAMD, ldsSizePerLocalWorkGroup ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderResourceUsageAMD, ldsUsageSizeInBytes ) == offsetof( VkShaderResourceUsageAMD, ldsUsageSizeInBytes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderResourceUsageAMD, scratchMemUsageInBytes ) == offsetof( VkShaderResourceUsageAMD, scratchMemUsageInBytes ), "struct member and wrapper member have different offset!" );

  struct VertexInputBindingDivisorDescriptionEXT
  {
    operator VkVertexInputBindingDivisorDescriptionEXT const&() const
    {
      return *reinterpret_cast<const VkVertexInputBindingDivisorDescriptionEXT*>(this);
    }

    operator VkVertexInputBindingDivisorDescriptionEXT &()
    {
      return *reinterpret_cast<VkVertexInputBindingDivisorDescriptionEXT*>(this);
    }

    bool operator==( VertexInputBindingDivisorDescriptionEXT const& rhs ) const
    {
      return ( binding == rhs.binding )
          && ( divisor == rhs.divisor );
    }

    bool operator!=( VertexInputBindingDivisorDescriptionEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t binding = 0;
    uint32_t divisor = 0;
  };
  static_assert( sizeof( VertexInputBindingDivisorDescriptionEXT ) == sizeof( VkVertexInputBindingDivisorDescriptionEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( VertexInputBindingDivisorDescriptionEXT, binding ) == offsetof( VkVertexInputBindingDivisorDescriptionEXT, binding ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( VertexInputBindingDivisorDescriptionEXT, divisor ) == offsetof( VkVertexInputBindingDivisorDescriptionEXT, divisor ), "struct member and wrapper member have different offset!" );

  struct CoarseSampleLocationNV
  {
    operator VkCoarseSampleLocationNV const&() const
    {
      return *reinterpret_cast<const VkCoarseSampleLocationNV*>(this);
    }

    operator VkCoarseSampleLocationNV &()
    {
      return *reinterpret_cast<VkCoarseSampleLocationNV*>(this);
    }

    bool operator==( CoarseSampleLocationNV const& rhs ) const
    {
      return ( pixelX == rhs.pixelX )
          && ( pixelY == rhs.pixelY )
          && ( sample == rhs.sample );
    }

    bool operator!=( CoarseSampleLocationNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t pixelX = 0;
    uint32_t pixelY = 0;
    uint32_t sample = 0;
  };
  static_assert( sizeof( CoarseSampleLocationNV ) == sizeof( VkCoarseSampleLocationNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( CoarseSampleLocationNV, pixelX ) == offsetof( VkCoarseSampleLocationNV, pixelX ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CoarseSampleLocationNV, pixelY ) == offsetof( VkCoarseSampleLocationNV, pixelY ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CoarseSampleLocationNV, sample ) == offsetof( VkCoarseSampleLocationNV, sample ), "struct member and wrapper member have different offset!" );

  struct DrawMeshTasksIndirectCommandNV
  {
    operator VkDrawMeshTasksIndirectCommandNV const&() const
    {
      return *reinterpret_cast<const VkDrawMeshTasksIndirectCommandNV*>(this);
    }

    operator VkDrawMeshTasksIndirectCommandNV &()
    {
      return *reinterpret_cast<VkDrawMeshTasksIndirectCommandNV*>(this);
    }

    bool operator==( DrawMeshTasksIndirectCommandNV const& rhs ) const
    {
      return ( taskCount == rhs.taskCount )
          && ( firstTask == rhs.firstTask );
    }

    bool operator!=( DrawMeshTasksIndirectCommandNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t taskCount = 0;
    uint32_t firstTask = 0;
  };
  static_assert( sizeof( DrawMeshTasksIndirectCommandNV ) == sizeof( VkDrawMeshTasksIndirectCommandNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( DrawMeshTasksIndirectCommandNV, taskCount ) == offsetof( VkDrawMeshTasksIndirectCommandNV, taskCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DrawMeshTasksIndirectCommandNV, firstTask ) == offsetof( VkDrawMeshTasksIndirectCommandNV, firstTask ), "struct member and wrapper member have different offset!" );

  enum class ImageLayout
  {
    eUndefined = VK_IMAGE_LAYOUT_UNDEFINED,
    eGeneral = VK_IMAGE_LAYOUT_GENERAL,
    eColorAttachmentOptimal = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
    eDepthStencilAttachmentOptimal = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    eDepthStencilReadOnlyOptimal = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
    eShaderReadOnlyOptimal = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    eTransferSrcOptimal = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
    eTransferDstOptimal = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    ePreinitialized = VK_IMAGE_LAYOUT_PREINITIALIZED,
    eDepthReadOnlyStencilAttachmentOptimal = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    eDepthReadOnlyStencilAttachmentOptimalKHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    eDepthAttachmentStencilReadOnlyOptimal = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    eDepthAttachmentStencilReadOnlyOptimalKHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    ePresentSrcKHR = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
    eSharedPresentKHR = VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
    eShadingRateOptimalNV = VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV
  };

  struct DescriptorImageInfo
  {
    operator VkDescriptorImageInfo const&() const
    {
      return *reinterpret_cast<const VkDescriptorImageInfo*>(this);
    }

    operator VkDescriptorImageInfo &()
    {
      return *reinterpret_cast<VkDescriptorImageInfo*>(this);
    }

    bool operator==( DescriptorImageInfo const& rhs ) const
    {
      return ( sampler == rhs.sampler )
          && ( imageView == rhs.imageView )
          && ( imageLayout == rhs.imageLayout );
    }

    bool operator!=( DescriptorImageInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    Sampler sampler = Sampler();
    ImageView imageView = ImageView();
    ImageLayout imageLayout = ImageLayout::eUndefined;
  };
  static_assert( sizeof( DescriptorImageInfo ) == sizeof( VkDescriptorImageInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorImageInfo, sampler ) == offsetof( VkDescriptorImageInfo, sampler ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorImageInfo, imageView ) == offsetof( VkDescriptorImageInfo, imageView ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorImageInfo, imageLayout ) == offsetof( VkDescriptorImageInfo, imageLayout ), "struct member and wrapper member have different offset!" );

  struct AttachmentReference
  {
    operator VkAttachmentReference const&() const
    {
      return *reinterpret_cast<const VkAttachmentReference*>(this);
    }

    operator VkAttachmentReference &()
    {
      return *reinterpret_cast<VkAttachmentReference*>(this);
    }

    bool operator==( AttachmentReference const& rhs ) const
    {
      return ( attachment == rhs.attachment )
          && ( layout == rhs.layout );
    }

    bool operator!=( AttachmentReference const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t attachment = 0;
    ImageLayout layout = ImageLayout::eUndefined;
  };
  static_assert( sizeof( AttachmentReference ) == sizeof( VkAttachmentReference ), "struct and wrapper have different size!" );
  static_assert( offsetof( AttachmentReference, attachment ) == offsetof( VkAttachmentReference, attachment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentReference, layout ) == offsetof( VkAttachmentReference, layout ), "struct member and wrapper member have different offset!" );

  enum class AttachmentLoadOp
  {
    eLoad = VK_ATTACHMENT_LOAD_OP_LOAD,
    eClear = VK_ATTACHMENT_LOAD_OP_CLEAR,
    eDontCare = VK_ATTACHMENT_LOAD_OP_DONT_CARE
  };

  enum class AttachmentStoreOp
  {
    eStore = VK_ATTACHMENT_STORE_OP_STORE,
    eDontCare = VK_ATTACHMENT_STORE_OP_DONT_CARE
  };

  enum class ImageType
  {
    e1D = VK_IMAGE_TYPE_1D,
    e2D = VK_IMAGE_TYPE_2D,
    e3D = VK_IMAGE_TYPE_3D
  };

  enum class ImageTiling
  {
    eOptimal = VK_IMAGE_TILING_OPTIMAL,
    eLinear = VK_IMAGE_TILING_LINEAR
  };

  enum class ImageViewType
  {
    e1D = VK_IMAGE_VIEW_TYPE_1D,
    e2D = VK_IMAGE_VIEW_TYPE_2D,
    e3D = VK_IMAGE_VIEW_TYPE_3D,
    eCube = VK_IMAGE_VIEW_TYPE_CUBE,
    e1DArray = VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    e2DArray = VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    eCubeArray = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
  };

  enum class CommandBufferLevel
  {
    ePrimary = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    eSecondary = VK_COMMAND_BUFFER_LEVEL_SECONDARY
  };

  enum class ComponentSwizzle
  {
    eIdentity = VK_COMPONENT_SWIZZLE_IDENTITY,
    eZero = VK_COMPONENT_SWIZZLE_ZERO,
    eOne = VK_COMPONENT_SWIZZLE_ONE,
    eR = VK_COMPONENT_SWIZZLE_R,
    eG = VK_COMPONENT_SWIZZLE_G,
    eB = VK_COMPONENT_SWIZZLE_B,
    eA = VK_COMPONENT_SWIZZLE_A
  };

  struct ComponentMapping
  {
    operator VkComponentMapping const&() const
    {
      return *reinterpret_cast<const VkComponentMapping*>(this);
    }

    operator VkComponentMapping &()
    {
      return *reinterpret_cast<VkComponentMapping*>(this);
    }

    bool operator==( ComponentMapping const& rhs ) const
    {
      return ( r == rhs.r )
          && ( g == rhs.g )
          && ( b == rhs.b )
          && ( a == rhs.a );
    }

    bool operator!=( ComponentMapping const& rhs ) const
    {
      return !operator==( rhs );
    }

    ComponentSwizzle r = ComponentSwizzle::eIdentity;
    ComponentSwizzle g = ComponentSwizzle::eIdentity;
    ComponentSwizzle b = ComponentSwizzle::eIdentity;
    ComponentSwizzle a = ComponentSwizzle::eIdentity;
  };
  static_assert( sizeof( ComponentMapping ) == sizeof( VkComponentMapping ), "struct and wrapper have different size!" );
  static_assert( offsetof( ComponentMapping, r ) == offsetof( VkComponentMapping, r ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ComponentMapping, g ) == offsetof( VkComponentMapping, g ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ComponentMapping, b ) == offsetof( VkComponentMapping, b ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ComponentMapping, a ) == offsetof( VkComponentMapping, a ), "struct member and wrapper member have different offset!" );

  enum class DescriptorType
  {
    eSampler = VK_DESCRIPTOR_TYPE_SAMPLER,
    eCombinedImageSampler = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    eSampledImage = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    eStorageImage = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    eUniformTexelBuffer = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    eStorageTexelBuffer = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    eUniformBuffer = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    eStorageBuffer = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    eUniformBufferDynamic = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    eStorageBufferDynamic = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
    eInputAttachment = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    eInlineUniformBlockEXT = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT,
    eAccelerationStructureNVX = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NVX
  };

  struct DescriptorPoolSize
  {
    operator VkDescriptorPoolSize const&() const
    {
      return *reinterpret_cast<const VkDescriptorPoolSize*>(this);
    }

    operator VkDescriptorPoolSize &()
    {
      return *reinterpret_cast<VkDescriptorPoolSize*>(this);
    }

    bool operator==( DescriptorPoolSize const& rhs ) const
    {
      return ( type == rhs.type )
          && ( descriptorCount == rhs.descriptorCount );
    }

    bool operator!=( DescriptorPoolSize const& rhs ) const
    {
      return !operator==( rhs );
    }

    DescriptorType type = DescriptorType::eSampler;
    uint32_t descriptorCount = 0;
  };
  static_assert( sizeof( DescriptorPoolSize ) == sizeof( VkDescriptorPoolSize ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorPoolSize, type ) == offsetof( VkDescriptorPoolSize, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorPoolSize, descriptorCount ) == offsetof( VkDescriptorPoolSize, descriptorCount ), "struct member and wrapper member have different offset!" );

  struct DescriptorUpdateTemplateEntry
  {
    operator VkDescriptorUpdateTemplateEntry const&() const
    {
      return *reinterpret_cast<const VkDescriptorUpdateTemplateEntry*>(this);
    }

    operator VkDescriptorUpdateTemplateEntry &()
    {
      return *reinterpret_cast<VkDescriptorUpdateTemplateEntry*>(this);
    }

    bool operator==( DescriptorUpdateTemplateEntry const& rhs ) const
    {
      return ( dstBinding == rhs.dstBinding )
          && ( dstArrayElement == rhs.dstArrayElement )
          && ( descriptorCount == rhs.descriptorCount )
          && ( descriptorType == rhs.descriptorType )
          && ( offset == rhs.offset )
          && ( stride == rhs.stride );
    }

    bool operator!=( DescriptorUpdateTemplateEntry const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t dstBinding = 0;
    uint32_t dstArrayElement = 0;
    uint32_t descriptorCount = 0;
    DescriptorType descriptorType = DescriptorType::eSampler;
    size_t offset = 0;
    size_t stride = 0;
  };
  static_assert( sizeof( DescriptorUpdateTemplateEntry ) == sizeof( VkDescriptorUpdateTemplateEntry ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorUpdateTemplateEntry, dstBinding ) == offsetof( VkDescriptorUpdateTemplateEntry, dstBinding ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateEntry, dstArrayElement ) == offsetof( VkDescriptorUpdateTemplateEntry, dstArrayElement ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateEntry, descriptorCount ) == offsetof( VkDescriptorUpdateTemplateEntry, descriptorCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateEntry, descriptorType ) == offsetof( VkDescriptorUpdateTemplateEntry, descriptorType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateEntry, offset ) == offsetof( VkDescriptorUpdateTemplateEntry, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateEntry, stride ) == offsetof( VkDescriptorUpdateTemplateEntry, stride ), "struct member and wrapper member have different offset!" );

  using DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;

  enum class QueryType
  {
    eOcclusion = VK_QUERY_TYPE_OCCLUSION,
    ePipelineStatistics = VK_QUERY_TYPE_PIPELINE_STATISTICS,
    eTimestamp = VK_QUERY_TYPE_TIMESTAMP,
    eCompactedSizeNVX = VK_QUERY_TYPE_COMPACTED_SIZE_NVX
  };

  enum class BorderColor
  {
    eFloatTransparentBlack = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    eIntTransparentBlack = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
    eFloatOpaqueBlack = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    eIntOpaqueBlack = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    eFloatOpaqueWhite = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
    eIntOpaqueWhite = VK_BORDER_COLOR_INT_OPAQUE_WHITE
  };

  enum class PipelineBindPoint
  {
    eGraphics = VK_PIPELINE_BIND_POINT_GRAPHICS,
    eCompute = VK_PIPELINE_BIND_POINT_COMPUTE,
    eRaytracingNVX = VK_PIPELINE_BIND_POINT_RAYTRACING_NVX
  };

  enum class PipelineCacheHeaderVersion
  {
    eOne = VK_PIPELINE_CACHE_HEADER_VERSION_ONE
  };

  enum class PrimitiveTopology
  {
    ePointList = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    eLineList = VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    eLineStrip = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
    eTriangleList = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    eTriangleStrip = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
    eTriangleFan = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
    eLineListWithAdjacency = VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    eLineStripWithAdjacency = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    eTriangleListWithAdjacency = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
    eTriangleStripWithAdjacency = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
    ePatchList = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
  };

  enum class SharingMode
  {
    eExclusive = VK_SHARING_MODE_EXCLUSIVE,
    eConcurrent = VK_SHARING_MODE_CONCURRENT
  };

  enum class IndexType
  {
    eUint16 = VK_INDEX_TYPE_UINT16,
    eUint32 = VK_INDEX_TYPE_UINT32
  };

  enum class Filter
  {
    eNearest = VK_FILTER_NEAREST,
    eLinear = VK_FILTER_LINEAR,
    eCubicIMG = VK_FILTER_CUBIC_IMG
  };

  enum class SamplerMipmapMode
  {
    eNearest = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    eLinear = VK_SAMPLER_MIPMAP_MODE_LINEAR
  };

  enum class SamplerAddressMode
  {
    eRepeat = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    eMirroredRepeat = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
    eClampToEdge = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
    eClampToBorder = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    eMirrorClampToEdge = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE
  };

  enum class CompareOp
  {
    eNever = VK_COMPARE_OP_NEVER,
    eLess = VK_COMPARE_OP_LESS,
    eEqual = VK_COMPARE_OP_EQUAL,
    eLessOrEqual = VK_COMPARE_OP_LESS_OR_EQUAL,
    eGreater = VK_COMPARE_OP_GREATER,
    eNotEqual = VK_COMPARE_OP_NOT_EQUAL,
    eGreaterOrEqual = VK_COMPARE_OP_GREATER_OR_EQUAL,
    eAlways = VK_COMPARE_OP_ALWAYS
  };

  enum class PolygonMode
  {
    eFill = VK_POLYGON_MODE_FILL,
    eLine = VK_POLYGON_MODE_LINE,
    ePoint = VK_POLYGON_MODE_POINT,
    eFillRectangleNV = VK_POLYGON_MODE_FILL_RECTANGLE_NV
  };

  enum class CullModeFlagBits
  {
    eNone = VK_CULL_MODE_NONE,
    eFront = VK_CULL_MODE_FRONT_BIT,
    eBack = VK_CULL_MODE_BACK_BIT,
    eFrontAndBack = VK_CULL_MODE_FRONT_AND_BACK
  };

  using CullModeFlags = Flags<CullModeFlagBits, VkCullModeFlags>;

  VULKAN_HPP_INLINE CullModeFlags operator|( CullModeFlagBits bit0, CullModeFlagBits bit1 )
  {
    return CullModeFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE CullModeFlags operator~( CullModeFlagBits bits )
  {
    return ~( CullModeFlags( bits ) );
  }

  template <> struct FlagTraits<CullModeFlagBits>
  {
    enum
    {
      allFlags = VkFlags(CullModeFlagBits::eNone) | VkFlags(CullModeFlagBits::eFront) | VkFlags(CullModeFlagBits::eBack) | VkFlags(CullModeFlagBits::eFrontAndBack)
    };
  };

  enum class FrontFace
  {
    eCounterClockwise = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    eClockwise = VK_FRONT_FACE_CLOCKWISE
  };

  enum class BlendFactor
  {
    eZero = VK_BLEND_FACTOR_ZERO,
    eOne = VK_BLEND_FACTOR_ONE,
    eSrcColor = VK_BLEND_FACTOR_SRC_COLOR,
    eOneMinusSrcColor = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
    eDstColor = VK_BLEND_FACTOR_DST_COLOR,
    eOneMinusDstColor = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
    eSrcAlpha = VK_BLEND_FACTOR_SRC_ALPHA,
    eOneMinusSrcAlpha = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
    eDstAlpha = VK_BLEND_FACTOR_DST_ALPHA,
    eOneMinusDstAlpha = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
    eConstantColor = VK_BLEND_FACTOR_CONSTANT_COLOR,
    eOneMinusConstantColor = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
    eConstantAlpha = VK_BLEND_FACTOR_CONSTANT_ALPHA,
    eOneMinusConstantAlpha = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
    eSrcAlphaSaturate = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
    eSrc1Color = VK_BLEND_FACTOR_SRC1_COLOR,
    eOneMinusSrc1Color = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    eSrc1Alpha = VK_BLEND_FACTOR_SRC1_ALPHA,
    eOneMinusSrc1Alpha = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
  };

  enum class BlendOp
  {
    eAdd = VK_BLEND_OP_ADD,
    eSubtract = VK_BLEND_OP_SUBTRACT,
    eReverseSubtract = VK_BLEND_OP_REVERSE_SUBTRACT,
    eMin = VK_BLEND_OP_MIN,
    eMax = VK_BLEND_OP_MAX,
    eZeroEXT = VK_BLEND_OP_ZERO_EXT,
    eSrcEXT = VK_BLEND_OP_SRC_EXT,
    eDstEXT = VK_BLEND_OP_DST_EXT,
    eSrcOverEXT = VK_BLEND_OP_SRC_OVER_EXT,
    eDstOverEXT = VK_BLEND_OP_DST_OVER_EXT,
    eSrcInEXT = VK_BLEND_OP_SRC_IN_EXT,
    eDstInEXT = VK_BLEND_OP_DST_IN_EXT,
    eSrcOutEXT = VK_BLEND_OP_SRC_OUT_EXT,
    eDstOutEXT = VK_BLEND_OP_DST_OUT_EXT,
    eSrcAtopEXT = VK_BLEND_OP_SRC_ATOP_EXT,
    eDstAtopEXT = VK_BLEND_OP_DST_ATOP_EXT,
    eXorEXT = VK_BLEND_OP_XOR_EXT,
    eMultiplyEXT = VK_BLEND_OP_MULTIPLY_EXT,
    eScreenEXT = VK_BLEND_OP_SCREEN_EXT,
    eOverlayEXT = VK_BLEND_OP_OVERLAY_EXT,
    eDarkenEXT = VK_BLEND_OP_DARKEN_EXT,
    eLightenEXT = VK_BLEND_OP_LIGHTEN_EXT,
    eColordodgeEXT = VK_BLEND_OP_COLORDODGE_EXT,
    eColorburnEXT = VK_BLEND_OP_COLORBURN_EXT,
    eHardlightEXT = VK_BLEND_OP_HARDLIGHT_EXT,
    eSoftlightEXT = VK_BLEND_OP_SOFTLIGHT_EXT,
    eDifferenceEXT = VK_BLEND_OP_DIFFERENCE_EXT,
    eExclusionEXT = VK_BLEND_OP_EXCLUSION_EXT,
    eInvertEXT = VK_BLEND_OP_INVERT_EXT,
    eInvertRgbEXT = VK_BLEND_OP_INVERT_RGB_EXT,
    eLineardodgeEXT = VK_BLEND_OP_LINEARDODGE_EXT,
    eLinearburnEXT = VK_BLEND_OP_LINEARBURN_EXT,
    eVividlightEXT = VK_BLEND_OP_VIVIDLIGHT_EXT,
    eLinearlightEXT = VK_BLEND_OP_LINEARLIGHT_EXT,
    ePinlightEXT = VK_BLEND_OP_PINLIGHT_EXT,
    eHardmixEXT = VK_BLEND_OP_HARDMIX_EXT,
    eHslHueEXT = VK_BLEND_OP_HSL_HUE_EXT,
    eHslSaturationEXT = VK_BLEND_OP_HSL_SATURATION_EXT,
    eHslColorEXT = VK_BLEND_OP_HSL_COLOR_EXT,
    eHslLuminosityEXT = VK_BLEND_OP_HSL_LUMINOSITY_EXT,
    ePlusEXT = VK_BLEND_OP_PLUS_EXT,
    ePlusClampedEXT = VK_BLEND_OP_PLUS_CLAMPED_EXT,
    ePlusClampedAlphaEXT = VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,
    ePlusDarkerEXT = VK_BLEND_OP_PLUS_DARKER_EXT,
    eMinusEXT = VK_BLEND_OP_MINUS_EXT,
    eMinusClampedEXT = VK_BLEND_OP_MINUS_CLAMPED_EXT,
    eContrastEXT = VK_BLEND_OP_CONTRAST_EXT,
    eInvertOvgEXT = VK_BLEND_OP_INVERT_OVG_EXT,
    eRedEXT = VK_BLEND_OP_RED_EXT,
    eGreenEXT = VK_BLEND_OP_GREEN_EXT,
    eBlueEXT = VK_BLEND_OP_BLUE_EXT
  };

  enum class StencilOp
  {
    eKeep = VK_STENCIL_OP_KEEP,
    eZero = VK_STENCIL_OP_ZERO,
    eReplace = VK_STENCIL_OP_REPLACE,
    eIncrementAndClamp = VK_STENCIL_OP_INCREMENT_AND_CLAMP,
    eDecrementAndClamp = VK_STENCIL_OP_DECREMENT_AND_CLAMP,
    eInvert = VK_STENCIL_OP_INVERT,
    eIncrementAndWrap = VK_STENCIL_OP_INCREMENT_AND_WRAP,
    eDecrementAndWrap = VK_STENCIL_OP_DECREMENT_AND_WRAP
  };

  struct StencilOpState
  {
    operator VkStencilOpState const&() const
    {
      return *reinterpret_cast<const VkStencilOpState*>(this);
    }

    operator VkStencilOpState &()
    {
      return *reinterpret_cast<VkStencilOpState*>(this);
    }

    bool operator==( StencilOpState const& rhs ) const
    {
      return ( failOp == rhs.failOp )
          && ( passOp == rhs.passOp )
          && ( depthFailOp == rhs.depthFailOp )
          && ( compareOp == rhs.compareOp )
          && ( compareMask == rhs.compareMask )
          && ( writeMask == rhs.writeMask )
          && ( reference == rhs.reference );
    }

    bool operator!=( StencilOpState const& rhs ) const
    {
      return !operator==( rhs );
    }

    StencilOp failOp = StencilOp::eKeep;
    StencilOp passOp = StencilOp::eKeep;
    StencilOp depthFailOp = StencilOp::eKeep;
    CompareOp compareOp = CompareOp::eNever;
    uint32_t compareMask = 0;
    uint32_t writeMask = 0;
    uint32_t reference = 0;
  };
  static_assert( sizeof( StencilOpState ) == sizeof( VkStencilOpState ), "struct and wrapper have different size!" );
  static_assert( offsetof( StencilOpState, failOp ) == offsetof( VkStencilOpState, failOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( StencilOpState, passOp ) == offsetof( VkStencilOpState, passOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( StencilOpState, depthFailOp ) == offsetof( VkStencilOpState, depthFailOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( StencilOpState, compareOp ) == offsetof( VkStencilOpState, compareOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( StencilOpState, compareMask ) == offsetof( VkStencilOpState, compareMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( StencilOpState, writeMask ) == offsetof( VkStencilOpState, writeMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( StencilOpState, reference ) == offsetof( VkStencilOpState, reference ), "struct member and wrapper member have different offset!" );

  enum class LogicOp
  {
    eClear = VK_LOGIC_OP_CLEAR,
    eAnd = VK_LOGIC_OP_AND,
    eAndReverse = VK_LOGIC_OP_AND_REVERSE,
    eCopy = VK_LOGIC_OP_COPY,
    eAndInverted = VK_LOGIC_OP_AND_INVERTED,
    eNoOp = VK_LOGIC_OP_NO_OP,
    eXor = VK_LOGIC_OP_XOR,
    eOr = VK_LOGIC_OP_OR,
    eNor = VK_LOGIC_OP_NOR,
    eEquivalent = VK_LOGIC_OP_EQUIVALENT,
    eInvert = VK_LOGIC_OP_INVERT,
    eOrReverse = VK_LOGIC_OP_OR_REVERSE,
    eCopyInverted = VK_LOGIC_OP_COPY_INVERTED,
    eOrInverted = VK_LOGIC_OP_OR_INVERTED,
    eNand = VK_LOGIC_OP_NAND,
    eSet = VK_LOGIC_OP_SET
  };

  enum class InternalAllocationType
  {
    eExecutable = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE
  };

  enum class SystemAllocationScope
  {
    eCommand = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    eObject = VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
    eCache = VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
    eDevice = VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
    eInstance = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE
  };

  enum class PhysicalDeviceType
  {
    eOther = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    eIntegratedGpu = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
    eDiscreteGpu = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
    eVirtualGpu = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
    eCpu = VK_PHYSICAL_DEVICE_TYPE_CPU
  };

  enum class VertexInputRate
  {
    eVertex = VK_VERTEX_INPUT_RATE_VERTEX,
    eInstance = VK_VERTEX_INPUT_RATE_INSTANCE
  };

  struct VertexInputBindingDescription
  {
    operator VkVertexInputBindingDescription const&() const
    {
      return *reinterpret_cast<const VkVertexInputBindingDescription*>(this);
    }

    operator VkVertexInputBindingDescription &()
    {
      return *reinterpret_cast<VkVertexInputBindingDescription*>(this);
    }

    bool operator==( VertexInputBindingDescription const& rhs ) const
    {
      return ( binding == rhs.binding )
          && ( stride == rhs.stride )
          && ( inputRate == rhs.inputRate );
    }

    bool operator!=( VertexInputBindingDescription const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t binding = 0;
    uint32_t stride = 0;
    VertexInputRate inputRate = VertexInputRate::eVertex;
  };
  static_assert( sizeof( VertexInputBindingDescription ) == sizeof( VkVertexInputBindingDescription ), "struct and wrapper have different size!" );
  static_assert( offsetof( VertexInputBindingDescription, binding ) == offsetof( VkVertexInputBindingDescription, binding ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( VertexInputBindingDescription, stride ) == offsetof( VkVertexInputBindingDescription, stride ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( VertexInputBindingDescription, inputRate ) == offsetof( VkVertexInputBindingDescription, inputRate ), "struct member and wrapper member have different offset!" );

  enum class Format
  {
    eUndefined = VK_FORMAT_UNDEFINED,
    eR4G4UnormPack8 = VK_FORMAT_R4G4_UNORM_PACK8,
    eR4G4B4A4UnormPack16 = VK_FORMAT_R4G4B4A4_UNORM_PACK16,
    eB4G4R4A4UnormPack16 = VK_FORMAT_B4G4R4A4_UNORM_PACK16,
    eR5G6B5UnormPack16 = VK_FORMAT_R5G6B5_UNORM_PACK16,
    eB5G6R5UnormPack16 = VK_FORMAT_B5G6R5_UNORM_PACK16,
    eR5G5B5A1UnormPack16 = VK_FORMAT_R5G5B5A1_UNORM_PACK16,
    eB5G5R5A1UnormPack16 = VK_FORMAT_B5G5R5A1_UNORM_PACK16,
    eA1R5G5B5UnormPack16 = VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    eR8Unorm = VK_FORMAT_R8_UNORM,
    eR8Snorm = VK_FORMAT_R8_SNORM,
    eR8Uscaled = VK_FORMAT_R8_USCALED,
    eR8Sscaled = VK_FORMAT_R8_SSCALED,
    eR8Uint = VK_FORMAT_R8_UINT,
    eR8Sint = VK_FORMAT_R8_SINT,
    eR8Srgb = VK_FORMAT_R8_SRGB,
    eR8G8Unorm = VK_FORMAT_R8G8_UNORM,
    eR8G8Snorm = VK_FORMAT_R8G8_SNORM,
    eR8G8Uscaled = VK_FORMAT_R8G8_USCALED,
    eR8G8Sscaled = VK_FORMAT_R8G8_SSCALED,
    eR8G8Uint = VK_FORMAT_R8G8_UINT,
    eR8G8Sint = VK_FORMAT_R8G8_SINT,
    eR8G8Srgb = VK_FORMAT_R8G8_SRGB,
    eR8G8B8Unorm = VK_FORMAT_R8G8B8_UNORM,
    eR8G8B8Snorm = VK_FORMAT_R8G8B8_SNORM,
    eR8G8B8Uscaled = VK_FORMAT_R8G8B8_USCALED,
    eR8G8B8Sscaled = VK_FORMAT_R8G8B8_SSCALED,
    eR8G8B8Uint = VK_FORMAT_R8G8B8_UINT,
    eR8G8B8Sint = VK_FORMAT_R8G8B8_SINT,
    eR8G8B8Srgb = VK_FORMAT_R8G8B8_SRGB,
    eB8G8R8Unorm = VK_FORMAT_B8G8R8_UNORM,
    eB8G8R8Snorm = VK_FORMAT_B8G8R8_SNORM,
    eB8G8R8Uscaled = VK_FORMAT_B8G8R8_USCALED,
    eB8G8R8Sscaled = VK_FORMAT_B8G8R8_SSCALED,
    eB8G8R8Uint = VK_FORMAT_B8G8R8_UINT,
    eB8G8R8Sint = VK_FORMAT_B8G8R8_SINT,
    eB8G8R8Srgb = VK_FORMAT_B8G8R8_SRGB,
    eR8G8B8A8Unorm = VK_FORMAT_R8G8B8A8_UNORM,
    eR8G8B8A8Snorm = VK_FORMAT_R8G8B8A8_SNORM,
    eR8G8B8A8Uscaled = VK_FORMAT_R8G8B8A8_USCALED,
    eR8G8B8A8Sscaled = VK_FORMAT_R8G8B8A8_SSCALED,
    eR8G8B8A8Uint = VK_FORMAT_R8G8B8A8_UINT,
    eR8G8B8A8Sint = VK_FORMAT_R8G8B8A8_SINT,
    eR8G8B8A8Srgb = VK_FORMAT_R8G8B8A8_SRGB,
    eB8G8R8A8Unorm = VK_FORMAT_B8G8R8A8_UNORM,
    eB8G8R8A8Snorm = VK_FORMAT_B8G8R8A8_SNORM,
    eB8G8R8A8Uscaled = VK_FORMAT_B8G8R8A8_USCALED,
    eB8G8R8A8Sscaled = VK_FORMAT_B8G8R8A8_SSCALED,
    eB8G8R8A8Uint = VK_FORMAT_B8G8R8A8_UINT,
    eB8G8R8A8Sint = VK_FORMAT_B8G8R8A8_SINT,
    eB8G8R8A8Srgb = VK_FORMAT_B8G8R8A8_SRGB,
    eA8B8G8R8UnormPack32 = VK_FORMAT_A8B8G8R8_UNORM_PACK32,
    eA8B8G8R8SnormPack32 = VK_FORMAT_A8B8G8R8_SNORM_PACK32,
    eA8B8G8R8UscaledPack32 = VK_FORMAT_A8B8G8R8_USCALED_PACK32,
    eA8B8G8R8SscaledPack32 = VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
    eA8B8G8R8UintPack32 = VK_FORMAT_A8B8G8R8_UINT_PACK32,
    eA8B8G8R8SintPack32 = VK_FORMAT_A8B8G8R8_SINT_PACK32,
    eA8B8G8R8SrgbPack32 = VK_FORMAT_A8B8G8R8_SRGB_PACK32,
    eA2R10G10B10UnormPack32 = VK_FORMAT_A2R10G10B10_UNORM_PACK32,
    eA2R10G10B10SnormPack32 = VK_FORMAT_A2R10G10B10_SNORM_PACK32,
    eA2R10G10B10UscaledPack32 = VK_FORMAT_A2R10G10B10_USCALED_PACK32,
    eA2R10G10B10SscaledPack32 = VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
    eA2R10G10B10UintPack32 = VK_FORMAT_A2R10G10B10_UINT_PACK32,
    eA2R10G10B10SintPack32 = VK_FORMAT_A2R10G10B10_SINT_PACK32,
    eA2B10G10R10UnormPack32 = VK_FORMAT_A2B10G10R10_UNORM_PACK32,
    eA2B10G10R10SnormPack32 = VK_FORMAT_A2B10G10R10_SNORM_PACK32,
    eA2B10G10R10UscaledPack32 = VK_FORMAT_A2B10G10R10_USCALED_PACK32,
    eA2B10G10R10SscaledPack32 = VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
    eA2B10G10R10UintPack32 = VK_FORMAT_A2B10G10R10_UINT_PACK32,
    eA2B10G10R10SintPack32 = VK_FORMAT_A2B10G10R10_SINT_PACK32,
    eR16Unorm = VK_FORMAT_R16_UNORM,
    eR16Snorm = VK_FORMAT_R16_SNORM,
    eR16Uscaled = VK_FORMAT_R16_USCALED,
    eR16Sscaled = VK_FORMAT_R16_SSCALED,
    eR16Uint = VK_FORMAT_R16_UINT,
    eR16Sint = VK_FORMAT_R16_SINT,
    eR16Sfloat = VK_FORMAT_R16_SFLOAT,
    eR16G16Unorm = VK_FORMAT_R16G16_UNORM,
    eR16G16Snorm = VK_FORMAT_R16G16_SNORM,
    eR16G16Uscaled = VK_FORMAT_R16G16_USCALED,
    eR16G16Sscaled = VK_FORMAT_R16G16_SSCALED,
    eR16G16Uint = VK_FORMAT_R16G16_UINT,
    eR16G16Sint = VK_FORMAT_R16G16_SINT,
    eR16G16Sfloat = VK_FORMAT_R16G16_SFLOAT,
    eR16G16B16Unorm = VK_FORMAT_R16G16B16_UNORM,
    eR16G16B16Snorm = VK_FORMAT_R16G16B16_SNORM,
    eR16G16B16Uscaled = VK_FORMAT_R16G16B16_USCALED,
    eR16G16B16Sscaled = VK_FORMAT_R16G16B16_SSCALED,
    eR16G16B16Uint = VK_FORMAT_R16G16B16_UINT,
    eR16G16B16Sint = VK_FORMAT_R16G16B16_SINT,
    eR16G16B16Sfloat = VK_FORMAT_R16G16B16_SFLOAT,
    eR16G16B16A16Unorm = VK_FORMAT_R16G16B16A16_UNORM,
    eR16G16B16A16Snorm = VK_FORMAT_R16G16B16A16_SNORM,
    eR16G16B16A16Uscaled = VK_FORMAT_R16G16B16A16_USCALED,
    eR16G16B16A16Sscaled = VK_FORMAT_R16G16B16A16_SSCALED,
    eR16G16B16A16Uint = VK_FORMAT_R16G16B16A16_UINT,
    eR16G16B16A16Sint = VK_FORMAT_R16G16B16A16_SINT,
    eR16G16B16A16Sfloat = VK_FORMAT_R16G16B16A16_SFLOAT,
    eR32Uint = VK_FORMAT_R32_UINT,
    eR32Sint = VK_FORMAT_R32_SINT,
    eR32Sfloat = VK_FORMAT_R32_SFLOAT,
    eR32G32Uint = VK_FORMAT_R32G32_UINT,
    eR32G32Sint = VK_FORMAT_R32G32_SINT,
    eR32G32Sfloat = VK_FORMAT_R32G32_SFLOAT,
    eR32G32B32Uint = VK_FORMAT_R32G32B32_UINT,
    eR32G32B32Sint = VK_FORMAT_R32G32B32_SINT,
    eR32G32B32Sfloat = VK_FORMAT_R32G32B32_SFLOAT,
    eR32G32B32A32Uint = VK_FORMAT_R32G32B32A32_UINT,
    eR32G32B32A32Sint = VK_FORMAT_R32G32B32A32_SINT,
    eR32G32B32A32Sfloat = VK_FORMAT_R32G32B32A32_SFLOAT,
    eR64Uint = VK_FORMAT_R64_UINT,
    eR64Sint = VK_FORMAT_R64_SINT,
    eR64Sfloat = VK_FORMAT_R64_SFLOAT,
    eR64G64Uint = VK_FORMAT_R64G64_UINT,
    eR64G64Sint = VK_FORMAT_R64G64_SINT,
    eR64G64Sfloat = VK_FORMAT_R64G64_SFLOAT,
    eR64G64B64Uint = VK_FORMAT_R64G64B64_UINT,
    eR64G64B64Sint = VK_FORMAT_R64G64B64_SINT,
    eR64G64B64Sfloat = VK_FORMAT_R64G64B64_SFLOAT,
    eR64G64B64A64Uint = VK_FORMAT_R64G64B64A64_UINT,
    eR64G64B64A64Sint = VK_FORMAT_R64G64B64A64_SINT,
    eR64G64B64A64Sfloat = VK_FORMAT_R64G64B64A64_SFLOAT,
    eB10G11R11UfloatPack32 = VK_FORMAT_B10G11R11_UFLOAT_PACK32,
    eE5B9G9R9UfloatPack32 = VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
    eD16Unorm = VK_FORMAT_D16_UNORM,
    eX8D24UnormPack32 = VK_FORMAT_X8_D24_UNORM_PACK32,
    eD32Sfloat = VK_FORMAT_D32_SFLOAT,
    eS8Uint = VK_FORMAT_S8_UINT,
    eD16UnormS8Uint = VK_FORMAT_D16_UNORM_S8_UINT,
    eD24UnormS8Uint = VK_FORMAT_D24_UNORM_S8_UINT,
    eD32SfloatS8Uint = VK_FORMAT_D32_SFLOAT_S8_UINT,
    eBc1RgbUnormBlock = VK_FORMAT_BC1_RGB_UNORM_BLOCK,
    eBc1RgbSrgbBlock = VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    eBc1RgbaUnormBlock = VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    eBc1RgbaSrgbBlock = VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
    eBc2UnormBlock = VK_FORMAT_BC2_UNORM_BLOCK,
    eBc2SrgbBlock = VK_FORMAT_BC2_SRGB_BLOCK,
    eBc3UnormBlock = VK_FORMAT_BC3_UNORM_BLOCK,
    eBc3SrgbBlock = VK_FORMAT_BC3_SRGB_BLOCK,
    eBc4UnormBlock = VK_FORMAT_BC4_UNORM_BLOCK,
    eBc4SnormBlock = VK_FORMAT_BC4_SNORM_BLOCK,
    eBc5UnormBlock = VK_FORMAT_BC5_UNORM_BLOCK,
    eBc5SnormBlock = VK_FORMAT_BC5_SNORM_BLOCK,
    eBc6HUfloatBlock = VK_FORMAT_BC6H_UFLOAT_BLOCK,
    eBc6HSfloatBlock = VK_FORMAT_BC6H_SFLOAT_BLOCK,
    eBc7UnormBlock = VK_FORMAT_BC7_UNORM_BLOCK,
    eBc7SrgbBlock = VK_FORMAT_BC7_SRGB_BLOCK,
    eEtc2R8G8B8UnormBlock = VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    eEtc2R8G8B8SrgbBlock = VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    eEtc2R8G8B8A1UnormBlock = VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    eEtc2R8G8B8A1SrgbBlock = VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    eEtc2R8G8B8A8UnormBlock = VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    eEtc2R8G8B8A8SrgbBlock = VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    eEacR11UnormBlock = VK_FORMAT_EAC_R11_UNORM_BLOCK,
    eEacR11SnormBlock = VK_FORMAT_EAC_R11_SNORM_BLOCK,
    eEacR11G11UnormBlock = VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
    eEacR11G11SnormBlock = VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
    eAstc4x4UnormBlock = VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    eAstc4x4SrgbBlock = VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    eAstc5x4UnormBlock = VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    eAstc5x4SrgbBlock = VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    eAstc5x5UnormBlock = VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    eAstc5x5SrgbBlock = VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    eAstc6x5UnormBlock = VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    eAstc6x5SrgbBlock = VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    eAstc6x6UnormBlock = VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    eAstc6x6SrgbBlock = VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    eAstc8x5UnormBlock = VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    eAstc8x5SrgbBlock = VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    eAstc8x6UnormBlock = VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    eAstc8x6SrgbBlock = VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    eAstc8x8UnormBlock = VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    eAstc8x8SrgbBlock = VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    eAstc10x5UnormBlock = VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    eAstc10x5SrgbBlock = VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    eAstc10x6UnormBlock = VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    eAstc10x6SrgbBlock = VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    eAstc10x8UnormBlock = VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    eAstc10x8SrgbBlock = VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    eAstc10x10UnormBlock = VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    eAstc10x10SrgbBlock = VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    eAstc12x10UnormBlock = VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    eAstc12x10SrgbBlock = VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    eAstc12x12UnormBlock = VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
    eAstc12x12SrgbBlock = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    eG8B8G8R8422Unorm = VK_FORMAT_G8B8G8R8_422_UNORM,
    eG8B8G8R8422UnormKHR = VK_FORMAT_G8B8G8R8_422_UNORM,
    eB8G8R8G8422Unorm = VK_FORMAT_B8G8R8G8_422_UNORM,
    eB8G8R8G8422UnormKHR = VK_FORMAT_B8G8R8G8_422_UNORM,
    eG8B8R83Plane420Unorm = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    eG8B8R83Plane420UnormKHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    eG8B8R82Plane420Unorm = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    eG8B8R82Plane420UnormKHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    eG8B8R83Plane422Unorm = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    eG8B8R83Plane422UnormKHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    eG8B8R82Plane422Unorm = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    eG8B8R82Plane422UnormKHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    eG8B8R83Plane444Unorm = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    eG8B8R83Plane444UnormKHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    eR10X6UnormPack16 = VK_FORMAT_R10X6_UNORM_PACK16,
    eR10X6UnormPack16KHR = VK_FORMAT_R10X6_UNORM_PACK16,
    eR10X6G10X6Unorm2Pack16 = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    eR10X6G10X6Unorm2Pack16KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    eR10X6G10X6B10X6A10X6Unorm4Pack16 = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    eR10X6G10X6B10X6A10X6Unorm4Pack16KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    eG10X6B10X6G10X6R10X6422Unorm4Pack16 = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    eB10X6G10X6R10X6G10X6422Unorm4Pack16 = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    eG10X6B10X6R10X63Plane420Unorm3Pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    eG10X6B10X6R10X63Plane420Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    eG10X6B10X6R10X62Plane420Unorm3Pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    eG10X6B10X6R10X62Plane420Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    eG10X6B10X6R10X63Plane422Unorm3Pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    eG10X6B10X6R10X63Plane422Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    eG10X6B10X6R10X62Plane422Unorm3Pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    eG10X6B10X6R10X62Plane422Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    eG10X6B10X6R10X63Plane444Unorm3Pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    eG10X6B10X6R10X63Plane444Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    eR12X4UnormPack16 = VK_FORMAT_R12X4_UNORM_PACK16,
    eR12X4UnormPack16KHR = VK_FORMAT_R12X4_UNORM_PACK16,
    eR12X4G12X4Unorm2Pack16 = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    eR12X4G12X4Unorm2Pack16KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    eR12X4G12X4B12X4A12X4Unorm4Pack16 = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    eR12X4G12X4B12X4A12X4Unorm4Pack16KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    eG12X4B12X4G12X4R12X4422Unorm4Pack16 = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    eB12X4G12X4R12X4G12X4422Unorm4Pack16 = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    eG12X4B12X4R12X43Plane420Unorm3Pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    eG12X4B12X4R12X43Plane420Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    eG12X4B12X4R12X42Plane420Unorm3Pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    eG12X4B12X4R12X42Plane420Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    eG12X4B12X4R12X43Plane422Unorm3Pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    eG12X4B12X4R12X43Plane422Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    eG12X4B12X4R12X42Plane422Unorm3Pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    eG12X4B12X4R12X42Plane422Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    eG12X4B12X4R12X43Plane444Unorm3Pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    eG12X4B12X4R12X43Plane444Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    eG16B16G16R16422Unorm = VK_FORMAT_G16B16G16R16_422_UNORM,
    eG16B16G16R16422UnormKHR = VK_FORMAT_G16B16G16R16_422_UNORM,
    eB16G16R16G16422Unorm = VK_FORMAT_B16G16R16G16_422_UNORM,
    eB16G16R16G16422UnormKHR = VK_FORMAT_B16G16R16G16_422_UNORM,
    eG16B16R163Plane420Unorm = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    eG16B16R163Plane420UnormKHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    eG16B16R162Plane420Unorm = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    eG16B16R162Plane420UnormKHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    eG16B16R163Plane422Unorm = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    eG16B16R163Plane422UnormKHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    eG16B16R162Plane422Unorm = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    eG16B16R162Plane422UnormKHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    eG16B16R163Plane444Unorm = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    eG16B16R163Plane444UnormKHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    ePvrtc12BppUnormBlockIMG = VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,
    ePvrtc14BppUnormBlockIMG = VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,
    ePvrtc22BppUnormBlockIMG = VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,
    ePvrtc24BppUnormBlockIMG = VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,
    ePvrtc12BppSrgbBlockIMG = VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,
    ePvrtc14BppSrgbBlockIMG = VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,
    ePvrtc22BppSrgbBlockIMG = VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,
    ePvrtc24BppSrgbBlockIMG = VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG
  };

  struct VertexInputAttributeDescription
  {
    operator VkVertexInputAttributeDescription const&() const
    {
      return *reinterpret_cast<const VkVertexInputAttributeDescription*>(this);
    }

    operator VkVertexInputAttributeDescription &()
    {
      return *reinterpret_cast<VkVertexInputAttributeDescription*>(this);
    }

    bool operator==( VertexInputAttributeDescription const& rhs ) const
    {
      return ( location == rhs.location )
          && ( binding == rhs.binding )
          && ( format == rhs.format )
          && ( offset == rhs.offset );
    }

    bool operator!=( VertexInputAttributeDescription const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t location = 0;
    uint32_t binding = 0;
    Format format = Format::eUndefined;
    uint32_t offset = 0;
  };
  static_assert( sizeof( VertexInputAttributeDescription ) == sizeof( VkVertexInputAttributeDescription ), "struct and wrapper have different size!" );
  static_assert( offsetof( VertexInputAttributeDescription, location ) == offsetof( VkVertexInputAttributeDescription, location ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( VertexInputAttributeDescription, binding ) == offsetof( VkVertexInputAttributeDescription, binding ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( VertexInputAttributeDescription, format ) == offsetof( VkVertexInputAttributeDescription, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( VertexInputAttributeDescription, offset ) == offsetof( VkVertexInputAttributeDescription, offset ), "struct member and wrapper member have different offset!" );

  enum class StructureType
  {
    eApplicationInfo = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    eInstanceCreateInfo = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
    eDeviceQueueCreateInfo = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
    eDeviceCreateInfo = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    eSubmitInfo = VK_STRUCTURE_TYPE_SUBMIT_INFO,
    eMemoryAllocateInfo = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
    eMappedMemoryRange = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
    eBindSparseInfo = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
    eFenceCreateInfo = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
    eSemaphoreCreateInfo = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
    eEventCreateInfo = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
    eQueryPoolCreateInfo = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
    eBufferCreateInfo = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    eBufferViewCreateInfo = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
    eImageCreateInfo = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    eImageViewCreateInfo = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    eShaderModuleCreateInfo = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
    ePipelineCacheCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
    ePipelineShaderStageCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
    ePipelineVertexInputStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
    ePipelineInputAssemblyStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
    ePipelineTessellationStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
    ePipelineViewportStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
    ePipelineRasterizationStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
    ePipelineMultisampleStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
    ePipelineDepthStencilStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
    ePipelineColorBlendStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
    ePipelineDynamicStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    eGraphicsPipelineCreateInfo = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
    eComputePipelineCreateInfo = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
    ePipelineLayoutCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    eSamplerCreateInfo = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    eDescriptorSetLayoutCreateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    eDescriptorPoolCreateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    eDescriptorSetAllocateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
    eWriteDescriptorSet = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    eCopyDescriptorSet = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
    eFramebufferCreateInfo = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
    eRenderPassCreateInfo = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
    eCommandPoolCreateInfo = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
    eCommandBufferAllocateInfo = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
    eCommandBufferInheritanceInfo = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
    eCommandBufferBeginInfo = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
    eRenderPassBeginInfo = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
    eBufferMemoryBarrier = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    eImageMemoryBarrier = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    eMemoryBarrier = VK_STRUCTURE_TYPE_MEMORY_BARRIER,
    eLoaderInstanceCreateInfo = VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
    eLoaderDeviceCreateInfo = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    ePhysicalDeviceSubgroupProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
    eBindBufferMemoryInfo = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    eBindBufferMemoryInfoKHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    eBindImageMemoryInfo = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    eBindImageMemoryInfoKHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    ePhysicalDevice16BitStorageFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    ePhysicalDevice16BitStorageFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    eMemoryDedicatedRequirements = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    eMemoryDedicatedRequirementsKHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    eMemoryDedicatedAllocateInfo = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    eMemoryDedicatedAllocateInfoKHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    eMemoryAllocateFlagsInfo = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    eMemoryAllocateFlagsInfoKHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    eDeviceGroupRenderPassBeginInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    eDeviceGroupRenderPassBeginInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    eDeviceGroupCommandBufferBeginInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    eDeviceGroupCommandBufferBeginInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    eDeviceGroupSubmitInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    eDeviceGroupSubmitInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    eDeviceGroupBindSparseInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    eDeviceGroupBindSparseInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    eBindBufferMemoryDeviceGroupInfo = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    eBindBufferMemoryDeviceGroupInfoKHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    eBindImageMemoryDeviceGroupInfo = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    eBindImageMemoryDeviceGroupInfoKHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    ePhysicalDeviceGroupProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    ePhysicalDeviceGroupPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    eDeviceGroupDeviceCreateInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    eDeviceGroupDeviceCreateInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    eBufferMemoryRequirementsInfo2 = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    eBufferMemoryRequirementsInfo2KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    eImageMemoryRequirementsInfo2 = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    eImageMemoryRequirementsInfo2KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    eImageSparseMemoryRequirementsInfo2 = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    eImageSparseMemoryRequirementsInfo2KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    eMemoryRequirements2 = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    eMemoryRequirements2KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    eSparseImageMemoryRequirements2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    eSparseImageMemoryRequirements2KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    ePhysicalDeviceFeatures2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    ePhysicalDeviceFeatures2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    ePhysicalDeviceProperties2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    ePhysicalDeviceProperties2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    eFormatProperties2 = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    eFormatProperties2KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    eImageFormatProperties2 = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    eImageFormatProperties2KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    ePhysicalDeviceImageFormatInfo2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    ePhysicalDeviceImageFormatInfo2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    eQueueFamilyProperties2 = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    eQueueFamilyProperties2KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    ePhysicalDeviceMemoryProperties2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    ePhysicalDeviceMemoryProperties2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    eSparseImageFormatProperties2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    eSparseImageFormatProperties2KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    ePhysicalDeviceSparseImageFormatInfo2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    ePhysicalDeviceSparseImageFormatInfo2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    ePhysicalDevicePointClippingProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    ePhysicalDevicePointClippingPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    eRenderPassInputAttachmentAspectCreateInfo = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    eRenderPassInputAttachmentAspectCreateInfoKHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    eImageViewUsageCreateInfo = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    eImageViewUsageCreateInfoKHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    ePipelineTessellationDomainOriginStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    ePipelineTessellationDomainOriginStateCreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    eRenderPassMultiviewCreateInfo = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    eRenderPassMultiviewCreateInfoKHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    ePhysicalDeviceMultiviewFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    ePhysicalDeviceMultiviewFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    ePhysicalDeviceMultiviewProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    ePhysicalDeviceMultiviewPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    ePhysicalDeviceVariablePointerFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    ePhysicalDeviceVariablePointerFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    eProtectedSubmitInfo = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
    ePhysicalDeviceProtectedMemoryFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
    ePhysicalDeviceProtectedMemoryProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
    eDeviceQueueInfo2 = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
    eSamplerYcbcrConversionCreateInfo = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    eSamplerYcbcrConversionCreateInfoKHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    eSamplerYcbcrConversionInfo = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    eSamplerYcbcrConversionInfoKHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    eBindImagePlaneMemoryInfo = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    eBindImagePlaneMemoryInfoKHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    eImagePlaneMemoryRequirementsInfo = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    eImagePlaneMemoryRequirementsInfoKHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    ePhysicalDeviceSamplerYcbcrConversionFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    ePhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    eSamplerYcbcrConversionImageFormatProperties = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    eSamplerYcbcrConversionImageFormatPropertiesKHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    eDescriptorUpdateTemplateCreateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    eDescriptorUpdateTemplateCreateInfoKHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    ePhysicalDeviceExternalImageFormatInfo = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    ePhysicalDeviceExternalImageFormatInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    eExternalImageFormatProperties = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    eExternalImageFormatPropertiesKHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    ePhysicalDeviceExternalBufferInfo = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    ePhysicalDeviceExternalBufferInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    eExternalBufferProperties = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    eExternalBufferPropertiesKHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    ePhysicalDeviceIdProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    ePhysicalDeviceIdPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    eExternalMemoryBufferCreateInfo = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    eExternalMemoryBufferCreateInfoKHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    eExternalMemoryImageCreateInfo = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    eExternalMemoryImageCreateInfoKHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    eExportMemoryAllocateInfo = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    eExportMemoryAllocateInfoKHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    ePhysicalDeviceExternalFenceInfo = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    ePhysicalDeviceExternalFenceInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    eExternalFenceProperties = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    eExternalFencePropertiesKHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    eExportFenceCreateInfo = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    eExportFenceCreateInfoKHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    eExportSemaphoreCreateInfo = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    eExportSemaphoreCreateInfoKHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    ePhysicalDeviceExternalSemaphoreInfo = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    ePhysicalDeviceExternalSemaphoreInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    eExternalSemaphoreProperties = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    eExternalSemaphorePropertiesKHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    ePhysicalDeviceMaintenance3Properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    ePhysicalDeviceMaintenance3PropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    eDescriptorSetLayoutSupport = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    eDescriptorSetLayoutSupportKHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    ePhysicalDeviceShaderDrawParameterFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES,
    eSwapchainCreateInfoKHR = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
    ePresentInfoKHR = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
    eDeviceGroupPresentCapabilitiesKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
    eImageSwapchainCreateInfoKHR = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
    eBindImageMemorySwapchainInfoKHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
    eAcquireNextImageInfoKHR = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
    eDeviceGroupPresentInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
    eDeviceGroupSwapchainCreateInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
    eDisplayModeCreateInfoKHR = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
    eDisplaySurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
    eDisplayPresentInfoKHR = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
    eXlibSurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
    eXcbSurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
    eWaylandSurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
    eMirSurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR,
    eAndroidSurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
    eWin32SurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
    eDebugReportCallbackCreateInfoEXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    eDebugReportCreateInfoEXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    ePipelineRasterizationStateRasterizationOrderAMD = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
    eDebugMarkerObjectNameInfoEXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
    eDebugMarkerObjectTagInfoEXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
    eDebugMarkerMarkerInfoEXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
    eDedicatedAllocationImageCreateInfoNV = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
    eDedicatedAllocationBufferCreateInfoNV = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
    eDedicatedAllocationMemoryAllocateInfoNV = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
    eTextureLodGatherFormatPropertiesAMD = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
    ePhysicalDeviceCornerSampledImageFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
    eExternalMemoryImageCreateInfoNV = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
    eExportMemoryAllocateInfoNV = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
    eImportMemoryWin32HandleInfoNV = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    eExportMemoryWin32HandleInfoNV = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    eWin32KeyedMutexAcquireReleaseInfoNV = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
    eValidationFlagsEXT = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
    eViSurfaceCreateInfoNN = VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN,
    eImageViewAstcDecodeModeEXT = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
    ePhysicalDeviceAstcDecodeFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
    eImportMemoryWin32HandleInfoKHR = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    eExportMemoryWin32HandleInfoKHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    eMemoryWin32HandlePropertiesKHR = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
    eMemoryGetWin32HandleInfoKHR = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
    eImportMemoryFdInfoKHR = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
    eMemoryFdPropertiesKHR = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
    eMemoryGetFdInfoKHR = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
    eWin32KeyedMutexAcquireReleaseInfoKHR = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
    eImportSemaphoreWin32HandleInfoKHR = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    eExportSemaphoreWin32HandleInfoKHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    eD3D12FenceSubmitInfoKHR = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
    eSemaphoreGetWin32HandleInfoKHR = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
    eImportSemaphoreFdInfoKHR = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
    eSemaphoreGetFdInfoKHR = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
    ePhysicalDevicePushDescriptorPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
    eCommandBufferInheritanceConditionalRenderingInfoEXT = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
    ePhysicalDeviceConditionalRenderingFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
    eConditionalRenderingBeginInfoEXT = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
    ePresentRegionsKHR = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
    eObjectTableCreateInfoNVX = VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX,
    eIndirectCommandsLayoutCreateInfoNVX = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX,
    eCmdProcessCommandsInfoNVX = VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX,
    eCmdReserveSpaceForCommandsInfoNVX = VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX,
    eDeviceGeneratedCommandsLimitsNVX = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX,
    eDeviceGeneratedCommandsFeaturesNVX = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX,
    ePipelineViewportWScalingStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
    eSurfaceCapabilities2EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    eDisplayPowerInfoEXT = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT,
    eDeviceEventInfoEXT = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
    eDisplayEventInfoEXT = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,
    eSwapchainCounterCreateInfoEXT = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
    ePresentTimesInfoGOOGLE = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
    ePhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
    ePipelineViewportSwizzleStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
    ePhysicalDeviceDiscardRectanglePropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
    ePipelineDiscardRectangleStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
    ePhysicalDeviceConservativeRasterizationPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
    ePipelineRasterizationConservativeStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
    eHdrMetadataEXT = VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
    eAttachmentDescription2KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR,
    eAttachmentReference2KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR,
    eSubpassDescription2KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR,
    eSubpassDependency2KHR = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR,
    eRenderPassCreateInfo2KHR = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR,
    eSubpassBeginInfoKHR = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR,
    eSubpassEndInfoKHR = VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR,
    eSharedPresentSurfaceCapabilitiesKHR = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
    eImportFenceWin32HandleInfoKHR = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    eExportFenceWin32HandleInfoKHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    eFenceGetWin32HandleInfoKHR = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR,
    eImportFenceFdInfoKHR = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
    eFenceGetFdInfoKHR = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR,
    ePhysicalDeviceSurfaceInfo2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
    eSurfaceCapabilities2KHR = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
    eSurfaceFormat2KHR = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
    eDisplayProperties2KHR = VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR,
    eDisplayPlaneProperties2KHR = VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR,
    eDisplayModeProperties2KHR = VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR,
    eDisplayPlaneInfo2KHR = VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR,
    eDisplayPlaneCapabilities2KHR = VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR,
    eIosSurfaceCreateInfoMVK = VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK,
    eMacosSurfaceCreateInfoMVK = VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
    eDebugUtilsObjectNameInfoEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    eDebugUtilsObjectTagInfoEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
    eDebugUtilsLabelEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
    eDebugUtilsMessengerCallbackDataEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
    eDebugUtilsMessengerCreateInfoEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
    eAndroidHardwareBufferUsageANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
    eAndroidHardwareBufferPropertiesANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
    eAndroidHardwareBufferFormatPropertiesANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
    eImportAndroidHardwareBufferInfoANDROID = VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    eMemoryGetAndroidHardwareBufferInfoANDROID = VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    eExternalFormatANDROID = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
    ePhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT,
    eSamplerReductionModeCreateInfoEXT = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT,
    ePhysicalDeviceInlineUniformBlockFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
    ePhysicalDeviceInlineUniformBlockPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
    eWriteDescriptorSetInlineUniformBlockEXT = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
    eDescriptorPoolInlineUniformBlockCreateInfoEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
    eSampleLocationsInfoEXT = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
    eRenderPassSampleLocationsBeginInfoEXT = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
    ePipelineSampleLocationsStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
    ePhysicalDeviceSampleLocationsPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
    eMultisamplePropertiesEXT = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT,
    eImageFormatListCreateInfoKHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR,
    ePhysicalDeviceBlendOperationAdvancedFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
    ePhysicalDeviceBlendOperationAdvancedPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
    ePipelineColorBlendAdvancedStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
    ePipelineCoverageToColorStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
    ePipelineCoverageModulationStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
    eValidationCacheCreateInfoEXT = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
    eShaderModuleValidationCacheCreateInfoEXT = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
    eDescriptorSetLayoutBindingFlagsCreateInfoEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
    ePhysicalDeviceDescriptorIndexingFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT,
    ePhysicalDeviceDescriptorIndexingPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT,
    eDescriptorSetVariableDescriptorCountAllocateInfoEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT,
    eDescriptorSetVariableDescriptorCountLayoutSupportEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT,
    ePipelineViewportShadingRateImageStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
    ePhysicalDeviceShadingRateImageFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
    ePhysicalDeviceShadingRateImagePropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
    ePipelineViewportCoarseSampleOrderStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
    eRaytracingPipelineCreateInfoNVX = VK_STRUCTURE_TYPE_RAYTRACING_PIPELINE_CREATE_INFO_NVX,
    eAccelerationStructureCreateInfoNVX = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NVX,
    eGeometryInstanceNVX = VK_STRUCTURE_TYPE_GEOMETRY_INSTANCE_NVX,
    eGeometryNVX = VK_STRUCTURE_TYPE_GEOMETRY_NVX,
    eGeometryTrianglesNVX = VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NVX,
    eGeometryAabbNVX = VK_STRUCTURE_TYPE_GEOMETRY_AABB_NVX,
    eBindAccelerationStructureMemoryInfoNVX = VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NVX,
    eDescriptorAccelerationStructureInfoNVX = VK_STRUCTURE_TYPE_DESCRIPTOR_ACCELERATION_STRUCTURE_INFO_NVX,
    eAccelerationStructureMemoryRequirementsInfoNVX = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NVX,
    ePhysicalDeviceRaytracingPropertiesNVX = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAYTRACING_PROPERTIES_NVX,
    eHitShaderModuleCreateInfoNVX = VK_STRUCTURE_TYPE_HIT_SHADER_MODULE_CREATE_INFO_NVX,
    ePhysicalDeviceRepresentativeFragmentTestFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
    ePipelineRepresentativeFragmentTestStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
    eDeviceQueueGlobalPriorityCreateInfoEXT = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
    ePhysicalDevice8BitStorageFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR,
    eImportMemoryHostPointerInfoEXT = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
    eMemoryHostPointerPropertiesEXT = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
    ePhysicalDeviceExternalMemoryHostPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
    ePhysicalDeviceShaderCorePropertiesAMD = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
    ePhysicalDeviceVertexAttributeDivisorPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
    ePipelineVertexInputDivisorStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
    ePhysicalDeviceVertexAttributeDivisorFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
    ePhysicalDeviceComputeShaderDerivativesFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
    ePhysicalDeviceMeshShaderFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
    ePhysicalDeviceMeshShaderPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
    ePhysicalDeviceFragmentShaderBarycentricFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
    ePhysicalDeviceShaderImageFootprintFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
    ePipelineViewportExclusiveScissorStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
    ePhysicalDeviceExclusiveScissorFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
    eCheckpointDataNV = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
    eQueueFamilyCheckpointPropertiesNV = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
    ePhysicalDeviceVulkanMemoryModelFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR
  };

  struct ApplicationInfo
  {
    operator VkApplicationInfo const&() const
    {
      return *reinterpret_cast<const VkApplicationInfo*>(this);
    }

    operator VkApplicationInfo &()
    {
      return *reinterpret_cast<VkApplicationInfo*>(this);
    }

    bool operator==( ApplicationInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( pApplicationName == rhs.pApplicationName )
          && ( applicationVersion == rhs.applicationVersion )
          && ( pEngineName == rhs.pEngineName )
          && ( engineVersion == rhs.engineVersion )
          && ( apiVersion == rhs.apiVersion );
    }

    bool operator!=( ApplicationInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eApplicationInfo;
    const void* pNext = nullptr;
    const char* pApplicationName = nullptr;
    uint32_t applicationVersion = 0;
    const char* pEngineName = nullptr;
    uint32_t engineVersion = 0;
    uint32_t apiVersion = 0;
  };
  static_assert( sizeof( ApplicationInfo ) == sizeof( VkApplicationInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ApplicationInfo, pNext ) == offsetof( VkApplicationInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ApplicationInfo, pApplicationName ) == offsetof( VkApplicationInfo, pApplicationName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ApplicationInfo, applicationVersion ) == offsetof( VkApplicationInfo, applicationVersion ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ApplicationInfo, pEngineName ) == offsetof( VkApplicationInfo, pEngineName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ApplicationInfo, engineVersion ) == offsetof( VkApplicationInfo, engineVersion ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ApplicationInfo, apiVersion ) == offsetof( VkApplicationInfo, apiVersion ), "struct member and wrapper member have different offset!" );

  struct InstanceCreateInfo
  {
    operator VkInstanceCreateInfo const&() const
    {
      return *reinterpret_cast<const VkInstanceCreateInfo*>(this);
    }

    operator VkInstanceCreateInfo &()
    {
      return *reinterpret_cast<VkInstanceCreateInfo*>(this);
    }

    bool operator==( InstanceCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( pApplicationInfo == rhs.pApplicationInfo )
          && ( enabledLayerCount == rhs.enabledLayerCount )
          && ( ppEnabledLayerNames == rhs.ppEnabledLayerNames )
          && ( enabledExtensionCount == rhs.enabledExtensionCount )
          && ( ppEnabledExtensionNames == rhs.ppEnabledExtensionNames );
    }

    bool operator!=( InstanceCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eInstanceCreateInfo;
    const void* pNext = nullptr;
    InstanceCreateFlags flags = InstanceCreateFlags();
    const ApplicationInfo* pApplicationInfo = nullptr;
    uint32_t enabledLayerCount = 0;
    const char* const* ppEnabledLayerNames = nullptr;
    uint32_t enabledExtensionCount = 0;
    const char* const* ppEnabledExtensionNames = nullptr;
  };
  static_assert( sizeof( InstanceCreateInfo ) == sizeof( VkInstanceCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( InstanceCreateInfo, pNext ) == offsetof( VkInstanceCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( InstanceCreateInfo, flags ) == offsetof( VkInstanceCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( InstanceCreateInfo, pApplicationInfo ) == offsetof( VkInstanceCreateInfo, pApplicationInfo ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( InstanceCreateInfo, enabledLayerCount ) == offsetof( VkInstanceCreateInfo, enabledLayerCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( InstanceCreateInfo, ppEnabledLayerNames ) == offsetof( VkInstanceCreateInfo, ppEnabledLayerNames ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( InstanceCreateInfo, enabledExtensionCount ) == offsetof( VkInstanceCreateInfo, enabledExtensionCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( InstanceCreateInfo, ppEnabledExtensionNames ) == offsetof( VkInstanceCreateInfo, ppEnabledExtensionNames ), "struct member and wrapper member have different offset!" );

  struct MemoryAllocateInfo
  {
    operator VkMemoryAllocateInfo const&() const
    {
      return *reinterpret_cast<const VkMemoryAllocateInfo*>(this);
    }

    operator VkMemoryAllocateInfo &()
    {
      return *reinterpret_cast<VkMemoryAllocateInfo*>(this);
    }

    bool operator==( MemoryAllocateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( allocationSize == rhs.allocationSize )
          && ( memoryTypeIndex == rhs.memoryTypeIndex );
    }

    bool operator!=( MemoryAllocateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryAllocateInfo;
    const void* pNext = nullptr;
    DeviceSize allocationSize = 0;
    uint32_t memoryTypeIndex = 0;
  };
  static_assert( sizeof( MemoryAllocateInfo ) == sizeof( VkMemoryAllocateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryAllocateInfo, pNext ) == offsetof( VkMemoryAllocateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryAllocateInfo, allocationSize ) == offsetof( VkMemoryAllocateInfo, allocationSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryAllocateInfo, memoryTypeIndex ) == offsetof( VkMemoryAllocateInfo, memoryTypeIndex ), "struct member and wrapper member have different offset!" );

  struct MappedMemoryRange
  {
    operator VkMappedMemoryRange const&() const
    {
      return *reinterpret_cast<const VkMappedMemoryRange*>(this);
    }

    operator VkMappedMemoryRange &()
    {
      return *reinterpret_cast<VkMappedMemoryRange*>(this);
    }

    bool operator==( MappedMemoryRange const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memory == rhs.memory )
          && ( offset == rhs.offset )
          && ( size == rhs.size );
    }

    bool operator!=( MappedMemoryRange const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMappedMemoryRange;
    const void* pNext = nullptr;
    DeviceMemory memory = DeviceMemory();
    DeviceSize offset = 0;
    DeviceSize size = 0;
  };
  static_assert( sizeof( MappedMemoryRange ) == sizeof( VkMappedMemoryRange ), "struct and wrapper have different size!" );
  static_assert( offsetof( MappedMemoryRange, pNext ) == offsetof( VkMappedMemoryRange, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MappedMemoryRange, memory ) == offsetof( VkMappedMemoryRange, memory ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MappedMemoryRange, offset ) == offsetof( VkMappedMemoryRange, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MappedMemoryRange, size ) == offsetof( VkMappedMemoryRange, size ), "struct member and wrapper member have different offset!" );

  struct WriteDescriptorSet
  {
    operator VkWriteDescriptorSet const&() const
    {
      return *reinterpret_cast<const VkWriteDescriptorSet*>(this);
    }

    operator VkWriteDescriptorSet &()
    {
      return *reinterpret_cast<VkWriteDescriptorSet*>(this);
    }

    bool operator==( WriteDescriptorSet const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( dstSet == rhs.dstSet )
          && ( dstBinding == rhs.dstBinding )
          && ( dstArrayElement == rhs.dstArrayElement )
          && ( descriptorCount == rhs.descriptorCount )
          && ( descriptorType == rhs.descriptorType )
          && ( pImageInfo == rhs.pImageInfo )
          && ( pBufferInfo == rhs.pBufferInfo )
          && ( pTexelBufferView == rhs.pTexelBufferView );
    }

    bool operator!=( WriteDescriptorSet const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eWriteDescriptorSet;
    const void* pNext = nullptr;
    DescriptorSet dstSet = DescriptorSet();
    uint32_t dstBinding = 0;
    uint32_t dstArrayElement = 0;
    uint32_t descriptorCount = 0;
    DescriptorType descriptorType = DescriptorType::eSampler;
    const DescriptorImageInfo* pImageInfo = nullptr;
    const DescriptorBufferInfo* pBufferInfo = nullptr;
    const BufferView* pTexelBufferView = nullptr;
  };
  static_assert( sizeof( WriteDescriptorSet ) == sizeof( VkWriteDescriptorSet ), "struct and wrapper have different size!" );
  static_assert( offsetof( WriteDescriptorSet, pNext ) == offsetof( VkWriteDescriptorSet, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSet, dstSet ) == offsetof( VkWriteDescriptorSet, dstSet ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSet, dstBinding ) == offsetof( VkWriteDescriptorSet, dstBinding ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSet, dstArrayElement ) == offsetof( VkWriteDescriptorSet, dstArrayElement ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSet, descriptorCount ) == offsetof( VkWriteDescriptorSet, descriptorCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSet, descriptorType ) == offsetof( VkWriteDescriptorSet, descriptorType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSet, pImageInfo ) == offsetof( VkWriteDescriptorSet, pImageInfo ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSet, pBufferInfo ) == offsetof( VkWriteDescriptorSet, pBufferInfo ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSet, pTexelBufferView ) == offsetof( VkWriteDescriptorSet, pTexelBufferView ), "struct member and wrapper member have different offset!" );

  struct CopyDescriptorSet
  {
    operator VkCopyDescriptorSet const&() const
    {
      return *reinterpret_cast<const VkCopyDescriptorSet*>(this);
    }

    operator VkCopyDescriptorSet &()
    {
      return *reinterpret_cast<VkCopyDescriptorSet*>(this);
    }

    bool operator==( CopyDescriptorSet const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( srcSet == rhs.srcSet )
          && ( srcBinding == rhs.srcBinding )
          && ( srcArrayElement == rhs.srcArrayElement )
          && ( dstSet == rhs.dstSet )
          && ( dstBinding == rhs.dstBinding )
          && ( dstArrayElement == rhs.dstArrayElement )
          && ( descriptorCount == rhs.descriptorCount );
    }

    bool operator!=( CopyDescriptorSet const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eCopyDescriptorSet;
    const void* pNext = nullptr;
    DescriptorSet srcSet = DescriptorSet();
    uint32_t srcBinding = 0;
    uint32_t srcArrayElement = 0;
    DescriptorSet dstSet = DescriptorSet();
    uint32_t dstBinding = 0;
    uint32_t dstArrayElement = 0;
    uint32_t descriptorCount = 0;
  };
  static_assert( sizeof( CopyDescriptorSet ) == sizeof( VkCopyDescriptorSet ), "struct and wrapper have different size!" );
  static_assert( offsetof( CopyDescriptorSet, pNext ) == offsetof( VkCopyDescriptorSet, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CopyDescriptorSet, srcSet ) == offsetof( VkCopyDescriptorSet, srcSet ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CopyDescriptorSet, srcBinding ) == offsetof( VkCopyDescriptorSet, srcBinding ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CopyDescriptorSet, srcArrayElement ) == offsetof( VkCopyDescriptorSet, srcArrayElement ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CopyDescriptorSet, dstSet ) == offsetof( VkCopyDescriptorSet, dstSet ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CopyDescriptorSet, dstBinding ) == offsetof( VkCopyDescriptorSet, dstBinding ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CopyDescriptorSet, dstArrayElement ) == offsetof( VkCopyDescriptorSet, dstArrayElement ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CopyDescriptorSet, descriptorCount ) == offsetof( VkCopyDescriptorSet, descriptorCount ), "struct member and wrapper member have different offset!" );

  struct BufferViewCreateInfo
  {
    operator VkBufferViewCreateInfo const&() const
    {
      return *reinterpret_cast<const VkBufferViewCreateInfo*>(this);
    }

    operator VkBufferViewCreateInfo &()
    {
      return *reinterpret_cast<VkBufferViewCreateInfo*>(this);
    }

    bool operator==( BufferViewCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( buffer == rhs.buffer )
          && ( format == rhs.format )
          && ( offset == rhs.offset )
          && ( range == rhs.range );
    }

    bool operator!=( BufferViewCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBufferViewCreateInfo;
    const void* pNext = nullptr;
    BufferViewCreateFlags flags = BufferViewCreateFlags();
    Buffer buffer = Buffer();
    Format format = Format::eUndefined;
    DeviceSize offset = 0;
    DeviceSize range = 0;
  };
  static_assert( sizeof( BufferViewCreateInfo ) == sizeof( VkBufferViewCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( BufferViewCreateInfo, pNext ) == offsetof( VkBufferViewCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferViewCreateInfo, flags ) == offsetof( VkBufferViewCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferViewCreateInfo, buffer ) == offsetof( VkBufferViewCreateInfo, buffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferViewCreateInfo, format ) == offsetof( VkBufferViewCreateInfo, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferViewCreateInfo, offset ) == offsetof( VkBufferViewCreateInfo, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferViewCreateInfo, range ) == offsetof( VkBufferViewCreateInfo, range ), "struct member and wrapper member have different offset!" );

  struct ShaderModuleCreateInfo
  {
    operator VkShaderModuleCreateInfo const&() const
    {
      return *reinterpret_cast<const VkShaderModuleCreateInfo*>(this);
    }

    operator VkShaderModuleCreateInfo &()
    {
      return *reinterpret_cast<VkShaderModuleCreateInfo*>(this);
    }

    bool operator==( ShaderModuleCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( codeSize == rhs.codeSize )
          && ( pCode == rhs.pCode );
    }

    bool operator!=( ShaderModuleCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eShaderModuleCreateInfo;
    const void* pNext = nullptr;
    ShaderModuleCreateFlags flags = ShaderModuleCreateFlags();
    size_t codeSize = 0;
    const uint32_t* pCode = nullptr;
  };
  static_assert( sizeof( ShaderModuleCreateInfo ) == sizeof( VkShaderModuleCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ShaderModuleCreateInfo, pNext ) == offsetof( VkShaderModuleCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderModuleCreateInfo, flags ) == offsetof( VkShaderModuleCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderModuleCreateInfo, codeSize ) == offsetof( VkShaderModuleCreateInfo, codeSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderModuleCreateInfo, pCode ) == offsetof( VkShaderModuleCreateInfo, pCode ), "struct member and wrapper member have different offset!" );

  struct DescriptorSetAllocateInfo
  {
    operator VkDescriptorSetAllocateInfo const&() const
    {
      return *reinterpret_cast<const VkDescriptorSetAllocateInfo*>(this);
    }

    operator VkDescriptorSetAllocateInfo &()
    {
      return *reinterpret_cast<VkDescriptorSetAllocateInfo*>(this);
    }

    bool operator==( DescriptorSetAllocateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( descriptorPool == rhs.descriptorPool )
          && ( descriptorSetCount == rhs.descriptorSetCount )
          && ( pSetLayouts == rhs.pSetLayouts );
    }

    bool operator!=( DescriptorSetAllocateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorSetAllocateInfo;
    const void* pNext = nullptr;
    DescriptorPool descriptorPool = DescriptorPool();
    uint32_t descriptorSetCount = 0;
    const DescriptorSetLayout* pSetLayouts = nullptr;
  };
  static_assert( sizeof( DescriptorSetAllocateInfo ) == sizeof( VkDescriptorSetAllocateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorSetAllocateInfo, pNext ) == offsetof( VkDescriptorSetAllocateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetAllocateInfo, descriptorPool ) == offsetof( VkDescriptorSetAllocateInfo, descriptorPool ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetAllocateInfo, descriptorSetCount ) == offsetof( VkDescriptorSetAllocateInfo, descriptorSetCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetAllocateInfo, pSetLayouts ) == offsetof( VkDescriptorSetAllocateInfo, pSetLayouts ), "struct member and wrapper member have different offset!" );

  struct PipelineVertexInputStateCreateInfo
  {
    operator VkPipelineVertexInputStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineVertexInputStateCreateInfo*>(this);
    }

    operator VkPipelineVertexInputStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineVertexInputStateCreateInfo*>(this);
    }

    bool operator==( PipelineVertexInputStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( vertexBindingDescriptionCount == rhs.vertexBindingDescriptionCount )
          && ( pVertexBindingDescriptions == rhs.pVertexBindingDescriptions )
          && ( vertexAttributeDescriptionCount == rhs.vertexAttributeDescriptionCount )
          && ( pVertexAttributeDescriptions == rhs.pVertexAttributeDescriptions );
    }

    bool operator!=( PipelineVertexInputStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineVertexInputStateCreateInfo;
    const void* pNext = nullptr;
    PipelineVertexInputStateCreateFlags flags = PipelineVertexInputStateCreateFlags();
    uint32_t vertexBindingDescriptionCount = 0;
    const VertexInputBindingDescription* pVertexBindingDescriptions = nullptr;
    uint32_t vertexAttributeDescriptionCount = 0;
    const VertexInputAttributeDescription* pVertexAttributeDescriptions = nullptr;
  };
  static_assert( sizeof( PipelineVertexInputStateCreateInfo ) == sizeof( VkPipelineVertexInputStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineVertexInputStateCreateInfo, pNext ) == offsetof( VkPipelineVertexInputStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineVertexInputStateCreateInfo, flags ) == offsetof( VkPipelineVertexInputStateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineVertexInputStateCreateInfo, vertexBindingDescriptionCount ) == offsetof( VkPipelineVertexInputStateCreateInfo, vertexBindingDescriptionCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineVertexInputStateCreateInfo, pVertexBindingDescriptions ) == offsetof( VkPipelineVertexInputStateCreateInfo, pVertexBindingDescriptions ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineVertexInputStateCreateInfo, vertexAttributeDescriptionCount ) == offsetof( VkPipelineVertexInputStateCreateInfo, vertexAttributeDescriptionCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineVertexInputStateCreateInfo, pVertexAttributeDescriptions ) == offsetof( VkPipelineVertexInputStateCreateInfo, pVertexAttributeDescriptions ), "struct member and wrapper member have different offset!" );

  struct PipelineInputAssemblyStateCreateInfo
  {
    operator VkPipelineInputAssemblyStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineInputAssemblyStateCreateInfo*>(this);
    }

    operator VkPipelineInputAssemblyStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineInputAssemblyStateCreateInfo*>(this);
    }

    bool operator==( PipelineInputAssemblyStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( topology == rhs.topology )
          && ( primitiveRestartEnable == rhs.primitiveRestartEnable );
    }

    bool operator!=( PipelineInputAssemblyStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineInputAssemblyStateCreateInfo;
    const void* pNext = nullptr;
    PipelineInputAssemblyStateCreateFlags flags = PipelineInputAssemblyStateCreateFlags();
    PrimitiveTopology topology = PrimitiveTopology::ePointList;
    Bool32 primitiveRestartEnable = 0;
  };
  static_assert( sizeof( PipelineInputAssemblyStateCreateInfo ) == sizeof( VkPipelineInputAssemblyStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineInputAssemblyStateCreateInfo, pNext ) == offsetof( VkPipelineInputAssemblyStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineInputAssemblyStateCreateInfo, flags ) == offsetof( VkPipelineInputAssemblyStateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineInputAssemblyStateCreateInfo, topology ) == offsetof( VkPipelineInputAssemblyStateCreateInfo, topology ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineInputAssemblyStateCreateInfo, primitiveRestartEnable ) == offsetof( VkPipelineInputAssemblyStateCreateInfo, primitiveRestartEnable ), "struct member and wrapper member have different offset!" );

  struct PipelineTessellationStateCreateInfo
  {
    operator VkPipelineTessellationStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineTessellationStateCreateInfo*>(this);
    }

    operator VkPipelineTessellationStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineTessellationStateCreateInfo*>(this);
    }

    bool operator==( PipelineTessellationStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( patchControlPoints == rhs.patchControlPoints );
    }

    bool operator!=( PipelineTessellationStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineTessellationStateCreateInfo;
    const void* pNext = nullptr;
    PipelineTessellationStateCreateFlags flags = PipelineTessellationStateCreateFlags();
    uint32_t patchControlPoints = 0;
  };
  static_assert( sizeof( PipelineTessellationStateCreateInfo ) == sizeof( VkPipelineTessellationStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineTessellationStateCreateInfo, pNext ) == offsetof( VkPipelineTessellationStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineTessellationStateCreateInfo, flags ) == offsetof( VkPipelineTessellationStateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineTessellationStateCreateInfo, patchControlPoints ) == offsetof( VkPipelineTessellationStateCreateInfo, patchControlPoints ), "struct member and wrapper member have different offset!" );

  struct PipelineViewportStateCreateInfo
  {
    operator VkPipelineViewportStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineViewportStateCreateInfo*>(this);
    }

    operator VkPipelineViewportStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineViewportStateCreateInfo*>(this);
    }

    bool operator==( PipelineViewportStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( viewportCount == rhs.viewportCount )
          && ( pViewports == rhs.pViewports )
          && ( scissorCount == rhs.scissorCount )
          && ( pScissors == rhs.pScissors );
    }

    bool operator!=( PipelineViewportStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineViewportStateCreateInfo;
    const void* pNext = nullptr;
    PipelineViewportStateCreateFlags flags = PipelineViewportStateCreateFlags();
    uint32_t viewportCount = 0;
    const Viewport* pViewports = nullptr;
    uint32_t scissorCount = 0;
    const Rect2D* pScissors = nullptr;
  };
  static_assert( sizeof( PipelineViewportStateCreateInfo ) == sizeof( VkPipelineViewportStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineViewportStateCreateInfo, pNext ) == offsetof( VkPipelineViewportStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportStateCreateInfo, flags ) == offsetof( VkPipelineViewportStateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportStateCreateInfo, viewportCount ) == offsetof( VkPipelineViewportStateCreateInfo, viewportCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportStateCreateInfo, pViewports ) == offsetof( VkPipelineViewportStateCreateInfo, pViewports ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportStateCreateInfo, scissorCount ) == offsetof( VkPipelineViewportStateCreateInfo, scissorCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportStateCreateInfo, pScissors ) == offsetof( VkPipelineViewportStateCreateInfo, pScissors ), "struct member and wrapper member have different offset!" );

  struct PipelineRasterizationStateCreateInfo
  {
    operator VkPipelineRasterizationStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineRasterizationStateCreateInfo*>(this);
    }

    operator VkPipelineRasterizationStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineRasterizationStateCreateInfo*>(this);
    }

    bool operator==( PipelineRasterizationStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( depthClampEnable == rhs.depthClampEnable )
          && ( rasterizerDiscardEnable == rhs.rasterizerDiscardEnable )
          && ( polygonMode == rhs.polygonMode )
          && ( cullMode == rhs.cullMode )
          && ( frontFace == rhs.frontFace )
          && ( depthBiasEnable == rhs.depthBiasEnable )
          && ( depthBiasConstantFactor == rhs.depthBiasConstantFactor )
          && ( depthBiasClamp == rhs.depthBiasClamp )
          && ( depthBiasSlopeFactor == rhs.depthBiasSlopeFactor )
          && ( lineWidth == rhs.lineWidth );
    }

    bool operator!=( PipelineRasterizationStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineRasterizationStateCreateInfo;
    const void* pNext = nullptr;
    PipelineRasterizationStateCreateFlags flags = PipelineRasterizationStateCreateFlags();
    Bool32 depthClampEnable = 0;
    Bool32 rasterizerDiscardEnable = 0;
    PolygonMode polygonMode = PolygonMode::eFill;
    CullModeFlags cullMode = CullModeFlags();
    FrontFace frontFace = FrontFace::eCounterClockwise;
    Bool32 depthBiasEnable = 0;
    float depthBiasConstantFactor = 0;
    float depthBiasClamp = 0;
    float depthBiasSlopeFactor = 0;
    float lineWidth = 0;
  };
  static_assert( sizeof( PipelineRasterizationStateCreateInfo ) == sizeof( VkPipelineRasterizationStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, pNext ) == offsetof( VkPipelineRasterizationStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, flags ) == offsetof( VkPipelineRasterizationStateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, depthClampEnable ) == offsetof( VkPipelineRasterizationStateCreateInfo, depthClampEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, rasterizerDiscardEnable ) == offsetof( VkPipelineRasterizationStateCreateInfo, rasterizerDiscardEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, polygonMode ) == offsetof( VkPipelineRasterizationStateCreateInfo, polygonMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, cullMode ) == offsetof( VkPipelineRasterizationStateCreateInfo, cullMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, frontFace ) == offsetof( VkPipelineRasterizationStateCreateInfo, frontFace ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, depthBiasEnable ) == offsetof( VkPipelineRasterizationStateCreateInfo, depthBiasEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, depthBiasConstantFactor ) == offsetof( VkPipelineRasterizationStateCreateInfo, depthBiasConstantFactor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, depthBiasClamp ) == offsetof( VkPipelineRasterizationStateCreateInfo, depthBiasClamp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, depthBiasSlopeFactor ) == offsetof( VkPipelineRasterizationStateCreateInfo, depthBiasSlopeFactor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateCreateInfo, lineWidth ) == offsetof( VkPipelineRasterizationStateCreateInfo, lineWidth ), "struct member and wrapper member have different offset!" );

  struct PipelineDepthStencilStateCreateInfo
  {
    operator VkPipelineDepthStencilStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineDepthStencilStateCreateInfo*>(this);
    }

    operator VkPipelineDepthStencilStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineDepthStencilStateCreateInfo*>(this);
    }

    bool operator==( PipelineDepthStencilStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( depthTestEnable == rhs.depthTestEnable )
          && ( depthWriteEnable == rhs.depthWriteEnable )
          && ( depthCompareOp == rhs.depthCompareOp )
          && ( depthBoundsTestEnable == rhs.depthBoundsTestEnable )
          && ( stencilTestEnable == rhs.stencilTestEnable )
          && ( front == rhs.front )
          && ( back == rhs.back )
          && ( minDepthBounds == rhs.minDepthBounds )
          && ( maxDepthBounds == rhs.maxDepthBounds );
    }

    bool operator!=( PipelineDepthStencilStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineDepthStencilStateCreateInfo;
    const void* pNext = nullptr;
    PipelineDepthStencilStateCreateFlags flags = PipelineDepthStencilStateCreateFlags();
    Bool32 depthTestEnable = 0;
    Bool32 depthWriteEnable = 0;
    CompareOp depthCompareOp = CompareOp::eNever;
    Bool32 depthBoundsTestEnable = 0;
    Bool32 stencilTestEnable = 0;
    StencilOpState front = StencilOpState();
    StencilOpState back = StencilOpState();
    float minDepthBounds = 0;
    float maxDepthBounds = 0;
  };
  static_assert( sizeof( PipelineDepthStencilStateCreateInfo ) == sizeof( VkPipelineDepthStencilStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, pNext ) == offsetof( VkPipelineDepthStencilStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, flags ) == offsetof( VkPipelineDepthStencilStateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, depthTestEnable ) == offsetof( VkPipelineDepthStencilStateCreateInfo, depthTestEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, depthWriteEnable ) == offsetof( VkPipelineDepthStencilStateCreateInfo, depthWriteEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, depthCompareOp ) == offsetof( VkPipelineDepthStencilStateCreateInfo, depthCompareOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, depthBoundsTestEnable ) == offsetof( VkPipelineDepthStencilStateCreateInfo, depthBoundsTestEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, stencilTestEnable ) == offsetof( VkPipelineDepthStencilStateCreateInfo, stencilTestEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, front ) == offsetof( VkPipelineDepthStencilStateCreateInfo, front ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, back ) == offsetof( VkPipelineDepthStencilStateCreateInfo, back ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, minDepthBounds ) == offsetof( VkPipelineDepthStencilStateCreateInfo, minDepthBounds ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDepthStencilStateCreateInfo, maxDepthBounds ) == offsetof( VkPipelineDepthStencilStateCreateInfo, maxDepthBounds ), "struct member and wrapper member have different offset!" );

  struct PipelineCacheCreateInfo
  {
    operator VkPipelineCacheCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineCacheCreateInfo*>(this);
    }

    operator VkPipelineCacheCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineCacheCreateInfo*>(this);
    }

    bool operator==( PipelineCacheCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( initialDataSize == rhs.initialDataSize )
          && ( pInitialData == rhs.pInitialData );
    }

    bool operator!=( PipelineCacheCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineCacheCreateInfo;
    const void* pNext = nullptr;
    PipelineCacheCreateFlags flags = PipelineCacheCreateFlags();
    size_t initialDataSize = 0;
    const void* pInitialData = nullptr;
  };
  static_assert( sizeof( PipelineCacheCreateInfo ) == sizeof( VkPipelineCacheCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineCacheCreateInfo, pNext ) == offsetof( VkPipelineCacheCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCacheCreateInfo, flags ) == offsetof( VkPipelineCacheCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCacheCreateInfo, initialDataSize ) == offsetof( VkPipelineCacheCreateInfo, initialDataSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCacheCreateInfo, pInitialData ) == offsetof( VkPipelineCacheCreateInfo, pInitialData ), "struct member and wrapper member have different offset!" );

  struct SamplerCreateInfo
  {
    operator VkSamplerCreateInfo const&() const
    {
      return *reinterpret_cast<const VkSamplerCreateInfo*>(this);
    }

    operator VkSamplerCreateInfo &()
    {
      return *reinterpret_cast<VkSamplerCreateInfo*>(this);
    }

    bool operator==( SamplerCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( magFilter == rhs.magFilter )
          && ( minFilter == rhs.minFilter )
          && ( mipmapMode == rhs.mipmapMode )
          && ( addressModeU == rhs.addressModeU )
          && ( addressModeV == rhs.addressModeV )
          && ( addressModeW == rhs.addressModeW )
          && ( mipLodBias == rhs.mipLodBias )
          && ( anisotropyEnable == rhs.anisotropyEnable )
          && ( maxAnisotropy == rhs.maxAnisotropy )
          && ( compareEnable == rhs.compareEnable )
          && ( compareOp == rhs.compareOp )
          && ( minLod == rhs.minLod )
          && ( maxLod == rhs.maxLod )
          && ( borderColor == rhs.borderColor )
          && ( unnormalizedCoordinates == rhs.unnormalizedCoordinates );
    }

    bool operator!=( SamplerCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSamplerCreateInfo;
    const void* pNext = nullptr;
    SamplerCreateFlags flags = SamplerCreateFlags();
    Filter magFilter = Filter::eNearest;
    Filter minFilter = Filter::eNearest;
    SamplerMipmapMode mipmapMode = SamplerMipmapMode::eNearest;
    SamplerAddressMode addressModeU = SamplerAddressMode::eRepeat;
    SamplerAddressMode addressModeV = SamplerAddressMode::eRepeat;
    SamplerAddressMode addressModeW = SamplerAddressMode::eRepeat;
    float mipLodBias = 0;
    Bool32 anisotropyEnable = 0;
    float maxAnisotropy = 0;
    Bool32 compareEnable = 0;
    CompareOp compareOp = CompareOp::eNever;
    float minLod = 0;
    float maxLod = 0;
    BorderColor borderColor = BorderColor::eFloatTransparentBlack;
    Bool32 unnormalizedCoordinates = 0;
  };
  static_assert( sizeof( SamplerCreateInfo ) == sizeof( VkSamplerCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( SamplerCreateInfo, pNext ) == offsetof( VkSamplerCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, flags ) == offsetof( VkSamplerCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, magFilter ) == offsetof( VkSamplerCreateInfo, magFilter ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, minFilter ) == offsetof( VkSamplerCreateInfo, minFilter ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, mipmapMode ) == offsetof( VkSamplerCreateInfo, mipmapMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, addressModeU ) == offsetof( VkSamplerCreateInfo, addressModeU ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, addressModeV ) == offsetof( VkSamplerCreateInfo, addressModeV ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, addressModeW ) == offsetof( VkSamplerCreateInfo, addressModeW ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, mipLodBias ) == offsetof( VkSamplerCreateInfo, mipLodBias ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, anisotropyEnable ) == offsetof( VkSamplerCreateInfo, anisotropyEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, maxAnisotropy ) == offsetof( VkSamplerCreateInfo, maxAnisotropy ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, compareEnable ) == offsetof( VkSamplerCreateInfo, compareEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, compareOp ) == offsetof( VkSamplerCreateInfo, compareOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, minLod ) == offsetof( VkSamplerCreateInfo, minLod ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, maxLod ) == offsetof( VkSamplerCreateInfo, maxLod ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, borderColor ) == offsetof( VkSamplerCreateInfo, borderColor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerCreateInfo, unnormalizedCoordinates ) == offsetof( VkSamplerCreateInfo, unnormalizedCoordinates ), "struct member and wrapper member have different offset!" );

  struct CommandBufferAllocateInfo
  {
    operator VkCommandBufferAllocateInfo const&() const
    {
      return *reinterpret_cast<const VkCommandBufferAllocateInfo*>(this);
    }

    operator VkCommandBufferAllocateInfo &()
    {
      return *reinterpret_cast<VkCommandBufferAllocateInfo*>(this);
    }

    bool operator==( CommandBufferAllocateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( commandPool == rhs.commandPool )
          && ( level == rhs.level )
          && ( commandBufferCount == rhs.commandBufferCount );
    }

    bool operator!=( CommandBufferAllocateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eCommandBufferAllocateInfo;
    const void* pNext = nullptr;
    CommandPool commandPool = CommandPool();
    CommandBufferLevel level = CommandBufferLevel::ePrimary;
    uint32_t commandBufferCount = 0;
  };
  static_assert( sizeof( CommandBufferAllocateInfo ) == sizeof( VkCommandBufferAllocateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( CommandBufferAllocateInfo, pNext ) == offsetof( VkCommandBufferAllocateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferAllocateInfo, commandPool ) == offsetof( VkCommandBufferAllocateInfo, commandPool ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferAllocateInfo, level ) == offsetof( VkCommandBufferAllocateInfo, level ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferAllocateInfo, commandBufferCount ) == offsetof( VkCommandBufferAllocateInfo, commandBufferCount ), "struct member and wrapper member have different offset!" );

  struct RenderPassBeginInfo
  {
    operator VkRenderPassBeginInfo const&() const
    {
      return *reinterpret_cast<const VkRenderPassBeginInfo*>(this);
    }

    operator VkRenderPassBeginInfo &()
    {
      return *reinterpret_cast<VkRenderPassBeginInfo*>(this);
    }

    bool operator==( RenderPassBeginInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( renderPass == rhs.renderPass )
          && ( framebuffer == rhs.framebuffer )
          && ( renderArea == rhs.renderArea )
          && ( clearValueCount == rhs.clearValueCount )
          && ( pClearValues == rhs.pClearValues );
    }

    bool operator!=( RenderPassBeginInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eRenderPassBeginInfo;
    const void* pNext = nullptr;
    RenderPass renderPass = RenderPass();
    Framebuffer framebuffer = Framebuffer();
    Rect2D renderArea = Rect2D();
    uint32_t clearValueCount = 0;
    const ClearValue* pClearValues = nullptr;
  };
  static_assert( sizeof( RenderPassBeginInfo ) == sizeof( VkRenderPassBeginInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( RenderPassBeginInfo, pNext ) == offsetof( VkRenderPassBeginInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassBeginInfo, renderPass ) == offsetof( VkRenderPassBeginInfo, renderPass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassBeginInfo, framebuffer ) == offsetof( VkRenderPassBeginInfo, framebuffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassBeginInfo, renderArea ) == offsetof( VkRenderPassBeginInfo, renderArea ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassBeginInfo, clearValueCount ) == offsetof( VkRenderPassBeginInfo, clearValueCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassBeginInfo, pClearValues ) == offsetof( VkRenderPassBeginInfo, pClearValues ), "struct member and wrapper member have different offset!" );

  struct EventCreateInfo
  {
    operator VkEventCreateInfo const&() const
    {
      return *reinterpret_cast<const VkEventCreateInfo*>(this);
    }

    operator VkEventCreateInfo &()
    {
      return *reinterpret_cast<VkEventCreateInfo*>(this);
    }

    bool operator==( EventCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags );
    }

    bool operator!=( EventCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eEventCreateInfo;
    const void* pNext = nullptr;
    EventCreateFlags flags = EventCreateFlags();
  };
  static_assert( sizeof( EventCreateInfo ) == sizeof( VkEventCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( EventCreateInfo, pNext ) == offsetof( VkEventCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( EventCreateInfo, flags ) == offsetof( VkEventCreateInfo, flags ), "struct member and wrapper member have different offset!" );

  struct SemaphoreCreateInfo
  {
    operator VkSemaphoreCreateInfo const&() const
    {
      return *reinterpret_cast<const VkSemaphoreCreateInfo*>(this);
    }

    operator VkSemaphoreCreateInfo &()
    {
      return *reinterpret_cast<VkSemaphoreCreateInfo*>(this);
    }

    bool operator==( SemaphoreCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags );
    }

    bool operator!=( SemaphoreCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSemaphoreCreateInfo;
    const void* pNext = nullptr;
    SemaphoreCreateFlags flags = SemaphoreCreateFlags();
  };
  static_assert( sizeof( SemaphoreCreateInfo ) == sizeof( VkSemaphoreCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( SemaphoreCreateInfo, pNext ) == offsetof( VkSemaphoreCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SemaphoreCreateInfo, flags ) == offsetof( VkSemaphoreCreateInfo, flags ), "struct member and wrapper member have different offset!" );

  struct FramebufferCreateInfo
  {
    operator VkFramebufferCreateInfo const&() const
    {
      return *reinterpret_cast<const VkFramebufferCreateInfo*>(this);
    }

    operator VkFramebufferCreateInfo &()
    {
      return *reinterpret_cast<VkFramebufferCreateInfo*>(this);
    }

    bool operator==( FramebufferCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( renderPass == rhs.renderPass )
          && ( attachmentCount == rhs.attachmentCount )
          && ( pAttachments == rhs.pAttachments )
          && ( width == rhs.width )
          && ( height == rhs.height )
          && ( layers == rhs.layers );
    }

    bool operator!=( FramebufferCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eFramebufferCreateInfo;
    const void* pNext = nullptr;
    FramebufferCreateFlags flags = FramebufferCreateFlags();
    RenderPass renderPass = RenderPass();
    uint32_t attachmentCount = 0;
    const ImageView* pAttachments = nullptr;
    uint32_t width = 0;
    uint32_t height = 0;
    uint32_t layers = 0;
  };
  static_assert( sizeof( FramebufferCreateInfo ) == sizeof( VkFramebufferCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( FramebufferCreateInfo, pNext ) == offsetof( VkFramebufferCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FramebufferCreateInfo, flags ) == offsetof( VkFramebufferCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FramebufferCreateInfo, renderPass ) == offsetof( VkFramebufferCreateInfo, renderPass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FramebufferCreateInfo, attachmentCount ) == offsetof( VkFramebufferCreateInfo, attachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FramebufferCreateInfo, pAttachments ) == offsetof( VkFramebufferCreateInfo, pAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FramebufferCreateInfo, width ) == offsetof( VkFramebufferCreateInfo, width ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FramebufferCreateInfo, height ) == offsetof( VkFramebufferCreateInfo, height ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FramebufferCreateInfo, layers ) == offsetof( VkFramebufferCreateInfo, layers ), "struct member and wrapper member have different offset!" );

  struct DisplayModeCreateInfoKHR
  {
    operator VkDisplayModeCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkDisplayModeCreateInfoKHR*>(this);
    }

    operator VkDisplayModeCreateInfoKHR &()
    {
      return *reinterpret_cast<VkDisplayModeCreateInfoKHR*>(this);
    }

    bool operator==( DisplayModeCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( parameters == rhs.parameters );
    }

    bool operator!=( DisplayModeCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplayModeCreateInfoKHR;
    const void* pNext = nullptr;
    DisplayModeCreateFlagsKHR flags = DisplayModeCreateFlagsKHR();
    DisplayModeParametersKHR parameters = DisplayModeParametersKHR();
  };
  static_assert( sizeof( DisplayModeCreateInfoKHR ) == sizeof( VkDisplayModeCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayModeCreateInfoKHR, pNext ) == offsetof( VkDisplayModeCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayModeCreateInfoKHR, flags ) == offsetof( VkDisplayModeCreateInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayModeCreateInfoKHR, parameters ) == offsetof( VkDisplayModeCreateInfoKHR, parameters ), "struct member and wrapper member have different offset!" );

  struct DisplayPresentInfoKHR
  {
    operator VkDisplayPresentInfoKHR const&() const
    {
      return *reinterpret_cast<const VkDisplayPresentInfoKHR*>(this);
    }

    operator VkDisplayPresentInfoKHR &()
    {
      return *reinterpret_cast<VkDisplayPresentInfoKHR*>(this);
    }

    bool operator==( DisplayPresentInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( srcRect == rhs.srcRect )
          && ( dstRect == rhs.dstRect )
          && ( persistent == rhs.persistent );
    }

    bool operator!=( DisplayPresentInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplayPresentInfoKHR;
    const void* pNext = nullptr;
    Rect2D srcRect = Rect2D();
    Rect2D dstRect = Rect2D();
    Bool32 persistent = 0;
  };
  static_assert( sizeof( DisplayPresentInfoKHR ) == sizeof( VkDisplayPresentInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayPresentInfoKHR, pNext ) == offsetof( VkDisplayPresentInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPresentInfoKHR, srcRect ) == offsetof( VkDisplayPresentInfoKHR, srcRect ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPresentInfoKHR, dstRect ) == offsetof( VkDisplayPresentInfoKHR, dstRect ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPresentInfoKHR, persistent ) == offsetof( VkDisplayPresentInfoKHR, persistent ), "struct member and wrapper member have different offset!" );

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  struct AndroidSurfaceCreateInfoKHR
  {
    operator VkAndroidSurfaceCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkAndroidSurfaceCreateInfoKHR*>(this);
    }

    operator VkAndroidSurfaceCreateInfoKHR &()
    {
      return *reinterpret_cast<VkAndroidSurfaceCreateInfoKHR*>(this);
    }

    bool operator==( AndroidSurfaceCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( window == rhs.window );
    }

    bool operator!=( AndroidSurfaceCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eAndroidSurfaceCreateInfoKHR;
    const void* pNext = nullptr;
    AndroidSurfaceCreateFlagsKHR flags = AndroidSurfaceCreateFlagsKHR();
    struct ANativeWindow* window = nullptr;
  };
  static_assert( sizeof( AndroidSurfaceCreateInfoKHR ) == sizeof( VkAndroidSurfaceCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( AndroidSurfaceCreateInfoKHR, pNext ) == offsetof( VkAndroidSurfaceCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidSurfaceCreateInfoKHR, flags ) == offsetof( VkAndroidSurfaceCreateInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidSurfaceCreateInfoKHR, window ) == offsetof( VkAndroidSurfaceCreateInfoKHR, window ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#ifdef VK_USE_PLATFORM_MIR_KHR
  struct MirSurfaceCreateInfoKHR
  {
    operator VkMirSurfaceCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkMirSurfaceCreateInfoKHR*>(this);
    }

    operator VkMirSurfaceCreateInfoKHR &()
    {
      return *reinterpret_cast<VkMirSurfaceCreateInfoKHR*>(this);
    }

    bool operator==( MirSurfaceCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( connection == rhs.connection )
          && ( mirSurface == rhs.mirSurface );
    }

    bool operator!=( MirSurfaceCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMirSurfaceCreateInfoKHR;
    const void* pNext = nullptr;
    MirSurfaceCreateFlagsKHR flags = MirSurfaceCreateFlagsKHR();
    MirConnection* connection = nullptr;
    MirSurface* mirSurface = nullptr;
  };
  static_assert( sizeof( MirSurfaceCreateInfoKHR ) == sizeof( VkMirSurfaceCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( MirSurfaceCreateInfoKHR, pNext ) == offsetof( VkMirSurfaceCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MirSurfaceCreateInfoKHR, flags ) == offsetof( VkMirSurfaceCreateInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MirSurfaceCreateInfoKHR, connection ) == offsetof( VkMirSurfaceCreateInfoKHR, connection ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MirSurfaceCreateInfoKHR, mirSurface ) == offsetof( VkMirSurfaceCreateInfoKHR, mirSurface ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_MIR_KHR*/

#ifdef VK_USE_PLATFORM_VI_NN
  struct ViSurfaceCreateInfoNN
  {
    operator VkViSurfaceCreateInfoNN const&() const
    {
      return *reinterpret_cast<const VkViSurfaceCreateInfoNN*>(this);
    }

    operator VkViSurfaceCreateInfoNN &()
    {
      return *reinterpret_cast<VkViSurfaceCreateInfoNN*>(this);
    }

    bool operator==( ViSurfaceCreateInfoNN const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( window == rhs.window );
    }

    bool operator!=( ViSurfaceCreateInfoNN const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eViSurfaceCreateInfoNN;
    const void* pNext = nullptr;
    ViSurfaceCreateFlagsNN flags = ViSurfaceCreateFlagsNN();
    void* window = nullptr;
  };
  static_assert( sizeof( ViSurfaceCreateInfoNN ) == sizeof( VkViSurfaceCreateInfoNN ), "struct and wrapper have different size!" );
  static_assert( offsetof( ViSurfaceCreateInfoNN, pNext ) == offsetof( VkViSurfaceCreateInfoNN, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ViSurfaceCreateInfoNN, flags ) == offsetof( VkViSurfaceCreateInfoNN, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ViSurfaceCreateInfoNN, window ) == offsetof( VkViSurfaceCreateInfoNN, window ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_VI_NN*/

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  struct WaylandSurfaceCreateInfoKHR
  {
    operator VkWaylandSurfaceCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkWaylandSurfaceCreateInfoKHR*>(this);
    }

    operator VkWaylandSurfaceCreateInfoKHR &()
    {
      return *reinterpret_cast<VkWaylandSurfaceCreateInfoKHR*>(this);
    }

    bool operator==( WaylandSurfaceCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( display == rhs.display )
          && ( surface == rhs.surface );
    }

    bool operator!=( WaylandSurfaceCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eWaylandSurfaceCreateInfoKHR;
    const void* pNext = nullptr;
    WaylandSurfaceCreateFlagsKHR flags = WaylandSurfaceCreateFlagsKHR();
    struct wl_display* display = nullptr;
    struct wl_surface* surface = nullptr;
  };
  static_assert( sizeof( WaylandSurfaceCreateInfoKHR ) == sizeof( VkWaylandSurfaceCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( WaylandSurfaceCreateInfoKHR, pNext ) == offsetof( VkWaylandSurfaceCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WaylandSurfaceCreateInfoKHR, flags ) == offsetof( VkWaylandSurfaceCreateInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WaylandSurfaceCreateInfoKHR, display ) == offsetof( VkWaylandSurfaceCreateInfoKHR, display ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WaylandSurfaceCreateInfoKHR, surface ) == offsetof( VkWaylandSurfaceCreateInfoKHR, surface ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct Win32SurfaceCreateInfoKHR
  {
    operator VkWin32SurfaceCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkWin32SurfaceCreateInfoKHR*>(this);
    }

    operator VkWin32SurfaceCreateInfoKHR &()
    {
      return *reinterpret_cast<VkWin32SurfaceCreateInfoKHR*>(this);
    }

    bool operator==( Win32SurfaceCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( hinstance == rhs.hinstance )
          && ( hwnd == rhs.hwnd );
    }

    bool operator!=( Win32SurfaceCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eWin32SurfaceCreateInfoKHR;
    const void* pNext = nullptr;
    Win32SurfaceCreateFlagsKHR flags = Win32SurfaceCreateFlagsKHR();
    HINSTANCE hinstance = 0;
    HWND hwnd = 0;
  };
  static_assert( sizeof( Win32SurfaceCreateInfoKHR ) == sizeof( VkWin32SurfaceCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( Win32SurfaceCreateInfoKHR, pNext ) == offsetof( VkWin32SurfaceCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32SurfaceCreateInfoKHR, flags ) == offsetof( VkWin32SurfaceCreateInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32SurfaceCreateInfoKHR, hinstance ) == offsetof( VkWin32SurfaceCreateInfoKHR, hinstance ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32SurfaceCreateInfoKHR, hwnd ) == offsetof( VkWin32SurfaceCreateInfoKHR, hwnd ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_XLIB_KHR
  struct XlibSurfaceCreateInfoKHR
  {
    operator VkXlibSurfaceCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkXlibSurfaceCreateInfoKHR*>(this);
    }

    operator VkXlibSurfaceCreateInfoKHR &()
    {
      return *reinterpret_cast<VkXlibSurfaceCreateInfoKHR*>(this);
    }

    bool operator==( XlibSurfaceCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( dpy == rhs.dpy )
          && ( window == rhs.window );
    }

    bool operator!=( XlibSurfaceCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eXlibSurfaceCreateInfoKHR;
    const void* pNext = nullptr;
    XlibSurfaceCreateFlagsKHR flags = XlibSurfaceCreateFlagsKHR();
    Display* dpy = nullptr;
    Window window = 0;
  };
  static_assert( sizeof( XlibSurfaceCreateInfoKHR ) == sizeof( VkXlibSurfaceCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( XlibSurfaceCreateInfoKHR, pNext ) == offsetof( VkXlibSurfaceCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( XlibSurfaceCreateInfoKHR, flags ) == offsetof( VkXlibSurfaceCreateInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( XlibSurfaceCreateInfoKHR, dpy ) == offsetof( VkXlibSurfaceCreateInfoKHR, dpy ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( XlibSurfaceCreateInfoKHR, window ) == offsetof( VkXlibSurfaceCreateInfoKHR, window ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#ifdef VK_USE_PLATFORM_XCB_KHR
  struct XcbSurfaceCreateInfoKHR
  {
    operator VkXcbSurfaceCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkXcbSurfaceCreateInfoKHR*>(this);
    }

    operator VkXcbSurfaceCreateInfoKHR &()
    {
      return *reinterpret_cast<VkXcbSurfaceCreateInfoKHR*>(this);
    }

    bool operator==( XcbSurfaceCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( connection == rhs.connection )
          && ( window == rhs.window );
    }

    bool operator!=( XcbSurfaceCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eXcbSurfaceCreateInfoKHR;
    const void* pNext = nullptr;
    XcbSurfaceCreateFlagsKHR flags = XcbSurfaceCreateFlagsKHR();
    xcb_connection_t* connection = nullptr;
    xcb_window_t window = 0;
  };
  static_assert( sizeof( XcbSurfaceCreateInfoKHR ) == sizeof( VkXcbSurfaceCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( XcbSurfaceCreateInfoKHR, pNext ) == offsetof( VkXcbSurfaceCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( XcbSurfaceCreateInfoKHR, flags ) == offsetof( VkXcbSurfaceCreateInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( XcbSurfaceCreateInfoKHR, connection ) == offsetof( VkXcbSurfaceCreateInfoKHR, connection ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( XcbSurfaceCreateInfoKHR, window ) == offsetof( VkXcbSurfaceCreateInfoKHR, window ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_XCB_KHR*/

  struct DebugMarkerMarkerInfoEXT
  {
    operator VkDebugMarkerMarkerInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDebugMarkerMarkerInfoEXT*>(this);
    }

    operator VkDebugMarkerMarkerInfoEXT &()
    {
      return *reinterpret_cast<VkDebugMarkerMarkerInfoEXT*>(this);
    }

    bool operator==( DebugMarkerMarkerInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( pMarkerName == rhs.pMarkerName )
          && ( color == rhs.color );
    }

    bool operator!=( DebugMarkerMarkerInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDebugMarkerMarkerInfoEXT;
    const void* pNext = nullptr;
    const char* pMarkerName = nullptr;
    std::array<float, 4> color = { { 0, 0, 0, 0 } };
  };
  static_assert( sizeof( DebugMarkerMarkerInfoEXT ) == sizeof( VkDebugMarkerMarkerInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DebugMarkerMarkerInfoEXT, pNext ) == offsetof( VkDebugMarkerMarkerInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerMarkerInfoEXT, pMarkerName ) == offsetof( VkDebugMarkerMarkerInfoEXT, pMarkerName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerMarkerInfoEXT, color ) == offsetof( VkDebugMarkerMarkerInfoEXT, color ), "struct member and wrapper member have different offset!" );

  struct DedicatedAllocationImageCreateInfoNV
  {
    operator VkDedicatedAllocationImageCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(this);
    }

    operator VkDedicatedAllocationImageCreateInfoNV &()
    {
      return *reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(this);
    }

    bool operator==( DedicatedAllocationImageCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( dedicatedAllocation == rhs.dedicatedAllocation );
    }

    bool operator!=( DedicatedAllocationImageCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDedicatedAllocationImageCreateInfoNV;
    const void* pNext = nullptr;
    Bool32 dedicatedAllocation = 0;
  };
  static_assert( sizeof( DedicatedAllocationImageCreateInfoNV ) == sizeof( VkDedicatedAllocationImageCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( DedicatedAllocationImageCreateInfoNV, pNext ) == offsetof( VkDedicatedAllocationImageCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DedicatedAllocationImageCreateInfoNV, dedicatedAllocation ) == offsetof( VkDedicatedAllocationImageCreateInfoNV, dedicatedAllocation ), "struct member and wrapper member have different offset!" );

  struct DedicatedAllocationBufferCreateInfoNV
  {
    operator VkDedicatedAllocationBufferCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(this);
    }

    operator VkDedicatedAllocationBufferCreateInfoNV &()
    {
      return *reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(this);
    }

    bool operator==( DedicatedAllocationBufferCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( dedicatedAllocation == rhs.dedicatedAllocation );
    }

    bool operator!=( DedicatedAllocationBufferCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDedicatedAllocationBufferCreateInfoNV;
    const void* pNext = nullptr;
    Bool32 dedicatedAllocation = 0;
  };
  static_assert( sizeof( DedicatedAllocationBufferCreateInfoNV ) == sizeof( VkDedicatedAllocationBufferCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( DedicatedAllocationBufferCreateInfoNV, pNext ) == offsetof( VkDedicatedAllocationBufferCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DedicatedAllocationBufferCreateInfoNV, dedicatedAllocation ) == offsetof( VkDedicatedAllocationBufferCreateInfoNV, dedicatedAllocation ), "struct member and wrapper member have different offset!" );

  struct DedicatedAllocationMemoryAllocateInfoNV
  {
    operator VkDedicatedAllocationMemoryAllocateInfoNV const&() const
    {
      return *reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(this);
    }

    operator VkDedicatedAllocationMemoryAllocateInfoNV &()
    {
      return *reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(this);
    }

    bool operator==( DedicatedAllocationMemoryAllocateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( image == rhs.image )
          && ( buffer == rhs.buffer );
    }

    bool operator!=( DedicatedAllocationMemoryAllocateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDedicatedAllocationMemoryAllocateInfoNV;
    const void* pNext = nullptr;
    Image image = Image();
    Buffer buffer = Buffer();
  };
  static_assert( sizeof( DedicatedAllocationMemoryAllocateInfoNV ) == sizeof( VkDedicatedAllocationMemoryAllocateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( DedicatedAllocationMemoryAllocateInfoNV, pNext ) == offsetof( VkDedicatedAllocationMemoryAllocateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DedicatedAllocationMemoryAllocateInfoNV, image ) == offsetof( VkDedicatedAllocationMemoryAllocateInfoNV, image ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DedicatedAllocationMemoryAllocateInfoNV, buffer ) == offsetof( VkDedicatedAllocationMemoryAllocateInfoNV, buffer ), "struct member and wrapper member have different offset!" );

#ifdef VK_USE_PLATFORM_WIN32_NV
  struct ExportMemoryWin32HandleInfoNV
  {
    operator VkExportMemoryWin32HandleInfoNV const&() const
    {
      return *reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(this);
    }

    operator VkExportMemoryWin32HandleInfoNV &()
    {
      return *reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(this);
    }

    bool operator==( ExportMemoryWin32HandleInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( pAttributes == rhs.pAttributes )
          && ( dwAccess == rhs.dwAccess );
    }

    bool operator!=( ExportMemoryWin32HandleInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExportMemoryWin32HandleInfoNV;
    const void* pNext = nullptr;
    const SECURITY_ATTRIBUTES* pAttributes = nullptr;
    DWORD dwAccess = 0;
  };
  static_assert( sizeof( ExportMemoryWin32HandleInfoNV ) == sizeof( VkExportMemoryWin32HandleInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExportMemoryWin32HandleInfoNV, pNext ) == offsetof( VkExportMemoryWin32HandleInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportMemoryWin32HandleInfoNV, pAttributes ) == offsetof( VkExportMemoryWin32HandleInfoNV, pAttributes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportMemoryWin32HandleInfoNV, dwAccess ) == offsetof( VkExportMemoryWin32HandleInfoNV, dwAccess ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_NV*/

#ifdef VK_USE_PLATFORM_WIN32_NV
  struct Win32KeyedMutexAcquireReleaseInfoNV
  {
    operator VkWin32KeyedMutexAcquireReleaseInfoNV const&() const
    {
      return *reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(this);
    }

    operator VkWin32KeyedMutexAcquireReleaseInfoNV &()
    {
      return *reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(this);
    }

    bool operator==( Win32KeyedMutexAcquireReleaseInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( acquireCount == rhs.acquireCount )
          && ( pAcquireSyncs == rhs.pAcquireSyncs )
          && ( pAcquireKeys == rhs.pAcquireKeys )
          && ( pAcquireTimeoutMilliseconds == rhs.pAcquireTimeoutMilliseconds )
          && ( releaseCount == rhs.releaseCount )
          && ( pReleaseSyncs == rhs.pReleaseSyncs )
          && ( pReleaseKeys == rhs.pReleaseKeys );
    }

    bool operator!=( Win32KeyedMutexAcquireReleaseInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eWin32KeyedMutexAcquireReleaseInfoNV;
    const void* pNext = nullptr;
    uint32_t acquireCount = 0;
    const DeviceMemory* pAcquireSyncs = nullptr;
    const uint64_t* pAcquireKeys = nullptr;
    const uint32_t* pAcquireTimeoutMilliseconds = nullptr;
    uint32_t releaseCount = 0;
    const DeviceMemory* pReleaseSyncs = nullptr;
    const uint64_t* pReleaseKeys = nullptr;
  };
  static_assert( sizeof( Win32KeyedMutexAcquireReleaseInfoNV ) == sizeof( VkWin32KeyedMutexAcquireReleaseInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoNV, pNext ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoNV, acquireCount ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoNV, acquireCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoNV, pAcquireSyncs ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoNV, pAcquireSyncs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoNV, pAcquireKeys ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoNV, pAcquireKeys ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoNV, pAcquireTimeoutMilliseconds ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoNV, pAcquireTimeoutMilliseconds ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoNV, releaseCount ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoNV, releaseCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoNV, pReleaseSyncs ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoNV, pReleaseSyncs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoNV, pReleaseKeys ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoNV, pReleaseKeys ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_NV*/

  struct DeviceGeneratedCommandsFeaturesNVX
  {
    operator VkDeviceGeneratedCommandsFeaturesNVX const&() const
    {
      return *reinterpret_cast<const VkDeviceGeneratedCommandsFeaturesNVX*>(this);
    }

    operator VkDeviceGeneratedCommandsFeaturesNVX &()
    {
      return *reinterpret_cast<VkDeviceGeneratedCommandsFeaturesNVX*>(this);
    }

    bool operator==( DeviceGeneratedCommandsFeaturesNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( computeBindingPointSupport == rhs.computeBindingPointSupport );
    }

    bool operator!=( DeviceGeneratedCommandsFeaturesNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGeneratedCommandsFeaturesNVX;
    const void* pNext = nullptr;
    Bool32 computeBindingPointSupport = 0;
  };
  static_assert( sizeof( DeviceGeneratedCommandsFeaturesNVX ) == sizeof( VkDeviceGeneratedCommandsFeaturesNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGeneratedCommandsFeaturesNVX, pNext ) == offsetof( VkDeviceGeneratedCommandsFeaturesNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGeneratedCommandsFeaturesNVX, computeBindingPointSupport ) == offsetof( VkDeviceGeneratedCommandsFeaturesNVX, computeBindingPointSupport ), "struct member and wrapper member have different offset!" );

  struct DeviceGeneratedCommandsLimitsNVX
  {
    operator VkDeviceGeneratedCommandsLimitsNVX const&() const
    {
      return *reinterpret_cast<const VkDeviceGeneratedCommandsLimitsNVX*>(this);
    }

    operator VkDeviceGeneratedCommandsLimitsNVX &()
    {
      return *reinterpret_cast<VkDeviceGeneratedCommandsLimitsNVX*>(this);
    }

    bool operator==( DeviceGeneratedCommandsLimitsNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxIndirectCommandsLayoutTokenCount == rhs.maxIndirectCommandsLayoutTokenCount )
          && ( maxObjectEntryCounts == rhs.maxObjectEntryCounts )
          && ( minSequenceCountBufferOffsetAlignment == rhs.minSequenceCountBufferOffsetAlignment )
          && ( minSequenceIndexBufferOffsetAlignment == rhs.minSequenceIndexBufferOffsetAlignment )
          && ( minCommandsTokenBufferOffsetAlignment == rhs.minCommandsTokenBufferOffsetAlignment );
    }

    bool operator!=( DeviceGeneratedCommandsLimitsNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGeneratedCommandsLimitsNVX;
    const void* pNext = nullptr;
    uint32_t maxIndirectCommandsLayoutTokenCount = 0;
    uint32_t maxObjectEntryCounts = 0;
    uint32_t minSequenceCountBufferOffsetAlignment = 0;
    uint32_t minSequenceIndexBufferOffsetAlignment = 0;
    uint32_t minCommandsTokenBufferOffsetAlignment = 0;
  };
  static_assert( sizeof( DeviceGeneratedCommandsLimitsNVX ) == sizeof( VkDeviceGeneratedCommandsLimitsNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGeneratedCommandsLimitsNVX, pNext ) == offsetof( VkDeviceGeneratedCommandsLimitsNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGeneratedCommandsLimitsNVX, maxIndirectCommandsLayoutTokenCount ) == offsetof( VkDeviceGeneratedCommandsLimitsNVX, maxIndirectCommandsLayoutTokenCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGeneratedCommandsLimitsNVX, maxObjectEntryCounts ) == offsetof( VkDeviceGeneratedCommandsLimitsNVX, maxObjectEntryCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGeneratedCommandsLimitsNVX, minSequenceCountBufferOffsetAlignment ) == offsetof( VkDeviceGeneratedCommandsLimitsNVX, minSequenceCountBufferOffsetAlignment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGeneratedCommandsLimitsNVX, minSequenceIndexBufferOffsetAlignment ) == offsetof( VkDeviceGeneratedCommandsLimitsNVX, minSequenceIndexBufferOffsetAlignment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGeneratedCommandsLimitsNVX, minCommandsTokenBufferOffsetAlignment ) == offsetof( VkDeviceGeneratedCommandsLimitsNVX, minCommandsTokenBufferOffsetAlignment ), "struct member and wrapper member have different offset!" );

  struct CmdReserveSpaceForCommandsInfoNVX
  {
    operator VkCmdReserveSpaceForCommandsInfoNVX const&() const
    {
      return *reinterpret_cast<const VkCmdReserveSpaceForCommandsInfoNVX*>(this);
    }

    operator VkCmdReserveSpaceForCommandsInfoNVX &()
    {
      return *reinterpret_cast<VkCmdReserveSpaceForCommandsInfoNVX*>(this);
    }

    bool operator==( CmdReserveSpaceForCommandsInfoNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( objectTable == rhs.objectTable )
          && ( indirectCommandsLayout == rhs.indirectCommandsLayout )
          && ( maxSequencesCount == rhs.maxSequencesCount );
    }

    bool operator!=( CmdReserveSpaceForCommandsInfoNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eCmdReserveSpaceForCommandsInfoNVX;
    const void* pNext = nullptr;
    ObjectTableNVX objectTable = ObjectTableNVX();
    IndirectCommandsLayoutNVX indirectCommandsLayout = IndirectCommandsLayoutNVX();
    uint32_t maxSequencesCount = 0;
  };
  static_assert( sizeof( CmdReserveSpaceForCommandsInfoNVX ) == sizeof( VkCmdReserveSpaceForCommandsInfoNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( CmdReserveSpaceForCommandsInfoNVX, pNext ) == offsetof( VkCmdReserveSpaceForCommandsInfoNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdReserveSpaceForCommandsInfoNVX, objectTable ) == offsetof( VkCmdReserveSpaceForCommandsInfoNVX, objectTable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdReserveSpaceForCommandsInfoNVX, indirectCommandsLayout ) == offsetof( VkCmdReserveSpaceForCommandsInfoNVX, indirectCommandsLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdReserveSpaceForCommandsInfoNVX, maxSequencesCount ) == offsetof( VkCmdReserveSpaceForCommandsInfoNVX, maxSequencesCount ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceFeatures2
  {
    operator VkPhysicalDeviceFeatures2 const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceFeatures2*>(this);
    }

    operator VkPhysicalDeviceFeatures2 &()
    {
      return *reinterpret_cast<VkPhysicalDeviceFeatures2*>(this);
    }

    bool operator==( PhysicalDeviceFeatures2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( features == rhs.features );
    }

    bool operator!=( PhysicalDeviceFeatures2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceFeatures2;
    void* pNext = nullptr;
    PhysicalDeviceFeatures features = PhysicalDeviceFeatures();
  };
  static_assert( sizeof( PhysicalDeviceFeatures2 ) == sizeof( VkPhysicalDeviceFeatures2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceFeatures2, pNext ) == offsetof( VkPhysicalDeviceFeatures2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFeatures2, features ) == offsetof( VkPhysicalDeviceFeatures2, features ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;

  struct PhysicalDevicePushDescriptorPropertiesKHR
  {
    operator VkPhysicalDevicePushDescriptorPropertiesKHR const&() const
    {
      return *reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(this);
    }

    operator VkPhysicalDevicePushDescriptorPropertiesKHR &()
    {
      return *reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(this);
    }

    bool operator==( PhysicalDevicePushDescriptorPropertiesKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxPushDescriptors == rhs.maxPushDescriptors );
    }

    bool operator!=( PhysicalDevicePushDescriptorPropertiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDevicePushDescriptorPropertiesKHR;
    void* pNext = nullptr;
    uint32_t maxPushDescriptors = 0;
  };
  static_assert( sizeof( PhysicalDevicePushDescriptorPropertiesKHR ) == sizeof( VkPhysicalDevicePushDescriptorPropertiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDevicePushDescriptorPropertiesKHR, pNext ) == offsetof( VkPhysicalDevicePushDescriptorPropertiesKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDevicePushDescriptorPropertiesKHR, maxPushDescriptors ) == offsetof( VkPhysicalDevicePushDescriptorPropertiesKHR, maxPushDescriptors ), "struct member and wrapper member have different offset!" );

  struct PresentRegionsKHR
  {
    operator VkPresentRegionsKHR const&() const
    {
      return *reinterpret_cast<const VkPresentRegionsKHR*>(this);
    }

    operator VkPresentRegionsKHR &()
    {
      return *reinterpret_cast<VkPresentRegionsKHR*>(this);
    }

    bool operator==( PresentRegionsKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( swapchainCount == rhs.swapchainCount )
          && ( pRegions == rhs.pRegions );
    }

    bool operator!=( PresentRegionsKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePresentRegionsKHR;
    const void* pNext = nullptr;
    uint32_t swapchainCount = 0;
    const PresentRegionKHR* pRegions = nullptr;
  };
  static_assert( sizeof( PresentRegionsKHR ) == sizeof( VkPresentRegionsKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( PresentRegionsKHR, pNext ) == offsetof( VkPresentRegionsKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentRegionsKHR, swapchainCount ) == offsetof( VkPresentRegionsKHR, swapchainCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentRegionsKHR, pRegions ) == offsetof( VkPresentRegionsKHR, pRegions ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceVariablePointerFeatures
  {
    operator VkPhysicalDeviceVariablePointerFeatures const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceVariablePointerFeatures*>(this);
    }

    operator VkPhysicalDeviceVariablePointerFeatures &()
    {
      return *reinterpret_cast<VkPhysicalDeviceVariablePointerFeatures*>(this);
    }

    bool operator==( PhysicalDeviceVariablePointerFeatures const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( variablePointersStorageBuffer == rhs.variablePointersStorageBuffer )
          && ( variablePointers == rhs.variablePointers );
    }

    bool operator!=( PhysicalDeviceVariablePointerFeatures const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceVariablePointerFeatures;
    void* pNext = nullptr;
    Bool32 variablePointersStorageBuffer = 0;
    Bool32 variablePointers = 0;
  };
  static_assert( sizeof( PhysicalDeviceVariablePointerFeatures ) == sizeof( VkPhysicalDeviceVariablePointerFeatures ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceVariablePointerFeatures, pNext ) == offsetof( VkPhysicalDeviceVariablePointerFeatures, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceVariablePointerFeatures, variablePointersStorageBuffer ) == offsetof( VkPhysicalDeviceVariablePointerFeatures, variablePointersStorageBuffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceVariablePointerFeatures, variablePointers ) == offsetof( VkPhysicalDeviceVariablePointerFeatures, variablePointers ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceVariablePointerFeaturesKHR = PhysicalDeviceVariablePointerFeatures;

  struct PhysicalDeviceIDProperties
  {
    operator VkPhysicalDeviceIDProperties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceIDProperties*>(this);
    }

    operator VkPhysicalDeviceIDProperties &()
    {
      return *reinterpret_cast<VkPhysicalDeviceIDProperties*>(this);
    }

    bool operator==( PhysicalDeviceIDProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( deviceUUID == rhs.deviceUUID )
          && ( driverUUID == rhs.driverUUID )
          && ( deviceLUID == rhs.deviceLUID )
          && ( deviceNodeMask == rhs.deviceNodeMask )
          && ( deviceLUIDValid == rhs.deviceLUIDValid );
    }

    bool operator!=( PhysicalDeviceIDProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceIdProperties;
    void* pNext = nullptr;
    std::array<uint8_t, VK_UUID_SIZE> deviceUUID = { { 0 } };
    std::array<uint8_t, VK_UUID_SIZE> driverUUID = { { 0 } };
    std::array<uint8_t, VK_LUID_SIZE> deviceLUID = { { 0 } };
    uint32_t deviceNodeMask = 0;
    Bool32 deviceLUIDValid = 0;
  };
  static_assert( sizeof( PhysicalDeviceIDProperties ) == sizeof( VkPhysicalDeviceIDProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceIDProperties, pNext ) == offsetof( VkPhysicalDeviceIDProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceIDProperties, deviceUUID ) == offsetof( VkPhysicalDeviceIDProperties, deviceUUID ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceIDProperties, driverUUID ) == offsetof( VkPhysicalDeviceIDProperties, driverUUID ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceIDProperties, deviceLUID ) == offsetof( VkPhysicalDeviceIDProperties, deviceLUID ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceIDProperties, deviceNodeMask ) == offsetof( VkPhysicalDeviceIDProperties, deviceNodeMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceIDProperties, deviceLUIDValid ) == offsetof( VkPhysicalDeviceIDProperties, deviceLUIDValid ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct ExportMemoryWin32HandleInfoKHR
  {
    operator VkExportMemoryWin32HandleInfoKHR const&() const
    {
      return *reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(this);
    }

    operator VkExportMemoryWin32HandleInfoKHR &()
    {
      return *reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(this);
    }

    bool operator==( ExportMemoryWin32HandleInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( pAttributes == rhs.pAttributes )
          && ( dwAccess == rhs.dwAccess )
          && ( name == rhs.name );
    }

    bool operator!=( ExportMemoryWin32HandleInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExportMemoryWin32HandleInfoKHR;
    const void* pNext = nullptr;
    const SECURITY_ATTRIBUTES* pAttributes = nullptr;
    DWORD dwAccess = 0;
    LPCWSTR name = 0;
  };
  static_assert( sizeof( ExportMemoryWin32HandleInfoKHR ) == sizeof( VkExportMemoryWin32HandleInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExportMemoryWin32HandleInfoKHR, pNext ) == offsetof( VkExportMemoryWin32HandleInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportMemoryWin32HandleInfoKHR, pAttributes ) == offsetof( VkExportMemoryWin32HandleInfoKHR, pAttributes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportMemoryWin32HandleInfoKHR, dwAccess ) == offsetof( VkExportMemoryWin32HandleInfoKHR, dwAccess ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportMemoryWin32HandleInfoKHR, name ) == offsetof( VkExportMemoryWin32HandleInfoKHR, name ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct MemoryWin32HandlePropertiesKHR
  {
    operator VkMemoryWin32HandlePropertiesKHR const&() const
    {
      return *reinterpret_cast<const VkMemoryWin32HandlePropertiesKHR*>(this);
    }

    operator VkMemoryWin32HandlePropertiesKHR &()
    {
      return *reinterpret_cast<VkMemoryWin32HandlePropertiesKHR*>(this);
    }

    bool operator==( MemoryWin32HandlePropertiesKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( MemoryWin32HandlePropertiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryWin32HandlePropertiesKHR;
    void* pNext = nullptr;
    uint32_t memoryTypeBits = 0;
  };
  static_assert( sizeof( MemoryWin32HandlePropertiesKHR ) == sizeof( VkMemoryWin32HandlePropertiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryWin32HandlePropertiesKHR, pNext ) == offsetof( VkMemoryWin32HandlePropertiesKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryWin32HandlePropertiesKHR, memoryTypeBits ) == offsetof( VkMemoryWin32HandlePropertiesKHR, memoryTypeBits ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct MemoryFdPropertiesKHR
  {
    operator VkMemoryFdPropertiesKHR const&() const
    {
      return *reinterpret_cast<const VkMemoryFdPropertiesKHR*>(this);
    }

    operator VkMemoryFdPropertiesKHR &()
    {
      return *reinterpret_cast<VkMemoryFdPropertiesKHR*>(this);
    }

    bool operator==( MemoryFdPropertiesKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( MemoryFdPropertiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryFdPropertiesKHR;
    void* pNext = nullptr;
    uint32_t memoryTypeBits = 0;
  };
  static_assert( sizeof( MemoryFdPropertiesKHR ) == sizeof( VkMemoryFdPropertiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryFdPropertiesKHR, pNext ) == offsetof( VkMemoryFdPropertiesKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryFdPropertiesKHR, memoryTypeBits ) == offsetof( VkMemoryFdPropertiesKHR, memoryTypeBits ), "struct member and wrapper member have different offset!" );

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct Win32KeyedMutexAcquireReleaseInfoKHR
  {
    operator VkWin32KeyedMutexAcquireReleaseInfoKHR const&() const
    {
      return *reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(this);
    }

    operator VkWin32KeyedMutexAcquireReleaseInfoKHR &()
    {
      return *reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(this);
    }

    bool operator==( Win32KeyedMutexAcquireReleaseInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( acquireCount == rhs.acquireCount )
          && ( pAcquireSyncs == rhs.pAcquireSyncs )
          && ( pAcquireKeys == rhs.pAcquireKeys )
          && ( pAcquireTimeouts == rhs.pAcquireTimeouts )
          && ( releaseCount == rhs.releaseCount )
          && ( pReleaseSyncs == rhs.pReleaseSyncs )
          && ( pReleaseKeys == rhs.pReleaseKeys );
    }

    bool operator!=( Win32KeyedMutexAcquireReleaseInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eWin32KeyedMutexAcquireReleaseInfoKHR;
    const void* pNext = nullptr;
    uint32_t acquireCount = 0;
    const DeviceMemory* pAcquireSyncs = nullptr;
    const uint64_t* pAcquireKeys = nullptr;
    const uint32_t* pAcquireTimeouts = nullptr;
    uint32_t releaseCount = 0;
    const DeviceMemory* pReleaseSyncs = nullptr;
    const uint64_t* pReleaseKeys = nullptr;
  };
  static_assert( sizeof( Win32KeyedMutexAcquireReleaseInfoKHR ) == sizeof( VkWin32KeyedMutexAcquireReleaseInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoKHR, pNext ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoKHR, acquireCount ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoKHR, acquireCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoKHR, pAcquireSyncs ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoKHR, pAcquireSyncs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoKHR, pAcquireKeys ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoKHR, pAcquireKeys ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoKHR, pAcquireTimeouts ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoKHR, pAcquireTimeouts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoKHR, releaseCount ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoKHR, releaseCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoKHR, pReleaseSyncs ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoKHR, pReleaseSyncs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( Win32KeyedMutexAcquireReleaseInfoKHR, pReleaseKeys ) == offsetof( VkWin32KeyedMutexAcquireReleaseInfoKHR, pReleaseKeys ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct ExportSemaphoreWin32HandleInfoKHR
  {
    operator VkExportSemaphoreWin32HandleInfoKHR const&() const
    {
      return *reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(this);
    }

    operator VkExportSemaphoreWin32HandleInfoKHR &()
    {
      return *reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(this);
    }

    bool operator==( ExportSemaphoreWin32HandleInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( pAttributes == rhs.pAttributes )
          && ( dwAccess == rhs.dwAccess )
          && ( name == rhs.name );
    }

    bool operator!=( ExportSemaphoreWin32HandleInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExportSemaphoreWin32HandleInfoKHR;
    const void* pNext = nullptr;
    const SECURITY_ATTRIBUTES* pAttributes = nullptr;
    DWORD dwAccess = 0;
    LPCWSTR name = 0;
  };
  static_assert( sizeof( ExportSemaphoreWin32HandleInfoKHR ) == sizeof( VkExportSemaphoreWin32HandleInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExportSemaphoreWin32HandleInfoKHR, pNext ) == offsetof( VkExportSemaphoreWin32HandleInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportSemaphoreWin32HandleInfoKHR, pAttributes ) == offsetof( VkExportSemaphoreWin32HandleInfoKHR, pAttributes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportSemaphoreWin32HandleInfoKHR, dwAccess ) == offsetof( VkExportSemaphoreWin32HandleInfoKHR, dwAccess ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportSemaphoreWin32HandleInfoKHR, name ) == offsetof( VkExportSemaphoreWin32HandleInfoKHR, name ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct D3D12FenceSubmitInfoKHR
  {
    operator VkD3D12FenceSubmitInfoKHR const&() const
    {
      return *reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(this);
    }

    operator VkD3D12FenceSubmitInfoKHR &()
    {
      return *reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(this);
    }

    bool operator==( D3D12FenceSubmitInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( waitSemaphoreValuesCount == rhs.waitSemaphoreValuesCount )
          && ( pWaitSemaphoreValues == rhs.pWaitSemaphoreValues )
          && ( signalSemaphoreValuesCount == rhs.signalSemaphoreValuesCount )
          && ( pSignalSemaphoreValues == rhs.pSignalSemaphoreValues );
    }

    bool operator!=( D3D12FenceSubmitInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eD3D12FenceSubmitInfoKHR;
    const void* pNext = nullptr;
    uint32_t waitSemaphoreValuesCount = 0;
    const uint64_t* pWaitSemaphoreValues = nullptr;
    uint32_t signalSemaphoreValuesCount = 0;
    const uint64_t* pSignalSemaphoreValues = nullptr;
  };
  static_assert( sizeof( D3D12FenceSubmitInfoKHR ) == sizeof( VkD3D12FenceSubmitInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( D3D12FenceSubmitInfoKHR, pNext ) == offsetof( VkD3D12FenceSubmitInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( D3D12FenceSubmitInfoKHR, waitSemaphoreValuesCount ) == offsetof( VkD3D12FenceSubmitInfoKHR, waitSemaphoreValuesCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( D3D12FenceSubmitInfoKHR, pWaitSemaphoreValues ) == offsetof( VkD3D12FenceSubmitInfoKHR, pWaitSemaphoreValues ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( D3D12FenceSubmitInfoKHR, signalSemaphoreValuesCount ) == offsetof( VkD3D12FenceSubmitInfoKHR, signalSemaphoreValuesCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( D3D12FenceSubmitInfoKHR, pSignalSemaphoreValues ) == offsetof( VkD3D12FenceSubmitInfoKHR, pSignalSemaphoreValues ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct ExportFenceWin32HandleInfoKHR
  {
    operator VkExportFenceWin32HandleInfoKHR const&() const
    {
      return *reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(this);
    }

    operator VkExportFenceWin32HandleInfoKHR &()
    {
      return *reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(this);
    }

    bool operator==( ExportFenceWin32HandleInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( pAttributes == rhs.pAttributes )
          && ( dwAccess == rhs.dwAccess )
          && ( name == rhs.name );
    }

    bool operator!=( ExportFenceWin32HandleInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExportFenceWin32HandleInfoKHR;
    const void* pNext = nullptr;
    const SECURITY_ATTRIBUTES* pAttributes = nullptr;
    DWORD dwAccess = 0;
    LPCWSTR name = 0;
  };
  static_assert( sizeof( ExportFenceWin32HandleInfoKHR ) == sizeof( VkExportFenceWin32HandleInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExportFenceWin32HandleInfoKHR, pNext ) == offsetof( VkExportFenceWin32HandleInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportFenceWin32HandleInfoKHR, pAttributes ) == offsetof( VkExportFenceWin32HandleInfoKHR, pAttributes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportFenceWin32HandleInfoKHR, dwAccess ) == offsetof( VkExportFenceWin32HandleInfoKHR, dwAccess ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportFenceWin32HandleInfoKHR, name ) == offsetof( VkExportFenceWin32HandleInfoKHR, name ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct PhysicalDeviceMultiviewFeatures
  {
    operator VkPhysicalDeviceMultiviewFeatures const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(this);
    }

    operator VkPhysicalDeviceMultiviewFeatures &()
    {
      return *reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(this);
    }

    bool operator==( PhysicalDeviceMultiviewFeatures const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( multiview == rhs.multiview )
          && ( multiviewGeometryShader == rhs.multiviewGeometryShader )
          && ( multiviewTessellationShader == rhs.multiviewTessellationShader );
    }

    bool operator!=( PhysicalDeviceMultiviewFeatures const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceMultiviewFeatures;
    void* pNext = nullptr;
    Bool32 multiview = 0;
    Bool32 multiviewGeometryShader = 0;
    Bool32 multiviewTessellationShader = 0;
  };
  static_assert( sizeof( PhysicalDeviceMultiviewFeatures ) == sizeof( VkPhysicalDeviceMultiviewFeatures ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceMultiviewFeatures, pNext ) == offsetof( VkPhysicalDeviceMultiviewFeatures, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMultiviewFeatures, multiview ) == offsetof( VkPhysicalDeviceMultiviewFeatures, multiview ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMultiviewFeatures, multiviewGeometryShader ) == offsetof( VkPhysicalDeviceMultiviewFeatures, multiviewGeometryShader ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMultiviewFeatures, multiviewTessellationShader ) == offsetof( VkPhysicalDeviceMultiviewFeatures, multiviewTessellationShader ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;

  struct PhysicalDeviceMultiviewProperties
  {
    operator VkPhysicalDeviceMultiviewProperties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(this);
    }

    operator VkPhysicalDeviceMultiviewProperties &()
    {
      return *reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(this);
    }

    bool operator==( PhysicalDeviceMultiviewProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxMultiviewViewCount == rhs.maxMultiviewViewCount )
          && ( maxMultiviewInstanceIndex == rhs.maxMultiviewInstanceIndex );
    }

    bool operator!=( PhysicalDeviceMultiviewProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceMultiviewProperties;
    void* pNext = nullptr;
    uint32_t maxMultiviewViewCount = 0;
    uint32_t maxMultiviewInstanceIndex = 0;
  };
  static_assert( sizeof( PhysicalDeviceMultiviewProperties ) == sizeof( VkPhysicalDeviceMultiviewProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceMultiviewProperties, pNext ) == offsetof( VkPhysicalDeviceMultiviewProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMultiviewProperties, maxMultiviewViewCount ) == offsetof( VkPhysicalDeviceMultiviewProperties, maxMultiviewViewCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMultiviewProperties, maxMultiviewInstanceIndex ) == offsetof( VkPhysicalDeviceMultiviewProperties, maxMultiviewInstanceIndex ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;

  struct RenderPassMultiviewCreateInfo
  {
    operator VkRenderPassMultiviewCreateInfo const&() const
    {
      return *reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(this);
    }

    operator VkRenderPassMultiviewCreateInfo &()
    {
      return *reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(this);
    }

    bool operator==( RenderPassMultiviewCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( subpassCount == rhs.subpassCount )
          && ( pViewMasks == rhs.pViewMasks )
          && ( dependencyCount == rhs.dependencyCount )
          && ( pViewOffsets == rhs.pViewOffsets )
          && ( correlationMaskCount == rhs.correlationMaskCount )
          && ( pCorrelationMasks == rhs.pCorrelationMasks );
    }

    bool operator!=( RenderPassMultiviewCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eRenderPassMultiviewCreateInfo;
    const void* pNext = nullptr;
    uint32_t subpassCount = 0;
    const uint32_t* pViewMasks = nullptr;
    uint32_t dependencyCount = 0;
    const int32_t* pViewOffsets = nullptr;
    uint32_t correlationMaskCount = 0;
    const uint32_t* pCorrelationMasks = nullptr;
  };
  static_assert( sizeof( RenderPassMultiviewCreateInfo ) == sizeof( VkRenderPassMultiviewCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( RenderPassMultiviewCreateInfo, pNext ) == offsetof( VkRenderPassMultiviewCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassMultiviewCreateInfo, subpassCount ) == offsetof( VkRenderPassMultiviewCreateInfo, subpassCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassMultiviewCreateInfo, pViewMasks ) == offsetof( VkRenderPassMultiviewCreateInfo, pViewMasks ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassMultiviewCreateInfo, dependencyCount ) == offsetof( VkRenderPassMultiviewCreateInfo, dependencyCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassMultiviewCreateInfo, pViewOffsets ) == offsetof( VkRenderPassMultiviewCreateInfo, pViewOffsets ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassMultiviewCreateInfo, correlationMaskCount ) == offsetof( VkRenderPassMultiviewCreateInfo, correlationMaskCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassMultiviewCreateInfo, pCorrelationMasks ) == offsetof( VkRenderPassMultiviewCreateInfo, pCorrelationMasks ), "struct member and wrapper member have different offset!" );

  using RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;

  struct BindBufferMemoryInfo
  {
    operator VkBindBufferMemoryInfo const&() const
    {
      return *reinterpret_cast<const VkBindBufferMemoryInfo*>(this);
    }

    operator VkBindBufferMemoryInfo &()
    {
      return *reinterpret_cast<VkBindBufferMemoryInfo*>(this);
    }

    bool operator==( BindBufferMemoryInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( buffer == rhs.buffer )
          && ( memory == rhs.memory )
          && ( memoryOffset == rhs.memoryOffset );
    }

    bool operator!=( BindBufferMemoryInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBindBufferMemoryInfo;
    const void* pNext = nullptr;
    Buffer buffer = Buffer();
    DeviceMemory memory = DeviceMemory();
    DeviceSize memoryOffset = 0;
  };
  static_assert( sizeof( BindBufferMemoryInfo ) == sizeof( VkBindBufferMemoryInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( BindBufferMemoryInfo, pNext ) == offsetof( VkBindBufferMemoryInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindBufferMemoryInfo, buffer ) == offsetof( VkBindBufferMemoryInfo, buffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindBufferMemoryInfo, memory ) == offsetof( VkBindBufferMemoryInfo, memory ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindBufferMemoryInfo, memoryOffset ) == offsetof( VkBindBufferMemoryInfo, memoryOffset ), "struct member and wrapper member have different offset!" );

  using BindBufferMemoryInfoKHR = BindBufferMemoryInfo;

  struct BindBufferMemoryDeviceGroupInfo
  {
    operator VkBindBufferMemoryDeviceGroupInfo const&() const
    {
      return *reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(this);
    }

    operator VkBindBufferMemoryDeviceGroupInfo &()
    {
      return *reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(this);
    }

    bool operator==( BindBufferMemoryDeviceGroupInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( deviceIndexCount == rhs.deviceIndexCount )
          && ( pDeviceIndices == rhs.pDeviceIndices );
    }

    bool operator!=( BindBufferMemoryDeviceGroupInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBindBufferMemoryDeviceGroupInfo;
    const void* pNext = nullptr;
    uint32_t deviceIndexCount = 0;
    const uint32_t* pDeviceIndices = nullptr;
  };
  static_assert( sizeof( BindBufferMemoryDeviceGroupInfo ) == sizeof( VkBindBufferMemoryDeviceGroupInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( BindBufferMemoryDeviceGroupInfo, pNext ) == offsetof( VkBindBufferMemoryDeviceGroupInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindBufferMemoryDeviceGroupInfo, deviceIndexCount ) == offsetof( VkBindBufferMemoryDeviceGroupInfo, deviceIndexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindBufferMemoryDeviceGroupInfo, pDeviceIndices ) == offsetof( VkBindBufferMemoryDeviceGroupInfo, pDeviceIndices ), "struct member and wrapper member have different offset!" );

  using BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;

  struct BindImageMemoryInfo
  {
    operator VkBindImageMemoryInfo const&() const
    {
      return *reinterpret_cast<const VkBindImageMemoryInfo*>(this);
    }

    operator VkBindImageMemoryInfo &()
    {
      return *reinterpret_cast<VkBindImageMemoryInfo*>(this);
    }

    bool operator==( BindImageMemoryInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( image == rhs.image )
          && ( memory == rhs.memory )
          && ( memoryOffset == rhs.memoryOffset );
    }

    bool operator!=( BindImageMemoryInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBindImageMemoryInfo;
    const void* pNext = nullptr;
    Image image = Image();
    DeviceMemory memory = DeviceMemory();
    DeviceSize memoryOffset = 0;
  };
  static_assert( sizeof( BindImageMemoryInfo ) == sizeof( VkBindImageMemoryInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( BindImageMemoryInfo, pNext ) == offsetof( VkBindImageMemoryInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImageMemoryInfo, image ) == offsetof( VkBindImageMemoryInfo, image ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImageMemoryInfo, memory ) == offsetof( VkBindImageMemoryInfo, memory ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImageMemoryInfo, memoryOffset ) == offsetof( VkBindImageMemoryInfo, memoryOffset ), "struct member and wrapper member have different offset!" );

  using BindImageMemoryInfoKHR = BindImageMemoryInfo;

  struct BindImageMemoryDeviceGroupInfo
  {
    operator VkBindImageMemoryDeviceGroupInfo const&() const
    {
      return *reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(this);
    }

    operator VkBindImageMemoryDeviceGroupInfo &()
    {
      return *reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(this);
    }

    bool operator==( BindImageMemoryDeviceGroupInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( deviceIndexCount == rhs.deviceIndexCount )
          && ( pDeviceIndices == rhs.pDeviceIndices )
          && ( splitInstanceBindRegionCount == rhs.splitInstanceBindRegionCount )
          && ( pSplitInstanceBindRegions == rhs.pSplitInstanceBindRegions );
    }

    bool operator!=( BindImageMemoryDeviceGroupInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBindImageMemoryDeviceGroupInfo;
    const void* pNext = nullptr;
    uint32_t deviceIndexCount = 0;
    const uint32_t* pDeviceIndices = nullptr;
    uint32_t splitInstanceBindRegionCount = 0;
    const Rect2D* pSplitInstanceBindRegions = nullptr;
  };
  static_assert( sizeof( BindImageMemoryDeviceGroupInfo ) == sizeof( VkBindImageMemoryDeviceGroupInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( BindImageMemoryDeviceGroupInfo, pNext ) == offsetof( VkBindImageMemoryDeviceGroupInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImageMemoryDeviceGroupInfo, deviceIndexCount ) == offsetof( VkBindImageMemoryDeviceGroupInfo, deviceIndexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImageMemoryDeviceGroupInfo, pDeviceIndices ) == offsetof( VkBindImageMemoryDeviceGroupInfo, pDeviceIndices ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImageMemoryDeviceGroupInfo, splitInstanceBindRegionCount ) == offsetof( VkBindImageMemoryDeviceGroupInfo, splitInstanceBindRegionCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImageMemoryDeviceGroupInfo, pSplitInstanceBindRegions ) == offsetof( VkBindImageMemoryDeviceGroupInfo, pSplitInstanceBindRegions ), "struct member and wrapper member have different offset!" );

  using BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;

  struct DeviceGroupRenderPassBeginInfo
  {
    operator VkDeviceGroupRenderPassBeginInfo const&() const
    {
      return *reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(this);
    }

    operator VkDeviceGroupRenderPassBeginInfo &()
    {
      return *reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(this);
    }

    bool operator==( DeviceGroupRenderPassBeginInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( deviceMask == rhs.deviceMask )
          && ( deviceRenderAreaCount == rhs.deviceRenderAreaCount )
          && ( pDeviceRenderAreas == rhs.pDeviceRenderAreas );
    }

    bool operator!=( DeviceGroupRenderPassBeginInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGroupRenderPassBeginInfo;
    const void* pNext = nullptr;
    uint32_t deviceMask = 0;
    uint32_t deviceRenderAreaCount = 0;
    const Rect2D* pDeviceRenderAreas = nullptr;
  };
  static_assert( sizeof( DeviceGroupRenderPassBeginInfo ) == sizeof( VkDeviceGroupRenderPassBeginInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGroupRenderPassBeginInfo, pNext ) == offsetof( VkDeviceGroupRenderPassBeginInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupRenderPassBeginInfo, deviceMask ) == offsetof( VkDeviceGroupRenderPassBeginInfo, deviceMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupRenderPassBeginInfo, deviceRenderAreaCount ) == offsetof( VkDeviceGroupRenderPassBeginInfo, deviceRenderAreaCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupRenderPassBeginInfo, pDeviceRenderAreas ) == offsetof( VkDeviceGroupRenderPassBeginInfo, pDeviceRenderAreas ), "struct member and wrapper member have different offset!" );

  using DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;

  struct DeviceGroupCommandBufferBeginInfo
  {
    operator VkDeviceGroupCommandBufferBeginInfo const&() const
    {
      return *reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(this);
    }

    operator VkDeviceGroupCommandBufferBeginInfo &()
    {
      return *reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(this);
    }

    bool operator==( DeviceGroupCommandBufferBeginInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( deviceMask == rhs.deviceMask );
    }

    bool operator!=( DeviceGroupCommandBufferBeginInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGroupCommandBufferBeginInfo;
    const void* pNext = nullptr;
    uint32_t deviceMask = 0;
  };
  static_assert( sizeof( DeviceGroupCommandBufferBeginInfo ) == sizeof( VkDeviceGroupCommandBufferBeginInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGroupCommandBufferBeginInfo, pNext ) == offsetof( VkDeviceGroupCommandBufferBeginInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupCommandBufferBeginInfo, deviceMask ) == offsetof( VkDeviceGroupCommandBufferBeginInfo, deviceMask ), "struct member and wrapper member have different offset!" );

  using DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;

  struct DeviceGroupSubmitInfo
  {
    operator VkDeviceGroupSubmitInfo const&() const
    {
      return *reinterpret_cast<const VkDeviceGroupSubmitInfo*>(this);
    }

    operator VkDeviceGroupSubmitInfo &()
    {
      return *reinterpret_cast<VkDeviceGroupSubmitInfo*>(this);
    }

    bool operator==( DeviceGroupSubmitInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( waitSemaphoreCount == rhs.waitSemaphoreCount )
          && ( pWaitSemaphoreDeviceIndices == rhs.pWaitSemaphoreDeviceIndices )
          && ( commandBufferCount == rhs.commandBufferCount )
          && ( pCommandBufferDeviceMasks == rhs.pCommandBufferDeviceMasks )
          && ( signalSemaphoreCount == rhs.signalSemaphoreCount )
          && ( pSignalSemaphoreDeviceIndices == rhs.pSignalSemaphoreDeviceIndices );
    }

    bool operator!=( DeviceGroupSubmitInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGroupSubmitInfo;
    const void* pNext = nullptr;
    uint32_t waitSemaphoreCount = 0;
    const uint32_t* pWaitSemaphoreDeviceIndices = nullptr;
    uint32_t commandBufferCount = 0;
    const uint32_t* pCommandBufferDeviceMasks = nullptr;
    uint32_t signalSemaphoreCount = 0;
    const uint32_t* pSignalSemaphoreDeviceIndices = nullptr;
  };
  static_assert( sizeof( DeviceGroupSubmitInfo ) == sizeof( VkDeviceGroupSubmitInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGroupSubmitInfo, pNext ) == offsetof( VkDeviceGroupSubmitInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupSubmitInfo, waitSemaphoreCount ) == offsetof( VkDeviceGroupSubmitInfo, waitSemaphoreCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupSubmitInfo, pWaitSemaphoreDeviceIndices ) == offsetof( VkDeviceGroupSubmitInfo, pWaitSemaphoreDeviceIndices ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupSubmitInfo, commandBufferCount ) == offsetof( VkDeviceGroupSubmitInfo, commandBufferCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupSubmitInfo, pCommandBufferDeviceMasks ) == offsetof( VkDeviceGroupSubmitInfo, pCommandBufferDeviceMasks ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupSubmitInfo, signalSemaphoreCount ) == offsetof( VkDeviceGroupSubmitInfo, signalSemaphoreCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupSubmitInfo, pSignalSemaphoreDeviceIndices ) == offsetof( VkDeviceGroupSubmitInfo, pSignalSemaphoreDeviceIndices ), "struct member and wrapper member have different offset!" );

  using DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;

  struct DeviceGroupBindSparseInfo
  {
    operator VkDeviceGroupBindSparseInfo const&() const
    {
      return *reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(this);
    }

    operator VkDeviceGroupBindSparseInfo &()
    {
      return *reinterpret_cast<VkDeviceGroupBindSparseInfo*>(this);
    }

    bool operator==( DeviceGroupBindSparseInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( resourceDeviceIndex == rhs.resourceDeviceIndex )
          && ( memoryDeviceIndex == rhs.memoryDeviceIndex );
    }

    bool operator!=( DeviceGroupBindSparseInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGroupBindSparseInfo;
    const void* pNext = nullptr;
    uint32_t resourceDeviceIndex = 0;
    uint32_t memoryDeviceIndex = 0;
  };
  static_assert( sizeof( DeviceGroupBindSparseInfo ) == sizeof( VkDeviceGroupBindSparseInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGroupBindSparseInfo, pNext ) == offsetof( VkDeviceGroupBindSparseInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupBindSparseInfo, resourceDeviceIndex ) == offsetof( VkDeviceGroupBindSparseInfo, resourceDeviceIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupBindSparseInfo, memoryDeviceIndex ) == offsetof( VkDeviceGroupBindSparseInfo, memoryDeviceIndex ), "struct member and wrapper member have different offset!" );

  using DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;

  struct ImageSwapchainCreateInfoKHR
  {
    operator VkImageSwapchainCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(this);
    }

    operator VkImageSwapchainCreateInfoKHR &()
    {
      return *reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(this);
    }

    bool operator==( ImageSwapchainCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( swapchain == rhs.swapchain );
    }

    bool operator!=( ImageSwapchainCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageSwapchainCreateInfoKHR;
    const void* pNext = nullptr;
    SwapchainKHR swapchain = SwapchainKHR();
  };
  static_assert( sizeof( ImageSwapchainCreateInfoKHR ) == sizeof( VkImageSwapchainCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageSwapchainCreateInfoKHR, pNext ) == offsetof( VkImageSwapchainCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSwapchainCreateInfoKHR, swapchain ) == offsetof( VkImageSwapchainCreateInfoKHR, swapchain ), "struct member and wrapper member have different offset!" );

  struct BindImageMemorySwapchainInfoKHR
  {
    operator VkBindImageMemorySwapchainInfoKHR const&() const
    {
      return *reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(this);
    }

    operator VkBindImageMemorySwapchainInfoKHR &()
    {
      return *reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(this);
    }

    bool operator==( BindImageMemorySwapchainInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( swapchain == rhs.swapchain )
          && ( imageIndex == rhs.imageIndex );
    }

    bool operator!=( BindImageMemorySwapchainInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBindImageMemorySwapchainInfoKHR;
    const void* pNext = nullptr;
    SwapchainKHR swapchain = SwapchainKHR();
    uint32_t imageIndex = 0;
  };
  static_assert( sizeof( BindImageMemorySwapchainInfoKHR ) == sizeof( VkBindImageMemorySwapchainInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( BindImageMemorySwapchainInfoKHR, pNext ) == offsetof( VkBindImageMemorySwapchainInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImageMemorySwapchainInfoKHR, swapchain ) == offsetof( VkBindImageMemorySwapchainInfoKHR, swapchain ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImageMemorySwapchainInfoKHR, imageIndex ) == offsetof( VkBindImageMemorySwapchainInfoKHR, imageIndex ), "struct member and wrapper member have different offset!" );

  struct AcquireNextImageInfoKHR
  {
    operator VkAcquireNextImageInfoKHR const&() const
    {
      return *reinterpret_cast<const VkAcquireNextImageInfoKHR*>(this);
    }

    operator VkAcquireNextImageInfoKHR &()
    {
      return *reinterpret_cast<VkAcquireNextImageInfoKHR*>(this);
    }

    bool operator==( AcquireNextImageInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( swapchain == rhs.swapchain )
          && ( timeout == rhs.timeout )
          && ( semaphore == rhs.semaphore )
          && ( fence == rhs.fence )
          && ( deviceMask == rhs.deviceMask );
    }

    bool operator!=( AcquireNextImageInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eAcquireNextImageInfoKHR;
    const void* pNext = nullptr;
    SwapchainKHR swapchain = SwapchainKHR();
    uint64_t timeout = 0;
    Semaphore semaphore = Semaphore();
    Fence fence = Fence();
    uint32_t deviceMask = 0;
  };
  static_assert( sizeof( AcquireNextImageInfoKHR ) == sizeof( VkAcquireNextImageInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( AcquireNextImageInfoKHR, pNext ) == offsetof( VkAcquireNextImageInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AcquireNextImageInfoKHR, swapchain ) == offsetof( VkAcquireNextImageInfoKHR, swapchain ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AcquireNextImageInfoKHR, timeout ) == offsetof( VkAcquireNextImageInfoKHR, timeout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AcquireNextImageInfoKHR, semaphore ) == offsetof( VkAcquireNextImageInfoKHR, semaphore ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AcquireNextImageInfoKHR, fence ) == offsetof( VkAcquireNextImageInfoKHR, fence ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AcquireNextImageInfoKHR, deviceMask ) == offsetof( VkAcquireNextImageInfoKHR, deviceMask ), "struct member and wrapper member have different offset!" );

  struct HdrMetadataEXT
  {
    operator VkHdrMetadataEXT const&() const
    {
      return *reinterpret_cast<const VkHdrMetadataEXT*>(this);
    }

    operator VkHdrMetadataEXT &()
    {
      return *reinterpret_cast<VkHdrMetadataEXT*>(this);
    }

    bool operator==( HdrMetadataEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( displayPrimaryRed == rhs.displayPrimaryRed )
          && ( displayPrimaryGreen == rhs.displayPrimaryGreen )
          && ( displayPrimaryBlue == rhs.displayPrimaryBlue )
          && ( whitePoint == rhs.whitePoint )
          && ( maxLuminance == rhs.maxLuminance )
          && ( minLuminance == rhs.minLuminance )
          && ( maxContentLightLevel == rhs.maxContentLightLevel )
          && ( maxFrameAverageLightLevel == rhs.maxFrameAverageLightLevel );
    }

    bool operator!=( HdrMetadataEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eHdrMetadataEXT;
    const void* pNext = nullptr;
    XYColorEXT displayPrimaryRed = XYColorEXT();
    XYColorEXT displayPrimaryGreen = XYColorEXT();
    XYColorEXT displayPrimaryBlue = XYColorEXT();
    XYColorEXT whitePoint = XYColorEXT();
    float maxLuminance = 0;
    float minLuminance = 0;
    float maxContentLightLevel = 0;
    float maxFrameAverageLightLevel = 0;
  };
  static_assert( sizeof( HdrMetadataEXT ) == sizeof( VkHdrMetadataEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( HdrMetadataEXT, pNext ) == offsetof( VkHdrMetadataEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( HdrMetadataEXT, displayPrimaryRed ) == offsetof( VkHdrMetadataEXT, displayPrimaryRed ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( HdrMetadataEXT, displayPrimaryGreen ) == offsetof( VkHdrMetadataEXT, displayPrimaryGreen ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( HdrMetadataEXT, displayPrimaryBlue ) == offsetof( VkHdrMetadataEXT, displayPrimaryBlue ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( HdrMetadataEXT, whitePoint ) == offsetof( VkHdrMetadataEXT, whitePoint ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( HdrMetadataEXT, maxLuminance ) == offsetof( VkHdrMetadataEXT, maxLuminance ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( HdrMetadataEXT, minLuminance ) == offsetof( VkHdrMetadataEXT, minLuminance ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( HdrMetadataEXT, maxContentLightLevel ) == offsetof( VkHdrMetadataEXT, maxContentLightLevel ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( HdrMetadataEXT, maxFrameAverageLightLevel ) == offsetof( VkHdrMetadataEXT, maxFrameAverageLightLevel ), "struct member and wrapper member have different offset!" );

  struct PresentTimesInfoGOOGLE
  {
    operator VkPresentTimesInfoGOOGLE const&() const
    {
      return *reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(this);
    }

    operator VkPresentTimesInfoGOOGLE &()
    {
      return *reinterpret_cast<VkPresentTimesInfoGOOGLE*>(this);
    }

    bool operator==( PresentTimesInfoGOOGLE const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( swapchainCount == rhs.swapchainCount )
          && ( pTimes == rhs.pTimes );
    }

    bool operator!=( PresentTimesInfoGOOGLE const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePresentTimesInfoGOOGLE;
    const void* pNext = nullptr;
    uint32_t swapchainCount = 0;
    const PresentTimeGOOGLE* pTimes = nullptr;
  };
  static_assert( sizeof( PresentTimesInfoGOOGLE ) == sizeof( VkPresentTimesInfoGOOGLE ), "struct and wrapper have different size!" );
  static_assert( offsetof( PresentTimesInfoGOOGLE, pNext ) == offsetof( VkPresentTimesInfoGOOGLE, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentTimesInfoGOOGLE, swapchainCount ) == offsetof( VkPresentTimesInfoGOOGLE, swapchainCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentTimesInfoGOOGLE, pTimes ) == offsetof( VkPresentTimesInfoGOOGLE, pTimes ), "struct member and wrapper member have different offset!" );

#ifdef VK_USE_PLATFORM_IOS_MVK
  struct IOSSurfaceCreateInfoMVK
  {
    operator VkIOSSurfaceCreateInfoMVK const&() const
    {
      return *reinterpret_cast<const VkIOSSurfaceCreateInfoMVK*>(this);
    }

    operator VkIOSSurfaceCreateInfoMVK &()
    {
      return *reinterpret_cast<VkIOSSurfaceCreateInfoMVK*>(this);
    }

    bool operator==( IOSSurfaceCreateInfoMVK const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( pView == rhs.pView );
    }

    bool operator!=( IOSSurfaceCreateInfoMVK const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eIosSurfaceCreateInfoMVK;
    const void* pNext = nullptr;
    IOSSurfaceCreateFlagsMVK flags = IOSSurfaceCreateFlagsMVK();
    const void* pView = nullptr;
  };
  static_assert( sizeof( IOSSurfaceCreateInfoMVK ) == sizeof( VkIOSSurfaceCreateInfoMVK ), "struct and wrapper have different size!" );
  static_assert( offsetof( IOSSurfaceCreateInfoMVK, pNext ) == offsetof( VkIOSSurfaceCreateInfoMVK, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IOSSurfaceCreateInfoMVK, flags ) == offsetof( VkIOSSurfaceCreateInfoMVK, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IOSSurfaceCreateInfoMVK, pView ) == offsetof( VkIOSSurfaceCreateInfoMVK, pView ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_IOS_MVK*/

#ifdef VK_USE_PLATFORM_MACOS_MVK
  struct MacOSSurfaceCreateInfoMVK
  {
    operator VkMacOSSurfaceCreateInfoMVK const&() const
    {
      return *reinterpret_cast<const VkMacOSSurfaceCreateInfoMVK*>(this);
    }

    operator VkMacOSSurfaceCreateInfoMVK &()
    {
      return *reinterpret_cast<VkMacOSSurfaceCreateInfoMVK*>(this);
    }

    bool operator==( MacOSSurfaceCreateInfoMVK const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( pView == rhs.pView );
    }

    bool operator!=( MacOSSurfaceCreateInfoMVK const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMacosSurfaceCreateInfoMVK;
    const void* pNext = nullptr;
    MacOSSurfaceCreateFlagsMVK flags = MacOSSurfaceCreateFlagsMVK();
    const void* pView = nullptr;
  };
  static_assert( sizeof( MacOSSurfaceCreateInfoMVK ) == sizeof( VkMacOSSurfaceCreateInfoMVK ), "struct and wrapper have different size!" );
  static_assert( offsetof( MacOSSurfaceCreateInfoMVK, pNext ) == offsetof( VkMacOSSurfaceCreateInfoMVK, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MacOSSurfaceCreateInfoMVK, flags ) == offsetof( VkMacOSSurfaceCreateInfoMVK, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MacOSSurfaceCreateInfoMVK, pView ) == offsetof( VkMacOSSurfaceCreateInfoMVK, pView ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_MACOS_MVK*/

  struct PipelineViewportWScalingStateCreateInfoNV
  {
    operator VkPipelineViewportWScalingStateCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(this);
    }

    operator VkPipelineViewportWScalingStateCreateInfoNV &()
    {
      return *reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(this);
    }

    bool operator==( PipelineViewportWScalingStateCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( viewportWScalingEnable == rhs.viewportWScalingEnable )
          && ( viewportCount == rhs.viewportCount )
          && ( pViewportWScalings == rhs.pViewportWScalings );
    }

    bool operator!=( PipelineViewportWScalingStateCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineViewportWScalingStateCreateInfoNV;
    const void* pNext = nullptr;
    Bool32 viewportWScalingEnable = 0;
    uint32_t viewportCount = 0;
    const ViewportWScalingNV* pViewportWScalings = nullptr;
  };
  static_assert( sizeof( PipelineViewportWScalingStateCreateInfoNV ) == sizeof( VkPipelineViewportWScalingStateCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineViewportWScalingStateCreateInfoNV, pNext ) == offsetof( VkPipelineViewportWScalingStateCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportWScalingStateCreateInfoNV, viewportWScalingEnable ) == offsetof( VkPipelineViewportWScalingStateCreateInfoNV, viewportWScalingEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportWScalingStateCreateInfoNV, viewportCount ) == offsetof( VkPipelineViewportWScalingStateCreateInfoNV, viewportCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportWScalingStateCreateInfoNV, pViewportWScalings ) == offsetof( VkPipelineViewportWScalingStateCreateInfoNV, pViewportWScalings ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceDiscardRectanglePropertiesEXT
  {
    operator VkPhysicalDeviceDiscardRectanglePropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(this);
    }

    operator VkPhysicalDeviceDiscardRectanglePropertiesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(this);
    }

    bool operator==( PhysicalDeviceDiscardRectanglePropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxDiscardRectangles == rhs.maxDiscardRectangles );
    }

    bool operator!=( PhysicalDeviceDiscardRectanglePropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceDiscardRectanglePropertiesEXT;
    void* pNext = nullptr;
    uint32_t maxDiscardRectangles = 0;
  };
  static_assert( sizeof( PhysicalDeviceDiscardRectanglePropertiesEXT ) == sizeof( VkPhysicalDeviceDiscardRectanglePropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceDiscardRectanglePropertiesEXT, pNext ) == offsetof( VkPhysicalDeviceDiscardRectanglePropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDiscardRectanglePropertiesEXT, maxDiscardRectangles ) == offsetof( VkPhysicalDeviceDiscardRectanglePropertiesEXT, maxDiscardRectangles ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
  {
    operator VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(this);
    }

    operator VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &()
    {
      return *reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(this);
    }

    bool operator==( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( perViewPositionAllComponents == rhs.perViewPositionAllComponents );
    }

    bool operator!=( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
    void* pNext = nullptr;
    Bool32 perViewPositionAllComponents = 0;
  };
  static_assert( sizeof( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) == sizeof( VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, pNext ) == offsetof( VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, perViewPositionAllComponents ) == offsetof( VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, perViewPositionAllComponents ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceSurfaceInfo2KHR
  {
    operator VkPhysicalDeviceSurfaceInfo2KHR const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>(this);
    }

    operator VkPhysicalDeviceSurfaceInfo2KHR &()
    {
      return *reinterpret_cast<VkPhysicalDeviceSurfaceInfo2KHR*>(this);
    }

    bool operator==( PhysicalDeviceSurfaceInfo2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( surface == rhs.surface );
    }

    bool operator!=( PhysicalDeviceSurfaceInfo2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceSurfaceInfo2KHR;
    const void* pNext = nullptr;
    SurfaceKHR surface = SurfaceKHR();
  };
  static_assert( sizeof( PhysicalDeviceSurfaceInfo2KHR ) == sizeof( VkPhysicalDeviceSurfaceInfo2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceSurfaceInfo2KHR, pNext ) == offsetof( VkPhysicalDeviceSurfaceInfo2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSurfaceInfo2KHR, surface ) == offsetof( VkPhysicalDeviceSurfaceInfo2KHR, surface ), "struct member and wrapper member have different offset!" );

  struct DisplayPlaneProperties2KHR
  {
    operator VkDisplayPlaneProperties2KHR const&() const
    {
      return *reinterpret_cast<const VkDisplayPlaneProperties2KHR*>(this);
    }

    operator VkDisplayPlaneProperties2KHR &()
    {
      return *reinterpret_cast<VkDisplayPlaneProperties2KHR*>(this);
    }

    bool operator==( DisplayPlaneProperties2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( displayPlaneProperties == rhs.displayPlaneProperties );
    }

    bool operator!=( DisplayPlaneProperties2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplayPlaneProperties2KHR;
    void* pNext = nullptr;
    DisplayPlanePropertiesKHR displayPlaneProperties = DisplayPlanePropertiesKHR();
  };
  static_assert( sizeof( DisplayPlaneProperties2KHR ) == sizeof( VkDisplayPlaneProperties2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayPlaneProperties2KHR, pNext ) == offsetof( VkDisplayPlaneProperties2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneProperties2KHR, displayPlaneProperties ) == offsetof( VkDisplayPlaneProperties2KHR, displayPlaneProperties ), "struct member and wrapper member have different offset!" );

  struct DisplayModeProperties2KHR
  {
    operator VkDisplayModeProperties2KHR const&() const
    {
      return *reinterpret_cast<const VkDisplayModeProperties2KHR*>(this);
    }

    operator VkDisplayModeProperties2KHR &()
    {
      return *reinterpret_cast<VkDisplayModeProperties2KHR*>(this);
    }

    bool operator==( DisplayModeProperties2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( displayModeProperties == rhs.displayModeProperties );
    }

    bool operator!=( DisplayModeProperties2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplayModeProperties2KHR;
    void* pNext = nullptr;
    DisplayModePropertiesKHR displayModeProperties = DisplayModePropertiesKHR();
  };
  static_assert( sizeof( DisplayModeProperties2KHR ) == sizeof( VkDisplayModeProperties2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayModeProperties2KHR, pNext ) == offsetof( VkDisplayModeProperties2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayModeProperties2KHR, displayModeProperties ) == offsetof( VkDisplayModeProperties2KHR, displayModeProperties ), "struct member and wrapper member have different offset!" );

  struct DisplayPlaneInfo2KHR
  {
    operator VkDisplayPlaneInfo2KHR const&() const
    {
      return *reinterpret_cast<const VkDisplayPlaneInfo2KHR*>(this);
    }

    operator VkDisplayPlaneInfo2KHR &()
    {
      return *reinterpret_cast<VkDisplayPlaneInfo2KHR*>(this);
    }

    bool operator==( DisplayPlaneInfo2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( mode == rhs.mode )
          && ( planeIndex == rhs.planeIndex );
    }

    bool operator!=( DisplayPlaneInfo2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplayPlaneInfo2KHR;
    const void* pNext = nullptr;
    DisplayModeKHR mode = DisplayModeKHR();
    uint32_t planeIndex = 0;
  };
  static_assert( sizeof( DisplayPlaneInfo2KHR ) == sizeof( VkDisplayPlaneInfo2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayPlaneInfo2KHR, pNext ) == offsetof( VkDisplayPlaneInfo2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneInfo2KHR, mode ) == offsetof( VkDisplayPlaneInfo2KHR, mode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneInfo2KHR, planeIndex ) == offsetof( VkDisplayPlaneInfo2KHR, planeIndex ), "struct member and wrapper member have different offset!" );

  struct PhysicalDevice16BitStorageFeatures
  {
    operator VkPhysicalDevice16BitStorageFeatures const&() const
    {
      return *reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(this);
    }

    operator VkPhysicalDevice16BitStorageFeatures &()
    {
      return *reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(this);
    }

    bool operator==( PhysicalDevice16BitStorageFeatures const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( storageBuffer16BitAccess == rhs.storageBuffer16BitAccess )
          && ( uniformAndStorageBuffer16BitAccess == rhs.uniformAndStorageBuffer16BitAccess )
          && ( storagePushConstant16 == rhs.storagePushConstant16 )
          && ( storageInputOutput16 == rhs.storageInputOutput16 );
    }

    bool operator!=( PhysicalDevice16BitStorageFeatures const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDevice16BitStorageFeatures;
    void* pNext = nullptr;
    Bool32 storageBuffer16BitAccess = 0;
    Bool32 uniformAndStorageBuffer16BitAccess = 0;
    Bool32 storagePushConstant16 = 0;
    Bool32 storageInputOutput16 = 0;
  };
  static_assert( sizeof( PhysicalDevice16BitStorageFeatures ) == sizeof( VkPhysicalDevice16BitStorageFeatures ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDevice16BitStorageFeatures, pNext ) == offsetof( VkPhysicalDevice16BitStorageFeatures, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDevice16BitStorageFeatures, storageBuffer16BitAccess ) == offsetof( VkPhysicalDevice16BitStorageFeatures, storageBuffer16BitAccess ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDevice16BitStorageFeatures, uniformAndStorageBuffer16BitAccess ) == offsetof( VkPhysicalDevice16BitStorageFeatures, uniformAndStorageBuffer16BitAccess ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDevice16BitStorageFeatures, storagePushConstant16 ) == offsetof( VkPhysicalDevice16BitStorageFeatures, storagePushConstant16 ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDevice16BitStorageFeatures, storageInputOutput16 ) == offsetof( VkPhysicalDevice16BitStorageFeatures, storageInputOutput16 ), "struct member and wrapper member have different offset!" );

  using PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;

  struct BufferMemoryRequirementsInfo2
  {
    operator VkBufferMemoryRequirementsInfo2 const&() const
    {
      return *reinterpret_cast<const VkBufferMemoryRequirementsInfo2*>(this);
    }

    operator VkBufferMemoryRequirementsInfo2 &()
    {
      return *reinterpret_cast<VkBufferMemoryRequirementsInfo2*>(this);
    }

    bool operator==( BufferMemoryRequirementsInfo2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( buffer == rhs.buffer );
    }

    bool operator!=( BufferMemoryRequirementsInfo2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBufferMemoryRequirementsInfo2;
    const void* pNext = nullptr;
    Buffer buffer = Buffer();
  };
  static_assert( sizeof( BufferMemoryRequirementsInfo2 ) == sizeof( VkBufferMemoryRequirementsInfo2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( BufferMemoryRequirementsInfo2, pNext ) == offsetof( VkBufferMemoryRequirementsInfo2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferMemoryRequirementsInfo2, buffer ) == offsetof( VkBufferMemoryRequirementsInfo2, buffer ), "struct member and wrapper member have different offset!" );

  using BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;

  struct ImageMemoryRequirementsInfo2
  {
    operator VkImageMemoryRequirementsInfo2 const&() const
    {
      return *reinterpret_cast<const VkImageMemoryRequirementsInfo2*>(this);
    }

    operator VkImageMemoryRequirementsInfo2 &()
    {
      return *reinterpret_cast<VkImageMemoryRequirementsInfo2*>(this);
    }

    bool operator==( ImageMemoryRequirementsInfo2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( image == rhs.image );
    }

    bool operator!=( ImageMemoryRequirementsInfo2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageMemoryRequirementsInfo2;
    const void* pNext = nullptr;
    Image image = Image();
  };
  static_assert( sizeof( ImageMemoryRequirementsInfo2 ) == sizeof( VkImageMemoryRequirementsInfo2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageMemoryRequirementsInfo2, pNext ) == offsetof( VkImageMemoryRequirementsInfo2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageMemoryRequirementsInfo2, image ) == offsetof( VkImageMemoryRequirementsInfo2, image ), "struct member and wrapper member have different offset!" );

  using ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;

  struct ImageSparseMemoryRequirementsInfo2
  {
    operator VkImageSparseMemoryRequirementsInfo2 const&() const
    {
      return *reinterpret_cast<const VkImageSparseMemoryRequirementsInfo2*>(this);
    }

    operator VkImageSparseMemoryRequirementsInfo2 &()
    {
      return *reinterpret_cast<VkImageSparseMemoryRequirementsInfo2*>(this);
    }

    bool operator==( ImageSparseMemoryRequirementsInfo2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( image == rhs.image );
    }

    bool operator!=( ImageSparseMemoryRequirementsInfo2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageSparseMemoryRequirementsInfo2;
    const void* pNext = nullptr;
    Image image = Image();
  };
  static_assert( sizeof( ImageSparseMemoryRequirementsInfo2 ) == sizeof( VkImageSparseMemoryRequirementsInfo2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageSparseMemoryRequirementsInfo2, pNext ) == offsetof( VkImageSparseMemoryRequirementsInfo2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSparseMemoryRequirementsInfo2, image ) == offsetof( VkImageSparseMemoryRequirementsInfo2, image ), "struct member and wrapper member have different offset!" );

  using ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;

  struct MemoryRequirements2
  {
    operator VkMemoryRequirements2 const&() const
    {
      return *reinterpret_cast<const VkMemoryRequirements2*>(this);
    }

    operator VkMemoryRequirements2 &()
    {
      return *reinterpret_cast<VkMemoryRequirements2*>(this);
    }

    bool operator==( MemoryRequirements2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memoryRequirements == rhs.memoryRequirements );
    }

    bool operator!=( MemoryRequirements2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryRequirements2;
    void* pNext = nullptr;
    MemoryRequirements memoryRequirements = MemoryRequirements();
  };
  static_assert( sizeof( MemoryRequirements2 ) == sizeof( VkMemoryRequirements2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryRequirements2, pNext ) == offsetof( VkMemoryRequirements2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryRequirements2, memoryRequirements ) == offsetof( VkMemoryRequirements2, memoryRequirements ), "struct member and wrapper member have different offset!" );

  using MemoryRequirements2KHR = MemoryRequirements2;

  struct MemoryDedicatedRequirements
  {
    operator VkMemoryDedicatedRequirements const&() const
    {
      return *reinterpret_cast<const VkMemoryDedicatedRequirements*>(this);
    }

    operator VkMemoryDedicatedRequirements &()
    {
      return *reinterpret_cast<VkMemoryDedicatedRequirements*>(this);
    }

    bool operator==( MemoryDedicatedRequirements const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( prefersDedicatedAllocation == rhs.prefersDedicatedAllocation )
          && ( requiresDedicatedAllocation == rhs.requiresDedicatedAllocation );
    }

    bool operator!=( MemoryDedicatedRequirements const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryDedicatedRequirements;
    void* pNext = nullptr;
    Bool32 prefersDedicatedAllocation = 0;
    Bool32 requiresDedicatedAllocation = 0;
  };
  static_assert( sizeof( MemoryDedicatedRequirements ) == sizeof( VkMemoryDedicatedRequirements ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryDedicatedRequirements, pNext ) == offsetof( VkMemoryDedicatedRequirements, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryDedicatedRequirements, prefersDedicatedAllocation ) == offsetof( VkMemoryDedicatedRequirements, prefersDedicatedAllocation ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryDedicatedRequirements, requiresDedicatedAllocation ) == offsetof( VkMemoryDedicatedRequirements, requiresDedicatedAllocation ), "struct member and wrapper member have different offset!" );

  using MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;

  struct MemoryDedicatedAllocateInfo
  {
    operator VkMemoryDedicatedAllocateInfo const&() const
    {
      return *reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(this);
    }

    operator VkMemoryDedicatedAllocateInfo &()
    {
      return *reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(this);
    }

    bool operator==( MemoryDedicatedAllocateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( image == rhs.image )
          && ( buffer == rhs.buffer );
    }

    bool operator!=( MemoryDedicatedAllocateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryDedicatedAllocateInfo;
    const void* pNext = nullptr;
    Image image = Image();
    Buffer buffer = Buffer();
  };
  static_assert( sizeof( MemoryDedicatedAllocateInfo ) == sizeof( VkMemoryDedicatedAllocateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryDedicatedAllocateInfo, pNext ) == offsetof( VkMemoryDedicatedAllocateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryDedicatedAllocateInfo, image ) == offsetof( VkMemoryDedicatedAllocateInfo, image ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryDedicatedAllocateInfo, buffer ) == offsetof( VkMemoryDedicatedAllocateInfo, buffer ), "struct member and wrapper member have different offset!" );

  using MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;

  struct SamplerYcbcrConversionInfo
  {
    operator VkSamplerYcbcrConversionInfo const&() const
    {
      return *reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(this);
    }

    operator VkSamplerYcbcrConversionInfo &()
    {
      return *reinterpret_cast<VkSamplerYcbcrConversionInfo*>(this);
    }

    bool operator==( SamplerYcbcrConversionInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( conversion == rhs.conversion );
    }

    bool operator!=( SamplerYcbcrConversionInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSamplerYcbcrConversionInfo;
    const void* pNext = nullptr;
    SamplerYcbcrConversion conversion = SamplerYcbcrConversion();
  };
  static_assert( sizeof( SamplerYcbcrConversionInfo ) == sizeof( VkSamplerYcbcrConversionInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( SamplerYcbcrConversionInfo, pNext ) == offsetof( VkSamplerYcbcrConversionInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionInfo, conversion ) == offsetof( VkSamplerYcbcrConversionInfo, conversion ), "struct member and wrapper member have different offset!" );

  using SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;

  struct PhysicalDeviceSamplerYcbcrConversionFeatures
  {
    operator VkPhysicalDeviceSamplerYcbcrConversionFeatures const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(this);
    }

    operator VkPhysicalDeviceSamplerYcbcrConversionFeatures &()
    {
      return *reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(this);
    }

    bool operator==( PhysicalDeviceSamplerYcbcrConversionFeatures const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( samplerYcbcrConversion == rhs.samplerYcbcrConversion );
    }

    bool operator!=( PhysicalDeviceSamplerYcbcrConversionFeatures const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceSamplerYcbcrConversionFeatures;
    void* pNext = nullptr;
    Bool32 samplerYcbcrConversion = 0;
  };
  static_assert( sizeof( PhysicalDeviceSamplerYcbcrConversionFeatures ) == sizeof( VkPhysicalDeviceSamplerYcbcrConversionFeatures ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceSamplerYcbcrConversionFeatures, pNext ) == offsetof( VkPhysicalDeviceSamplerYcbcrConversionFeatures, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSamplerYcbcrConversionFeatures, samplerYcbcrConversion ) == offsetof( VkPhysicalDeviceSamplerYcbcrConversionFeatures, samplerYcbcrConversion ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;

  struct SamplerYcbcrConversionImageFormatProperties
  {
    operator VkSamplerYcbcrConversionImageFormatProperties const&() const
    {
      return *reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(this);
    }

    operator VkSamplerYcbcrConversionImageFormatProperties &()
    {
      return *reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(this);
    }

    bool operator==( SamplerYcbcrConversionImageFormatProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( combinedImageSamplerDescriptorCount == rhs.combinedImageSamplerDescriptorCount );
    }

    bool operator!=( SamplerYcbcrConversionImageFormatProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSamplerYcbcrConversionImageFormatProperties;
    void* pNext = nullptr;
    uint32_t combinedImageSamplerDescriptorCount = 0;
  };
  static_assert( sizeof( SamplerYcbcrConversionImageFormatProperties ) == sizeof( VkSamplerYcbcrConversionImageFormatProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( SamplerYcbcrConversionImageFormatProperties, pNext ) == offsetof( VkSamplerYcbcrConversionImageFormatProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionImageFormatProperties, combinedImageSamplerDescriptorCount ) == offsetof( VkSamplerYcbcrConversionImageFormatProperties, combinedImageSamplerDescriptorCount ), "struct member and wrapper member have different offset!" );

  using SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;

  struct TextureLODGatherFormatPropertiesAMD
  {
    operator VkTextureLODGatherFormatPropertiesAMD const&() const
    {
      return *reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(this);
    }

    operator VkTextureLODGatherFormatPropertiesAMD &()
    {
      return *reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(this);
    }

    bool operator==( TextureLODGatherFormatPropertiesAMD const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( supportsTextureGatherLODBiasAMD == rhs.supportsTextureGatherLODBiasAMD );
    }

    bool operator!=( TextureLODGatherFormatPropertiesAMD const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eTextureLodGatherFormatPropertiesAMD;
    void* pNext = nullptr;
    Bool32 supportsTextureGatherLODBiasAMD = 0;
  };
  static_assert( sizeof( TextureLODGatherFormatPropertiesAMD ) == sizeof( VkTextureLODGatherFormatPropertiesAMD ), "struct and wrapper have different size!" );
  static_assert( offsetof( TextureLODGatherFormatPropertiesAMD, pNext ) == offsetof( VkTextureLODGatherFormatPropertiesAMD, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( TextureLODGatherFormatPropertiesAMD, supportsTextureGatherLODBiasAMD ) == offsetof( VkTextureLODGatherFormatPropertiesAMD, supportsTextureGatherLODBiasAMD ), "struct member and wrapper member have different offset!" );

  struct ProtectedSubmitInfo
  {
    operator VkProtectedSubmitInfo const&() const
    {
      return *reinterpret_cast<const VkProtectedSubmitInfo*>(this);
    }

    operator VkProtectedSubmitInfo &()
    {
      return *reinterpret_cast<VkProtectedSubmitInfo*>(this);
    }

    bool operator==( ProtectedSubmitInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( protectedSubmit == rhs.protectedSubmit );
    }

    bool operator!=( ProtectedSubmitInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eProtectedSubmitInfo;
    const void* pNext = nullptr;
    Bool32 protectedSubmit = 0;
  };
  static_assert( sizeof( ProtectedSubmitInfo ) == sizeof( VkProtectedSubmitInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ProtectedSubmitInfo, pNext ) == offsetof( VkProtectedSubmitInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ProtectedSubmitInfo, protectedSubmit ) == offsetof( VkProtectedSubmitInfo, protectedSubmit ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceProtectedMemoryFeatures
  {
    operator VkPhysicalDeviceProtectedMemoryFeatures const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(this);
    }

    operator VkPhysicalDeviceProtectedMemoryFeatures &()
    {
      return *reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(this);
    }

    bool operator==( PhysicalDeviceProtectedMemoryFeatures const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( protectedMemory == rhs.protectedMemory );
    }

    bool operator!=( PhysicalDeviceProtectedMemoryFeatures const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceProtectedMemoryFeatures;
    void* pNext = nullptr;
    Bool32 protectedMemory = 0;
  };
  static_assert( sizeof( PhysicalDeviceProtectedMemoryFeatures ) == sizeof( VkPhysicalDeviceProtectedMemoryFeatures ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceProtectedMemoryFeatures, pNext ) == offsetof( VkPhysicalDeviceProtectedMemoryFeatures, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProtectedMemoryFeatures, protectedMemory ) == offsetof( VkPhysicalDeviceProtectedMemoryFeatures, protectedMemory ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceProtectedMemoryProperties
  {
    operator VkPhysicalDeviceProtectedMemoryProperties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(this);
    }

    operator VkPhysicalDeviceProtectedMemoryProperties &()
    {
      return *reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(this);
    }

    bool operator==( PhysicalDeviceProtectedMemoryProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( protectedNoFault == rhs.protectedNoFault );
    }

    bool operator!=( PhysicalDeviceProtectedMemoryProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceProtectedMemoryProperties;
    void* pNext = nullptr;
    Bool32 protectedNoFault = 0;
  };
  static_assert( sizeof( PhysicalDeviceProtectedMemoryProperties ) == sizeof( VkPhysicalDeviceProtectedMemoryProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceProtectedMemoryProperties, pNext ) == offsetof( VkPhysicalDeviceProtectedMemoryProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProtectedMemoryProperties, protectedNoFault ) == offsetof( VkPhysicalDeviceProtectedMemoryProperties, protectedNoFault ), "struct member and wrapper member have different offset!" );

  struct PipelineCoverageToColorStateCreateInfoNV
  {
    operator VkPipelineCoverageToColorStateCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(this);
    }

    operator VkPipelineCoverageToColorStateCreateInfoNV &()
    {
      return *reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(this);
    }

    bool operator==( PipelineCoverageToColorStateCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( coverageToColorEnable == rhs.coverageToColorEnable )
          && ( coverageToColorLocation == rhs.coverageToColorLocation );
    }

    bool operator!=( PipelineCoverageToColorStateCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineCoverageToColorStateCreateInfoNV;
    const void* pNext = nullptr;
    PipelineCoverageToColorStateCreateFlagsNV flags = PipelineCoverageToColorStateCreateFlagsNV();
    Bool32 coverageToColorEnable = 0;
    uint32_t coverageToColorLocation = 0;
  };
  static_assert( sizeof( PipelineCoverageToColorStateCreateInfoNV ) == sizeof( VkPipelineCoverageToColorStateCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineCoverageToColorStateCreateInfoNV, pNext ) == offsetof( VkPipelineCoverageToColorStateCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCoverageToColorStateCreateInfoNV, flags ) == offsetof( VkPipelineCoverageToColorStateCreateInfoNV, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCoverageToColorStateCreateInfoNV, coverageToColorEnable ) == offsetof( VkPipelineCoverageToColorStateCreateInfoNV, coverageToColorEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCoverageToColorStateCreateInfoNV, coverageToColorLocation ) == offsetof( VkPipelineCoverageToColorStateCreateInfoNV, coverageToColorLocation ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceSamplerFilterMinmaxPropertiesEXT
  {
    operator VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(this);
    }

    operator VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(this);
    }

    bool operator==( PhysicalDeviceSamplerFilterMinmaxPropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( filterMinmaxSingleComponentFormats == rhs.filterMinmaxSingleComponentFormats )
          && ( filterMinmaxImageComponentMapping == rhs.filterMinmaxImageComponentMapping );
    }

    bool operator!=( PhysicalDeviceSamplerFilterMinmaxPropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceSamplerFilterMinmaxPropertiesEXT;
    void* pNext = nullptr;
    Bool32 filterMinmaxSingleComponentFormats = 0;
    Bool32 filterMinmaxImageComponentMapping = 0;
  };
  static_assert( sizeof( PhysicalDeviceSamplerFilterMinmaxPropertiesEXT ) == sizeof( VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceSamplerFilterMinmaxPropertiesEXT, pNext ) == offsetof( VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSamplerFilterMinmaxPropertiesEXT, filterMinmaxSingleComponentFormats ) == offsetof( VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, filterMinmaxSingleComponentFormats ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSamplerFilterMinmaxPropertiesEXT, filterMinmaxImageComponentMapping ) == offsetof( VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, filterMinmaxImageComponentMapping ), "struct member and wrapper member have different offset!" );

  struct MultisamplePropertiesEXT
  {
    operator VkMultisamplePropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkMultisamplePropertiesEXT*>(this);
    }

    operator VkMultisamplePropertiesEXT &()
    {
      return *reinterpret_cast<VkMultisamplePropertiesEXT*>(this);
    }

    bool operator==( MultisamplePropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxSampleLocationGridSize == rhs.maxSampleLocationGridSize );
    }

    bool operator!=( MultisamplePropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMultisamplePropertiesEXT;
    void* pNext = nullptr;
    Extent2D maxSampleLocationGridSize = Extent2D();
  };
  static_assert( sizeof( MultisamplePropertiesEXT ) == sizeof( VkMultisamplePropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( MultisamplePropertiesEXT, pNext ) == offsetof( VkMultisamplePropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MultisamplePropertiesEXT, maxSampleLocationGridSize ) == offsetof( VkMultisamplePropertiesEXT, maxSampleLocationGridSize ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT
  {
    operator VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(this);
    }

    operator VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(this);
    }

    bool operator==( PhysicalDeviceBlendOperationAdvancedFeaturesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( advancedBlendCoherentOperations == rhs.advancedBlendCoherentOperations );
    }

    bool operator!=( PhysicalDeviceBlendOperationAdvancedFeaturesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceBlendOperationAdvancedFeaturesEXT;
    void* pNext = nullptr;
    Bool32 advancedBlendCoherentOperations = 0;
  };
  static_assert( sizeof( PhysicalDeviceBlendOperationAdvancedFeaturesEXT ) == sizeof( VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceBlendOperationAdvancedFeaturesEXT, pNext ) == offsetof( VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceBlendOperationAdvancedFeaturesEXT, advancedBlendCoherentOperations ) == offsetof( VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, advancedBlendCoherentOperations ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT
  {
    operator VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(this);
    }

    operator VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(this);
    }

    bool operator==( PhysicalDeviceBlendOperationAdvancedPropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( advancedBlendMaxColorAttachments == rhs.advancedBlendMaxColorAttachments )
          && ( advancedBlendIndependentBlend == rhs.advancedBlendIndependentBlend )
          && ( advancedBlendNonPremultipliedSrcColor == rhs.advancedBlendNonPremultipliedSrcColor )
          && ( advancedBlendNonPremultipliedDstColor == rhs.advancedBlendNonPremultipliedDstColor )
          && ( advancedBlendCorrelatedOverlap == rhs.advancedBlendCorrelatedOverlap )
          && ( advancedBlendAllOperations == rhs.advancedBlendAllOperations );
    }

    bool operator!=( PhysicalDeviceBlendOperationAdvancedPropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceBlendOperationAdvancedPropertiesEXT;
    void* pNext = nullptr;
    uint32_t advancedBlendMaxColorAttachments = 0;
    Bool32 advancedBlendIndependentBlend = 0;
    Bool32 advancedBlendNonPremultipliedSrcColor = 0;
    Bool32 advancedBlendNonPremultipliedDstColor = 0;
    Bool32 advancedBlendCorrelatedOverlap = 0;
    Bool32 advancedBlendAllOperations = 0;
  };
  static_assert( sizeof( PhysicalDeviceBlendOperationAdvancedPropertiesEXT ) == sizeof( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceBlendOperationAdvancedPropertiesEXT, pNext ) == offsetof( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendMaxColorAttachments ) == offsetof( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendMaxColorAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendIndependentBlend ) == offsetof( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendIndependentBlend ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendNonPremultipliedSrcColor ) == offsetof( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendNonPremultipliedSrcColor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendNonPremultipliedDstColor ) == offsetof( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendNonPremultipliedDstColor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendCorrelatedOverlap ) == offsetof( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendCorrelatedOverlap ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendAllOperations ) == offsetof( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, advancedBlendAllOperations ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceInlineUniformBlockFeaturesEXT
  {
    operator VkPhysicalDeviceInlineUniformBlockFeaturesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(this);
    }

    operator VkPhysicalDeviceInlineUniformBlockFeaturesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(this);
    }

    bool operator==( PhysicalDeviceInlineUniformBlockFeaturesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( inlineUniformBlock == rhs.inlineUniformBlock )
          && ( descriptorBindingInlineUniformBlockUpdateAfterBind == rhs.descriptorBindingInlineUniformBlockUpdateAfterBind );
    }

    bool operator!=( PhysicalDeviceInlineUniformBlockFeaturesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceInlineUniformBlockFeaturesEXT;
    void* pNext = nullptr;
    Bool32 inlineUniformBlock = 0;
    Bool32 descriptorBindingInlineUniformBlockUpdateAfterBind = 0;
  };
  static_assert( sizeof( PhysicalDeviceInlineUniformBlockFeaturesEXT ) == sizeof( VkPhysicalDeviceInlineUniformBlockFeaturesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceInlineUniformBlockFeaturesEXT, pNext ) == offsetof( VkPhysicalDeviceInlineUniformBlockFeaturesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceInlineUniformBlockFeaturesEXT, inlineUniformBlock ) == offsetof( VkPhysicalDeviceInlineUniformBlockFeaturesEXT, inlineUniformBlock ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceInlineUniformBlockFeaturesEXT, descriptorBindingInlineUniformBlockUpdateAfterBind ) == offsetof( VkPhysicalDeviceInlineUniformBlockFeaturesEXT, descriptorBindingInlineUniformBlockUpdateAfterBind ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceInlineUniformBlockPropertiesEXT
  {
    operator VkPhysicalDeviceInlineUniformBlockPropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(this);
    }

    operator VkPhysicalDeviceInlineUniformBlockPropertiesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(this);
    }

    bool operator==( PhysicalDeviceInlineUniformBlockPropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxInlineUniformBlockSize == rhs.maxInlineUniformBlockSize )
          && ( maxPerStageDescriptorInlineUniformBlocks == rhs.maxPerStageDescriptorInlineUniformBlocks )
          && ( maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks == rhs.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks )
          && ( maxDescriptorSetInlineUniformBlocks == rhs.maxDescriptorSetInlineUniformBlocks )
          && ( maxDescriptorSetUpdateAfterBindInlineUniformBlocks == rhs.maxDescriptorSetUpdateAfterBindInlineUniformBlocks );
    }

    bool operator!=( PhysicalDeviceInlineUniformBlockPropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceInlineUniformBlockPropertiesEXT;
    void* pNext = nullptr;
    uint32_t maxInlineUniformBlockSize = 0;
    uint32_t maxPerStageDescriptorInlineUniformBlocks = 0;
    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = 0;
    uint32_t maxDescriptorSetInlineUniformBlocks = 0;
    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks = 0;
  };
  static_assert( sizeof( PhysicalDeviceInlineUniformBlockPropertiesEXT ) == sizeof( VkPhysicalDeviceInlineUniformBlockPropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceInlineUniformBlockPropertiesEXT, pNext ) == offsetof( VkPhysicalDeviceInlineUniformBlockPropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceInlineUniformBlockPropertiesEXT, maxInlineUniformBlockSize ) == offsetof( VkPhysicalDeviceInlineUniformBlockPropertiesEXT, maxInlineUniformBlockSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceInlineUniformBlockPropertiesEXT, maxPerStageDescriptorInlineUniformBlocks ) == offsetof( VkPhysicalDeviceInlineUniformBlockPropertiesEXT, maxPerStageDescriptorInlineUniformBlocks ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceInlineUniformBlockPropertiesEXT, maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks ) == offsetof( VkPhysicalDeviceInlineUniformBlockPropertiesEXT, maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceInlineUniformBlockPropertiesEXT, maxDescriptorSetInlineUniformBlocks ) == offsetof( VkPhysicalDeviceInlineUniformBlockPropertiesEXT, maxDescriptorSetInlineUniformBlocks ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceInlineUniformBlockPropertiesEXT, maxDescriptorSetUpdateAfterBindInlineUniformBlocks ) == offsetof( VkPhysicalDeviceInlineUniformBlockPropertiesEXT, maxDescriptorSetUpdateAfterBindInlineUniformBlocks ), "struct member and wrapper member have different offset!" );

  struct WriteDescriptorSetInlineUniformBlockEXT
  {
    operator VkWriteDescriptorSetInlineUniformBlockEXT const&() const
    {
      return *reinterpret_cast<const VkWriteDescriptorSetInlineUniformBlockEXT*>(this);
    }

    operator VkWriteDescriptorSetInlineUniformBlockEXT &()
    {
      return *reinterpret_cast<VkWriteDescriptorSetInlineUniformBlockEXT*>(this);
    }

    bool operator==( WriteDescriptorSetInlineUniformBlockEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( dataSize == rhs.dataSize )
          && ( pData == rhs.pData );
    }

    bool operator!=( WriteDescriptorSetInlineUniformBlockEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eWriteDescriptorSetInlineUniformBlockEXT;
    const void* pNext = nullptr;
    uint32_t dataSize = 0;
    const void* pData = nullptr;
  };
  static_assert( sizeof( WriteDescriptorSetInlineUniformBlockEXT ) == sizeof( VkWriteDescriptorSetInlineUniformBlockEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( WriteDescriptorSetInlineUniformBlockEXT, pNext ) == offsetof( VkWriteDescriptorSetInlineUniformBlockEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSetInlineUniformBlockEXT, dataSize ) == offsetof( VkWriteDescriptorSetInlineUniformBlockEXT, dataSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( WriteDescriptorSetInlineUniformBlockEXT, pData ) == offsetof( VkWriteDescriptorSetInlineUniformBlockEXT, pData ), "struct member and wrapper member have different offset!" );

  struct DescriptorPoolInlineUniformBlockCreateInfoEXT
  {
    operator VkDescriptorPoolInlineUniformBlockCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(this);
    }

    operator VkDescriptorPoolInlineUniformBlockCreateInfoEXT &()
    {
      return *reinterpret_cast<VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(this);
    }

    bool operator==( DescriptorPoolInlineUniformBlockCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxInlineUniformBlockBindings == rhs.maxInlineUniformBlockBindings );
    }

    bool operator!=( DescriptorPoolInlineUniformBlockCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorPoolInlineUniformBlockCreateInfoEXT;
    const void* pNext = nullptr;
    uint32_t maxInlineUniformBlockBindings = 0;
  };
  static_assert( sizeof( DescriptorPoolInlineUniformBlockCreateInfoEXT ) == sizeof( VkDescriptorPoolInlineUniformBlockCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorPoolInlineUniformBlockCreateInfoEXT, pNext ) == offsetof( VkDescriptorPoolInlineUniformBlockCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorPoolInlineUniformBlockCreateInfoEXT, maxInlineUniformBlockBindings ) == offsetof( VkDescriptorPoolInlineUniformBlockCreateInfoEXT, maxInlineUniformBlockBindings ), "struct member and wrapper member have different offset!" );

  struct ImageFormatListCreateInfoKHR
  {
    operator VkImageFormatListCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkImageFormatListCreateInfoKHR*>(this);
    }

    operator VkImageFormatListCreateInfoKHR &()
    {
      return *reinterpret_cast<VkImageFormatListCreateInfoKHR*>(this);
    }

    bool operator==( ImageFormatListCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( viewFormatCount == rhs.viewFormatCount )
          && ( pViewFormats == rhs.pViewFormats );
    }

    bool operator!=( ImageFormatListCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageFormatListCreateInfoKHR;
    const void* pNext = nullptr;
    uint32_t viewFormatCount = 0;
    const Format* pViewFormats = nullptr;
  };
  static_assert( sizeof( ImageFormatListCreateInfoKHR ) == sizeof( VkImageFormatListCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageFormatListCreateInfoKHR, pNext ) == offsetof( VkImageFormatListCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageFormatListCreateInfoKHR, viewFormatCount ) == offsetof( VkImageFormatListCreateInfoKHR, viewFormatCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageFormatListCreateInfoKHR, pViewFormats ) == offsetof( VkImageFormatListCreateInfoKHR, pViewFormats ), "struct member and wrapper member have different offset!" );

  struct ValidationCacheCreateInfoEXT
  {
    operator VkValidationCacheCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkValidationCacheCreateInfoEXT*>(this);
    }

    operator VkValidationCacheCreateInfoEXT &()
    {
      return *reinterpret_cast<VkValidationCacheCreateInfoEXT*>(this);
    }

    bool operator==( ValidationCacheCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( initialDataSize == rhs.initialDataSize )
          && ( pInitialData == rhs.pInitialData );
    }

    bool operator!=( ValidationCacheCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eValidationCacheCreateInfoEXT;
    const void* pNext = nullptr;
    ValidationCacheCreateFlagsEXT flags = ValidationCacheCreateFlagsEXT();
    size_t initialDataSize = 0;
    const void* pInitialData = nullptr;
  };
  static_assert( sizeof( ValidationCacheCreateInfoEXT ) == sizeof( VkValidationCacheCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( ValidationCacheCreateInfoEXT, pNext ) == offsetof( VkValidationCacheCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ValidationCacheCreateInfoEXT, flags ) == offsetof( VkValidationCacheCreateInfoEXT, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ValidationCacheCreateInfoEXT, initialDataSize ) == offsetof( VkValidationCacheCreateInfoEXT, initialDataSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ValidationCacheCreateInfoEXT, pInitialData ) == offsetof( VkValidationCacheCreateInfoEXT, pInitialData ), "struct member and wrapper member have different offset!" );

  struct ShaderModuleValidationCacheCreateInfoEXT
  {
    operator VkShaderModuleValidationCacheCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(this);
    }

    operator VkShaderModuleValidationCacheCreateInfoEXT &()
    {
      return *reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(this);
    }

    bool operator==( ShaderModuleValidationCacheCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( validationCache == rhs.validationCache );
    }

    bool operator!=( ShaderModuleValidationCacheCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eShaderModuleValidationCacheCreateInfoEXT;
    const void* pNext = nullptr;
    ValidationCacheEXT validationCache = ValidationCacheEXT();
  };
  static_assert( sizeof( ShaderModuleValidationCacheCreateInfoEXT ) == sizeof( VkShaderModuleValidationCacheCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( ShaderModuleValidationCacheCreateInfoEXT, pNext ) == offsetof( VkShaderModuleValidationCacheCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderModuleValidationCacheCreateInfoEXT, validationCache ) == offsetof( VkShaderModuleValidationCacheCreateInfoEXT, validationCache ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceMaintenance3Properties
  {
    operator VkPhysicalDeviceMaintenance3Properties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(this);
    }

    operator VkPhysicalDeviceMaintenance3Properties &()
    {
      return *reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(this);
    }

    bool operator==( PhysicalDeviceMaintenance3Properties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxPerSetDescriptors == rhs.maxPerSetDescriptors )
          && ( maxMemoryAllocationSize == rhs.maxMemoryAllocationSize );
    }

    bool operator!=( PhysicalDeviceMaintenance3Properties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceMaintenance3Properties;
    void* pNext = nullptr;
    uint32_t maxPerSetDescriptors = 0;
    DeviceSize maxMemoryAllocationSize = 0;
  };
  static_assert( sizeof( PhysicalDeviceMaintenance3Properties ) == sizeof( VkPhysicalDeviceMaintenance3Properties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceMaintenance3Properties, pNext ) == offsetof( VkPhysicalDeviceMaintenance3Properties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMaintenance3Properties, maxPerSetDescriptors ) == offsetof( VkPhysicalDeviceMaintenance3Properties, maxPerSetDescriptors ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMaintenance3Properties, maxMemoryAllocationSize ) == offsetof( VkPhysicalDeviceMaintenance3Properties, maxMemoryAllocationSize ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;

  struct DescriptorSetLayoutSupport
  {
    operator VkDescriptorSetLayoutSupport const&() const
    {
      return *reinterpret_cast<const VkDescriptorSetLayoutSupport*>(this);
    }

    operator VkDescriptorSetLayoutSupport &()
    {
      return *reinterpret_cast<VkDescriptorSetLayoutSupport*>(this);
    }

    bool operator==( DescriptorSetLayoutSupport const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( supported == rhs.supported );
    }

    bool operator!=( DescriptorSetLayoutSupport const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorSetLayoutSupport;
    void* pNext = nullptr;
    Bool32 supported = 0;
  };
  static_assert( sizeof( DescriptorSetLayoutSupport ) == sizeof( VkDescriptorSetLayoutSupport ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorSetLayoutSupport, pNext ) == offsetof( VkDescriptorSetLayoutSupport, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutSupport, supported ) == offsetof( VkDescriptorSetLayoutSupport, supported ), "struct member and wrapper member have different offset!" );

  using DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;

  struct PhysicalDeviceShaderDrawParameterFeatures
  {
    operator VkPhysicalDeviceShaderDrawParameterFeatures const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderDrawParameterFeatures*>(this);
    }

    operator VkPhysicalDeviceShaderDrawParameterFeatures &()
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderDrawParameterFeatures*>(this);
    }

    bool operator==( PhysicalDeviceShaderDrawParameterFeatures const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( shaderDrawParameters == rhs.shaderDrawParameters );
    }

    bool operator!=( PhysicalDeviceShaderDrawParameterFeatures const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceShaderDrawParameterFeatures;
    void* pNext = nullptr;
    Bool32 shaderDrawParameters = 0;
  };
  static_assert( sizeof( PhysicalDeviceShaderDrawParameterFeatures ) == sizeof( VkPhysicalDeviceShaderDrawParameterFeatures ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceShaderDrawParameterFeatures, pNext ) == offsetof( VkPhysicalDeviceShaderDrawParameterFeatures, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderDrawParameterFeatures, shaderDrawParameters ) == offsetof( VkPhysicalDeviceShaderDrawParameterFeatures, shaderDrawParameters ), "struct member and wrapper member have different offset!" );

  struct DebugUtilsLabelEXT
  {
    operator VkDebugUtilsLabelEXT const&() const
    {
      return *reinterpret_cast<const VkDebugUtilsLabelEXT*>(this);
    }

    operator VkDebugUtilsLabelEXT &()
    {
      return *reinterpret_cast<VkDebugUtilsLabelEXT*>(this);
    }

    bool operator==( DebugUtilsLabelEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( pLabelName == rhs.pLabelName )
          && ( color == rhs.color );
    }

    bool operator!=( DebugUtilsLabelEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDebugUtilsLabelEXT;
    const void* pNext = nullptr;
    const char* pLabelName = nullptr;
    std::array<float, 4> color = { { 0, 0, 0, 0 } };
  };
  static_assert( sizeof( DebugUtilsLabelEXT ) == sizeof( VkDebugUtilsLabelEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DebugUtilsLabelEXT, pNext ) == offsetof( VkDebugUtilsLabelEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsLabelEXT, pLabelName ) == offsetof( VkDebugUtilsLabelEXT, pLabelName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsLabelEXT, color ) == offsetof( VkDebugUtilsLabelEXT, color ), "struct member and wrapper member have different offset!" );

  struct MemoryHostPointerPropertiesEXT
  {
    operator VkMemoryHostPointerPropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkMemoryHostPointerPropertiesEXT*>(this);
    }

    operator VkMemoryHostPointerPropertiesEXT &()
    {
      return *reinterpret_cast<VkMemoryHostPointerPropertiesEXT*>(this);
    }

    bool operator==( MemoryHostPointerPropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( MemoryHostPointerPropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryHostPointerPropertiesEXT;
    void* pNext = nullptr;
    uint32_t memoryTypeBits = 0;
  };
  static_assert( sizeof( MemoryHostPointerPropertiesEXT ) == sizeof( VkMemoryHostPointerPropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryHostPointerPropertiesEXT, pNext ) == offsetof( VkMemoryHostPointerPropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryHostPointerPropertiesEXT, memoryTypeBits ) == offsetof( VkMemoryHostPointerPropertiesEXT, memoryTypeBits ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceExternalMemoryHostPropertiesEXT
  {
    operator VkPhysicalDeviceExternalMemoryHostPropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(this);
    }

    operator VkPhysicalDeviceExternalMemoryHostPropertiesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(this);
    }

    bool operator==( PhysicalDeviceExternalMemoryHostPropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( minImportedHostPointerAlignment == rhs.minImportedHostPointerAlignment );
    }

    bool operator!=( PhysicalDeviceExternalMemoryHostPropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceExternalMemoryHostPropertiesEXT;
    void* pNext = nullptr;
    DeviceSize minImportedHostPointerAlignment = 0;
  };
  static_assert( sizeof( PhysicalDeviceExternalMemoryHostPropertiesEXT ) == sizeof( VkPhysicalDeviceExternalMemoryHostPropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceExternalMemoryHostPropertiesEXT, pNext ) == offsetof( VkPhysicalDeviceExternalMemoryHostPropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceExternalMemoryHostPropertiesEXT, minImportedHostPointerAlignment ) == offsetof( VkPhysicalDeviceExternalMemoryHostPropertiesEXT, minImportedHostPointerAlignment ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceConservativeRasterizationPropertiesEXT
  {
    operator VkPhysicalDeviceConservativeRasterizationPropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(this);
    }

    operator VkPhysicalDeviceConservativeRasterizationPropertiesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(this);
    }

    bool operator==( PhysicalDeviceConservativeRasterizationPropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( primitiveOverestimationSize == rhs.primitiveOverestimationSize )
          && ( maxExtraPrimitiveOverestimationSize == rhs.maxExtraPrimitiveOverestimationSize )
          && ( extraPrimitiveOverestimationSizeGranularity == rhs.extraPrimitiveOverestimationSizeGranularity )
          && ( primitiveUnderestimation == rhs.primitiveUnderestimation )
          && ( conservativePointAndLineRasterization == rhs.conservativePointAndLineRasterization )
          && ( degenerateTrianglesRasterized == rhs.degenerateTrianglesRasterized )
          && ( degenerateLinesRasterized == rhs.degenerateLinesRasterized )
          && ( fullyCoveredFragmentShaderInputVariable == rhs.fullyCoveredFragmentShaderInputVariable )
          && ( conservativeRasterizationPostDepthCoverage == rhs.conservativeRasterizationPostDepthCoverage );
    }

    bool operator!=( PhysicalDeviceConservativeRasterizationPropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceConservativeRasterizationPropertiesEXT;
    void* pNext = nullptr;
    float primitiveOverestimationSize = 0;
    float maxExtraPrimitiveOverestimationSize = 0;
    float extraPrimitiveOverestimationSizeGranularity = 0;
    Bool32 primitiveUnderestimation = 0;
    Bool32 conservativePointAndLineRasterization = 0;
    Bool32 degenerateTrianglesRasterized = 0;
    Bool32 degenerateLinesRasterized = 0;
    Bool32 fullyCoveredFragmentShaderInputVariable = 0;
    Bool32 conservativeRasterizationPostDepthCoverage = 0;
  };
  static_assert( sizeof( PhysicalDeviceConservativeRasterizationPropertiesEXT ) == sizeof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, pNext ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, primitiveOverestimationSize ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, primitiveOverestimationSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, maxExtraPrimitiveOverestimationSize ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, maxExtraPrimitiveOverestimationSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, extraPrimitiveOverestimationSizeGranularity ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, extraPrimitiveOverestimationSizeGranularity ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, primitiveUnderestimation ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, primitiveUnderestimation ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, conservativePointAndLineRasterization ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, conservativePointAndLineRasterization ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, degenerateTrianglesRasterized ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, degenerateTrianglesRasterized ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, degenerateLinesRasterized ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, degenerateLinesRasterized ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, fullyCoveredFragmentShaderInputVariable ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, fullyCoveredFragmentShaderInputVariable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConservativeRasterizationPropertiesEXT, conservativeRasterizationPostDepthCoverage ) == offsetof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT, conservativeRasterizationPostDepthCoverage ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceShaderCorePropertiesAMD
  {
    operator VkPhysicalDeviceShaderCorePropertiesAMD const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(this);
    }

    operator VkPhysicalDeviceShaderCorePropertiesAMD &()
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(this);
    }

    bool operator==( PhysicalDeviceShaderCorePropertiesAMD const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( shaderEngineCount == rhs.shaderEngineCount )
          && ( shaderArraysPerEngineCount == rhs.shaderArraysPerEngineCount )
          && ( computeUnitsPerShaderArray == rhs.computeUnitsPerShaderArray )
          && ( simdPerComputeUnit == rhs.simdPerComputeUnit )
          && ( wavefrontsPerSimd == rhs.wavefrontsPerSimd )
          && ( wavefrontSize == rhs.wavefrontSize )
          && ( sgprsPerSimd == rhs.sgprsPerSimd )
          && ( minSgprAllocation == rhs.minSgprAllocation )
          && ( maxSgprAllocation == rhs.maxSgprAllocation )
          && ( sgprAllocationGranularity == rhs.sgprAllocationGranularity )
          && ( vgprsPerSimd == rhs.vgprsPerSimd )
          && ( minVgprAllocation == rhs.minVgprAllocation )
          && ( maxVgprAllocation == rhs.maxVgprAllocation )
          && ( vgprAllocationGranularity == rhs.vgprAllocationGranularity );
    }

    bool operator!=( PhysicalDeviceShaderCorePropertiesAMD const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceShaderCorePropertiesAMD;
    void* pNext = nullptr;
    uint32_t shaderEngineCount = 0;
    uint32_t shaderArraysPerEngineCount = 0;
    uint32_t computeUnitsPerShaderArray = 0;
    uint32_t simdPerComputeUnit = 0;
    uint32_t wavefrontsPerSimd = 0;
    uint32_t wavefrontSize = 0;
    uint32_t sgprsPerSimd = 0;
    uint32_t minSgprAllocation = 0;
    uint32_t maxSgprAllocation = 0;
    uint32_t sgprAllocationGranularity = 0;
    uint32_t vgprsPerSimd = 0;
    uint32_t minVgprAllocation = 0;
    uint32_t maxVgprAllocation = 0;
    uint32_t vgprAllocationGranularity = 0;
  };
  static_assert( sizeof( PhysicalDeviceShaderCorePropertiesAMD ) == sizeof( VkPhysicalDeviceShaderCorePropertiesAMD ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, pNext ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, shaderEngineCount ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, shaderEngineCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, shaderArraysPerEngineCount ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, shaderArraysPerEngineCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, computeUnitsPerShaderArray ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, computeUnitsPerShaderArray ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, simdPerComputeUnit ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, simdPerComputeUnit ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, wavefrontsPerSimd ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, wavefrontsPerSimd ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, wavefrontSize ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, wavefrontSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, sgprsPerSimd ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, sgprsPerSimd ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, minSgprAllocation ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, minSgprAllocation ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, maxSgprAllocation ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, maxSgprAllocation ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, sgprAllocationGranularity ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, sgprAllocationGranularity ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, vgprsPerSimd ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, vgprsPerSimd ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, minVgprAllocation ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, minVgprAllocation ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, maxVgprAllocation ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, maxVgprAllocation ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderCorePropertiesAMD, vgprAllocationGranularity ) == offsetof( VkPhysicalDeviceShaderCorePropertiesAMD, vgprAllocationGranularity ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceDescriptorIndexingFeaturesEXT
  {
    operator VkPhysicalDeviceDescriptorIndexingFeaturesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(this);
    }

    operator VkPhysicalDeviceDescriptorIndexingFeaturesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(this);
    }

    bool operator==( PhysicalDeviceDescriptorIndexingFeaturesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( shaderInputAttachmentArrayDynamicIndexing == rhs.shaderInputAttachmentArrayDynamicIndexing )
          && ( shaderUniformTexelBufferArrayDynamicIndexing == rhs.shaderUniformTexelBufferArrayDynamicIndexing )
          && ( shaderStorageTexelBufferArrayDynamicIndexing == rhs.shaderStorageTexelBufferArrayDynamicIndexing )
          && ( shaderUniformBufferArrayNonUniformIndexing == rhs.shaderUniformBufferArrayNonUniformIndexing )
          && ( shaderSampledImageArrayNonUniformIndexing == rhs.shaderSampledImageArrayNonUniformIndexing )
          && ( shaderStorageBufferArrayNonUniformIndexing == rhs.shaderStorageBufferArrayNonUniformIndexing )
          && ( shaderStorageImageArrayNonUniformIndexing == rhs.shaderStorageImageArrayNonUniformIndexing )
          && ( shaderInputAttachmentArrayNonUniformIndexing == rhs.shaderInputAttachmentArrayNonUniformIndexing )
          && ( shaderUniformTexelBufferArrayNonUniformIndexing == rhs.shaderUniformTexelBufferArrayNonUniformIndexing )
          && ( shaderStorageTexelBufferArrayNonUniformIndexing == rhs.shaderStorageTexelBufferArrayNonUniformIndexing )
          && ( descriptorBindingUniformBufferUpdateAfterBind == rhs.descriptorBindingUniformBufferUpdateAfterBind )
          && ( descriptorBindingSampledImageUpdateAfterBind == rhs.descriptorBindingSampledImageUpdateAfterBind )
          && ( descriptorBindingStorageImageUpdateAfterBind == rhs.descriptorBindingStorageImageUpdateAfterBind )
          && ( descriptorBindingStorageBufferUpdateAfterBind == rhs.descriptorBindingStorageBufferUpdateAfterBind )
          && ( descriptorBindingUniformTexelBufferUpdateAfterBind == rhs.descriptorBindingUniformTexelBufferUpdateAfterBind )
          && ( descriptorBindingStorageTexelBufferUpdateAfterBind == rhs.descriptorBindingStorageTexelBufferUpdateAfterBind )
          && ( descriptorBindingUpdateUnusedWhilePending == rhs.descriptorBindingUpdateUnusedWhilePending )
          && ( descriptorBindingPartiallyBound == rhs.descriptorBindingPartiallyBound )
          && ( descriptorBindingVariableDescriptorCount == rhs.descriptorBindingVariableDescriptorCount )
          && ( runtimeDescriptorArray == rhs.runtimeDescriptorArray );
    }

    bool operator!=( PhysicalDeviceDescriptorIndexingFeaturesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceDescriptorIndexingFeaturesEXT;
    void* pNext = nullptr;
    Bool32 shaderInputAttachmentArrayDynamicIndexing = 0;
    Bool32 shaderUniformTexelBufferArrayDynamicIndexing = 0;
    Bool32 shaderStorageTexelBufferArrayDynamicIndexing = 0;
    Bool32 shaderUniformBufferArrayNonUniformIndexing = 0;
    Bool32 shaderSampledImageArrayNonUniformIndexing = 0;
    Bool32 shaderStorageBufferArrayNonUniformIndexing = 0;
    Bool32 shaderStorageImageArrayNonUniformIndexing = 0;
    Bool32 shaderInputAttachmentArrayNonUniformIndexing = 0;
    Bool32 shaderUniformTexelBufferArrayNonUniformIndexing = 0;
    Bool32 shaderStorageTexelBufferArrayNonUniformIndexing = 0;
    Bool32 descriptorBindingUniformBufferUpdateAfterBind = 0;
    Bool32 descriptorBindingSampledImageUpdateAfterBind = 0;
    Bool32 descriptorBindingStorageImageUpdateAfterBind = 0;
    Bool32 descriptorBindingStorageBufferUpdateAfterBind = 0;
    Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind = 0;
    Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind = 0;
    Bool32 descriptorBindingUpdateUnusedWhilePending = 0;
    Bool32 descriptorBindingPartiallyBound = 0;
    Bool32 descriptorBindingVariableDescriptorCount = 0;
    Bool32 runtimeDescriptorArray = 0;
  };
  static_assert( sizeof( PhysicalDeviceDescriptorIndexingFeaturesEXT ) == sizeof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, pNext ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderInputAttachmentArrayDynamicIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderInputAttachmentArrayDynamicIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderUniformTexelBufferArrayDynamicIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderUniformTexelBufferArrayDynamicIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderStorageTexelBufferArrayDynamicIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderStorageTexelBufferArrayDynamicIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderUniformBufferArrayNonUniformIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderUniformBufferArrayNonUniformIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderSampledImageArrayNonUniformIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderSampledImageArrayNonUniformIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderStorageBufferArrayNonUniformIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderStorageBufferArrayNonUniformIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderStorageImageArrayNonUniformIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderStorageImageArrayNonUniformIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderInputAttachmentArrayNonUniformIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderInputAttachmentArrayNonUniformIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderUniformTexelBufferArrayNonUniformIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderUniformTexelBufferArrayNonUniformIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, shaderStorageTexelBufferArrayNonUniformIndexing ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, shaderStorageTexelBufferArrayNonUniformIndexing ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingUniformBufferUpdateAfterBind ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingUniformBufferUpdateAfterBind ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingSampledImageUpdateAfterBind ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingSampledImageUpdateAfterBind ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingStorageImageUpdateAfterBind ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingStorageImageUpdateAfterBind ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingStorageBufferUpdateAfterBind ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingStorageBufferUpdateAfterBind ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingUniformTexelBufferUpdateAfterBind ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingUniformTexelBufferUpdateAfterBind ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingStorageTexelBufferUpdateAfterBind ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingStorageTexelBufferUpdateAfterBind ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingUpdateUnusedWhilePending ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingUpdateUnusedWhilePending ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingPartiallyBound ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingPartiallyBound ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingVariableDescriptorCount ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, descriptorBindingVariableDescriptorCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingFeaturesEXT, runtimeDescriptorArray ) == offsetof( VkPhysicalDeviceDescriptorIndexingFeaturesEXT, runtimeDescriptorArray ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceDescriptorIndexingPropertiesEXT
  {
    operator VkPhysicalDeviceDescriptorIndexingPropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(this);
    }

    operator VkPhysicalDeviceDescriptorIndexingPropertiesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(this);
    }

    bool operator==( PhysicalDeviceDescriptorIndexingPropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxUpdateAfterBindDescriptorsInAllPools == rhs.maxUpdateAfterBindDescriptorsInAllPools )
          && ( shaderUniformBufferArrayNonUniformIndexingNative == rhs.shaderUniformBufferArrayNonUniformIndexingNative )
          && ( shaderSampledImageArrayNonUniformIndexingNative == rhs.shaderSampledImageArrayNonUniformIndexingNative )
          && ( shaderStorageBufferArrayNonUniformIndexingNative == rhs.shaderStorageBufferArrayNonUniformIndexingNative )
          && ( shaderStorageImageArrayNonUniformIndexingNative == rhs.shaderStorageImageArrayNonUniformIndexingNative )
          && ( shaderInputAttachmentArrayNonUniformIndexingNative == rhs.shaderInputAttachmentArrayNonUniformIndexingNative )
          && ( robustBufferAccessUpdateAfterBind == rhs.robustBufferAccessUpdateAfterBind )
          && ( quadDivergentImplicitLod == rhs.quadDivergentImplicitLod )
          && ( maxPerStageDescriptorUpdateAfterBindSamplers == rhs.maxPerStageDescriptorUpdateAfterBindSamplers )
          && ( maxPerStageDescriptorUpdateAfterBindUniformBuffers == rhs.maxPerStageDescriptorUpdateAfterBindUniformBuffers )
          && ( maxPerStageDescriptorUpdateAfterBindStorageBuffers == rhs.maxPerStageDescriptorUpdateAfterBindStorageBuffers )
          && ( maxPerStageDescriptorUpdateAfterBindSampledImages == rhs.maxPerStageDescriptorUpdateAfterBindSampledImages )
          && ( maxPerStageDescriptorUpdateAfterBindStorageImages == rhs.maxPerStageDescriptorUpdateAfterBindStorageImages )
          && ( maxPerStageDescriptorUpdateAfterBindInputAttachments == rhs.maxPerStageDescriptorUpdateAfterBindInputAttachments )
          && ( maxPerStageUpdateAfterBindResources == rhs.maxPerStageUpdateAfterBindResources )
          && ( maxDescriptorSetUpdateAfterBindSamplers == rhs.maxDescriptorSetUpdateAfterBindSamplers )
          && ( maxDescriptorSetUpdateAfterBindUniformBuffers == rhs.maxDescriptorSetUpdateAfterBindUniformBuffers )
          && ( maxDescriptorSetUpdateAfterBindUniformBuffersDynamic == rhs.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic )
          && ( maxDescriptorSetUpdateAfterBindStorageBuffers == rhs.maxDescriptorSetUpdateAfterBindStorageBuffers )
          && ( maxDescriptorSetUpdateAfterBindStorageBuffersDynamic == rhs.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic )
          && ( maxDescriptorSetUpdateAfterBindSampledImages == rhs.maxDescriptorSetUpdateAfterBindSampledImages )
          && ( maxDescriptorSetUpdateAfterBindStorageImages == rhs.maxDescriptorSetUpdateAfterBindStorageImages )
          && ( maxDescriptorSetUpdateAfterBindInputAttachments == rhs.maxDescriptorSetUpdateAfterBindInputAttachments );
    }

    bool operator!=( PhysicalDeviceDescriptorIndexingPropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceDescriptorIndexingPropertiesEXT;
    void* pNext = nullptr;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools = 0;
    Bool32 shaderUniformBufferArrayNonUniformIndexingNative = 0;
    Bool32 shaderSampledImageArrayNonUniformIndexingNative = 0;
    Bool32 shaderStorageBufferArrayNonUniformIndexingNative = 0;
    Bool32 shaderStorageImageArrayNonUniformIndexingNative = 0;
    Bool32 shaderInputAttachmentArrayNonUniformIndexingNative = 0;
    Bool32 robustBufferAccessUpdateAfterBind = 0;
    Bool32 quadDivergentImplicitLod = 0;
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers = 0;
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers = 0;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers = 0;
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages = 0;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages = 0;
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments = 0;
    uint32_t maxPerStageUpdateAfterBindResources = 0;
    uint32_t maxDescriptorSetUpdateAfterBindSamplers = 0;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers = 0;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = 0;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers = 0;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = 0;
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages = 0;
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages = 0;
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments = 0;
  };
  static_assert( sizeof( PhysicalDeviceDescriptorIndexingPropertiesEXT ) == sizeof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, pNext ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxUpdateAfterBindDescriptorsInAllPools ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxUpdateAfterBindDescriptorsInAllPools ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, shaderUniformBufferArrayNonUniformIndexingNative ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, shaderUniformBufferArrayNonUniformIndexingNative ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, shaderSampledImageArrayNonUniformIndexingNative ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, shaderSampledImageArrayNonUniformIndexingNative ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, shaderStorageBufferArrayNonUniformIndexingNative ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, shaderStorageBufferArrayNonUniformIndexingNative ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, shaderStorageImageArrayNonUniformIndexingNative ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, shaderStorageImageArrayNonUniformIndexingNative ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, shaderInputAttachmentArrayNonUniformIndexingNative ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, shaderInputAttachmentArrayNonUniformIndexingNative ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, robustBufferAccessUpdateAfterBind ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, robustBufferAccessUpdateAfterBind ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, quadDivergentImplicitLod ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, quadDivergentImplicitLod ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindSamplers ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindSamplers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindUniformBuffers ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindUniformBuffers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindStorageBuffers ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindStorageBuffers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindSampledImages ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindSampledImages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindStorageImages ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindStorageImages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindInputAttachments ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageDescriptorUpdateAfterBindInputAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageUpdateAfterBindResources ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxPerStageUpdateAfterBindResources ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindSamplers ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindSamplers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindUniformBuffers ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindUniformBuffers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindUniformBuffersDynamic ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindUniformBuffersDynamic ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindStorageBuffers ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindStorageBuffers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindStorageBuffersDynamic ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindStorageBuffersDynamic ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindSampledImages ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindSampledImages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindStorageImages ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindStorageImages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindInputAttachments ) == offsetof( VkPhysicalDeviceDescriptorIndexingPropertiesEXT, maxDescriptorSetUpdateAfterBindInputAttachments ), "struct member and wrapper member have different offset!" );

  struct DescriptorSetVariableDescriptorCountAllocateInfoEXT
  {
    operator VkDescriptorSetVariableDescriptorCountAllocateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(this);
    }

    operator VkDescriptorSetVariableDescriptorCountAllocateInfoEXT &()
    {
      return *reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(this);
    }

    bool operator==( DescriptorSetVariableDescriptorCountAllocateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( descriptorSetCount == rhs.descriptorSetCount )
          && ( pDescriptorCounts == rhs.pDescriptorCounts );
    }

    bool operator!=( DescriptorSetVariableDescriptorCountAllocateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorSetVariableDescriptorCountAllocateInfoEXT;
    const void* pNext = nullptr;
    uint32_t descriptorSetCount = 0;
    const uint32_t* pDescriptorCounts = nullptr;
  };
  static_assert( sizeof( DescriptorSetVariableDescriptorCountAllocateInfoEXT ) == sizeof( VkDescriptorSetVariableDescriptorCountAllocateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorSetVariableDescriptorCountAllocateInfoEXT, pNext ) == offsetof( VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetVariableDescriptorCountAllocateInfoEXT, descriptorSetCount ) == offsetof( VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, descriptorSetCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetVariableDescriptorCountAllocateInfoEXT, pDescriptorCounts ) == offsetof( VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, pDescriptorCounts ), "struct member and wrapper member have different offset!" );

  struct DescriptorSetVariableDescriptorCountLayoutSupportEXT
  {
    operator VkDescriptorSetVariableDescriptorCountLayoutSupportEXT const&() const
    {
      return *reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(this);
    }

    operator VkDescriptorSetVariableDescriptorCountLayoutSupportEXT &()
    {
      return *reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(this);
    }

    bool operator==( DescriptorSetVariableDescriptorCountLayoutSupportEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxVariableDescriptorCount == rhs.maxVariableDescriptorCount );
    }

    bool operator!=( DescriptorSetVariableDescriptorCountLayoutSupportEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorSetVariableDescriptorCountLayoutSupportEXT;
    void* pNext = nullptr;
    uint32_t maxVariableDescriptorCount = 0;
  };
  static_assert( sizeof( DescriptorSetVariableDescriptorCountLayoutSupportEXT ) == sizeof( VkDescriptorSetVariableDescriptorCountLayoutSupportEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorSetVariableDescriptorCountLayoutSupportEXT, pNext ) == offsetof( VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetVariableDescriptorCountLayoutSupportEXT, maxVariableDescriptorCount ) == offsetof( VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, maxVariableDescriptorCount ), "struct member and wrapper member have different offset!" );

  struct SubpassEndInfoKHR
  {
    operator VkSubpassEndInfoKHR const&() const
    {
      return *reinterpret_cast<const VkSubpassEndInfoKHR*>(this);
    }

    operator VkSubpassEndInfoKHR &()
    {
      return *reinterpret_cast<VkSubpassEndInfoKHR*>(this);
    }

    bool operator==( SubpassEndInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext );
    }

    bool operator!=( SubpassEndInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSubpassEndInfoKHR;
    const void* pNext = nullptr;
  };
  static_assert( sizeof( SubpassEndInfoKHR ) == sizeof( VkSubpassEndInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SubpassEndInfoKHR, pNext ) == offsetof( VkSubpassEndInfoKHR, pNext ), "struct member and wrapper member have different offset!" );

  struct PipelineVertexInputDivisorStateCreateInfoEXT
  {
    operator VkPipelineVertexInputDivisorStateCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(this);
    }

    operator VkPipelineVertexInputDivisorStateCreateInfoEXT &()
    {
      return *reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(this);
    }

    bool operator==( PipelineVertexInputDivisorStateCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( vertexBindingDivisorCount == rhs.vertexBindingDivisorCount )
          && ( pVertexBindingDivisors == rhs.pVertexBindingDivisors );
    }

    bool operator!=( PipelineVertexInputDivisorStateCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineVertexInputDivisorStateCreateInfoEXT;
    const void* pNext = nullptr;
    uint32_t vertexBindingDivisorCount = 0;
    const VertexInputBindingDivisorDescriptionEXT* pVertexBindingDivisors = nullptr;
  };
  static_assert( sizeof( PipelineVertexInputDivisorStateCreateInfoEXT ) == sizeof( VkPipelineVertexInputDivisorStateCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineVertexInputDivisorStateCreateInfoEXT, pNext ) == offsetof( VkPipelineVertexInputDivisorStateCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineVertexInputDivisorStateCreateInfoEXT, vertexBindingDivisorCount ) == offsetof( VkPipelineVertexInputDivisorStateCreateInfoEXT, vertexBindingDivisorCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineVertexInputDivisorStateCreateInfoEXT, pVertexBindingDivisors ) == offsetof( VkPipelineVertexInputDivisorStateCreateInfoEXT, pVertexBindingDivisors ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT
  {
    operator VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(this);
    }

    operator VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(this);
    }

    bool operator==( PhysicalDeviceVertexAttributeDivisorPropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxVertexAttribDivisor == rhs.maxVertexAttribDivisor );
    }

    bool operator!=( PhysicalDeviceVertexAttributeDivisorPropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceVertexAttributeDivisorPropertiesEXT;
    void* pNext = nullptr;
    uint32_t maxVertexAttribDivisor = 0;
  };
  static_assert( sizeof( PhysicalDeviceVertexAttributeDivisorPropertiesEXT ) == sizeof( VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceVertexAttributeDivisorPropertiesEXT, pNext ) == offsetof( VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceVertexAttributeDivisorPropertiesEXT, maxVertexAttribDivisor ) == offsetof( VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, maxVertexAttribDivisor ), "struct member and wrapper member have different offset!" );

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  struct ImportAndroidHardwareBufferInfoANDROID
  {
    operator VkImportAndroidHardwareBufferInfoANDROID const&() const
    {
      return *reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(this);
    }

    operator VkImportAndroidHardwareBufferInfoANDROID &()
    {
      return *reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(this);
    }

    bool operator==( ImportAndroidHardwareBufferInfoANDROID const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( buffer == rhs.buffer );
    }

    bool operator!=( ImportAndroidHardwareBufferInfoANDROID const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImportAndroidHardwareBufferInfoANDROID;
    const void* pNext = nullptr;
    struct AHardwareBuffer* buffer = nullptr;
  };
  static_assert( sizeof( ImportAndroidHardwareBufferInfoANDROID ) == sizeof( VkImportAndroidHardwareBufferInfoANDROID ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImportAndroidHardwareBufferInfoANDROID, pNext ) == offsetof( VkImportAndroidHardwareBufferInfoANDROID, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportAndroidHardwareBufferInfoANDROID, buffer ) == offsetof( VkImportAndroidHardwareBufferInfoANDROID, buffer ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  struct AndroidHardwareBufferUsageANDROID
  {
    operator VkAndroidHardwareBufferUsageANDROID const&() const
    {
      return *reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(this);
    }

    operator VkAndroidHardwareBufferUsageANDROID &()
    {
      return *reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(this);
    }

    bool operator==( AndroidHardwareBufferUsageANDROID const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( androidHardwareBufferUsage == rhs.androidHardwareBufferUsage );
    }

    bool operator!=( AndroidHardwareBufferUsageANDROID const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eAndroidHardwareBufferUsageANDROID;
    void* pNext = nullptr;
    uint64_t androidHardwareBufferUsage = 0;
  };
  static_assert( sizeof( AndroidHardwareBufferUsageANDROID ) == sizeof( VkAndroidHardwareBufferUsageANDROID ), "struct and wrapper have different size!" );
  static_assert( offsetof( AndroidHardwareBufferUsageANDROID, pNext ) == offsetof( VkAndroidHardwareBufferUsageANDROID, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferUsageANDROID, androidHardwareBufferUsage ) == offsetof( VkAndroidHardwareBufferUsageANDROID, androidHardwareBufferUsage ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  struct AndroidHardwareBufferPropertiesANDROID
  {
    operator VkAndroidHardwareBufferPropertiesANDROID const&() const
    {
      return *reinterpret_cast<const VkAndroidHardwareBufferPropertiesANDROID*>(this);
    }

    operator VkAndroidHardwareBufferPropertiesANDROID &()
    {
      return *reinterpret_cast<VkAndroidHardwareBufferPropertiesANDROID*>(this);
    }

    bool operator==( AndroidHardwareBufferPropertiesANDROID const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( allocationSize == rhs.allocationSize )
          && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( AndroidHardwareBufferPropertiesANDROID const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eAndroidHardwareBufferPropertiesANDROID;
    void* pNext = nullptr;
    DeviceSize allocationSize = 0;
    uint32_t memoryTypeBits = 0;
  };
  static_assert( sizeof( AndroidHardwareBufferPropertiesANDROID ) == sizeof( VkAndroidHardwareBufferPropertiesANDROID ), "struct and wrapper have different size!" );
  static_assert( offsetof( AndroidHardwareBufferPropertiesANDROID, pNext ) == offsetof( VkAndroidHardwareBufferPropertiesANDROID, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferPropertiesANDROID, allocationSize ) == offsetof( VkAndroidHardwareBufferPropertiesANDROID, allocationSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferPropertiesANDROID, memoryTypeBits ) == offsetof( VkAndroidHardwareBufferPropertiesANDROID, memoryTypeBits ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  struct MemoryGetAndroidHardwareBufferInfoANDROID
  {
    operator VkMemoryGetAndroidHardwareBufferInfoANDROID const&() const
    {
      return *reinterpret_cast<const VkMemoryGetAndroidHardwareBufferInfoANDROID*>(this);
    }

    operator VkMemoryGetAndroidHardwareBufferInfoANDROID &()
    {
      return *reinterpret_cast<VkMemoryGetAndroidHardwareBufferInfoANDROID*>(this);
    }

    bool operator==( MemoryGetAndroidHardwareBufferInfoANDROID const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memory == rhs.memory );
    }

    bool operator!=( MemoryGetAndroidHardwareBufferInfoANDROID const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryGetAndroidHardwareBufferInfoANDROID;
    const void* pNext = nullptr;
    DeviceMemory memory = DeviceMemory();
  };
  static_assert( sizeof( MemoryGetAndroidHardwareBufferInfoANDROID ) == sizeof( VkMemoryGetAndroidHardwareBufferInfoANDROID ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryGetAndroidHardwareBufferInfoANDROID, pNext ) == offsetof( VkMemoryGetAndroidHardwareBufferInfoANDROID, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryGetAndroidHardwareBufferInfoANDROID, memory ) == offsetof( VkMemoryGetAndroidHardwareBufferInfoANDROID, memory ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

  struct CommandBufferInheritanceConditionalRenderingInfoEXT
  {
    operator VkCommandBufferInheritanceConditionalRenderingInfoEXT const&() const
    {
      return *reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(this);
    }

    operator VkCommandBufferInheritanceConditionalRenderingInfoEXT &()
    {
      return *reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(this);
    }

    bool operator==( CommandBufferInheritanceConditionalRenderingInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( conditionalRenderingEnable == rhs.conditionalRenderingEnable );
    }

    bool operator!=( CommandBufferInheritanceConditionalRenderingInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eCommandBufferInheritanceConditionalRenderingInfoEXT;
    const void* pNext = nullptr;
    Bool32 conditionalRenderingEnable = 0;
  };
  static_assert( sizeof( CommandBufferInheritanceConditionalRenderingInfoEXT ) == sizeof( VkCommandBufferInheritanceConditionalRenderingInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( CommandBufferInheritanceConditionalRenderingInfoEXT, pNext ) == offsetof( VkCommandBufferInheritanceConditionalRenderingInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferInheritanceConditionalRenderingInfoEXT, conditionalRenderingEnable ) == offsetof( VkCommandBufferInheritanceConditionalRenderingInfoEXT, conditionalRenderingEnable ), "struct member and wrapper member have different offset!" );

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  struct ExternalFormatANDROID
  {
    operator VkExternalFormatANDROID const&() const
    {
      return *reinterpret_cast<const VkExternalFormatANDROID*>(this);
    }

    operator VkExternalFormatANDROID &()
    {
      return *reinterpret_cast<VkExternalFormatANDROID*>(this);
    }

    bool operator==( ExternalFormatANDROID const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( externalFormat == rhs.externalFormat );
    }

    bool operator!=( ExternalFormatANDROID const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExternalFormatANDROID;
    void* pNext = nullptr;
    uint64_t externalFormat = 0;
  };
  static_assert( sizeof( ExternalFormatANDROID ) == sizeof( VkExternalFormatANDROID ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalFormatANDROID, pNext ) == offsetof( VkExternalFormatANDROID, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalFormatANDROID, externalFormat ) == offsetof( VkExternalFormatANDROID, externalFormat ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

  struct PhysicalDevice8BitStorageFeaturesKHR
  {
    operator VkPhysicalDevice8BitStorageFeaturesKHR const&() const
    {
      return *reinterpret_cast<const VkPhysicalDevice8BitStorageFeaturesKHR*>(this);
    }

    operator VkPhysicalDevice8BitStorageFeaturesKHR &()
    {
      return *reinterpret_cast<VkPhysicalDevice8BitStorageFeaturesKHR*>(this);
    }

    bool operator==( PhysicalDevice8BitStorageFeaturesKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( storageBuffer8BitAccess == rhs.storageBuffer8BitAccess )
          && ( uniformAndStorageBuffer8BitAccess == rhs.uniformAndStorageBuffer8BitAccess )
          && ( storagePushConstant8 == rhs.storagePushConstant8 );
    }

    bool operator!=( PhysicalDevice8BitStorageFeaturesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDevice8BitStorageFeaturesKHR;
    void* pNext = nullptr;
    Bool32 storageBuffer8BitAccess = 0;
    Bool32 uniformAndStorageBuffer8BitAccess = 0;
    Bool32 storagePushConstant8 = 0;
  };
  static_assert( sizeof( PhysicalDevice8BitStorageFeaturesKHR ) == sizeof( VkPhysicalDevice8BitStorageFeaturesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDevice8BitStorageFeaturesKHR, pNext ) == offsetof( VkPhysicalDevice8BitStorageFeaturesKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDevice8BitStorageFeaturesKHR, storageBuffer8BitAccess ) == offsetof( VkPhysicalDevice8BitStorageFeaturesKHR, storageBuffer8BitAccess ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDevice8BitStorageFeaturesKHR, uniformAndStorageBuffer8BitAccess ) == offsetof( VkPhysicalDevice8BitStorageFeaturesKHR, uniformAndStorageBuffer8BitAccess ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDevice8BitStorageFeaturesKHR, storagePushConstant8 ) == offsetof( VkPhysicalDevice8BitStorageFeaturesKHR, storagePushConstant8 ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceConditionalRenderingFeaturesEXT
  {
    operator VkPhysicalDeviceConditionalRenderingFeaturesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(this);
    }

    operator VkPhysicalDeviceConditionalRenderingFeaturesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(this);
    }

    bool operator==( PhysicalDeviceConditionalRenderingFeaturesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( conditionalRendering == rhs.conditionalRendering )
          && ( inheritedConditionalRendering == rhs.inheritedConditionalRendering );
    }

    bool operator!=( PhysicalDeviceConditionalRenderingFeaturesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceConditionalRenderingFeaturesEXT;
    void* pNext = nullptr;
    Bool32 conditionalRendering = 0;
    Bool32 inheritedConditionalRendering = 0;
  };
  static_assert( sizeof( PhysicalDeviceConditionalRenderingFeaturesEXT ) == sizeof( VkPhysicalDeviceConditionalRenderingFeaturesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceConditionalRenderingFeaturesEXT, pNext ) == offsetof( VkPhysicalDeviceConditionalRenderingFeaturesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConditionalRenderingFeaturesEXT, conditionalRendering ) == offsetof( VkPhysicalDeviceConditionalRenderingFeaturesEXT, conditionalRendering ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceConditionalRenderingFeaturesEXT, inheritedConditionalRendering ) == offsetof( VkPhysicalDeviceConditionalRenderingFeaturesEXT, inheritedConditionalRendering ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceVulkanMemoryModelFeaturesKHR
  {
    operator VkPhysicalDeviceVulkanMemoryModelFeaturesKHR const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceVulkanMemoryModelFeaturesKHR*>(this);
    }

    operator VkPhysicalDeviceVulkanMemoryModelFeaturesKHR &()
    {
      return *reinterpret_cast<VkPhysicalDeviceVulkanMemoryModelFeaturesKHR*>(this);
    }

    bool operator==( PhysicalDeviceVulkanMemoryModelFeaturesKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( vulkanMemoryModel == rhs.vulkanMemoryModel )
          && ( vulkanMemoryModelDeviceScope == rhs.vulkanMemoryModelDeviceScope );
    }

    bool operator!=( PhysicalDeviceVulkanMemoryModelFeaturesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceVulkanMemoryModelFeaturesKHR;
    void* pNext = nullptr;
    Bool32 vulkanMemoryModel = 0;
    Bool32 vulkanMemoryModelDeviceScope = 0;
  };
  static_assert( sizeof( PhysicalDeviceVulkanMemoryModelFeaturesKHR ) == sizeof( VkPhysicalDeviceVulkanMemoryModelFeaturesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceVulkanMemoryModelFeaturesKHR, pNext ) == offsetof( VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceVulkanMemoryModelFeaturesKHR, vulkanMemoryModel ) == offsetof( VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, vulkanMemoryModel ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceVulkanMemoryModelFeaturesKHR, vulkanMemoryModelDeviceScope ) == offsetof( VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, vulkanMemoryModelDeviceScope ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT
  {
    operator VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(this);
    }

    operator VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(this);
    }

    bool operator==( PhysicalDeviceVertexAttributeDivisorFeaturesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( vertexAttributeInstanceRateDivisor == rhs.vertexAttributeInstanceRateDivisor )
          && ( vertexAttributeInstanceRateZeroDivisor == rhs.vertexAttributeInstanceRateZeroDivisor );
    }

    bool operator!=( PhysicalDeviceVertexAttributeDivisorFeaturesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceVertexAttributeDivisorFeaturesEXT;
    void* pNext = nullptr;
    Bool32 vertexAttributeInstanceRateDivisor = 0;
    Bool32 vertexAttributeInstanceRateZeroDivisor = 0;
  };
  static_assert( sizeof( PhysicalDeviceVertexAttributeDivisorFeaturesEXT ) == sizeof( VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceVertexAttributeDivisorFeaturesEXT, pNext ) == offsetof( VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceVertexAttributeDivisorFeaturesEXT, vertexAttributeInstanceRateDivisor ) == offsetof( VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, vertexAttributeInstanceRateDivisor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceVertexAttributeDivisorFeaturesEXT, vertexAttributeInstanceRateZeroDivisor ) == offsetof( VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, vertexAttributeInstanceRateZeroDivisor ), "struct member and wrapper member have different offset!" );

  struct ImageViewASTCDecodeModeEXT
  {
    operator VkImageViewASTCDecodeModeEXT const&() const
    {
      return *reinterpret_cast<const VkImageViewASTCDecodeModeEXT*>(this);
    }

    operator VkImageViewASTCDecodeModeEXT &()
    {
      return *reinterpret_cast<VkImageViewASTCDecodeModeEXT*>(this);
    }

    bool operator==( ImageViewASTCDecodeModeEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( decodeMode == rhs.decodeMode );
    }

    bool operator!=( ImageViewASTCDecodeModeEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageViewAstcDecodeModeEXT;
    const void* pNext = nullptr;
    Format decodeMode = Format::eUndefined;
  };
  static_assert( sizeof( ImageViewASTCDecodeModeEXT ) == sizeof( VkImageViewASTCDecodeModeEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageViewASTCDecodeModeEXT, pNext ) == offsetof( VkImageViewASTCDecodeModeEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageViewASTCDecodeModeEXT, decodeMode ) == offsetof( VkImageViewASTCDecodeModeEXT, decodeMode ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceASTCDecodeFeaturesEXT
  {
    operator VkPhysicalDeviceASTCDecodeFeaturesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT*>(this);
    }

    operator VkPhysicalDeviceASTCDecodeFeaturesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceASTCDecodeFeaturesEXT*>(this);
    }

    bool operator==( PhysicalDeviceASTCDecodeFeaturesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( decodeModeSharedExponent == rhs.decodeModeSharedExponent );
    }

    bool operator!=( PhysicalDeviceASTCDecodeFeaturesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceAstcDecodeFeaturesEXT;
    void* pNext = nullptr;
    Bool32 decodeModeSharedExponent = 0;
  };
  static_assert( sizeof( PhysicalDeviceASTCDecodeFeaturesEXT ) == sizeof( VkPhysicalDeviceASTCDecodeFeaturesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceASTCDecodeFeaturesEXT, pNext ) == offsetof( VkPhysicalDeviceASTCDecodeFeaturesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceASTCDecodeFeaturesEXT, decodeModeSharedExponent ) == offsetof( VkPhysicalDeviceASTCDecodeFeaturesEXT, decodeModeSharedExponent ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV
  {
    operator VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(this);
    }

    operator VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(this);
    }

    bool operator==( PhysicalDeviceRepresentativeFragmentTestFeaturesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( representativeFragmentTest == rhs.representativeFragmentTest );
    }

    bool operator!=( PhysicalDeviceRepresentativeFragmentTestFeaturesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceRepresentativeFragmentTestFeaturesNV;
    void* pNext = nullptr;
    Bool32 representativeFragmentTest = 0;
  };
  static_assert( sizeof( PhysicalDeviceRepresentativeFragmentTestFeaturesNV ) == sizeof( VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceRepresentativeFragmentTestFeaturesNV, pNext ) == offsetof( VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceRepresentativeFragmentTestFeaturesNV, representativeFragmentTest ) == offsetof( VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, representativeFragmentTest ), "struct member and wrapper member have different offset!" );

  struct PipelineRepresentativeFragmentTestStateCreateInfoNV
  {
    operator VkPipelineRepresentativeFragmentTestStateCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(this);
    }

    operator VkPipelineRepresentativeFragmentTestStateCreateInfoNV &()
    {
      return *reinterpret_cast<VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(this);
    }

    bool operator==( PipelineRepresentativeFragmentTestStateCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( representativeFragmentTestEnable == rhs.representativeFragmentTestEnable );
    }

    bool operator!=( PipelineRepresentativeFragmentTestStateCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineRepresentativeFragmentTestStateCreateInfoNV;
    const void* pNext = nullptr;
    Bool32 representativeFragmentTestEnable = 0;
  };
  static_assert( sizeof( PipelineRepresentativeFragmentTestStateCreateInfoNV ) == sizeof( VkPipelineRepresentativeFragmentTestStateCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineRepresentativeFragmentTestStateCreateInfoNV, pNext ) == offsetof( VkPipelineRepresentativeFragmentTestStateCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRepresentativeFragmentTestStateCreateInfoNV, representativeFragmentTestEnable ) == offsetof( VkPipelineRepresentativeFragmentTestStateCreateInfoNV, representativeFragmentTestEnable ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceExclusiveScissorFeaturesNV
  {
    operator VkPhysicalDeviceExclusiveScissorFeaturesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV*>(this);
    }

    operator VkPhysicalDeviceExclusiveScissorFeaturesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceExclusiveScissorFeaturesNV*>(this);
    }

    bool operator==( PhysicalDeviceExclusiveScissorFeaturesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( exclusiveScissor == rhs.exclusiveScissor );
    }

    bool operator!=( PhysicalDeviceExclusiveScissorFeaturesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceExclusiveScissorFeaturesNV;
    void* pNext = nullptr;
    Bool32 exclusiveScissor = 0;
  };
  static_assert( sizeof( PhysicalDeviceExclusiveScissorFeaturesNV ) == sizeof( VkPhysicalDeviceExclusiveScissorFeaturesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceExclusiveScissorFeaturesNV, pNext ) == offsetof( VkPhysicalDeviceExclusiveScissorFeaturesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceExclusiveScissorFeaturesNV, exclusiveScissor ) == offsetof( VkPhysicalDeviceExclusiveScissorFeaturesNV, exclusiveScissor ), "struct member and wrapper member have different offset!" );

  struct PipelineViewportExclusiveScissorStateCreateInfoNV
  {
    operator VkPipelineViewportExclusiveScissorStateCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(this);
    }

    operator VkPipelineViewportExclusiveScissorStateCreateInfoNV &()
    {
      return *reinterpret_cast<VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(this);
    }

    bool operator==( PipelineViewportExclusiveScissorStateCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( exclusiveScissorCount == rhs.exclusiveScissorCount )
          && ( pExclusiveScissors == rhs.pExclusiveScissors );
    }

    bool operator!=( PipelineViewportExclusiveScissorStateCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineViewportExclusiveScissorStateCreateInfoNV;
    const void* pNext = nullptr;
    uint32_t exclusiveScissorCount = 0;
    const Rect2D* pExclusiveScissors = nullptr;
  };
  static_assert( sizeof( PipelineViewportExclusiveScissorStateCreateInfoNV ) == sizeof( VkPipelineViewportExclusiveScissorStateCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineViewportExclusiveScissorStateCreateInfoNV, pNext ) == offsetof( VkPipelineViewportExclusiveScissorStateCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportExclusiveScissorStateCreateInfoNV, exclusiveScissorCount ) == offsetof( VkPipelineViewportExclusiveScissorStateCreateInfoNV, exclusiveScissorCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportExclusiveScissorStateCreateInfoNV, pExclusiveScissors ) == offsetof( VkPipelineViewportExclusiveScissorStateCreateInfoNV, pExclusiveScissors ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceCornerSampledImageFeaturesNV
  {
    operator VkPhysicalDeviceCornerSampledImageFeaturesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV*>(this);
    }

    operator VkPhysicalDeviceCornerSampledImageFeaturesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceCornerSampledImageFeaturesNV*>(this);
    }

    bool operator==( PhysicalDeviceCornerSampledImageFeaturesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( cornerSampledImage == rhs.cornerSampledImage );
    }

    bool operator!=( PhysicalDeviceCornerSampledImageFeaturesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceCornerSampledImageFeaturesNV;
    void* pNext = nullptr;
    Bool32 cornerSampledImage = 0;
  };
  static_assert( sizeof( PhysicalDeviceCornerSampledImageFeaturesNV ) == sizeof( VkPhysicalDeviceCornerSampledImageFeaturesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceCornerSampledImageFeaturesNV, pNext ) == offsetof( VkPhysicalDeviceCornerSampledImageFeaturesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceCornerSampledImageFeaturesNV, cornerSampledImage ) == offsetof( VkPhysicalDeviceCornerSampledImageFeaturesNV, cornerSampledImage ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceComputeShaderDerivativesFeaturesNV
  {
    operator VkPhysicalDeviceComputeShaderDerivativesFeaturesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(this);
    }

    operator VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(this);
    }

    bool operator==( PhysicalDeviceComputeShaderDerivativesFeaturesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( computeDerivativeGroupQuads == rhs.computeDerivativeGroupQuads )
          && ( computeDerivativeGroupLinear == rhs.computeDerivativeGroupLinear );
    }

    bool operator!=( PhysicalDeviceComputeShaderDerivativesFeaturesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceComputeShaderDerivativesFeaturesNV;
    void* pNext = nullptr;
    Bool32 computeDerivativeGroupQuads = 0;
    Bool32 computeDerivativeGroupLinear = 0;
  };
  static_assert( sizeof( PhysicalDeviceComputeShaderDerivativesFeaturesNV ) == sizeof( VkPhysicalDeviceComputeShaderDerivativesFeaturesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceComputeShaderDerivativesFeaturesNV, pNext ) == offsetof( VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceComputeShaderDerivativesFeaturesNV, computeDerivativeGroupQuads ) == offsetof( VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, computeDerivativeGroupQuads ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceComputeShaderDerivativesFeaturesNV, computeDerivativeGroupLinear ) == offsetof( VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, computeDerivativeGroupLinear ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceFragmentShaderBarycentricFeaturesNV
  {
    operator VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(this);
    }

    operator VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(this);
    }

    bool operator==( PhysicalDeviceFragmentShaderBarycentricFeaturesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( fragmentShaderBarycentric == rhs.fragmentShaderBarycentric );
    }

    bool operator!=( PhysicalDeviceFragmentShaderBarycentricFeaturesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceFragmentShaderBarycentricFeaturesNV;
    void* pNext = nullptr;
    Bool32 fragmentShaderBarycentric = 0;
  };
  static_assert( sizeof( PhysicalDeviceFragmentShaderBarycentricFeaturesNV ) == sizeof( VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceFragmentShaderBarycentricFeaturesNV, pNext ) == offsetof( VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceFragmentShaderBarycentricFeaturesNV, fragmentShaderBarycentric ) == offsetof( VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, fragmentShaderBarycentric ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceShaderImageFootprintFeaturesNV
  {
    operator VkPhysicalDeviceShaderImageFootprintFeaturesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(this);
    }

    operator VkPhysicalDeviceShaderImageFootprintFeaturesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(this);
    }

    bool operator==( PhysicalDeviceShaderImageFootprintFeaturesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( imageFootprint == rhs.imageFootprint );
    }

    bool operator!=( PhysicalDeviceShaderImageFootprintFeaturesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceShaderImageFootprintFeaturesNV;
    void* pNext = nullptr;
    Bool32 imageFootprint = 0;
  };
  static_assert( sizeof( PhysicalDeviceShaderImageFootprintFeaturesNV ) == sizeof( VkPhysicalDeviceShaderImageFootprintFeaturesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceShaderImageFootprintFeaturesNV, pNext ) == offsetof( VkPhysicalDeviceShaderImageFootprintFeaturesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShaderImageFootprintFeaturesNV, imageFootprint ) == offsetof( VkPhysicalDeviceShaderImageFootprintFeaturesNV, imageFootprint ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceShadingRateImageFeaturesNV
  {
    operator VkPhysicalDeviceShadingRateImageFeaturesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV*>(this);
    }

    operator VkPhysicalDeviceShadingRateImageFeaturesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceShadingRateImageFeaturesNV*>(this);
    }

    bool operator==( PhysicalDeviceShadingRateImageFeaturesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( shadingRateImage == rhs.shadingRateImage )
          && ( shadingRateCoarseSampleOrder == rhs.shadingRateCoarseSampleOrder );
    }

    bool operator!=( PhysicalDeviceShadingRateImageFeaturesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceShadingRateImageFeaturesNV;
    void* pNext = nullptr;
    Bool32 shadingRateImage = 0;
    Bool32 shadingRateCoarseSampleOrder = 0;
  };
  static_assert( sizeof( PhysicalDeviceShadingRateImageFeaturesNV ) == sizeof( VkPhysicalDeviceShadingRateImageFeaturesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceShadingRateImageFeaturesNV, pNext ) == offsetof( VkPhysicalDeviceShadingRateImageFeaturesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShadingRateImageFeaturesNV, shadingRateImage ) == offsetof( VkPhysicalDeviceShadingRateImageFeaturesNV, shadingRateImage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShadingRateImageFeaturesNV, shadingRateCoarseSampleOrder ) == offsetof( VkPhysicalDeviceShadingRateImageFeaturesNV, shadingRateCoarseSampleOrder ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceShadingRateImagePropertiesNV
  {
    operator VkPhysicalDeviceShadingRateImagePropertiesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceShadingRateImagePropertiesNV*>(this);
    }

    operator VkPhysicalDeviceShadingRateImagePropertiesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceShadingRateImagePropertiesNV*>(this);
    }

    bool operator==( PhysicalDeviceShadingRateImagePropertiesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( shadingRateTexelSize == rhs.shadingRateTexelSize )
          && ( shadingRatePaletteSize == rhs.shadingRatePaletteSize )
          && ( shadingRateMaxCoarseSamples == rhs.shadingRateMaxCoarseSamples );
    }

    bool operator!=( PhysicalDeviceShadingRateImagePropertiesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceShadingRateImagePropertiesNV;
    void* pNext = nullptr;
    Extent2D shadingRateTexelSize = Extent2D();
    uint32_t shadingRatePaletteSize = 0;
    uint32_t shadingRateMaxCoarseSamples = 0;
  };
  static_assert( sizeof( PhysicalDeviceShadingRateImagePropertiesNV ) == sizeof( VkPhysicalDeviceShadingRateImagePropertiesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceShadingRateImagePropertiesNV, pNext ) == offsetof( VkPhysicalDeviceShadingRateImagePropertiesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShadingRateImagePropertiesNV, shadingRateTexelSize ) == offsetof( VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRateTexelSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShadingRateImagePropertiesNV, shadingRatePaletteSize ) == offsetof( VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRatePaletteSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceShadingRateImagePropertiesNV, shadingRateMaxCoarseSamples ) == offsetof( VkPhysicalDeviceShadingRateImagePropertiesNV, shadingRateMaxCoarseSamples ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceMeshShaderFeaturesNV
  {
    operator VkPhysicalDeviceMeshShaderFeaturesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceMeshShaderFeaturesNV*>(this);
    }

    operator VkPhysicalDeviceMeshShaderFeaturesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceMeshShaderFeaturesNV*>(this);
    }

    bool operator==( PhysicalDeviceMeshShaderFeaturesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( taskShader == rhs.taskShader )
          && ( meshShader == rhs.meshShader );
    }

    bool operator!=( PhysicalDeviceMeshShaderFeaturesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceMeshShaderFeaturesNV;
    void* pNext = nullptr;
    Bool32 taskShader = 0;
    Bool32 meshShader = 0;
  };
  static_assert( sizeof( PhysicalDeviceMeshShaderFeaturesNV ) == sizeof( VkPhysicalDeviceMeshShaderFeaturesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderFeaturesNV, pNext ) == offsetof( VkPhysicalDeviceMeshShaderFeaturesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderFeaturesNV, taskShader ) == offsetof( VkPhysicalDeviceMeshShaderFeaturesNV, taskShader ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderFeaturesNV, meshShader ) == offsetof( VkPhysicalDeviceMeshShaderFeaturesNV, meshShader ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceMeshShaderPropertiesNV
  {
    operator VkPhysicalDeviceMeshShaderPropertiesNV const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceMeshShaderPropertiesNV*>(this);
    }

    operator VkPhysicalDeviceMeshShaderPropertiesNV &()
    {
      return *reinterpret_cast<VkPhysicalDeviceMeshShaderPropertiesNV*>(this);
    }

    bool operator==( PhysicalDeviceMeshShaderPropertiesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( maxDrawMeshTasksCount == rhs.maxDrawMeshTasksCount )
          && ( maxTaskWorkGroupInvocations == rhs.maxTaskWorkGroupInvocations )
          && ( maxTaskWorkGroupSize == rhs.maxTaskWorkGroupSize )
          && ( maxTaskTotalMemorySize == rhs.maxTaskTotalMemorySize )
          && ( maxTaskOutputCount == rhs.maxTaskOutputCount )
          && ( maxMeshWorkGroupInvocations == rhs.maxMeshWorkGroupInvocations )
          && ( maxMeshWorkGroupSize == rhs.maxMeshWorkGroupSize )
          && ( maxMeshTotalMemorySize == rhs.maxMeshTotalMemorySize )
          && ( maxMeshOutputVertices == rhs.maxMeshOutputVertices )
          && ( maxMeshOutputPrimitives == rhs.maxMeshOutputPrimitives )
          && ( maxMeshMultiviewViewCount == rhs.maxMeshMultiviewViewCount )
          && ( meshOutputPerVertexGranularity == rhs.meshOutputPerVertexGranularity )
          && ( meshOutputPerPrimitiveGranularity == rhs.meshOutputPerPrimitiveGranularity );
    }

    bool operator!=( PhysicalDeviceMeshShaderPropertiesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceMeshShaderPropertiesNV;
    void* pNext = nullptr;
    uint32_t maxDrawMeshTasksCount = 0;
    uint32_t maxTaskWorkGroupInvocations = 0;
    std::array<uint32_t, 3> maxTaskWorkGroupSize = { { 0, 0, 0 } };
    uint32_t maxTaskTotalMemorySize = 0;
    uint32_t maxTaskOutputCount = 0;
    uint32_t maxMeshWorkGroupInvocations = 0;
    std::array<uint32_t, 3> maxMeshWorkGroupSize = { { 0, 0, 0 } };
    uint32_t maxMeshTotalMemorySize = 0;
    uint32_t maxMeshOutputVertices = 0;
    uint32_t maxMeshOutputPrimitives = 0;
    uint32_t maxMeshMultiviewViewCount = 0;
    uint32_t meshOutputPerVertexGranularity = 0;
    uint32_t meshOutputPerPrimitiveGranularity = 0;
  };
  static_assert( sizeof( PhysicalDeviceMeshShaderPropertiesNV ) == sizeof( VkPhysicalDeviceMeshShaderPropertiesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, pNext ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxDrawMeshTasksCount ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxDrawMeshTasksCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupInvocations ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupInvocations ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupSize ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskWorkGroupSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxTaskTotalMemorySize ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskTotalMemorySize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxTaskOutputCount ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxTaskOutputCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupInvocations ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupInvocations ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupSize ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshWorkGroupSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxMeshTotalMemorySize ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshTotalMemorySize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxMeshOutputVertices ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshOutputVertices ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxMeshOutputPrimitives ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshOutputPrimitives ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, maxMeshMultiviewViewCount ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, maxMeshMultiviewViewCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, meshOutputPerVertexGranularity ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, meshOutputPerVertexGranularity ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMeshShaderPropertiesNV, meshOutputPerPrimitiveGranularity ) == offsetof( VkPhysicalDeviceMeshShaderPropertiesNV, meshOutputPerPrimitiveGranularity ), "struct member and wrapper member have different offset!" );

  struct GeometryTrianglesNVX
  {
    operator VkGeometryTrianglesNVX const&() const
    {
      return *reinterpret_cast<const VkGeometryTrianglesNVX*>(this);
    }

    operator VkGeometryTrianglesNVX &()
    {
      return *reinterpret_cast<VkGeometryTrianglesNVX*>(this);
    }

    bool operator==( GeometryTrianglesNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( vertexData == rhs.vertexData )
          && ( vertexOffset == rhs.vertexOffset )
          && ( vertexCount == rhs.vertexCount )
          && ( vertexStride == rhs.vertexStride )
          && ( vertexFormat == rhs.vertexFormat )
          && ( indexData == rhs.indexData )
          && ( indexOffset == rhs.indexOffset )
          && ( indexCount == rhs.indexCount )
          && ( indexType == rhs.indexType )
          && ( transformData == rhs.transformData )
          && ( transformOffset == rhs.transformOffset );
    }

    bool operator!=( GeometryTrianglesNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eGeometryTrianglesNVX;
    const void* pNext = nullptr;
    Buffer vertexData = Buffer();
    DeviceSize vertexOffset = 0;
    uint32_t vertexCount = 0;
    DeviceSize vertexStride = 0;
    Format vertexFormat = Format::eUndefined;
    Buffer indexData = Buffer();
    DeviceSize indexOffset = 0;
    uint32_t indexCount = 0;
    IndexType indexType = IndexType::eUint16;
    Buffer transformData = Buffer();
    DeviceSize transformOffset = 0;
  };
  static_assert( sizeof( GeometryTrianglesNVX ) == sizeof( VkGeometryTrianglesNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( GeometryTrianglesNVX, pNext ) == offsetof( VkGeometryTrianglesNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, vertexData ) == offsetof( VkGeometryTrianglesNVX, vertexData ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, vertexOffset ) == offsetof( VkGeometryTrianglesNVX, vertexOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, vertexCount ) == offsetof( VkGeometryTrianglesNVX, vertexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, vertexStride ) == offsetof( VkGeometryTrianglesNVX, vertexStride ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, vertexFormat ) == offsetof( VkGeometryTrianglesNVX, vertexFormat ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, indexData ) == offsetof( VkGeometryTrianglesNVX, indexData ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, indexOffset ) == offsetof( VkGeometryTrianglesNVX, indexOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, indexCount ) == offsetof( VkGeometryTrianglesNVX, indexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, indexType ) == offsetof( VkGeometryTrianglesNVX, indexType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, transformData ) == offsetof( VkGeometryTrianglesNVX, transformData ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryTrianglesNVX, transformOffset ) == offsetof( VkGeometryTrianglesNVX, transformOffset ), "struct member and wrapper member have different offset!" );

  struct GeometryAABBNVX
  {
    operator VkGeometryAABBNVX const&() const
    {
      return *reinterpret_cast<const VkGeometryAABBNVX*>(this);
    }

    operator VkGeometryAABBNVX &()
    {
      return *reinterpret_cast<VkGeometryAABBNVX*>(this);
    }

    bool operator==( GeometryAABBNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( aabbData == rhs.aabbData )
          && ( numAABBs == rhs.numAABBs )
          && ( stride == rhs.stride )
          && ( offset == rhs.offset );
    }

    bool operator!=( GeometryAABBNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eGeometryAabbNVX;
    const void* pNext = nullptr;
    Buffer aabbData = Buffer();
    uint32_t numAABBs = 0;
    uint32_t stride = 0;
    DeviceSize offset = 0;
  };
  static_assert( sizeof( GeometryAABBNVX ) == sizeof( VkGeometryAABBNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( GeometryAABBNVX, pNext ) == offsetof( VkGeometryAABBNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryAABBNVX, aabbData ) == offsetof( VkGeometryAABBNVX, aabbData ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryAABBNVX, numAABBs ) == offsetof( VkGeometryAABBNVX, numAABBs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryAABBNVX, stride ) == offsetof( VkGeometryAABBNVX, stride ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryAABBNVX, offset ) == offsetof( VkGeometryAABBNVX, offset ), "struct member and wrapper member have different offset!" );

  struct GeometryDataNVX
  {
    operator VkGeometryDataNVX const&() const
    {
      return *reinterpret_cast<const VkGeometryDataNVX*>(this);
    }

    operator VkGeometryDataNVX &()
    {
      return *reinterpret_cast<VkGeometryDataNVX*>(this);
    }

    bool operator==( GeometryDataNVX const& rhs ) const
    {
      return ( triangles == rhs.triangles )
          && ( aabbs == rhs.aabbs );
    }

    bool operator!=( GeometryDataNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    GeometryTrianglesNVX triangles = GeometryTrianglesNVX();
    GeometryAABBNVX aabbs = GeometryAABBNVX();
  };
  static_assert( sizeof( GeometryDataNVX ) == sizeof( VkGeometryDataNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( GeometryDataNVX, triangles ) == offsetof( VkGeometryDataNVX, triangles ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryDataNVX, aabbs ) == offsetof( VkGeometryDataNVX, aabbs ), "struct member and wrapper member have different offset!" );

  struct BindAccelerationStructureMemoryInfoNVX
  {
    operator VkBindAccelerationStructureMemoryInfoNVX const&() const
    {
      return *reinterpret_cast<const VkBindAccelerationStructureMemoryInfoNVX*>(this);
    }

    operator VkBindAccelerationStructureMemoryInfoNVX &()
    {
      return *reinterpret_cast<VkBindAccelerationStructureMemoryInfoNVX*>(this);
    }

    bool operator==( BindAccelerationStructureMemoryInfoNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( accelerationStructure == rhs.accelerationStructure )
          && ( memory == rhs.memory )
          && ( memoryOffset == rhs.memoryOffset )
          && ( deviceIndexCount == rhs.deviceIndexCount )
          && ( pDeviceIndices == rhs.pDeviceIndices );
    }

    bool operator!=( BindAccelerationStructureMemoryInfoNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBindAccelerationStructureMemoryInfoNVX;
    const void* pNext = nullptr;
    AccelerationStructureNVX accelerationStructure = AccelerationStructureNVX();
    DeviceMemory memory = DeviceMemory();
    DeviceSize memoryOffset = 0;
    uint32_t deviceIndexCount = 0;
    const uint32_t* pDeviceIndices = nullptr;
  };
  static_assert( sizeof( BindAccelerationStructureMemoryInfoNVX ) == sizeof( VkBindAccelerationStructureMemoryInfoNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( BindAccelerationStructureMemoryInfoNVX, pNext ) == offsetof( VkBindAccelerationStructureMemoryInfoNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindAccelerationStructureMemoryInfoNVX, accelerationStructure ) == offsetof( VkBindAccelerationStructureMemoryInfoNVX, accelerationStructure ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindAccelerationStructureMemoryInfoNVX, memory ) == offsetof( VkBindAccelerationStructureMemoryInfoNVX, memory ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindAccelerationStructureMemoryInfoNVX, memoryOffset ) == offsetof( VkBindAccelerationStructureMemoryInfoNVX, memoryOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindAccelerationStructureMemoryInfoNVX, deviceIndexCount ) == offsetof( VkBindAccelerationStructureMemoryInfoNVX, deviceIndexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindAccelerationStructureMemoryInfoNVX, pDeviceIndices ) == offsetof( VkBindAccelerationStructureMemoryInfoNVX, pDeviceIndices ), "struct member and wrapper member have different offset!" );

  struct DescriptorAccelerationStructureInfoNVX
  {
    operator VkDescriptorAccelerationStructureInfoNVX const&() const
    {
      return *reinterpret_cast<const VkDescriptorAccelerationStructureInfoNVX*>(this);
    }

    operator VkDescriptorAccelerationStructureInfoNVX &()
    {
      return *reinterpret_cast<VkDescriptorAccelerationStructureInfoNVX*>(this);
    }

    bool operator==( DescriptorAccelerationStructureInfoNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( accelerationStructureCount == rhs.accelerationStructureCount )
          && ( pAccelerationStructures == rhs.pAccelerationStructures );
    }

    bool operator!=( DescriptorAccelerationStructureInfoNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorAccelerationStructureInfoNVX;
    const void* pNext = nullptr;
    uint32_t accelerationStructureCount = 0;
    const AccelerationStructureNVX* pAccelerationStructures = nullptr;
  };
  static_assert( sizeof( DescriptorAccelerationStructureInfoNVX ) == sizeof( VkDescriptorAccelerationStructureInfoNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorAccelerationStructureInfoNVX, pNext ) == offsetof( VkDescriptorAccelerationStructureInfoNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorAccelerationStructureInfoNVX, accelerationStructureCount ) == offsetof( VkDescriptorAccelerationStructureInfoNVX, accelerationStructureCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorAccelerationStructureInfoNVX, pAccelerationStructures ) == offsetof( VkDescriptorAccelerationStructureInfoNVX, pAccelerationStructures ), "struct member and wrapper member have different offset!" );

  struct AccelerationStructureMemoryRequirementsInfoNVX
  {
    operator VkAccelerationStructureMemoryRequirementsInfoNVX const&() const
    {
      return *reinterpret_cast<const VkAccelerationStructureMemoryRequirementsInfoNVX*>(this);
    }

    operator VkAccelerationStructureMemoryRequirementsInfoNVX &()
    {
      return *reinterpret_cast<VkAccelerationStructureMemoryRequirementsInfoNVX*>(this);
    }

    bool operator==( AccelerationStructureMemoryRequirementsInfoNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( accelerationStructure == rhs.accelerationStructure );
    }

    bool operator!=( AccelerationStructureMemoryRequirementsInfoNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eAccelerationStructureMemoryRequirementsInfoNVX;
    const void* pNext = nullptr;
    AccelerationStructureNVX accelerationStructure = AccelerationStructureNVX();
  };
  static_assert( sizeof( AccelerationStructureMemoryRequirementsInfoNVX ) == sizeof( VkAccelerationStructureMemoryRequirementsInfoNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( AccelerationStructureMemoryRequirementsInfoNVX, pNext ) == offsetof( VkAccelerationStructureMemoryRequirementsInfoNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AccelerationStructureMemoryRequirementsInfoNVX, accelerationStructure ) == offsetof( VkAccelerationStructureMemoryRequirementsInfoNVX, accelerationStructure ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceRaytracingPropertiesNVX
  {
    operator VkPhysicalDeviceRaytracingPropertiesNVX const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceRaytracingPropertiesNVX*>(this);
    }

    operator VkPhysicalDeviceRaytracingPropertiesNVX &()
    {
      return *reinterpret_cast<VkPhysicalDeviceRaytracingPropertiesNVX*>(this);
    }

    bool operator==( PhysicalDeviceRaytracingPropertiesNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( shaderHeaderSize == rhs.shaderHeaderSize )
          && ( maxRecursionDepth == rhs.maxRecursionDepth )
          && ( maxGeometryCount == rhs.maxGeometryCount );
    }

    bool operator!=( PhysicalDeviceRaytracingPropertiesNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceRaytracingPropertiesNVX;
    void* pNext = nullptr;
    uint32_t shaderHeaderSize = 0;
    uint32_t maxRecursionDepth = 0;
    uint32_t maxGeometryCount = 0;
  };
  static_assert( sizeof( PhysicalDeviceRaytracingPropertiesNVX ) == sizeof( VkPhysicalDeviceRaytracingPropertiesNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceRaytracingPropertiesNVX, pNext ) == offsetof( VkPhysicalDeviceRaytracingPropertiesNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceRaytracingPropertiesNVX, shaderHeaderSize ) == offsetof( VkPhysicalDeviceRaytracingPropertiesNVX, shaderHeaderSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceRaytracingPropertiesNVX, maxRecursionDepth ) == offsetof( VkPhysicalDeviceRaytracingPropertiesNVX, maxRecursionDepth ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceRaytracingPropertiesNVX, maxGeometryCount ) == offsetof( VkPhysicalDeviceRaytracingPropertiesNVX, maxGeometryCount ), "struct member and wrapper member have different offset!" );

  enum class SubpassContents
  {
    eInline = VK_SUBPASS_CONTENTS_INLINE,
    eSecondaryCommandBuffers = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS
  };

  struct SubpassBeginInfoKHR
  {
    operator VkSubpassBeginInfoKHR const&() const
    {
      return *reinterpret_cast<const VkSubpassBeginInfoKHR*>(this);
    }

    operator VkSubpassBeginInfoKHR &()
    {
      return *reinterpret_cast<VkSubpassBeginInfoKHR*>(this);
    }

    bool operator==( SubpassBeginInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( contents == rhs.contents );
    }

    bool operator!=( SubpassBeginInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSubpassBeginInfoKHR;
    const void* pNext = nullptr;
    SubpassContents contents = SubpassContents::eInline;
  };
  static_assert( sizeof( SubpassBeginInfoKHR ) == sizeof( VkSubpassBeginInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SubpassBeginInfoKHR, pNext ) == offsetof( VkSubpassBeginInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassBeginInfoKHR, contents ) == offsetof( VkSubpassBeginInfoKHR, contents ), "struct member and wrapper member have different offset!" );

  struct PresentInfoKHR
  {
    operator VkPresentInfoKHR const&() const
    {
      return *reinterpret_cast<const VkPresentInfoKHR*>(this);
    }

    operator VkPresentInfoKHR &()
    {
      return *reinterpret_cast<VkPresentInfoKHR*>(this);
    }

    bool operator==( PresentInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( waitSemaphoreCount == rhs.waitSemaphoreCount )
          && ( pWaitSemaphores == rhs.pWaitSemaphores )
          && ( swapchainCount == rhs.swapchainCount )
          && ( pSwapchains == rhs.pSwapchains )
          && ( pImageIndices == rhs.pImageIndices )
          && ( pResults == rhs.pResults );
    }

    bool operator!=( PresentInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePresentInfoKHR;
    const void* pNext = nullptr;
    uint32_t waitSemaphoreCount = 0;
    const Semaphore* pWaitSemaphores = nullptr;
    uint32_t swapchainCount = 0;
    const SwapchainKHR* pSwapchains = nullptr;
    const uint32_t* pImageIndices = nullptr;
    Result* pResults = nullptr;
  };
  static_assert( sizeof( PresentInfoKHR ) == sizeof( VkPresentInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( PresentInfoKHR, pNext ) == offsetof( VkPresentInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentInfoKHR, waitSemaphoreCount ) == offsetof( VkPresentInfoKHR, waitSemaphoreCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentInfoKHR, pWaitSemaphores ) == offsetof( VkPresentInfoKHR, pWaitSemaphores ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentInfoKHR, swapchainCount ) == offsetof( VkPresentInfoKHR, swapchainCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentInfoKHR, pSwapchains ) == offsetof( VkPresentInfoKHR, pSwapchains ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentInfoKHR, pImageIndices ) == offsetof( VkPresentInfoKHR, pImageIndices ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PresentInfoKHR, pResults ) == offsetof( VkPresentInfoKHR, pResults ), "struct member and wrapper member have different offset!" );

  enum class DynamicState
  {
    eViewport = VK_DYNAMIC_STATE_VIEWPORT,
    eScissor = VK_DYNAMIC_STATE_SCISSOR,
    eLineWidth = VK_DYNAMIC_STATE_LINE_WIDTH,
    eDepthBias = VK_DYNAMIC_STATE_DEPTH_BIAS,
    eBlendConstants = VK_DYNAMIC_STATE_BLEND_CONSTANTS,
    eDepthBounds = VK_DYNAMIC_STATE_DEPTH_BOUNDS,
    eStencilCompareMask = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
    eStencilWriteMask = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
    eStencilReference = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    eViewportWScalingNV = VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV,
    eDiscardRectangleEXT = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
    eSampleLocationsEXT = VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT,
    eViewportShadingRatePaletteNV = VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV,
    eViewportCoarseSampleOrderNV = VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV,
    eExclusiveScissorNV = VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV
  };

  struct PipelineDynamicStateCreateInfo
  {
    operator VkPipelineDynamicStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineDynamicStateCreateInfo*>(this);
    }

    operator VkPipelineDynamicStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineDynamicStateCreateInfo*>(this);
    }

    bool operator==( PipelineDynamicStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( dynamicStateCount == rhs.dynamicStateCount )
          && ( pDynamicStates == rhs.pDynamicStates );
    }

    bool operator!=( PipelineDynamicStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineDynamicStateCreateInfo;
    const void* pNext = nullptr;
    PipelineDynamicStateCreateFlags flags = PipelineDynamicStateCreateFlags();
    uint32_t dynamicStateCount = 0;
    const DynamicState* pDynamicStates = nullptr;
  };
  static_assert( sizeof( PipelineDynamicStateCreateInfo ) == sizeof( VkPipelineDynamicStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineDynamicStateCreateInfo, pNext ) == offsetof( VkPipelineDynamicStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDynamicStateCreateInfo, flags ) == offsetof( VkPipelineDynamicStateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDynamicStateCreateInfo, dynamicStateCount ) == offsetof( VkPipelineDynamicStateCreateInfo, dynamicStateCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDynamicStateCreateInfo, pDynamicStates ) == offsetof( VkPipelineDynamicStateCreateInfo, pDynamicStates ), "struct member and wrapper member have different offset!" );

  enum class DescriptorUpdateTemplateType
  {
    eDescriptorSet = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    eDescriptorSetKHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    ePushDescriptorsKHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
  };

  struct DescriptorUpdateTemplateCreateInfo
  {
    operator VkDescriptorUpdateTemplateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkDescriptorUpdateTemplateCreateInfo*>(this);
    }

    operator VkDescriptorUpdateTemplateCreateInfo &()
    {
      return *reinterpret_cast<VkDescriptorUpdateTemplateCreateInfo*>(this);
    }

    bool operator==( DescriptorUpdateTemplateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( descriptorUpdateEntryCount == rhs.descriptorUpdateEntryCount )
          && ( pDescriptorUpdateEntries == rhs.pDescriptorUpdateEntries )
          && ( templateType == rhs.templateType )
          && ( descriptorSetLayout == rhs.descriptorSetLayout )
          && ( pipelineBindPoint == rhs.pipelineBindPoint )
          && ( pipelineLayout == rhs.pipelineLayout )
          && ( set == rhs.set );
    }

    bool operator!=( DescriptorUpdateTemplateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorUpdateTemplateCreateInfo;
    void* pNext = nullptr;
    DescriptorUpdateTemplateCreateFlags flags = DescriptorUpdateTemplateCreateFlags();
    uint32_t descriptorUpdateEntryCount = 0;
    const DescriptorUpdateTemplateEntry* pDescriptorUpdateEntries = nullptr;
    DescriptorUpdateTemplateType templateType = DescriptorUpdateTemplateType::eDescriptorSet;
    DescriptorSetLayout descriptorSetLayout = DescriptorSetLayout();
    PipelineBindPoint pipelineBindPoint = PipelineBindPoint::eGraphics;
    PipelineLayout pipelineLayout = PipelineLayout();
    uint32_t set = 0;
  };
  static_assert( sizeof( DescriptorUpdateTemplateCreateInfo ) == sizeof( VkDescriptorUpdateTemplateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorUpdateTemplateCreateInfo, pNext ) == offsetof( VkDescriptorUpdateTemplateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateCreateInfo, flags ) == offsetof( VkDescriptorUpdateTemplateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateCreateInfo, descriptorUpdateEntryCount ) == offsetof( VkDescriptorUpdateTemplateCreateInfo, descriptorUpdateEntryCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateCreateInfo, pDescriptorUpdateEntries ) == offsetof( VkDescriptorUpdateTemplateCreateInfo, pDescriptorUpdateEntries ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateCreateInfo, templateType ) == offsetof( VkDescriptorUpdateTemplateCreateInfo, templateType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateCreateInfo, descriptorSetLayout ) == offsetof( VkDescriptorUpdateTemplateCreateInfo, descriptorSetLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateCreateInfo, pipelineBindPoint ) == offsetof( VkDescriptorUpdateTemplateCreateInfo, pipelineBindPoint ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateCreateInfo, pipelineLayout ) == offsetof( VkDescriptorUpdateTemplateCreateInfo, pipelineLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorUpdateTemplateCreateInfo, set ) == offsetof( VkDescriptorUpdateTemplateCreateInfo, set ), "struct member and wrapper member have different offset!" );

  using DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;

  enum class ObjectType
  {
    eUnknown = VK_OBJECT_TYPE_UNKNOWN,
    eInstance = VK_OBJECT_TYPE_INSTANCE,
    ePhysicalDevice = VK_OBJECT_TYPE_PHYSICAL_DEVICE,
    eDevice = VK_OBJECT_TYPE_DEVICE,
    eQueue = VK_OBJECT_TYPE_QUEUE,
    eSemaphore = VK_OBJECT_TYPE_SEMAPHORE,
    eCommandBuffer = VK_OBJECT_TYPE_COMMAND_BUFFER,
    eFence = VK_OBJECT_TYPE_FENCE,
    eDeviceMemory = VK_OBJECT_TYPE_DEVICE_MEMORY,
    eBuffer = VK_OBJECT_TYPE_BUFFER,
    eImage = VK_OBJECT_TYPE_IMAGE,
    eEvent = VK_OBJECT_TYPE_EVENT,
    eQueryPool = VK_OBJECT_TYPE_QUERY_POOL,
    eBufferView = VK_OBJECT_TYPE_BUFFER_VIEW,
    eImageView = VK_OBJECT_TYPE_IMAGE_VIEW,
    eShaderModule = VK_OBJECT_TYPE_SHADER_MODULE,
    ePipelineCache = VK_OBJECT_TYPE_PIPELINE_CACHE,
    ePipelineLayout = VK_OBJECT_TYPE_PIPELINE_LAYOUT,
    eRenderPass = VK_OBJECT_TYPE_RENDER_PASS,
    ePipeline = VK_OBJECT_TYPE_PIPELINE,
    eDescriptorSetLayout = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
    eSampler = VK_OBJECT_TYPE_SAMPLER,
    eDescriptorPool = VK_OBJECT_TYPE_DESCRIPTOR_POOL,
    eDescriptorSet = VK_OBJECT_TYPE_DESCRIPTOR_SET,
    eFramebuffer = VK_OBJECT_TYPE_FRAMEBUFFER,
    eCommandPool = VK_OBJECT_TYPE_COMMAND_POOL,
    eSamplerYcbcrConversion = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    eSamplerYcbcrConversionKHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    eDescriptorUpdateTemplate = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    eDescriptorUpdateTemplateKHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    eSurfaceKHR = VK_OBJECT_TYPE_SURFACE_KHR,
    eSwapchainKHR = VK_OBJECT_TYPE_SWAPCHAIN_KHR,
    eDisplayKHR = VK_OBJECT_TYPE_DISPLAY_KHR,
    eDisplayModeKHR = VK_OBJECT_TYPE_DISPLAY_MODE_KHR,
    eDebugReportCallbackEXT = VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT,
    eObjectTableNVX = VK_OBJECT_TYPE_OBJECT_TABLE_NVX,
    eIndirectCommandsLayoutNVX = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX,
    eDebugUtilsMessengerEXT = VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
    eValidationCacheEXT = VK_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    eAccelerationStructureNVX = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NVX
  };

  struct DebugUtilsObjectNameInfoEXT
  {
    operator VkDebugUtilsObjectNameInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDebugUtilsObjectNameInfoEXT*>(this);
    }

    operator VkDebugUtilsObjectNameInfoEXT &()
    {
      return *reinterpret_cast<VkDebugUtilsObjectNameInfoEXT*>(this);
    }

    bool operator==( DebugUtilsObjectNameInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( objectType == rhs.objectType )
          && ( objectHandle == rhs.objectHandle )
          && ( pObjectName == rhs.pObjectName );
    }

    bool operator!=( DebugUtilsObjectNameInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDebugUtilsObjectNameInfoEXT;
    const void* pNext = nullptr;
    ObjectType objectType = ObjectType::eUnknown;
    uint64_t objectHandle = 0;
    const char* pObjectName = nullptr;
  };
  static_assert( sizeof( DebugUtilsObjectNameInfoEXT ) == sizeof( VkDebugUtilsObjectNameInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DebugUtilsObjectNameInfoEXT, pNext ) == offsetof( VkDebugUtilsObjectNameInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsObjectNameInfoEXT, objectType ) == offsetof( VkDebugUtilsObjectNameInfoEXT, objectType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsObjectNameInfoEXT, objectHandle ) == offsetof( VkDebugUtilsObjectNameInfoEXT, objectHandle ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsObjectNameInfoEXT, pObjectName ) == offsetof( VkDebugUtilsObjectNameInfoEXT, pObjectName ), "struct member and wrapper member have different offset!" );

  struct DebugUtilsObjectTagInfoEXT
  {
    operator VkDebugUtilsObjectTagInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDebugUtilsObjectTagInfoEXT*>(this);
    }

    operator VkDebugUtilsObjectTagInfoEXT &()
    {
      return *reinterpret_cast<VkDebugUtilsObjectTagInfoEXT*>(this);
    }

    bool operator==( DebugUtilsObjectTagInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( objectType == rhs.objectType )
          && ( objectHandle == rhs.objectHandle )
          && ( tagName == rhs.tagName )
          && ( tagSize == rhs.tagSize )
          && ( pTag == rhs.pTag );
    }

    bool operator!=( DebugUtilsObjectTagInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDebugUtilsObjectTagInfoEXT;
    const void* pNext = nullptr;
    ObjectType objectType = ObjectType::eUnknown;
    uint64_t objectHandle = 0;
    uint64_t tagName = 0;
    size_t tagSize = 0;
    const void* pTag = nullptr;
  };
  static_assert( sizeof( DebugUtilsObjectTagInfoEXT ) == sizeof( VkDebugUtilsObjectTagInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DebugUtilsObjectTagInfoEXT, pNext ) == offsetof( VkDebugUtilsObjectTagInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsObjectTagInfoEXT, objectType ) == offsetof( VkDebugUtilsObjectTagInfoEXT, objectType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsObjectTagInfoEXT, objectHandle ) == offsetof( VkDebugUtilsObjectTagInfoEXT, objectHandle ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsObjectTagInfoEXT, tagName ) == offsetof( VkDebugUtilsObjectTagInfoEXT, tagName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsObjectTagInfoEXT, tagSize ) == offsetof( VkDebugUtilsObjectTagInfoEXT, tagSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsObjectTagInfoEXT, pTag ) == offsetof( VkDebugUtilsObjectTagInfoEXT, pTag ), "struct member and wrapper member have different offset!" );

  struct DebugUtilsMessengerCallbackDataEXT
  {
    operator VkDebugUtilsMessengerCallbackDataEXT const&() const
    {
      return *reinterpret_cast<const VkDebugUtilsMessengerCallbackDataEXT*>(this);
    }

    operator VkDebugUtilsMessengerCallbackDataEXT &()
    {
      return *reinterpret_cast<VkDebugUtilsMessengerCallbackDataEXT*>(this);
    }

    bool operator==( DebugUtilsMessengerCallbackDataEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( pMessageIdName == rhs.pMessageIdName )
          && ( messageIdNumber == rhs.messageIdNumber )
          && ( pMessage == rhs.pMessage )
          && ( queueLabelCount == rhs.queueLabelCount )
          && ( pQueueLabels == rhs.pQueueLabels )
          && ( cmdBufLabelCount == rhs.cmdBufLabelCount )
          && ( pCmdBufLabels == rhs.pCmdBufLabels )
          && ( objectCount == rhs.objectCount )
          && ( pObjects == rhs.pObjects );
    }

    bool operator!=( DebugUtilsMessengerCallbackDataEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDebugUtilsMessengerCallbackDataEXT;
    const void* pNext = nullptr;
    DebugUtilsMessengerCallbackDataFlagsEXT flags = DebugUtilsMessengerCallbackDataFlagsEXT();
    const char* pMessageIdName = nullptr;
    int32_t messageIdNumber = 0;
    const char* pMessage = nullptr;
    uint32_t queueLabelCount = 0;
    DebugUtilsLabelEXT* pQueueLabels = nullptr;
    uint32_t cmdBufLabelCount = 0;
    DebugUtilsLabelEXT* pCmdBufLabels = nullptr;
    uint32_t objectCount = 0;
    DebugUtilsObjectNameInfoEXT* pObjects = nullptr;
  };
  static_assert( sizeof( DebugUtilsMessengerCallbackDataEXT ) == sizeof( VkDebugUtilsMessengerCallbackDataEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, pNext ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, flags ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, pMessageIdName ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, pMessageIdName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, messageIdNumber ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, messageIdNumber ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, pMessage ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, pMessage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, queueLabelCount ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, queueLabelCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, pQueueLabels ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, pQueueLabels ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, cmdBufLabelCount ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, cmdBufLabelCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, pCmdBufLabels ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, pCmdBufLabels ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, objectCount ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, objectCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCallbackDataEXT, pObjects ) == offsetof( VkDebugUtilsMessengerCallbackDataEXT, pObjects ), "struct member and wrapper member have different offset!" );

  enum class QueueFlagBits
  {
    eGraphics = VK_QUEUE_GRAPHICS_BIT,
    eCompute = VK_QUEUE_COMPUTE_BIT,
    eTransfer = VK_QUEUE_TRANSFER_BIT,
    eSparseBinding = VK_QUEUE_SPARSE_BINDING_BIT,
    eProtected = VK_QUEUE_PROTECTED_BIT
  };

  using QueueFlags = Flags<QueueFlagBits, VkQueueFlags>;

  VULKAN_HPP_INLINE QueueFlags operator|( QueueFlagBits bit0, QueueFlagBits bit1 )
  {
    return QueueFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE QueueFlags operator~( QueueFlagBits bits )
  {
    return ~( QueueFlags( bits ) );
  }

  template <> struct FlagTraits<QueueFlagBits>
  {
    enum
    {
      allFlags = VkFlags(QueueFlagBits::eGraphics) | VkFlags(QueueFlagBits::eCompute) | VkFlags(QueueFlagBits::eTransfer) | VkFlags(QueueFlagBits::eSparseBinding) | VkFlags(QueueFlagBits::eProtected)
    };
  };

  struct QueueFamilyProperties
  {
    operator VkQueueFamilyProperties const&() const
    {
      return *reinterpret_cast<const VkQueueFamilyProperties*>(this);
    }

    operator VkQueueFamilyProperties &()
    {
      return *reinterpret_cast<VkQueueFamilyProperties*>(this);
    }

    bool operator==( QueueFamilyProperties const& rhs ) const
    {
      return ( queueFlags == rhs.queueFlags )
          && ( queueCount == rhs.queueCount )
          && ( timestampValidBits == rhs.timestampValidBits )
          && ( minImageTransferGranularity == rhs.minImageTransferGranularity );
    }

    bool operator!=( QueueFamilyProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    QueueFlags queueFlags = QueueFlags();
    uint32_t queueCount = 0;
    uint32_t timestampValidBits = 0;
    Extent3D minImageTransferGranularity = Extent3D();
  };
  static_assert( sizeof( QueueFamilyProperties ) == sizeof( VkQueueFamilyProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( QueueFamilyProperties, queueFlags ) == offsetof( VkQueueFamilyProperties, queueFlags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( QueueFamilyProperties, queueCount ) == offsetof( VkQueueFamilyProperties, queueCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( QueueFamilyProperties, timestampValidBits ) == offsetof( VkQueueFamilyProperties, timestampValidBits ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( QueueFamilyProperties, minImageTransferGranularity ) == offsetof( VkQueueFamilyProperties, minImageTransferGranularity ), "struct member and wrapper member have different offset!" );

  struct QueueFamilyProperties2
  {
    operator VkQueueFamilyProperties2 const&() const
    {
      return *reinterpret_cast<const VkQueueFamilyProperties2*>(this);
    }

    operator VkQueueFamilyProperties2 &()
    {
      return *reinterpret_cast<VkQueueFamilyProperties2*>(this);
    }

    bool operator==( QueueFamilyProperties2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( queueFamilyProperties == rhs.queueFamilyProperties );
    }

    bool operator!=( QueueFamilyProperties2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eQueueFamilyProperties2;
    void* pNext = nullptr;
    QueueFamilyProperties queueFamilyProperties = QueueFamilyProperties();
  };
  static_assert( sizeof( QueueFamilyProperties2 ) == sizeof( VkQueueFamilyProperties2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( QueueFamilyProperties2, pNext ) == offsetof( VkQueueFamilyProperties2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( QueueFamilyProperties2, queueFamilyProperties ) == offsetof( VkQueueFamilyProperties2, queueFamilyProperties ), "struct member and wrapper member have different offset!" );

  using QueueFamilyProperties2KHR = QueueFamilyProperties2;

  enum class DeviceQueueCreateFlagBits
  {
    eProtected = VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT
  };

  using DeviceQueueCreateFlags = Flags<DeviceQueueCreateFlagBits, VkDeviceQueueCreateFlags>;

  VULKAN_HPP_INLINE DeviceQueueCreateFlags operator|( DeviceQueueCreateFlagBits bit0, DeviceQueueCreateFlagBits bit1 )
  {
    return DeviceQueueCreateFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DeviceQueueCreateFlags operator~( DeviceQueueCreateFlagBits bits )
  {
    return ~( DeviceQueueCreateFlags( bits ) );
  }

  template <> struct FlagTraits<DeviceQueueCreateFlagBits>
  {
    enum
    {
      allFlags = VkFlags(DeviceQueueCreateFlagBits::eProtected)
    };
  };

  struct DeviceQueueCreateInfo
  {
    operator VkDeviceQueueCreateInfo const&() const
    {
      return *reinterpret_cast<const VkDeviceQueueCreateInfo*>(this);
    }

    operator VkDeviceQueueCreateInfo &()
    {
      return *reinterpret_cast<VkDeviceQueueCreateInfo*>(this);
    }

    bool operator==( DeviceQueueCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( queueFamilyIndex == rhs.queueFamilyIndex )
          && ( queueCount == rhs.queueCount )
          && ( pQueuePriorities == rhs.pQueuePriorities );
    }

    bool operator!=( DeviceQueueCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceQueueCreateInfo;
    const void* pNext = nullptr;
    DeviceQueueCreateFlags flags = DeviceQueueCreateFlags();
    uint32_t queueFamilyIndex = 0;
    uint32_t queueCount = 0;
    const float* pQueuePriorities = nullptr;
  };
  static_assert( sizeof( DeviceQueueCreateInfo ) == sizeof( VkDeviceQueueCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceQueueCreateInfo, pNext ) == offsetof( VkDeviceQueueCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceQueueCreateInfo, flags ) == offsetof( VkDeviceQueueCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceQueueCreateInfo, queueFamilyIndex ) == offsetof( VkDeviceQueueCreateInfo, queueFamilyIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceQueueCreateInfo, queueCount ) == offsetof( VkDeviceQueueCreateInfo, queueCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceQueueCreateInfo, pQueuePriorities ) == offsetof( VkDeviceQueueCreateInfo, pQueuePriorities ), "struct member and wrapper member have different offset!" );

  struct DeviceCreateInfo
  {
    operator VkDeviceCreateInfo const&() const
    {
      return *reinterpret_cast<const VkDeviceCreateInfo*>(this);
    }

    operator VkDeviceCreateInfo &()
    {
      return *reinterpret_cast<VkDeviceCreateInfo*>(this);
    }

    bool operator==( DeviceCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( queueCreateInfoCount == rhs.queueCreateInfoCount )
          && ( pQueueCreateInfos == rhs.pQueueCreateInfos )
          && ( enabledLayerCount == rhs.enabledLayerCount )
          && ( ppEnabledLayerNames == rhs.ppEnabledLayerNames )
          && ( enabledExtensionCount == rhs.enabledExtensionCount )
          && ( ppEnabledExtensionNames == rhs.ppEnabledExtensionNames )
          && ( pEnabledFeatures == rhs.pEnabledFeatures );
    }

    bool operator!=( DeviceCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceCreateInfo;
    const void* pNext = nullptr;
    DeviceCreateFlags flags = DeviceCreateFlags();
    uint32_t queueCreateInfoCount = 0;
    const DeviceQueueCreateInfo* pQueueCreateInfos = nullptr;
    uint32_t enabledLayerCount = 0;
    const char* const* ppEnabledLayerNames = nullptr;
    uint32_t enabledExtensionCount = 0;
    const char* const* ppEnabledExtensionNames = nullptr;
    const PhysicalDeviceFeatures* pEnabledFeatures = nullptr;
  };
  static_assert( sizeof( DeviceCreateInfo ) == sizeof( VkDeviceCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceCreateInfo, pNext ) == offsetof( VkDeviceCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceCreateInfo, flags ) == offsetof( VkDeviceCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceCreateInfo, queueCreateInfoCount ) == offsetof( VkDeviceCreateInfo, queueCreateInfoCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceCreateInfo, pQueueCreateInfos ) == offsetof( VkDeviceCreateInfo, pQueueCreateInfos ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceCreateInfo, enabledLayerCount ) == offsetof( VkDeviceCreateInfo, enabledLayerCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceCreateInfo, ppEnabledLayerNames ) == offsetof( VkDeviceCreateInfo, ppEnabledLayerNames ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceCreateInfo, enabledExtensionCount ) == offsetof( VkDeviceCreateInfo, enabledExtensionCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceCreateInfo, ppEnabledExtensionNames ) == offsetof( VkDeviceCreateInfo, ppEnabledExtensionNames ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceCreateInfo, pEnabledFeatures ) == offsetof( VkDeviceCreateInfo, pEnabledFeatures ), "struct member and wrapper member have different offset!" );

  struct DeviceQueueInfo2
  {
    operator VkDeviceQueueInfo2 const&() const
    {
      return *reinterpret_cast<const VkDeviceQueueInfo2*>(this);
    }

    operator VkDeviceQueueInfo2 &()
    {
      return *reinterpret_cast<VkDeviceQueueInfo2*>(this);
    }

    bool operator==( DeviceQueueInfo2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( queueFamilyIndex == rhs.queueFamilyIndex )
          && ( queueIndex == rhs.queueIndex );
    }

    bool operator!=( DeviceQueueInfo2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceQueueInfo2;
    const void* pNext = nullptr;
    DeviceQueueCreateFlags flags = DeviceQueueCreateFlags();
    uint32_t queueFamilyIndex = 0;
    uint32_t queueIndex = 0;
  };
  static_assert( sizeof( DeviceQueueInfo2 ) == sizeof( VkDeviceQueueInfo2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceQueueInfo2, pNext ) == offsetof( VkDeviceQueueInfo2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceQueueInfo2, flags ) == offsetof( VkDeviceQueueInfo2, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceQueueInfo2, queueFamilyIndex ) == offsetof( VkDeviceQueueInfo2, queueFamilyIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceQueueInfo2, queueIndex ) == offsetof( VkDeviceQueueInfo2, queueIndex ), "struct member and wrapper member have different offset!" );

  enum class MemoryPropertyFlagBits
  {
    eDeviceLocal = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
    eHostVisible = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
    eHostCoherent = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
    eHostCached = VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
    eLazilyAllocated = VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
    eProtected = VK_MEMORY_PROPERTY_PROTECTED_BIT
  };

  using MemoryPropertyFlags = Flags<MemoryPropertyFlagBits, VkMemoryPropertyFlags>;

  VULKAN_HPP_INLINE MemoryPropertyFlags operator|( MemoryPropertyFlagBits bit0, MemoryPropertyFlagBits bit1 )
  {
    return MemoryPropertyFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE MemoryPropertyFlags operator~( MemoryPropertyFlagBits bits )
  {
    return ~( MemoryPropertyFlags( bits ) );
  }

  template <> struct FlagTraits<MemoryPropertyFlagBits>
  {
    enum
    {
      allFlags = VkFlags(MemoryPropertyFlagBits::eDeviceLocal) | VkFlags(MemoryPropertyFlagBits::eHostVisible) | VkFlags(MemoryPropertyFlagBits::eHostCoherent) | VkFlags(MemoryPropertyFlagBits::eHostCached) | VkFlags(MemoryPropertyFlagBits::eLazilyAllocated) | VkFlags(MemoryPropertyFlagBits::eProtected)
    };
  };

  struct MemoryType
  {
    operator VkMemoryType const&() const
    {
      return *reinterpret_cast<const VkMemoryType*>(this);
    }

    operator VkMemoryType &()
    {
      return *reinterpret_cast<VkMemoryType*>(this);
    }

    bool operator==( MemoryType const& rhs ) const
    {
      return ( propertyFlags == rhs.propertyFlags )
          && ( heapIndex == rhs.heapIndex );
    }

    bool operator!=( MemoryType const& rhs ) const
    {
      return !operator==( rhs );
    }

    MemoryPropertyFlags propertyFlags = MemoryPropertyFlags();
    uint32_t heapIndex = 0;
  };
  static_assert( sizeof( MemoryType ) == sizeof( VkMemoryType ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryType, propertyFlags ) == offsetof( VkMemoryType, propertyFlags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryType, heapIndex ) == offsetof( VkMemoryType, heapIndex ), "struct member and wrapper member have different offset!" );

  enum class MemoryHeapFlagBits
  {
    eDeviceLocal = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,
    eMultiInstance = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
    eMultiInstanceKHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT
  };

  using MemoryHeapFlags = Flags<MemoryHeapFlagBits, VkMemoryHeapFlags>;

  VULKAN_HPP_INLINE MemoryHeapFlags operator|( MemoryHeapFlagBits bit0, MemoryHeapFlagBits bit1 )
  {
    return MemoryHeapFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE MemoryHeapFlags operator~( MemoryHeapFlagBits bits )
  {
    return ~( MemoryHeapFlags( bits ) );
  }

  template <> struct FlagTraits<MemoryHeapFlagBits>
  {
    enum
    {
      allFlags = VkFlags(MemoryHeapFlagBits::eDeviceLocal) | VkFlags(MemoryHeapFlagBits::eMultiInstance)
    };
  };

  struct MemoryHeap
  {
    operator VkMemoryHeap const&() const
    {
      return *reinterpret_cast<const VkMemoryHeap*>(this);
    }

    operator VkMemoryHeap &()
    {
      return *reinterpret_cast<VkMemoryHeap*>(this);
    }

    bool operator==( MemoryHeap const& rhs ) const
    {
      return ( size == rhs.size )
          && ( flags == rhs.flags );
    }

    bool operator!=( MemoryHeap const& rhs ) const
    {
      return !operator==( rhs );
    }

    DeviceSize size = 0;
    MemoryHeapFlags flags = MemoryHeapFlags();
  };
  static_assert( sizeof( MemoryHeap ) == sizeof( VkMemoryHeap ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryHeap, size ) == offsetof( VkMemoryHeap, size ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryHeap, flags ) == offsetof( VkMemoryHeap, flags ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceMemoryProperties
  {
    operator VkPhysicalDeviceMemoryProperties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceMemoryProperties*>(this);
    }

    operator VkPhysicalDeviceMemoryProperties &()
    {
      return *reinterpret_cast<VkPhysicalDeviceMemoryProperties*>(this);
    }

    bool operator==( PhysicalDeviceMemoryProperties const& rhs ) const
    {
      return ( memoryTypeCount == rhs.memoryTypeCount )
          && ( memoryTypes == rhs.memoryTypes )
          && ( memoryHeapCount == rhs.memoryHeapCount )
          && ( memoryHeaps == rhs.memoryHeaps );
    }

    bool operator!=( PhysicalDeviceMemoryProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t memoryTypeCount = 0;
    std::array<MemoryType, VK_MAX_MEMORY_TYPES> memoryTypes = { { MemoryType() } };
    uint32_t memoryHeapCount = 0;
    std::array<MemoryHeap, VK_MAX_MEMORY_HEAPS> memoryHeaps = { { MemoryHeap() } };
  };
  static_assert( sizeof( PhysicalDeviceMemoryProperties ) == sizeof( VkPhysicalDeviceMemoryProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceMemoryProperties, memoryTypeCount ) == offsetof( VkPhysicalDeviceMemoryProperties, memoryTypeCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMemoryProperties, memoryTypes ) == offsetof( VkPhysicalDeviceMemoryProperties, memoryTypes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMemoryProperties, memoryHeapCount ) == offsetof( VkPhysicalDeviceMemoryProperties, memoryHeapCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMemoryProperties, memoryHeaps ) == offsetof( VkPhysicalDeviceMemoryProperties, memoryHeaps ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceMemoryProperties2
  {
    operator VkPhysicalDeviceMemoryProperties2 const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceMemoryProperties2*>(this);
    }

    operator VkPhysicalDeviceMemoryProperties2 &()
    {
      return *reinterpret_cast<VkPhysicalDeviceMemoryProperties2*>(this);
    }

    bool operator==( PhysicalDeviceMemoryProperties2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memoryProperties == rhs.memoryProperties );
    }

    bool operator!=( PhysicalDeviceMemoryProperties2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceMemoryProperties2;
    void* pNext = nullptr;
    PhysicalDeviceMemoryProperties memoryProperties = PhysicalDeviceMemoryProperties();
  };
  static_assert( sizeof( PhysicalDeviceMemoryProperties2 ) == sizeof( VkPhysicalDeviceMemoryProperties2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceMemoryProperties2, pNext ) == offsetof( VkPhysicalDeviceMemoryProperties2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceMemoryProperties2, memoryProperties ) == offsetof( VkPhysicalDeviceMemoryProperties2, memoryProperties ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;

  enum class AccessFlagBits
  {
    eIndirectCommandRead = VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    eIndexRead = VK_ACCESS_INDEX_READ_BIT,
    eVertexAttributeRead = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
    eUniformRead = VK_ACCESS_UNIFORM_READ_BIT,
    eInputAttachmentRead = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
    eShaderRead = VK_ACCESS_SHADER_READ_BIT,
    eShaderWrite = VK_ACCESS_SHADER_WRITE_BIT,
    eColorAttachmentRead = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
    eColorAttachmentWrite = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
    eDepthStencilAttachmentRead = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
    eDepthStencilAttachmentWrite = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
    eTransferRead = VK_ACCESS_TRANSFER_READ_BIT,
    eTransferWrite = VK_ACCESS_TRANSFER_WRITE_BIT,
    eHostRead = VK_ACCESS_HOST_READ_BIT,
    eHostWrite = VK_ACCESS_HOST_WRITE_BIT,
    eMemoryRead = VK_ACCESS_MEMORY_READ_BIT,
    eMemoryWrite = VK_ACCESS_MEMORY_WRITE_BIT,
    eConditionalRenderingReadEXT = VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT,
    eCommandProcessReadNVX = VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX,
    eCommandProcessWriteNVX = VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX,
    eColorAttachmentReadNoncoherentEXT = VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
    eShadingRateImageReadNV = VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV,
    eAccelerationStructureReadNVX = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NVX,
    eAccelerationStructureWriteNVX = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NVX
  };

  using AccessFlags = Flags<AccessFlagBits, VkAccessFlags>;

  VULKAN_HPP_INLINE AccessFlags operator|( AccessFlagBits bit0, AccessFlagBits bit1 )
  {
    return AccessFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE AccessFlags operator~( AccessFlagBits bits )
  {
    return ~( AccessFlags( bits ) );
  }

  template <> struct FlagTraits<AccessFlagBits>
  {
    enum
    {
      allFlags = VkFlags(AccessFlagBits::eIndirectCommandRead) | VkFlags(AccessFlagBits::eIndexRead) | VkFlags(AccessFlagBits::eVertexAttributeRead) | VkFlags(AccessFlagBits::eUniformRead) | VkFlags(AccessFlagBits::eInputAttachmentRead) | VkFlags(AccessFlagBits::eShaderRead) | VkFlags(AccessFlagBits::eShaderWrite) | VkFlags(AccessFlagBits::eColorAttachmentRead) | VkFlags(AccessFlagBits::eColorAttachmentWrite) | VkFlags(AccessFlagBits::eDepthStencilAttachmentRead) | VkFlags(AccessFlagBits::eDepthStencilAttachmentWrite) | VkFlags(AccessFlagBits::eTransferRead) | VkFlags(AccessFlagBits::eTransferWrite) | VkFlags(AccessFlagBits::eHostRead) | VkFlags(AccessFlagBits::eHostWrite) | VkFlags(AccessFlagBits::eMemoryRead) | VkFlags(AccessFlagBits::eMemoryWrite) | VkFlags(AccessFlagBits::eConditionalRenderingReadEXT) | VkFlags(AccessFlagBits::eCommandProcessReadNVX) | VkFlags(AccessFlagBits::eCommandProcessWriteNVX) | VkFlags(AccessFlagBits::eColorAttachmentReadNoncoherentEXT) | VkFlags(AccessFlagBits::eShadingRateImageReadNV) | VkFlags(AccessFlagBits::eAccelerationStructureReadNVX) | VkFlags(AccessFlagBits::eAccelerationStructureWriteNVX)
    };
  };

  struct MemoryBarrier
  {
    operator VkMemoryBarrier const&() const
    {
      return *reinterpret_cast<const VkMemoryBarrier*>(this);
    }

    operator VkMemoryBarrier &()
    {
      return *reinterpret_cast<VkMemoryBarrier*>(this);
    }

    bool operator==( MemoryBarrier const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( srcAccessMask == rhs.srcAccessMask )
          && ( dstAccessMask == rhs.dstAccessMask );
    }

    bool operator!=( MemoryBarrier const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryBarrier;
    const void* pNext = nullptr;
    AccessFlags srcAccessMask = AccessFlags();
    AccessFlags dstAccessMask = AccessFlags();
  };
  static_assert( sizeof( MemoryBarrier ) == sizeof( VkMemoryBarrier ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryBarrier, pNext ) == offsetof( VkMemoryBarrier, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryBarrier, srcAccessMask ) == offsetof( VkMemoryBarrier, srcAccessMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryBarrier, dstAccessMask ) == offsetof( VkMemoryBarrier, dstAccessMask ), "struct member and wrapper member have different offset!" );

  struct BufferMemoryBarrier
  {
    operator VkBufferMemoryBarrier const&() const
    {
      return *reinterpret_cast<const VkBufferMemoryBarrier*>(this);
    }

    operator VkBufferMemoryBarrier &()
    {
      return *reinterpret_cast<VkBufferMemoryBarrier*>(this);
    }

    bool operator==( BufferMemoryBarrier const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( srcAccessMask == rhs.srcAccessMask )
          && ( dstAccessMask == rhs.dstAccessMask )
          && ( srcQueueFamilyIndex == rhs.srcQueueFamilyIndex )
          && ( dstQueueFamilyIndex == rhs.dstQueueFamilyIndex )
          && ( buffer == rhs.buffer )
          && ( offset == rhs.offset )
          && ( size == rhs.size );
    }

    bool operator!=( BufferMemoryBarrier const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBufferMemoryBarrier;
    const void* pNext = nullptr;
    AccessFlags srcAccessMask = AccessFlags();
    AccessFlags dstAccessMask = AccessFlags();
    uint32_t srcQueueFamilyIndex = 0;
    uint32_t dstQueueFamilyIndex = 0;
    Buffer buffer = Buffer();
    DeviceSize offset = 0;
    DeviceSize size = 0;
  };
  static_assert( sizeof( BufferMemoryBarrier ) == sizeof( VkBufferMemoryBarrier ), "struct and wrapper have different size!" );
  static_assert( offsetof( BufferMemoryBarrier, pNext ) == offsetof( VkBufferMemoryBarrier, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferMemoryBarrier, srcAccessMask ) == offsetof( VkBufferMemoryBarrier, srcAccessMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferMemoryBarrier, dstAccessMask ) == offsetof( VkBufferMemoryBarrier, dstAccessMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferMemoryBarrier, srcQueueFamilyIndex ) == offsetof( VkBufferMemoryBarrier, srcQueueFamilyIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferMemoryBarrier, dstQueueFamilyIndex ) == offsetof( VkBufferMemoryBarrier, dstQueueFamilyIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferMemoryBarrier, buffer ) == offsetof( VkBufferMemoryBarrier, buffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferMemoryBarrier, offset ) == offsetof( VkBufferMemoryBarrier, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferMemoryBarrier, size ) == offsetof( VkBufferMemoryBarrier, size ), "struct member and wrapper member have different offset!" );

  enum class BufferUsageFlagBits
  {
    eTransferSrc = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
    eTransferDst = VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    eUniformTexelBuffer = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
    eStorageTexelBuffer = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
    eUniformBuffer = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
    eStorageBuffer = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
    eIndexBuffer = VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
    eVertexBuffer = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    eIndirectBuffer = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
    eConditionalRenderingEXT = VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT,
    eRaytracingNVX = VK_BUFFER_USAGE_RAYTRACING_BIT_NVX
  };

  using BufferUsageFlags = Flags<BufferUsageFlagBits, VkBufferUsageFlags>;

  VULKAN_HPP_INLINE BufferUsageFlags operator|( BufferUsageFlagBits bit0, BufferUsageFlagBits bit1 )
  {
    return BufferUsageFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE BufferUsageFlags operator~( BufferUsageFlagBits bits )
  {
    return ~( BufferUsageFlags( bits ) );
  }

  template <> struct FlagTraits<BufferUsageFlagBits>
  {
    enum
    {
      allFlags = VkFlags(BufferUsageFlagBits::eTransferSrc) | VkFlags(BufferUsageFlagBits::eTransferDst) | VkFlags(BufferUsageFlagBits::eUniformTexelBuffer) | VkFlags(BufferUsageFlagBits::eStorageTexelBuffer) | VkFlags(BufferUsageFlagBits::eUniformBuffer) | VkFlags(BufferUsageFlagBits::eStorageBuffer) | VkFlags(BufferUsageFlagBits::eIndexBuffer) | VkFlags(BufferUsageFlagBits::eVertexBuffer) | VkFlags(BufferUsageFlagBits::eIndirectBuffer) | VkFlags(BufferUsageFlagBits::eConditionalRenderingEXT) | VkFlags(BufferUsageFlagBits::eRaytracingNVX)
    };
  };

  enum class BufferCreateFlagBits
  {
    eSparseBinding = VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    eSparseResidency = VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,
    eSparseAliased = VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,
    eProtected = VK_BUFFER_CREATE_PROTECTED_BIT
  };

  using BufferCreateFlags = Flags<BufferCreateFlagBits, VkBufferCreateFlags>;

  VULKAN_HPP_INLINE BufferCreateFlags operator|( BufferCreateFlagBits bit0, BufferCreateFlagBits bit1 )
  {
    return BufferCreateFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE BufferCreateFlags operator~( BufferCreateFlagBits bits )
  {
    return ~( BufferCreateFlags( bits ) );
  }

  template <> struct FlagTraits<BufferCreateFlagBits>
  {
    enum
    {
      allFlags = VkFlags(BufferCreateFlagBits::eSparseBinding) | VkFlags(BufferCreateFlagBits::eSparseResidency) | VkFlags(BufferCreateFlagBits::eSparseAliased) | VkFlags(BufferCreateFlagBits::eProtected)
    };
  };

  struct BufferCreateInfo
  {
    operator VkBufferCreateInfo const&() const
    {
      return *reinterpret_cast<const VkBufferCreateInfo*>(this);
    }

    operator VkBufferCreateInfo &()
    {
      return *reinterpret_cast<VkBufferCreateInfo*>(this);
    }

    bool operator==( BufferCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( size == rhs.size )
          && ( usage == rhs.usage )
          && ( sharingMode == rhs.sharingMode )
          && ( queueFamilyIndexCount == rhs.queueFamilyIndexCount )
          && ( pQueueFamilyIndices == rhs.pQueueFamilyIndices );
    }

    bool operator!=( BufferCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBufferCreateInfo;
    const void* pNext = nullptr;
    BufferCreateFlags flags = BufferCreateFlags();
    DeviceSize size = 0;
    BufferUsageFlags usage = BufferUsageFlags();
    SharingMode sharingMode = SharingMode::eExclusive;
    uint32_t queueFamilyIndexCount = 0;
    const uint32_t* pQueueFamilyIndices = nullptr;
  };
  static_assert( sizeof( BufferCreateInfo ) == sizeof( VkBufferCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( BufferCreateInfo, pNext ) == offsetof( VkBufferCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferCreateInfo, flags ) == offsetof( VkBufferCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferCreateInfo, size ) == offsetof( VkBufferCreateInfo, size ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferCreateInfo, usage ) == offsetof( VkBufferCreateInfo, usage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferCreateInfo, sharingMode ) == offsetof( VkBufferCreateInfo, sharingMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferCreateInfo, queueFamilyIndexCount ) == offsetof( VkBufferCreateInfo, queueFamilyIndexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferCreateInfo, pQueueFamilyIndices ) == offsetof( VkBufferCreateInfo, pQueueFamilyIndices ), "struct member and wrapper member have different offset!" );

  enum class ShaderStageFlagBits
  {
    eVertex = VK_SHADER_STAGE_VERTEX_BIT,
    eTessellationControl = VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    eTessellationEvaluation = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    eGeometry = VK_SHADER_STAGE_GEOMETRY_BIT,
    eFragment = VK_SHADER_STAGE_FRAGMENT_BIT,
    eCompute = VK_SHADER_STAGE_COMPUTE_BIT,
    eAllGraphics = VK_SHADER_STAGE_ALL_GRAPHICS,
    eAll = VK_SHADER_STAGE_ALL,
    eRaygenNVX = VK_SHADER_STAGE_RAYGEN_BIT_NVX,
    eAnyHitNVX = VK_SHADER_STAGE_ANY_HIT_BIT_NVX,
    eClosestHitNVX = VK_SHADER_STAGE_CLOSEST_HIT_BIT_NVX,
    eMissNVX = VK_SHADER_STAGE_MISS_BIT_NVX,
    eIntersectionNVX = VK_SHADER_STAGE_INTERSECTION_BIT_NVX,
    eCallableNVX = VK_SHADER_STAGE_CALLABLE_BIT_NVX,
    eTaskNV = VK_SHADER_STAGE_TASK_BIT_NV,
    eMeshNV = VK_SHADER_STAGE_MESH_BIT_NV
  };

  using ShaderStageFlags = Flags<ShaderStageFlagBits, VkShaderStageFlags>;

  VULKAN_HPP_INLINE ShaderStageFlags operator|( ShaderStageFlagBits bit0, ShaderStageFlagBits bit1 )
  {
    return ShaderStageFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ShaderStageFlags operator~( ShaderStageFlagBits bits )
  {
    return ~( ShaderStageFlags( bits ) );
  }

  template <> struct FlagTraits<ShaderStageFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ShaderStageFlagBits::eVertex) | VkFlags(ShaderStageFlagBits::eTessellationControl) | VkFlags(ShaderStageFlagBits::eTessellationEvaluation) | VkFlags(ShaderStageFlagBits::eGeometry) | VkFlags(ShaderStageFlagBits::eFragment) | VkFlags(ShaderStageFlagBits::eCompute) | VkFlags(ShaderStageFlagBits::eAllGraphics) | VkFlags(ShaderStageFlagBits::eAll) | VkFlags(ShaderStageFlagBits::eRaygenNVX) | VkFlags(ShaderStageFlagBits::eAnyHitNVX) | VkFlags(ShaderStageFlagBits::eClosestHitNVX) | VkFlags(ShaderStageFlagBits::eMissNVX) | VkFlags(ShaderStageFlagBits::eIntersectionNVX) | VkFlags(ShaderStageFlagBits::eCallableNVX) | VkFlags(ShaderStageFlagBits::eTaskNV) | VkFlags(ShaderStageFlagBits::eMeshNV)
    };
  };

  struct DescriptorSetLayoutBinding
  {
    operator VkDescriptorSetLayoutBinding const&() const
    {
      return *reinterpret_cast<const VkDescriptorSetLayoutBinding*>(this);
    }

    operator VkDescriptorSetLayoutBinding &()
    {
      return *reinterpret_cast<VkDescriptorSetLayoutBinding*>(this);
    }

    bool operator==( DescriptorSetLayoutBinding const& rhs ) const
    {
      return ( binding == rhs.binding )
          && ( descriptorType == rhs.descriptorType )
          && ( descriptorCount == rhs.descriptorCount )
          && ( stageFlags == rhs.stageFlags )
          && ( pImmutableSamplers == rhs.pImmutableSamplers );
    }

    bool operator!=( DescriptorSetLayoutBinding const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t binding = 0;
    DescriptorType descriptorType = DescriptorType::eSampler;
    uint32_t descriptorCount = 0;
    ShaderStageFlags stageFlags = ShaderStageFlags();
    const Sampler* pImmutableSamplers = nullptr;
  };
  static_assert( sizeof( DescriptorSetLayoutBinding ) == sizeof( VkDescriptorSetLayoutBinding ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorSetLayoutBinding, binding ) == offsetof( VkDescriptorSetLayoutBinding, binding ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutBinding, descriptorType ) == offsetof( VkDescriptorSetLayoutBinding, descriptorType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutBinding, descriptorCount ) == offsetof( VkDescriptorSetLayoutBinding, descriptorCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutBinding, stageFlags ) == offsetof( VkDescriptorSetLayoutBinding, stageFlags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutBinding, pImmutableSamplers ) == offsetof( VkDescriptorSetLayoutBinding, pImmutableSamplers ), "struct member and wrapper member have different offset!" );

  struct PipelineShaderStageCreateInfo
  {
    operator VkPipelineShaderStageCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineShaderStageCreateInfo*>(this);
    }

    operator VkPipelineShaderStageCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineShaderStageCreateInfo*>(this);
    }

    bool operator==( PipelineShaderStageCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( stage == rhs.stage )
          && ( module == rhs.module )
          && ( pName == rhs.pName )
          && ( pSpecializationInfo == rhs.pSpecializationInfo );
    }

    bool operator!=( PipelineShaderStageCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineShaderStageCreateInfo;
    const void* pNext = nullptr;
    PipelineShaderStageCreateFlags flags = PipelineShaderStageCreateFlags();
    ShaderStageFlagBits stage = ShaderStageFlagBits::eVertex;
    ShaderModule module = ShaderModule();
    const char* pName = nullptr;
    const SpecializationInfo* pSpecializationInfo = nullptr;
  };
  static_assert( sizeof( PipelineShaderStageCreateInfo ) == sizeof( VkPipelineShaderStageCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineShaderStageCreateInfo, pNext ) == offsetof( VkPipelineShaderStageCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineShaderStageCreateInfo, flags ) == offsetof( VkPipelineShaderStageCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineShaderStageCreateInfo, stage ) == offsetof( VkPipelineShaderStageCreateInfo, stage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineShaderStageCreateInfo, module ) == offsetof( VkPipelineShaderStageCreateInfo, module ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineShaderStageCreateInfo, pName ) == offsetof( VkPipelineShaderStageCreateInfo, pName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineShaderStageCreateInfo, pSpecializationInfo ) == offsetof( VkPipelineShaderStageCreateInfo, pSpecializationInfo ), "struct member and wrapper member have different offset!" );

  struct PushConstantRange
  {
    operator VkPushConstantRange const&() const
    {
      return *reinterpret_cast<const VkPushConstantRange*>(this);
    }

    operator VkPushConstantRange &()
    {
      return *reinterpret_cast<VkPushConstantRange*>(this);
    }

    bool operator==( PushConstantRange const& rhs ) const
    {
      return ( stageFlags == rhs.stageFlags )
          && ( offset == rhs.offset )
          && ( size == rhs.size );
    }

    bool operator!=( PushConstantRange const& rhs ) const
    {
      return !operator==( rhs );
    }

    ShaderStageFlags stageFlags = ShaderStageFlags();
    uint32_t offset = 0;
    uint32_t size = 0;
  };
  static_assert( sizeof( PushConstantRange ) == sizeof( VkPushConstantRange ), "struct and wrapper have different size!" );
  static_assert( offsetof( PushConstantRange, stageFlags ) == offsetof( VkPushConstantRange, stageFlags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PushConstantRange, offset ) == offsetof( VkPushConstantRange, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PushConstantRange, size ) == offsetof( VkPushConstantRange, size ), "struct member and wrapper member have different offset!" );

  struct PipelineLayoutCreateInfo
  {
    operator VkPipelineLayoutCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineLayoutCreateInfo*>(this);
    }

    operator VkPipelineLayoutCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineLayoutCreateInfo*>(this);
    }

    bool operator==( PipelineLayoutCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( setLayoutCount == rhs.setLayoutCount )
          && ( pSetLayouts == rhs.pSetLayouts )
          && ( pushConstantRangeCount == rhs.pushConstantRangeCount )
          && ( pPushConstantRanges == rhs.pPushConstantRanges );
    }

    bool operator!=( PipelineLayoutCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineLayoutCreateInfo;
    const void* pNext = nullptr;
    PipelineLayoutCreateFlags flags = PipelineLayoutCreateFlags();
    uint32_t setLayoutCount = 0;
    const DescriptorSetLayout* pSetLayouts = nullptr;
    uint32_t pushConstantRangeCount = 0;
    const PushConstantRange* pPushConstantRanges = nullptr;
  };
  static_assert( sizeof( PipelineLayoutCreateInfo ) == sizeof( VkPipelineLayoutCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineLayoutCreateInfo, pNext ) == offsetof( VkPipelineLayoutCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineLayoutCreateInfo, flags ) == offsetof( VkPipelineLayoutCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineLayoutCreateInfo, setLayoutCount ) == offsetof( VkPipelineLayoutCreateInfo, setLayoutCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineLayoutCreateInfo, pSetLayouts ) == offsetof( VkPipelineLayoutCreateInfo, pSetLayouts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineLayoutCreateInfo, pushConstantRangeCount ) == offsetof( VkPipelineLayoutCreateInfo, pushConstantRangeCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineLayoutCreateInfo, pPushConstantRanges ) == offsetof( VkPipelineLayoutCreateInfo, pPushConstantRanges ), "struct member and wrapper member have different offset!" );

  struct ShaderStatisticsInfoAMD
  {
    operator VkShaderStatisticsInfoAMD const&() const
    {
      return *reinterpret_cast<const VkShaderStatisticsInfoAMD*>(this);
    }

    operator VkShaderStatisticsInfoAMD &()
    {
      return *reinterpret_cast<VkShaderStatisticsInfoAMD*>(this);
    }

    bool operator==( ShaderStatisticsInfoAMD const& rhs ) const
    {
      return ( shaderStageMask == rhs.shaderStageMask )
          && ( resourceUsage == rhs.resourceUsage )
          && ( numPhysicalVgprs == rhs.numPhysicalVgprs )
          && ( numPhysicalSgprs == rhs.numPhysicalSgprs )
          && ( numAvailableVgprs == rhs.numAvailableVgprs )
          && ( numAvailableSgprs == rhs.numAvailableSgprs )
          && ( computeWorkGroupSize == rhs.computeWorkGroupSize );
    }

    bool operator!=( ShaderStatisticsInfoAMD const& rhs ) const
    {
      return !operator==( rhs );
    }

    ShaderStageFlags shaderStageMask = ShaderStageFlags();
    ShaderResourceUsageAMD resourceUsage = ShaderResourceUsageAMD();
    uint32_t numPhysicalVgprs = 0;
    uint32_t numPhysicalSgprs = 0;
    uint32_t numAvailableVgprs = 0;
    uint32_t numAvailableSgprs = 0;
    std::array<uint32_t, 3> computeWorkGroupSize = { { 0, 0, 0 } };
  };
  static_assert( sizeof( ShaderStatisticsInfoAMD ) == sizeof( VkShaderStatisticsInfoAMD ), "struct and wrapper have different size!" );
  static_assert( offsetof( ShaderStatisticsInfoAMD, shaderStageMask ) == offsetof( VkShaderStatisticsInfoAMD, shaderStageMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderStatisticsInfoAMD, resourceUsage ) == offsetof( VkShaderStatisticsInfoAMD, resourceUsage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderStatisticsInfoAMD, numPhysicalVgprs ) == offsetof( VkShaderStatisticsInfoAMD, numPhysicalVgprs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderStatisticsInfoAMD, numPhysicalSgprs ) == offsetof( VkShaderStatisticsInfoAMD, numPhysicalSgprs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderStatisticsInfoAMD, numAvailableVgprs ) == offsetof( VkShaderStatisticsInfoAMD, numAvailableVgprs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderStatisticsInfoAMD, numAvailableSgprs ) == offsetof( VkShaderStatisticsInfoAMD, numAvailableSgprs ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShaderStatisticsInfoAMD, computeWorkGroupSize ) == offsetof( VkShaderStatisticsInfoAMD, computeWorkGroupSize ), "struct member and wrapper member have different offset!" );

  enum class ImageUsageFlagBits
  {
    eTransferSrc = VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
    eTransferDst = VK_IMAGE_USAGE_TRANSFER_DST_BIT,
    eSampled = VK_IMAGE_USAGE_SAMPLED_BIT,
    eStorage = VK_IMAGE_USAGE_STORAGE_BIT,
    eColorAttachment = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    eDepthStencilAttachment = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    eTransientAttachment = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    eInputAttachment = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
    eShadingRateImageNV = VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV
  };

  using ImageUsageFlags = Flags<ImageUsageFlagBits, VkImageUsageFlags>;

  VULKAN_HPP_INLINE ImageUsageFlags operator|( ImageUsageFlagBits bit0, ImageUsageFlagBits bit1 )
  {
    return ImageUsageFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ImageUsageFlags operator~( ImageUsageFlagBits bits )
  {
    return ~( ImageUsageFlags( bits ) );
  }

  template <> struct FlagTraits<ImageUsageFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ImageUsageFlagBits::eTransferSrc) | VkFlags(ImageUsageFlagBits::eTransferDst) | VkFlags(ImageUsageFlagBits::eSampled) | VkFlags(ImageUsageFlagBits::eStorage) | VkFlags(ImageUsageFlagBits::eColorAttachment) | VkFlags(ImageUsageFlagBits::eDepthStencilAttachment) | VkFlags(ImageUsageFlagBits::eTransientAttachment) | VkFlags(ImageUsageFlagBits::eInputAttachment) | VkFlags(ImageUsageFlagBits::eShadingRateImageNV)
    };
  };

  struct SharedPresentSurfaceCapabilitiesKHR
  {
    operator VkSharedPresentSurfaceCapabilitiesKHR const&() const
    {
      return *reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(this);
    }

    operator VkSharedPresentSurfaceCapabilitiesKHR &()
    {
      return *reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(this);
    }

    bool operator==( SharedPresentSurfaceCapabilitiesKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( sharedPresentSupportedUsageFlags == rhs.sharedPresentSupportedUsageFlags );
    }

    bool operator!=( SharedPresentSurfaceCapabilitiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSharedPresentSurfaceCapabilitiesKHR;
    void* pNext = nullptr;
    ImageUsageFlags sharedPresentSupportedUsageFlags = ImageUsageFlags();
  };
  static_assert( sizeof( SharedPresentSurfaceCapabilitiesKHR ) == sizeof( VkSharedPresentSurfaceCapabilitiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SharedPresentSurfaceCapabilitiesKHR, pNext ) == offsetof( VkSharedPresentSurfaceCapabilitiesKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SharedPresentSurfaceCapabilitiesKHR, sharedPresentSupportedUsageFlags ) == offsetof( VkSharedPresentSurfaceCapabilitiesKHR, sharedPresentSupportedUsageFlags ), "struct member and wrapper member have different offset!" );

  struct ImageViewUsageCreateInfo
  {
    operator VkImageViewUsageCreateInfo const&() const
    {
      return *reinterpret_cast<const VkImageViewUsageCreateInfo*>(this);
    }

    operator VkImageViewUsageCreateInfo &()
    {
      return *reinterpret_cast<VkImageViewUsageCreateInfo*>(this);
    }

    bool operator==( ImageViewUsageCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( usage == rhs.usage );
    }

    bool operator!=( ImageViewUsageCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageViewUsageCreateInfo;
    const void* pNext = nullptr;
    ImageUsageFlags usage = ImageUsageFlags();
  };
  static_assert( sizeof( ImageViewUsageCreateInfo ) == sizeof( VkImageViewUsageCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageViewUsageCreateInfo, pNext ) == offsetof( VkImageViewUsageCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageViewUsageCreateInfo, usage ) == offsetof( VkImageViewUsageCreateInfo, usage ), "struct member and wrapper member have different offset!" );

  using ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;

  enum class ImageCreateFlagBits
  {
    eSparseBinding = VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    eSparseResidency = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    eSparseAliased = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
    eMutableFormat = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
    eCubeCompatible = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    eAlias = VK_IMAGE_CREATE_ALIAS_BIT,
    eAliasKHR = VK_IMAGE_CREATE_ALIAS_BIT,
    eSplitInstanceBindRegions = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    eSplitInstanceBindRegionsKHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    e2DArrayCompatible = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    e2DArrayCompatibleKHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    eBlockTexelViewCompatible = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    eBlockTexelViewCompatibleKHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    eExtendedUsage = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    eExtendedUsageKHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    eProtected = VK_IMAGE_CREATE_PROTECTED_BIT,
    eDisjoint = VK_IMAGE_CREATE_DISJOINT_BIT,
    eDisjointKHR = VK_IMAGE_CREATE_DISJOINT_BIT,
    eCornerSampledNV = VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV,
    eSampleLocationsCompatibleDepthEXT = VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT
  };

  using ImageCreateFlags = Flags<ImageCreateFlagBits, VkImageCreateFlags>;

  VULKAN_HPP_INLINE ImageCreateFlags operator|( ImageCreateFlagBits bit0, ImageCreateFlagBits bit1 )
  {
    return ImageCreateFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ImageCreateFlags operator~( ImageCreateFlagBits bits )
  {
    return ~( ImageCreateFlags( bits ) );
  }

  template <> struct FlagTraits<ImageCreateFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ImageCreateFlagBits::eSparseBinding) | VkFlags(ImageCreateFlagBits::eSparseResidency) | VkFlags(ImageCreateFlagBits::eSparseAliased) | VkFlags(ImageCreateFlagBits::eMutableFormat) | VkFlags(ImageCreateFlagBits::eCubeCompatible) | VkFlags(ImageCreateFlagBits::eAlias) | VkFlags(ImageCreateFlagBits::eSplitInstanceBindRegions) | VkFlags(ImageCreateFlagBits::e2DArrayCompatible) | VkFlags(ImageCreateFlagBits::eBlockTexelViewCompatible) | VkFlags(ImageCreateFlagBits::eExtendedUsage) | VkFlags(ImageCreateFlagBits::eProtected) | VkFlags(ImageCreateFlagBits::eDisjoint) | VkFlags(ImageCreateFlagBits::eCornerSampledNV) | VkFlags(ImageCreateFlagBits::eSampleLocationsCompatibleDepthEXT)
    };
  };

  struct PhysicalDeviceImageFormatInfo2
  {
    operator VkPhysicalDeviceImageFormatInfo2 const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceImageFormatInfo2*>(this);
    }

    operator VkPhysicalDeviceImageFormatInfo2 &()
    {
      return *reinterpret_cast<VkPhysicalDeviceImageFormatInfo2*>(this);
    }

    bool operator==( PhysicalDeviceImageFormatInfo2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( format == rhs.format )
          && ( type == rhs.type )
          && ( tiling == rhs.tiling )
          && ( usage == rhs.usage )
          && ( flags == rhs.flags );
    }

    bool operator!=( PhysicalDeviceImageFormatInfo2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceImageFormatInfo2;
    const void* pNext = nullptr;
    Format format = Format::eUndefined;
    ImageType type = ImageType::e1D;
    ImageTiling tiling = ImageTiling::eOptimal;
    ImageUsageFlags usage = ImageUsageFlags();
    ImageCreateFlags flags = ImageCreateFlags();
  };
  static_assert( sizeof( PhysicalDeviceImageFormatInfo2 ) == sizeof( VkPhysicalDeviceImageFormatInfo2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceImageFormatInfo2, pNext ) == offsetof( VkPhysicalDeviceImageFormatInfo2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceImageFormatInfo2, format ) == offsetof( VkPhysicalDeviceImageFormatInfo2, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceImageFormatInfo2, type ) == offsetof( VkPhysicalDeviceImageFormatInfo2, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceImageFormatInfo2, tiling ) == offsetof( VkPhysicalDeviceImageFormatInfo2, tiling ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceImageFormatInfo2, usage ) == offsetof( VkPhysicalDeviceImageFormatInfo2, usage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceImageFormatInfo2, flags ) == offsetof( VkPhysicalDeviceImageFormatInfo2, flags ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;

  enum class PipelineCreateFlagBits
  {
    eDisableOptimization = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
    eAllowDerivatives = VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
    eDerivative = VK_PIPELINE_CREATE_DERIVATIVE_BIT,
    eViewIndexFromDeviceIndex = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    eViewIndexFromDeviceIndexKHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    eDispatchBase = VK_PIPELINE_CREATE_DISPATCH_BASE,
    eDispatchBaseKHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
    eDeferCompileNVX = VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NVX
  };

  using PipelineCreateFlags = Flags<PipelineCreateFlagBits, VkPipelineCreateFlags>;

  VULKAN_HPP_INLINE PipelineCreateFlags operator|( PipelineCreateFlagBits bit0, PipelineCreateFlagBits bit1 )
  {
    return PipelineCreateFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE PipelineCreateFlags operator~( PipelineCreateFlagBits bits )
  {
    return ~( PipelineCreateFlags( bits ) );
  }

  template <> struct FlagTraits<PipelineCreateFlagBits>
  {
    enum
    {
      allFlags = VkFlags(PipelineCreateFlagBits::eDisableOptimization) | VkFlags(PipelineCreateFlagBits::eAllowDerivatives) | VkFlags(PipelineCreateFlagBits::eDerivative) | VkFlags(PipelineCreateFlagBits::eViewIndexFromDeviceIndex) | VkFlags(PipelineCreateFlagBits::eDispatchBase) | VkFlags(PipelineCreateFlagBits::eDeferCompileNVX)
    };
  };

  struct ComputePipelineCreateInfo
  {
    operator VkComputePipelineCreateInfo const&() const
    {
      return *reinterpret_cast<const VkComputePipelineCreateInfo*>(this);
    }

    operator VkComputePipelineCreateInfo &()
    {
      return *reinterpret_cast<VkComputePipelineCreateInfo*>(this);
    }

    bool operator==( ComputePipelineCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( stage == rhs.stage )
          && ( layout == rhs.layout )
          && ( basePipelineHandle == rhs.basePipelineHandle )
          && ( basePipelineIndex == rhs.basePipelineIndex );
    }

    bool operator!=( ComputePipelineCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eComputePipelineCreateInfo;
    const void* pNext = nullptr;
    PipelineCreateFlags flags = PipelineCreateFlags();
    PipelineShaderStageCreateInfo stage = PipelineShaderStageCreateInfo();
    PipelineLayout layout = PipelineLayout();
    Pipeline basePipelineHandle = Pipeline();
    int32_t basePipelineIndex = 0;
  };
  static_assert( sizeof( ComputePipelineCreateInfo ) == sizeof( VkComputePipelineCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ComputePipelineCreateInfo, pNext ) == offsetof( VkComputePipelineCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ComputePipelineCreateInfo, flags ) == offsetof( VkComputePipelineCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ComputePipelineCreateInfo, stage ) == offsetof( VkComputePipelineCreateInfo, stage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ComputePipelineCreateInfo, layout ) == offsetof( VkComputePipelineCreateInfo, layout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ComputePipelineCreateInfo, basePipelineHandle ) == offsetof( VkComputePipelineCreateInfo, basePipelineHandle ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ComputePipelineCreateInfo, basePipelineIndex ) == offsetof( VkComputePipelineCreateInfo, basePipelineIndex ), "struct member and wrapper member have different offset!" );

  struct RaytracingPipelineCreateInfoNVX
  {
    operator VkRaytracingPipelineCreateInfoNVX const&() const
    {
      return *reinterpret_cast<const VkRaytracingPipelineCreateInfoNVX*>(this);
    }

    operator VkRaytracingPipelineCreateInfoNVX &()
    {
      return *reinterpret_cast<VkRaytracingPipelineCreateInfoNVX*>(this);
    }

    bool operator==( RaytracingPipelineCreateInfoNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( stageCount == rhs.stageCount )
          && ( pStages == rhs.pStages )
          && ( pGroupNumbers == rhs.pGroupNumbers )
          && ( maxRecursionDepth == rhs.maxRecursionDepth )
          && ( layout == rhs.layout )
          && ( basePipelineHandle == rhs.basePipelineHandle )
          && ( basePipelineIndex == rhs.basePipelineIndex );
    }

    bool operator!=( RaytracingPipelineCreateInfoNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eRaytracingPipelineCreateInfoNVX;
    const void* pNext = nullptr;
    PipelineCreateFlags flags = PipelineCreateFlags();
    uint32_t stageCount = 0;
    const PipelineShaderStageCreateInfo* pStages = nullptr;
    const uint32_t* pGroupNumbers = nullptr;
    uint32_t maxRecursionDepth = 0;
    PipelineLayout layout = PipelineLayout();
    Pipeline basePipelineHandle = Pipeline();
    int32_t basePipelineIndex = 0;
  };
  static_assert( sizeof( RaytracingPipelineCreateInfoNVX ) == sizeof( VkRaytracingPipelineCreateInfoNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( RaytracingPipelineCreateInfoNVX, pNext ) == offsetof( VkRaytracingPipelineCreateInfoNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RaytracingPipelineCreateInfoNVX, flags ) == offsetof( VkRaytracingPipelineCreateInfoNVX, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RaytracingPipelineCreateInfoNVX, stageCount ) == offsetof( VkRaytracingPipelineCreateInfoNVX, stageCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RaytracingPipelineCreateInfoNVX, pStages ) == offsetof( VkRaytracingPipelineCreateInfoNVX, pStages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RaytracingPipelineCreateInfoNVX, pGroupNumbers ) == offsetof( VkRaytracingPipelineCreateInfoNVX, pGroupNumbers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RaytracingPipelineCreateInfoNVX, maxRecursionDepth ) == offsetof( VkRaytracingPipelineCreateInfoNVX, maxRecursionDepth ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RaytracingPipelineCreateInfoNVX, layout ) == offsetof( VkRaytracingPipelineCreateInfoNVX, layout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RaytracingPipelineCreateInfoNVX, basePipelineHandle ) == offsetof( VkRaytracingPipelineCreateInfoNVX, basePipelineHandle ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RaytracingPipelineCreateInfoNVX, basePipelineIndex ) == offsetof( VkRaytracingPipelineCreateInfoNVX, basePipelineIndex ), "struct member and wrapper member have different offset!" );

  enum class ColorComponentFlagBits
  {
    eR = VK_COLOR_COMPONENT_R_BIT,
    eG = VK_COLOR_COMPONENT_G_BIT,
    eB = VK_COLOR_COMPONENT_B_BIT,
    eA = VK_COLOR_COMPONENT_A_BIT
  };

  using ColorComponentFlags = Flags<ColorComponentFlagBits, VkColorComponentFlags>;

  VULKAN_HPP_INLINE ColorComponentFlags operator|( ColorComponentFlagBits bit0, ColorComponentFlagBits bit1 )
  {
    return ColorComponentFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ColorComponentFlags operator~( ColorComponentFlagBits bits )
  {
    return ~( ColorComponentFlags( bits ) );
  }

  template <> struct FlagTraits<ColorComponentFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ColorComponentFlagBits::eR) | VkFlags(ColorComponentFlagBits::eG) | VkFlags(ColorComponentFlagBits::eB) | VkFlags(ColorComponentFlagBits::eA)
    };
  };

  struct PipelineColorBlendAttachmentState
  {
    operator VkPipelineColorBlendAttachmentState const&() const
    {
      return *reinterpret_cast<const VkPipelineColorBlendAttachmentState*>(this);
    }

    operator VkPipelineColorBlendAttachmentState &()
    {
      return *reinterpret_cast<VkPipelineColorBlendAttachmentState*>(this);
    }

    bool operator==( PipelineColorBlendAttachmentState const& rhs ) const
    {
      return ( blendEnable == rhs.blendEnable )
          && ( srcColorBlendFactor == rhs.srcColorBlendFactor )
          && ( dstColorBlendFactor == rhs.dstColorBlendFactor )
          && ( colorBlendOp == rhs.colorBlendOp )
          && ( srcAlphaBlendFactor == rhs.srcAlphaBlendFactor )
          && ( dstAlphaBlendFactor == rhs.dstAlphaBlendFactor )
          && ( alphaBlendOp == rhs.alphaBlendOp )
          && ( colorWriteMask == rhs.colorWriteMask );
    }

    bool operator!=( PipelineColorBlendAttachmentState const& rhs ) const
    {
      return !operator==( rhs );
    }

    Bool32 blendEnable = 0;
    BlendFactor srcColorBlendFactor = BlendFactor::eZero;
    BlendFactor dstColorBlendFactor = BlendFactor::eZero;
    BlendOp colorBlendOp = BlendOp::eAdd;
    BlendFactor srcAlphaBlendFactor = BlendFactor::eZero;
    BlendFactor dstAlphaBlendFactor = BlendFactor::eZero;
    BlendOp alphaBlendOp = BlendOp::eAdd;
    ColorComponentFlags colorWriteMask = ColorComponentFlags();
  };
  static_assert( sizeof( PipelineColorBlendAttachmentState ) == sizeof( VkPipelineColorBlendAttachmentState ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineColorBlendAttachmentState, blendEnable ) == offsetof( VkPipelineColorBlendAttachmentState, blendEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAttachmentState, srcColorBlendFactor ) == offsetof( VkPipelineColorBlendAttachmentState, srcColorBlendFactor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAttachmentState, dstColorBlendFactor ) == offsetof( VkPipelineColorBlendAttachmentState, dstColorBlendFactor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAttachmentState, colorBlendOp ) == offsetof( VkPipelineColorBlendAttachmentState, colorBlendOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAttachmentState, srcAlphaBlendFactor ) == offsetof( VkPipelineColorBlendAttachmentState, srcAlphaBlendFactor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAttachmentState, dstAlphaBlendFactor ) == offsetof( VkPipelineColorBlendAttachmentState, dstAlphaBlendFactor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAttachmentState, alphaBlendOp ) == offsetof( VkPipelineColorBlendAttachmentState, alphaBlendOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAttachmentState, colorWriteMask ) == offsetof( VkPipelineColorBlendAttachmentState, colorWriteMask ), "struct member and wrapper member have different offset!" );

  struct PipelineColorBlendStateCreateInfo
  {
    operator VkPipelineColorBlendStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineColorBlendStateCreateInfo*>(this);
    }

    operator VkPipelineColorBlendStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineColorBlendStateCreateInfo*>(this);
    }

    bool operator==( PipelineColorBlendStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( logicOpEnable == rhs.logicOpEnable )
          && ( logicOp == rhs.logicOp )
          && ( attachmentCount == rhs.attachmentCount )
          && ( pAttachments == rhs.pAttachments )
          && ( blendConstants == rhs.blendConstants );
    }

    bool operator!=( PipelineColorBlendStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineColorBlendStateCreateInfo;
    const void* pNext = nullptr;
    PipelineColorBlendStateCreateFlags flags = PipelineColorBlendStateCreateFlags();
    Bool32 logicOpEnable = 0;
    LogicOp logicOp = LogicOp::eClear;
    uint32_t attachmentCount = 0;
    const PipelineColorBlendAttachmentState* pAttachments = nullptr;
    std::array<float, 4> blendConstants = { { 0, 0, 0, 0 } };
  };
  static_assert( sizeof( PipelineColorBlendStateCreateInfo ) == sizeof( VkPipelineColorBlendStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineColorBlendStateCreateInfo, pNext ) == offsetof( VkPipelineColorBlendStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendStateCreateInfo, flags ) == offsetof( VkPipelineColorBlendStateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendStateCreateInfo, logicOpEnable ) == offsetof( VkPipelineColorBlendStateCreateInfo, logicOpEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendStateCreateInfo, logicOp ) == offsetof( VkPipelineColorBlendStateCreateInfo, logicOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendStateCreateInfo, attachmentCount ) == offsetof( VkPipelineColorBlendStateCreateInfo, attachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendStateCreateInfo, pAttachments ) == offsetof( VkPipelineColorBlendStateCreateInfo, pAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendStateCreateInfo, blendConstants ) == offsetof( VkPipelineColorBlendStateCreateInfo, blendConstants ), "struct member and wrapper member have different offset!" );

  enum class FenceCreateFlagBits
  {
    eSignaled = VK_FENCE_CREATE_SIGNALED_BIT
  };

  using FenceCreateFlags = Flags<FenceCreateFlagBits, VkFenceCreateFlags>;

  VULKAN_HPP_INLINE FenceCreateFlags operator|( FenceCreateFlagBits bit0, FenceCreateFlagBits bit1 )
  {
    return FenceCreateFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE FenceCreateFlags operator~( FenceCreateFlagBits bits )
  {
    return ~( FenceCreateFlags( bits ) );
  }

  template <> struct FlagTraits<FenceCreateFlagBits>
  {
    enum
    {
      allFlags = VkFlags(FenceCreateFlagBits::eSignaled)
    };
  };

  struct FenceCreateInfo
  {
    operator VkFenceCreateInfo const&() const
    {
      return *reinterpret_cast<const VkFenceCreateInfo*>(this);
    }

    operator VkFenceCreateInfo &()
    {
      return *reinterpret_cast<VkFenceCreateInfo*>(this);
    }

    bool operator==( FenceCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags );
    }

    bool operator!=( FenceCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eFenceCreateInfo;
    const void* pNext = nullptr;
    FenceCreateFlags flags = FenceCreateFlags();
  };
  static_assert( sizeof( FenceCreateInfo ) == sizeof( VkFenceCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( FenceCreateInfo, pNext ) == offsetof( VkFenceCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FenceCreateInfo, flags ) == offsetof( VkFenceCreateInfo, flags ), "struct member and wrapper member have different offset!" );

  enum class FormatFeatureFlagBits
  {
    eSampledImage = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    eStorageImage = VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
    eStorageImageAtomic = VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
    eUniformTexelBuffer = VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
    eStorageTexelBuffer = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
    eStorageTexelBufferAtomic = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
    eVertexBuffer = VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
    eColorAttachment = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
    eColorAttachmentBlend = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
    eDepthStencilAttachment = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
    eBlitSrc = VK_FORMAT_FEATURE_BLIT_SRC_BIT,
    eBlitDst = VK_FORMAT_FEATURE_BLIT_DST_BIT,
    eSampledImageFilterLinear = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
    eTransferSrc = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    eTransferSrcKHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    eTransferDst = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    eTransferDstKHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    eMidpointChromaSamples = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    eMidpointChromaSamplesKHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    eSampledImageYcbcrConversionLinearFilter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    eSampledImageYcbcrConversionLinearFilterKHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    eSampledImageYcbcrConversionSeparateReconstructionFilter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    eSampledImageYcbcrConversionSeparateReconstructionFilterKHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    eSampledImageYcbcrConversionChromaReconstructionExplicit = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    eSampledImageYcbcrConversionChromaReconstructionExplicitKHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    eSampledImageYcbcrConversionChromaReconstructionExplicitForceable = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    eSampledImageYcbcrConversionChromaReconstructionExplicitForceableKHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    eDisjoint = VK_FORMAT_FEATURE_DISJOINT_BIT,
    eDisjointKHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
    eCositedChromaSamples = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    eCositedChromaSamplesKHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    eSampledImageFilterCubicIMG = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    eSampledImageFilterMinmaxEXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT
  };

  using FormatFeatureFlags = Flags<FormatFeatureFlagBits, VkFormatFeatureFlags>;

  VULKAN_HPP_INLINE FormatFeatureFlags operator|( FormatFeatureFlagBits bit0, FormatFeatureFlagBits bit1 )
  {
    return FormatFeatureFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE FormatFeatureFlags operator~( FormatFeatureFlagBits bits )
  {
    return ~( FormatFeatureFlags( bits ) );
  }

  template <> struct FlagTraits<FormatFeatureFlagBits>
  {
    enum
    {
      allFlags = VkFlags(FormatFeatureFlagBits::eSampledImage) | VkFlags(FormatFeatureFlagBits::eStorageImage) | VkFlags(FormatFeatureFlagBits::eStorageImageAtomic) | VkFlags(FormatFeatureFlagBits::eUniformTexelBuffer) | VkFlags(FormatFeatureFlagBits::eStorageTexelBuffer) | VkFlags(FormatFeatureFlagBits::eStorageTexelBufferAtomic) | VkFlags(FormatFeatureFlagBits::eVertexBuffer) | VkFlags(FormatFeatureFlagBits::eColorAttachment) | VkFlags(FormatFeatureFlagBits::eColorAttachmentBlend) | VkFlags(FormatFeatureFlagBits::eDepthStencilAttachment) | VkFlags(FormatFeatureFlagBits::eBlitSrc) | VkFlags(FormatFeatureFlagBits::eBlitDst) | VkFlags(FormatFeatureFlagBits::eSampledImageFilterLinear) | VkFlags(FormatFeatureFlagBits::eTransferSrc) | VkFlags(FormatFeatureFlagBits::eTransferDst) | VkFlags(FormatFeatureFlagBits::eMidpointChromaSamples) | VkFlags(FormatFeatureFlagBits::eSampledImageYcbcrConversionLinearFilter) | VkFlags(FormatFeatureFlagBits::eSampledImageYcbcrConversionSeparateReconstructionFilter) | VkFlags(FormatFeatureFlagBits::eSampledImageYcbcrConversionChromaReconstructionExplicit) | VkFlags(FormatFeatureFlagBits::eSampledImageYcbcrConversionChromaReconstructionExplicitForceable) | VkFlags(FormatFeatureFlagBits::eDisjoint) | VkFlags(FormatFeatureFlagBits::eCositedChromaSamples) | VkFlags(FormatFeatureFlagBits::eSampledImageFilterCubicIMG) | VkFlags(FormatFeatureFlagBits::eSampledImageFilterMinmaxEXT)
    };
  };

  struct FormatProperties
  {
    operator VkFormatProperties const&() const
    {
      return *reinterpret_cast<const VkFormatProperties*>(this);
    }

    operator VkFormatProperties &()
    {
      return *reinterpret_cast<VkFormatProperties*>(this);
    }

    bool operator==( FormatProperties const& rhs ) const
    {
      return ( linearTilingFeatures == rhs.linearTilingFeatures )
          && ( optimalTilingFeatures == rhs.optimalTilingFeatures )
          && ( bufferFeatures == rhs.bufferFeatures );
    }

    bool operator!=( FormatProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    FormatFeatureFlags linearTilingFeatures = FormatFeatureFlags();
    FormatFeatureFlags optimalTilingFeatures = FormatFeatureFlags();
    FormatFeatureFlags bufferFeatures = FormatFeatureFlags();
  };
  static_assert( sizeof( FormatProperties ) == sizeof( VkFormatProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( FormatProperties, linearTilingFeatures ) == offsetof( VkFormatProperties, linearTilingFeatures ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FormatProperties, optimalTilingFeatures ) == offsetof( VkFormatProperties, optimalTilingFeatures ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FormatProperties, bufferFeatures ) == offsetof( VkFormatProperties, bufferFeatures ), "struct member and wrapper member have different offset!" );

  struct FormatProperties2
  {
    operator VkFormatProperties2 const&() const
    {
      return *reinterpret_cast<const VkFormatProperties2*>(this);
    }

    operator VkFormatProperties2 &()
    {
      return *reinterpret_cast<VkFormatProperties2*>(this);
    }

    bool operator==( FormatProperties2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( formatProperties == rhs.formatProperties );
    }

    bool operator!=( FormatProperties2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eFormatProperties2;
    void* pNext = nullptr;
    FormatProperties formatProperties = FormatProperties();
  };
  static_assert( sizeof( FormatProperties2 ) == sizeof( VkFormatProperties2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( FormatProperties2, pNext ) == offsetof( VkFormatProperties2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FormatProperties2, formatProperties ) == offsetof( VkFormatProperties2, formatProperties ), "struct member and wrapper member have different offset!" );

  using FormatProperties2KHR = FormatProperties2;

  enum class QueryControlFlagBits
  {
    ePrecise = VK_QUERY_CONTROL_PRECISE_BIT
  };

  using QueryControlFlags = Flags<QueryControlFlagBits, VkQueryControlFlags>;

  VULKAN_HPP_INLINE QueryControlFlags operator|( QueryControlFlagBits bit0, QueryControlFlagBits bit1 )
  {
    return QueryControlFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE QueryControlFlags operator~( QueryControlFlagBits bits )
  {
    return ~( QueryControlFlags( bits ) );
  }

  template <> struct FlagTraits<QueryControlFlagBits>
  {
    enum
    {
      allFlags = VkFlags(QueryControlFlagBits::ePrecise)
    };
  };

  enum class QueryResultFlagBits
  {
    e64 = VK_QUERY_RESULT_64_BIT,
    eWait = VK_QUERY_RESULT_WAIT_BIT,
    eWithAvailability = VK_QUERY_RESULT_WITH_AVAILABILITY_BIT,
    ePartial = VK_QUERY_RESULT_PARTIAL_BIT
  };

  using QueryResultFlags = Flags<QueryResultFlagBits, VkQueryResultFlags>;

  VULKAN_HPP_INLINE QueryResultFlags operator|( QueryResultFlagBits bit0, QueryResultFlagBits bit1 )
  {
    return QueryResultFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE QueryResultFlags operator~( QueryResultFlagBits bits )
  {
    return ~( QueryResultFlags( bits ) );
  }

  template <> struct FlagTraits<QueryResultFlagBits>
  {
    enum
    {
      allFlags = VkFlags(QueryResultFlagBits::e64) | VkFlags(QueryResultFlagBits::eWait) | VkFlags(QueryResultFlagBits::eWithAvailability) | VkFlags(QueryResultFlagBits::ePartial)
    };
  };

  enum class CommandBufferUsageFlagBits
  {
    eOneTimeSubmit = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
    eRenderPassContinue = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
    eSimultaneousUse = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT
  };

  using CommandBufferUsageFlags = Flags<CommandBufferUsageFlagBits, VkCommandBufferUsageFlags>;

  VULKAN_HPP_INLINE CommandBufferUsageFlags operator|( CommandBufferUsageFlagBits bit0, CommandBufferUsageFlagBits bit1 )
  {
    return CommandBufferUsageFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE CommandBufferUsageFlags operator~( CommandBufferUsageFlagBits bits )
  {
    return ~( CommandBufferUsageFlags( bits ) );
  }

  template <> struct FlagTraits<CommandBufferUsageFlagBits>
  {
    enum
    {
      allFlags = VkFlags(CommandBufferUsageFlagBits::eOneTimeSubmit) | VkFlags(CommandBufferUsageFlagBits::eRenderPassContinue) | VkFlags(CommandBufferUsageFlagBits::eSimultaneousUse)
    };
  };

  enum class QueryPipelineStatisticFlagBits
  {
    eInputAssemblyVertices = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
    eInputAssemblyPrimitives = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
    eVertexShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
    eGeometryShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
    eGeometryShaderPrimitives = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
    eClippingInvocations = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
    eClippingPrimitives = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
    eFragmentShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
    eTessellationControlShaderPatches = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
    eTessellationEvaluationShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
    eComputeShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT
  };

  using QueryPipelineStatisticFlags = Flags<QueryPipelineStatisticFlagBits, VkQueryPipelineStatisticFlags>;

  VULKAN_HPP_INLINE QueryPipelineStatisticFlags operator|( QueryPipelineStatisticFlagBits bit0, QueryPipelineStatisticFlagBits bit1 )
  {
    return QueryPipelineStatisticFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE QueryPipelineStatisticFlags operator~( QueryPipelineStatisticFlagBits bits )
  {
    return ~( QueryPipelineStatisticFlags( bits ) );
  }

  template <> struct FlagTraits<QueryPipelineStatisticFlagBits>
  {
    enum
    {
      allFlags = VkFlags(QueryPipelineStatisticFlagBits::eInputAssemblyVertices) | VkFlags(QueryPipelineStatisticFlagBits::eInputAssemblyPrimitives) | VkFlags(QueryPipelineStatisticFlagBits::eVertexShaderInvocations) | VkFlags(QueryPipelineStatisticFlagBits::eGeometryShaderInvocations) | VkFlags(QueryPipelineStatisticFlagBits::eGeometryShaderPrimitives) | VkFlags(QueryPipelineStatisticFlagBits::eClippingInvocations) | VkFlags(QueryPipelineStatisticFlagBits::eClippingPrimitives) | VkFlags(QueryPipelineStatisticFlagBits::eFragmentShaderInvocations) | VkFlags(QueryPipelineStatisticFlagBits::eTessellationControlShaderPatches) | VkFlags(QueryPipelineStatisticFlagBits::eTessellationEvaluationShaderInvocations) | VkFlags(QueryPipelineStatisticFlagBits::eComputeShaderInvocations)
    };
  };

  struct CommandBufferInheritanceInfo
  {
    operator VkCommandBufferInheritanceInfo const&() const
    {
      return *reinterpret_cast<const VkCommandBufferInheritanceInfo*>(this);
    }

    operator VkCommandBufferInheritanceInfo &()
    {
      return *reinterpret_cast<VkCommandBufferInheritanceInfo*>(this);
    }

    bool operator==( CommandBufferInheritanceInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( renderPass == rhs.renderPass )
          && ( subpass == rhs.subpass )
          && ( framebuffer == rhs.framebuffer )
          && ( occlusionQueryEnable == rhs.occlusionQueryEnable )
          && ( queryFlags == rhs.queryFlags )
          && ( pipelineStatistics == rhs.pipelineStatistics );
    }

    bool operator!=( CommandBufferInheritanceInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eCommandBufferInheritanceInfo;
    const void* pNext = nullptr;
    RenderPass renderPass = RenderPass();
    uint32_t subpass = 0;
    Framebuffer framebuffer = Framebuffer();
    Bool32 occlusionQueryEnable = 0;
    QueryControlFlags queryFlags = QueryControlFlags();
    QueryPipelineStatisticFlags pipelineStatistics = QueryPipelineStatisticFlags();
  };
  static_assert( sizeof( CommandBufferInheritanceInfo ) == sizeof( VkCommandBufferInheritanceInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( CommandBufferInheritanceInfo, pNext ) == offsetof( VkCommandBufferInheritanceInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferInheritanceInfo, renderPass ) == offsetof( VkCommandBufferInheritanceInfo, renderPass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferInheritanceInfo, subpass ) == offsetof( VkCommandBufferInheritanceInfo, subpass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferInheritanceInfo, framebuffer ) == offsetof( VkCommandBufferInheritanceInfo, framebuffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferInheritanceInfo, occlusionQueryEnable ) == offsetof( VkCommandBufferInheritanceInfo, occlusionQueryEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferInheritanceInfo, queryFlags ) == offsetof( VkCommandBufferInheritanceInfo, queryFlags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferInheritanceInfo, pipelineStatistics ) == offsetof( VkCommandBufferInheritanceInfo, pipelineStatistics ), "struct member and wrapper member have different offset!" );

  struct CommandBufferBeginInfo
  {
    operator VkCommandBufferBeginInfo const&() const
    {
      return *reinterpret_cast<const VkCommandBufferBeginInfo*>(this);
    }

    operator VkCommandBufferBeginInfo &()
    {
      return *reinterpret_cast<VkCommandBufferBeginInfo*>(this);
    }

    bool operator==( CommandBufferBeginInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( pInheritanceInfo == rhs.pInheritanceInfo );
    }

    bool operator!=( CommandBufferBeginInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eCommandBufferBeginInfo;
    const void* pNext = nullptr;
    CommandBufferUsageFlags flags = CommandBufferUsageFlags();
    const CommandBufferInheritanceInfo* pInheritanceInfo = nullptr;
  };
  static_assert( sizeof( CommandBufferBeginInfo ) == sizeof( VkCommandBufferBeginInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( CommandBufferBeginInfo, pNext ) == offsetof( VkCommandBufferBeginInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferBeginInfo, flags ) == offsetof( VkCommandBufferBeginInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandBufferBeginInfo, pInheritanceInfo ) == offsetof( VkCommandBufferBeginInfo, pInheritanceInfo ), "struct member and wrapper member have different offset!" );

  struct QueryPoolCreateInfo
  {
    operator VkQueryPoolCreateInfo const&() const
    {
      return *reinterpret_cast<const VkQueryPoolCreateInfo*>(this);
    }

    operator VkQueryPoolCreateInfo &()
    {
      return *reinterpret_cast<VkQueryPoolCreateInfo*>(this);
    }

    bool operator==( QueryPoolCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( queryType == rhs.queryType )
          && ( queryCount == rhs.queryCount )
          && ( pipelineStatistics == rhs.pipelineStatistics );
    }

    bool operator!=( QueryPoolCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eQueryPoolCreateInfo;
    const void* pNext = nullptr;
    QueryPoolCreateFlags flags = QueryPoolCreateFlags();
    QueryType queryType = QueryType::eOcclusion;
    uint32_t queryCount = 0;
    QueryPipelineStatisticFlags pipelineStatistics = QueryPipelineStatisticFlags();
  };
  static_assert( sizeof( QueryPoolCreateInfo ) == sizeof( VkQueryPoolCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( QueryPoolCreateInfo, pNext ) == offsetof( VkQueryPoolCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( QueryPoolCreateInfo, flags ) == offsetof( VkQueryPoolCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( QueryPoolCreateInfo, queryType ) == offsetof( VkQueryPoolCreateInfo, queryType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( QueryPoolCreateInfo, queryCount ) == offsetof( VkQueryPoolCreateInfo, queryCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( QueryPoolCreateInfo, pipelineStatistics ) == offsetof( VkQueryPoolCreateInfo, pipelineStatistics ), "struct member and wrapper member have different offset!" );

  enum class ImageAspectFlagBits
  {
    eColor = VK_IMAGE_ASPECT_COLOR_BIT,
    eDepth = VK_IMAGE_ASPECT_DEPTH_BIT,
    eStencil = VK_IMAGE_ASPECT_STENCIL_BIT,
    eMetadata = VK_IMAGE_ASPECT_METADATA_BIT,
    ePlane0 = VK_IMAGE_ASPECT_PLANE_0_BIT,
    ePlane0KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
    ePlane1 = VK_IMAGE_ASPECT_PLANE_1_BIT,
    ePlane1KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
    ePlane2 = VK_IMAGE_ASPECT_PLANE_2_BIT,
    ePlane2KHR = VK_IMAGE_ASPECT_PLANE_2_BIT
  };

  using ImageAspectFlags = Flags<ImageAspectFlagBits, VkImageAspectFlags>;

  VULKAN_HPP_INLINE ImageAspectFlags operator|( ImageAspectFlagBits bit0, ImageAspectFlagBits bit1 )
  {
    return ImageAspectFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ImageAspectFlags operator~( ImageAspectFlagBits bits )
  {
    return ~( ImageAspectFlags( bits ) );
  }

  template <> struct FlagTraits<ImageAspectFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ImageAspectFlagBits::eColor) | VkFlags(ImageAspectFlagBits::eDepth) | VkFlags(ImageAspectFlagBits::eStencil) | VkFlags(ImageAspectFlagBits::eMetadata) | VkFlags(ImageAspectFlagBits::ePlane0) | VkFlags(ImageAspectFlagBits::ePlane1) | VkFlags(ImageAspectFlagBits::ePlane2)
    };
  };

  struct ImageSubresource
  {
    operator VkImageSubresource const&() const
    {
      return *reinterpret_cast<const VkImageSubresource*>(this);
    }

    operator VkImageSubresource &()
    {
      return *reinterpret_cast<VkImageSubresource*>(this);
    }

    bool operator==( ImageSubresource const& rhs ) const
    {
      return ( aspectMask == rhs.aspectMask )
          && ( mipLevel == rhs.mipLevel )
          && ( arrayLayer == rhs.arrayLayer );
    }

    bool operator!=( ImageSubresource const& rhs ) const
    {
      return !operator==( rhs );
    }

    ImageAspectFlags aspectMask = ImageAspectFlags();
    uint32_t mipLevel = 0;
    uint32_t arrayLayer = 0;
  };
  static_assert( sizeof( ImageSubresource ) == sizeof( VkImageSubresource ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageSubresource, aspectMask ) == offsetof( VkImageSubresource, aspectMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSubresource, mipLevel ) == offsetof( VkImageSubresource, mipLevel ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSubresource, arrayLayer ) == offsetof( VkImageSubresource, arrayLayer ), "struct member and wrapper member have different offset!" );

  struct ImageSubresourceLayers
  {
    operator VkImageSubresourceLayers const&() const
    {
      return *reinterpret_cast<const VkImageSubresourceLayers*>(this);
    }

    operator VkImageSubresourceLayers &()
    {
      return *reinterpret_cast<VkImageSubresourceLayers*>(this);
    }

    bool operator==( ImageSubresourceLayers const& rhs ) const
    {
      return ( aspectMask == rhs.aspectMask )
          && ( mipLevel == rhs.mipLevel )
          && ( baseArrayLayer == rhs.baseArrayLayer )
          && ( layerCount == rhs.layerCount );
    }

    bool operator!=( ImageSubresourceLayers const& rhs ) const
    {
      return !operator==( rhs );
    }

    ImageAspectFlags aspectMask = ImageAspectFlags();
    uint32_t mipLevel = 0;
    uint32_t baseArrayLayer = 0;
    uint32_t layerCount = 0;
  };
  static_assert( sizeof( ImageSubresourceLayers ) == sizeof( VkImageSubresourceLayers ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageSubresourceLayers, aspectMask ) == offsetof( VkImageSubresourceLayers, aspectMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSubresourceLayers, mipLevel ) == offsetof( VkImageSubresourceLayers, mipLevel ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSubresourceLayers, baseArrayLayer ) == offsetof( VkImageSubresourceLayers, baseArrayLayer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSubresourceLayers, layerCount ) == offsetof( VkImageSubresourceLayers, layerCount ), "struct member and wrapper member have different offset!" );

  struct ImageSubresourceRange
  {
    operator VkImageSubresourceRange const&() const
    {
      return *reinterpret_cast<const VkImageSubresourceRange*>(this);
    }

    operator VkImageSubresourceRange &()
    {
      return *reinterpret_cast<VkImageSubresourceRange*>(this);
    }

    bool operator==( ImageSubresourceRange const& rhs ) const
    {
      return ( aspectMask == rhs.aspectMask )
          && ( baseMipLevel == rhs.baseMipLevel )
          && ( levelCount == rhs.levelCount )
          && ( baseArrayLayer == rhs.baseArrayLayer )
          && ( layerCount == rhs.layerCount );
    }

    bool operator!=( ImageSubresourceRange const& rhs ) const
    {
      return !operator==( rhs );
    }

    ImageAspectFlags aspectMask = ImageAspectFlags();
    uint32_t baseMipLevel = 0;
    uint32_t levelCount = 0;
    uint32_t baseArrayLayer = 0;
    uint32_t layerCount = 0;
  };
  static_assert( sizeof( ImageSubresourceRange ) == sizeof( VkImageSubresourceRange ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageSubresourceRange, aspectMask ) == offsetof( VkImageSubresourceRange, aspectMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSubresourceRange, baseMipLevel ) == offsetof( VkImageSubresourceRange, baseMipLevel ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSubresourceRange, levelCount ) == offsetof( VkImageSubresourceRange, levelCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSubresourceRange, baseArrayLayer ) == offsetof( VkImageSubresourceRange, baseArrayLayer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageSubresourceRange, layerCount ) == offsetof( VkImageSubresourceRange, layerCount ), "struct member and wrapper member have different offset!" );

  struct ImageMemoryBarrier
  {
    operator VkImageMemoryBarrier const&() const
    {
      return *reinterpret_cast<const VkImageMemoryBarrier*>(this);
    }

    operator VkImageMemoryBarrier &()
    {
      return *reinterpret_cast<VkImageMemoryBarrier*>(this);
    }

    bool operator==( ImageMemoryBarrier const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( srcAccessMask == rhs.srcAccessMask )
          && ( dstAccessMask == rhs.dstAccessMask )
          && ( oldLayout == rhs.oldLayout )
          && ( newLayout == rhs.newLayout )
          && ( srcQueueFamilyIndex == rhs.srcQueueFamilyIndex )
          && ( dstQueueFamilyIndex == rhs.dstQueueFamilyIndex )
          && ( image == rhs.image )
          && ( subresourceRange == rhs.subresourceRange );
    }

    bool operator!=( ImageMemoryBarrier const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageMemoryBarrier;
    const void* pNext = nullptr;
    AccessFlags srcAccessMask = AccessFlags();
    AccessFlags dstAccessMask = AccessFlags();
    ImageLayout oldLayout = ImageLayout::eUndefined;
    ImageLayout newLayout = ImageLayout::eUndefined;
    uint32_t srcQueueFamilyIndex = 0;
    uint32_t dstQueueFamilyIndex = 0;
    Image image = Image();
    ImageSubresourceRange subresourceRange = ImageSubresourceRange();
  };
  static_assert( sizeof( ImageMemoryBarrier ) == sizeof( VkImageMemoryBarrier ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageMemoryBarrier, pNext ) == offsetof( VkImageMemoryBarrier, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageMemoryBarrier, srcAccessMask ) == offsetof( VkImageMemoryBarrier, srcAccessMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageMemoryBarrier, dstAccessMask ) == offsetof( VkImageMemoryBarrier, dstAccessMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageMemoryBarrier, oldLayout ) == offsetof( VkImageMemoryBarrier, oldLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageMemoryBarrier, newLayout ) == offsetof( VkImageMemoryBarrier, newLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageMemoryBarrier, srcQueueFamilyIndex ) == offsetof( VkImageMemoryBarrier, srcQueueFamilyIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageMemoryBarrier, dstQueueFamilyIndex ) == offsetof( VkImageMemoryBarrier, dstQueueFamilyIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageMemoryBarrier, image ) == offsetof( VkImageMemoryBarrier, image ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageMemoryBarrier, subresourceRange ) == offsetof( VkImageMemoryBarrier, subresourceRange ), "struct member and wrapper member have different offset!" );

  struct ImageViewCreateInfo
  {
    operator VkImageViewCreateInfo const&() const
    {
      return *reinterpret_cast<const VkImageViewCreateInfo*>(this);
    }

    operator VkImageViewCreateInfo &()
    {
      return *reinterpret_cast<VkImageViewCreateInfo*>(this);
    }

    bool operator==( ImageViewCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( image == rhs.image )
          && ( viewType == rhs.viewType )
          && ( format == rhs.format )
          && ( components == rhs.components )
          && ( subresourceRange == rhs.subresourceRange );
    }

    bool operator!=( ImageViewCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageViewCreateInfo;
    const void* pNext = nullptr;
    ImageViewCreateFlags flags = ImageViewCreateFlags();
    Image image = Image();
    ImageViewType viewType = ImageViewType::e1D;
    Format format = Format::eUndefined;
    ComponentMapping components = ComponentMapping();
    ImageSubresourceRange subresourceRange = ImageSubresourceRange();
  };
  static_assert( sizeof( ImageViewCreateInfo ) == sizeof( VkImageViewCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageViewCreateInfo, pNext ) == offsetof( VkImageViewCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageViewCreateInfo, flags ) == offsetof( VkImageViewCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageViewCreateInfo, image ) == offsetof( VkImageViewCreateInfo, image ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageViewCreateInfo, viewType ) == offsetof( VkImageViewCreateInfo, viewType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageViewCreateInfo, format ) == offsetof( VkImageViewCreateInfo, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageViewCreateInfo, components ) == offsetof( VkImageViewCreateInfo, components ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageViewCreateInfo, subresourceRange ) == offsetof( VkImageViewCreateInfo, subresourceRange ), "struct member and wrapper member have different offset!" );

  struct ImageCopy
  {
    operator VkImageCopy const&() const
    {
      return *reinterpret_cast<const VkImageCopy*>(this);
    }

    operator VkImageCopy &()
    {
      return *reinterpret_cast<VkImageCopy*>(this);
    }

    bool operator==( ImageCopy const& rhs ) const
    {
      return ( srcSubresource == rhs.srcSubresource )
          && ( srcOffset == rhs.srcOffset )
          && ( dstSubresource == rhs.dstSubresource )
          && ( dstOffset == rhs.dstOffset )
          && ( extent == rhs.extent );
    }

    bool operator!=( ImageCopy const& rhs ) const
    {
      return !operator==( rhs );
    }

    ImageSubresourceLayers srcSubresource = ImageSubresourceLayers();
    Offset3D srcOffset = Offset3D();
    ImageSubresourceLayers dstSubresource = ImageSubresourceLayers();
    Offset3D dstOffset = Offset3D();
    Extent3D extent = Extent3D();
  };
  static_assert( sizeof( ImageCopy ) == sizeof( VkImageCopy ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageCopy, srcSubresource ) == offsetof( VkImageCopy, srcSubresource ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCopy, srcOffset ) == offsetof( VkImageCopy, srcOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCopy, dstSubresource ) == offsetof( VkImageCopy, dstSubresource ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCopy, dstOffset ) == offsetof( VkImageCopy, dstOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCopy, extent ) == offsetof( VkImageCopy, extent ), "struct member and wrapper member have different offset!" );

  struct ImageBlit
  {
    operator VkImageBlit const&() const
    {
      return *reinterpret_cast<const VkImageBlit*>(this);
    }

    operator VkImageBlit &()
    {
      return *reinterpret_cast<VkImageBlit*>(this);
    }

    bool operator==( ImageBlit const& rhs ) const
    {
      return ( srcSubresource == rhs.srcSubresource )
          && ( srcOffsets == rhs.srcOffsets )
          && ( dstSubresource == rhs.dstSubresource )
          && ( dstOffsets == rhs.dstOffsets );
    }

    bool operator!=( ImageBlit const& rhs ) const
    {
      return !operator==( rhs );
    }

    ImageSubresourceLayers srcSubresource = ImageSubresourceLayers();
    std::array<Offset3D, 2> srcOffsets = { { Offset3D(), Offset3D() } };
    ImageSubresourceLayers dstSubresource = ImageSubresourceLayers();
    std::array<Offset3D, 2> dstOffsets = { { Offset3D(), Offset3D() } };
  };
  static_assert( sizeof( ImageBlit ) == sizeof( VkImageBlit ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageBlit, srcSubresource ) == offsetof( VkImageBlit, srcSubresource ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageBlit, srcOffsets ) == offsetof( VkImageBlit, srcOffsets ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageBlit, dstSubresource ) == offsetof( VkImageBlit, dstSubresource ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageBlit, dstOffsets ) == offsetof( VkImageBlit, dstOffsets ), "struct member and wrapper member have different offset!" );

  struct BufferImageCopy
  {
    operator VkBufferImageCopy const&() const
    {
      return *reinterpret_cast<const VkBufferImageCopy*>(this);
    }

    operator VkBufferImageCopy &()
    {
      return *reinterpret_cast<VkBufferImageCopy*>(this);
    }

    bool operator==( BufferImageCopy const& rhs ) const
    {
      return ( bufferOffset == rhs.bufferOffset )
          && ( bufferRowLength == rhs.bufferRowLength )
          && ( bufferImageHeight == rhs.bufferImageHeight )
          && ( imageSubresource == rhs.imageSubresource )
          && ( imageOffset == rhs.imageOffset )
          && ( imageExtent == rhs.imageExtent );
    }

    bool operator!=( BufferImageCopy const& rhs ) const
    {
      return !operator==( rhs );
    }

    DeviceSize bufferOffset = 0;
    uint32_t bufferRowLength = 0;
    uint32_t bufferImageHeight = 0;
    ImageSubresourceLayers imageSubresource = ImageSubresourceLayers();
    Offset3D imageOffset = Offset3D();
    Extent3D imageExtent = Extent3D();
  };
  static_assert( sizeof( BufferImageCopy ) == sizeof( VkBufferImageCopy ), "struct and wrapper have different size!" );
  static_assert( offsetof( BufferImageCopy, bufferOffset ) == offsetof( VkBufferImageCopy, bufferOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferImageCopy, bufferRowLength ) == offsetof( VkBufferImageCopy, bufferRowLength ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferImageCopy, bufferImageHeight ) == offsetof( VkBufferImageCopy, bufferImageHeight ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferImageCopy, imageSubresource ) == offsetof( VkBufferImageCopy, imageSubresource ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferImageCopy, imageOffset ) == offsetof( VkBufferImageCopy, imageOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BufferImageCopy, imageExtent ) == offsetof( VkBufferImageCopy, imageExtent ), "struct member and wrapper member have different offset!" );

  struct ImageResolve
  {
    operator VkImageResolve const&() const
    {
      return *reinterpret_cast<const VkImageResolve*>(this);
    }

    operator VkImageResolve &()
    {
      return *reinterpret_cast<VkImageResolve*>(this);
    }

    bool operator==( ImageResolve const& rhs ) const
    {
      return ( srcSubresource == rhs.srcSubresource )
          && ( srcOffset == rhs.srcOffset )
          && ( dstSubresource == rhs.dstSubresource )
          && ( dstOffset == rhs.dstOffset )
          && ( extent == rhs.extent );
    }

    bool operator!=( ImageResolve const& rhs ) const
    {
      return !operator==( rhs );
    }

    ImageSubresourceLayers srcSubresource = ImageSubresourceLayers();
    Offset3D srcOffset = Offset3D();
    ImageSubresourceLayers dstSubresource = ImageSubresourceLayers();
    Offset3D dstOffset = Offset3D();
    Extent3D extent = Extent3D();
  };
  static_assert( sizeof( ImageResolve ) == sizeof( VkImageResolve ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageResolve, srcSubresource ) == offsetof( VkImageResolve, srcSubresource ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageResolve, srcOffset ) == offsetof( VkImageResolve, srcOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageResolve, dstSubresource ) == offsetof( VkImageResolve, dstSubresource ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageResolve, dstOffset ) == offsetof( VkImageResolve, dstOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageResolve, extent ) == offsetof( VkImageResolve, extent ), "struct member and wrapper member have different offset!" );

  struct ClearAttachment
  {
    operator VkClearAttachment const&() const
    {
      return *reinterpret_cast<const VkClearAttachment*>(this);
    }

    operator VkClearAttachment &()
    {
      return *reinterpret_cast<VkClearAttachment*>(this);
    }

    ImageAspectFlags aspectMask = ImageAspectFlags();
    uint32_t colorAttachment = 0;
    ClearValue clearValue = ClearValue();
  };
  static_assert( sizeof( ClearAttachment ) == sizeof( VkClearAttachment ), "struct and wrapper have different size!" );
  static_assert( offsetof( ClearAttachment, aspectMask ) == offsetof( VkClearAttachment, aspectMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ClearAttachment, colorAttachment ) == offsetof( VkClearAttachment, colorAttachment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ClearAttachment, clearValue ) == offsetof( VkClearAttachment, clearValue ), "struct member and wrapper member have different offset!" );

  struct InputAttachmentAspectReference
  {
    operator VkInputAttachmentAspectReference const&() const
    {
      return *reinterpret_cast<const VkInputAttachmentAspectReference*>(this);
    }

    operator VkInputAttachmentAspectReference &()
    {
      return *reinterpret_cast<VkInputAttachmentAspectReference*>(this);
    }

    bool operator==( InputAttachmentAspectReference const& rhs ) const
    {
      return ( subpass == rhs.subpass )
          && ( inputAttachmentIndex == rhs.inputAttachmentIndex )
          && ( aspectMask == rhs.aspectMask );
    }

    bool operator!=( InputAttachmentAspectReference const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t subpass = 0;
    uint32_t inputAttachmentIndex = 0;
    ImageAspectFlags aspectMask = ImageAspectFlags();
  };
  static_assert( sizeof( InputAttachmentAspectReference ) == sizeof( VkInputAttachmentAspectReference ), "struct and wrapper have different size!" );
  static_assert( offsetof( InputAttachmentAspectReference, subpass ) == offsetof( VkInputAttachmentAspectReference, subpass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( InputAttachmentAspectReference, inputAttachmentIndex ) == offsetof( VkInputAttachmentAspectReference, inputAttachmentIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( InputAttachmentAspectReference, aspectMask ) == offsetof( VkInputAttachmentAspectReference, aspectMask ), "struct member and wrapper member have different offset!" );

  using InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;

  struct RenderPassInputAttachmentAspectCreateInfo
  {
    operator VkRenderPassInputAttachmentAspectCreateInfo const&() const
    {
      return *reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(this);
    }

    operator VkRenderPassInputAttachmentAspectCreateInfo &()
    {
      return *reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(this);
    }

    bool operator==( RenderPassInputAttachmentAspectCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( aspectReferenceCount == rhs.aspectReferenceCount )
          && ( pAspectReferences == rhs.pAspectReferences );
    }

    bool operator!=( RenderPassInputAttachmentAspectCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eRenderPassInputAttachmentAspectCreateInfo;
    const void* pNext = nullptr;
    uint32_t aspectReferenceCount = 0;
    const InputAttachmentAspectReference* pAspectReferences = nullptr;
  };
  static_assert( sizeof( RenderPassInputAttachmentAspectCreateInfo ) == sizeof( VkRenderPassInputAttachmentAspectCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( RenderPassInputAttachmentAspectCreateInfo, pNext ) == offsetof( VkRenderPassInputAttachmentAspectCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassInputAttachmentAspectCreateInfo, aspectReferenceCount ) == offsetof( VkRenderPassInputAttachmentAspectCreateInfo, aspectReferenceCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassInputAttachmentAspectCreateInfo, pAspectReferences ) == offsetof( VkRenderPassInputAttachmentAspectCreateInfo, pAspectReferences ), "struct member and wrapper member have different offset!" );

  using RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;

  struct BindImagePlaneMemoryInfo
  {
    operator VkBindImagePlaneMemoryInfo const&() const
    {
      return *reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(this);
    }

    operator VkBindImagePlaneMemoryInfo &()
    {
      return *reinterpret_cast<VkBindImagePlaneMemoryInfo*>(this);
    }

    bool operator==( BindImagePlaneMemoryInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( planeAspect == rhs.planeAspect );
    }

    bool operator!=( BindImagePlaneMemoryInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBindImagePlaneMemoryInfo;
    const void* pNext = nullptr;
    ImageAspectFlagBits planeAspect = ImageAspectFlagBits::eColor;
  };
  static_assert( sizeof( BindImagePlaneMemoryInfo ) == sizeof( VkBindImagePlaneMemoryInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( BindImagePlaneMemoryInfo, pNext ) == offsetof( VkBindImagePlaneMemoryInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindImagePlaneMemoryInfo, planeAspect ) == offsetof( VkBindImagePlaneMemoryInfo, planeAspect ), "struct member and wrapper member have different offset!" );

  using BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;

  struct ImagePlaneMemoryRequirementsInfo
  {
    operator VkImagePlaneMemoryRequirementsInfo const&() const
    {
      return *reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(this);
    }

    operator VkImagePlaneMemoryRequirementsInfo &()
    {
      return *reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(this);
    }

    bool operator==( ImagePlaneMemoryRequirementsInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( planeAspect == rhs.planeAspect );
    }

    bool operator!=( ImagePlaneMemoryRequirementsInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImagePlaneMemoryRequirementsInfo;
    const void* pNext = nullptr;
    ImageAspectFlagBits planeAspect = ImageAspectFlagBits::eColor;
  };
  static_assert( sizeof( ImagePlaneMemoryRequirementsInfo ) == sizeof( VkImagePlaneMemoryRequirementsInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImagePlaneMemoryRequirementsInfo, pNext ) == offsetof( VkImagePlaneMemoryRequirementsInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImagePlaneMemoryRequirementsInfo, planeAspect ) == offsetof( VkImagePlaneMemoryRequirementsInfo, planeAspect ), "struct member and wrapper member have different offset!" );

  using ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;

  struct AttachmentReference2KHR
  {
    operator VkAttachmentReference2KHR const&() const
    {
      return *reinterpret_cast<const VkAttachmentReference2KHR*>(this);
    }

    operator VkAttachmentReference2KHR &()
    {
      return *reinterpret_cast<VkAttachmentReference2KHR*>(this);
    }

    bool operator==( AttachmentReference2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( attachment == rhs.attachment )
          && ( layout == rhs.layout )
          && ( aspectMask == rhs.aspectMask );
    }

    bool operator!=( AttachmentReference2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eAttachmentReference2KHR;
    const void* pNext = nullptr;
    uint32_t attachment = 0;
    ImageLayout layout = ImageLayout::eUndefined;
    ImageAspectFlags aspectMask = ImageAspectFlags();
  };
  static_assert( sizeof( AttachmentReference2KHR ) == sizeof( VkAttachmentReference2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( AttachmentReference2KHR, pNext ) == offsetof( VkAttachmentReference2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentReference2KHR, attachment ) == offsetof( VkAttachmentReference2KHR, attachment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentReference2KHR, layout ) == offsetof( VkAttachmentReference2KHR, layout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentReference2KHR, aspectMask ) == offsetof( VkAttachmentReference2KHR, aspectMask ), "struct member and wrapper member have different offset!" );

  enum class SparseImageFormatFlagBits
  {
    eSingleMiptail = VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT,
    eAlignedMipSize = VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT,
    eNonstandardBlockSize = VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT
  };

  using SparseImageFormatFlags = Flags<SparseImageFormatFlagBits, VkSparseImageFormatFlags>;

  VULKAN_HPP_INLINE SparseImageFormatFlags operator|( SparseImageFormatFlagBits bit0, SparseImageFormatFlagBits bit1 )
  {
    return SparseImageFormatFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE SparseImageFormatFlags operator~( SparseImageFormatFlagBits bits )
  {
    return ~( SparseImageFormatFlags( bits ) );
  }

  template <> struct FlagTraits<SparseImageFormatFlagBits>
  {
    enum
    {
      allFlags = VkFlags(SparseImageFormatFlagBits::eSingleMiptail) | VkFlags(SparseImageFormatFlagBits::eAlignedMipSize) | VkFlags(SparseImageFormatFlagBits::eNonstandardBlockSize)
    };
  };

  struct SparseImageFormatProperties
  {
    operator VkSparseImageFormatProperties const&() const
    {
      return *reinterpret_cast<const VkSparseImageFormatProperties*>(this);
    }

    operator VkSparseImageFormatProperties &()
    {
      return *reinterpret_cast<VkSparseImageFormatProperties*>(this);
    }

    bool operator==( SparseImageFormatProperties const& rhs ) const
    {
      return ( aspectMask == rhs.aspectMask )
          && ( imageGranularity == rhs.imageGranularity )
          && ( flags == rhs.flags );
    }

    bool operator!=( SparseImageFormatProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    ImageAspectFlags aspectMask = ImageAspectFlags();
    Extent3D imageGranularity = Extent3D();
    SparseImageFormatFlags flags = SparseImageFormatFlags();
  };
  static_assert( sizeof( SparseImageFormatProperties ) == sizeof( VkSparseImageFormatProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( SparseImageFormatProperties, aspectMask ) == offsetof( VkSparseImageFormatProperties, aspectMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageFormatProperties, imageGranularity ) == offsetof( VkSparseImageFormatProperties, imageGranularity ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageFormatProperties, flags ) == offsetof( VkSparseImageFormatProperties, flags ), "struct member and wrapper member have different offset!" );

  struct SparseImageMemoryRequirements
  {
    operator VkSparseImageMemoryRequirements const&() const
    {
      return *reinterpret_cast<const VkSparseImageMemoryRequirements*>(this);
    }

    operator VkSparseImageMemoryRequirements &()
    {
      return *reinterpret_cast<VkSparseImageMemoryRequirements*>(this);
    }

    bool operator==( SparseImageMemoryRequirements const& rhs ) const
    {
      return ( formatProperties == rhs.formatProperties )
          && ( imageMipTailFirstLod == rhs.imageMipTailFirstLod )
          && ( imageMipTailSize == rhs.imageMipTailSize )
          && ( imageMipTailOffset == rhs.imageMipTailOffset )
          && ( imageMipTailStride == rhs.imageMipTailStride );
    }

    bool operator!=( SparseImageMemoryRequirements const& rhs ) const
    {
      return !operator==( rhs );
    }

    SparseImageFormatProperties formatProperties = SparseImageFormatProperties();
    uint32_t imageMipTailFirstLod = 0;
    DeviceSize imageMipTailSize = 0;
    DeviceSize imageMipTailOffset = 0;
    DeviceSize imageMipTailStride = 0;
  };
  static_assert( sizeof( SparseImageMemoryRequirements ) == sizeof( VkSparseImageMemoryRequirements ), "struct and wrapper have different size!" );
  static_assert( offsetof( SparseImageMemoryRequirements, formatProperties ) == offsetof( VkSparseImageMemoryRequirements, formatProperties ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryRequirements, imageMipTailFirstLod ) == offsetof( VkSparseImageMemoryRequirements, imageMipTailFirstLod ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryRequirements, imageMipTailSize ) == offsetof( VkSparseImageMemoryRequirements, imageMipTailSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryRequirements, imageMipTailOffset ) == offsetof( VkSparseImageMemoryRequirements, imageMipTailOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryRequirements, imageMipTailStride ) == offsetof( VkSparseImageMemoryRequirements, imageMipTailStride ), "struct member and wrapper member have different offset!" );

  struct SparseImageFormatProperties2
  {
    operator VkSparseImageFormatProperties2 const&() const
    {
      return *reinterpret_cast<const VkSparseImageFormatProperties2*>(this);
    }

    operator VkSparseImageFormatProperties2 &()
    {
      return *reinterpret_cast<VkSparseImageFormatProperties2*>(this);
    }

    bool operator==( SparseImageFormatProperties2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( properties == rhs.properties );
    }

    bool operator!=( SparseImageFormatProperties2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSparseImageFormatProperties2;
    void* pNext = nullptr;
    SparseImageFormatProperties properties = SparseImageFormatProperties();
  };
  static_assert( sizeof( SparseImageFormatProperties2 ) == sizeof( VkSparseImageFormatProperties2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( SparseImageFormatProperties2, pNext ) == offsetof( VkSparseImageFormatProperties2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageFormatProperties2, properties ) == offsetof( VkSparseImageFormatProperties2, properties ), "struct member and wrapper member have different offset!" );

  using SparseImageFormatProperties2KHR = SparseImageFormatProperties2;

  struct SparseImageMemoryRequirements2
  {
    operator VkSparseImageMemoryRequirements2 const&() const
    {
      return *reinterpret_cast<const VkSparseImageMemoryRequirements2*>(this);
    }

    operator VkSparseImageMemoryRequirements2 &()
    {
      return *reinterpret_cast<VkSparseImageMemoryRequirements2*>(this);
    }

    bool operator==( SparseImageMemoryRequirements2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memoryRequirements == rhs.memoryRequirements );
    }

    bool operator!=( SparseImageMemoryRequirements2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSparseImageMemoryRequirements2;
    void* pNext = nullptr;
    SparseImageMemoryRequirements memoryRequirements = SparseImageMemoryRequirements();
  };
  static_assert( sizeof( SparseImageMemoryRequirements2 ) == sizeof( VkSparseImageMemoryRequirements2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( SparseImageMemoryRequirements2, pNext ) == offsetof( VkSparseImageMemoryRequirements2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryRequirements2, memoryRequirements ) == offsetof( VkSparseImageMemoryRequirements2, memoryRequirements ), "struct member and wrapper member have different offset!" );

  using SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;

  enum class SparseMemoryBindFlagBits
  {
    eMetadata = VK_SPARSE_MEMORY_BIND_METADATA_BIT
  };

  using SparseMemoryBindFlags = Flags<SparseMemoryBindFlagBits, VkSparseMemoryBindFlags>;

  VULKAN_HPP_INLINE SparseMemoryBindFlags operator|( SparseMemoryBindFlagBits bit0, SparseMemoryBindFlagBits bit1 )
  {
    return SparseMemoryBindFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE SparseMemoryBindFlags operator~( SparseMemoryBindFlagBits bits )
  {
    return ~( SparseMemoryBindFlags( bits ) );
  }

  template <> struct FlagTraits<SparseMemoryBindFlagBits>
  {
    enum
    {
      allFlags = VkFlags(SparseMemoryBindFlagBits::eMetadata)
    };
  };

  struct SparseMemoryBind
  {
    operator VkSparseMemoryBind const&() const
    {
      return *reinterpret_cast<const VkSparseMemoryBind*>(this);
    }

    operator VkSparseMemoryBind &()
    {
      return *reinterpret_cast<VkSparseMemoryBind*>(this);
    }

    bool operator==( SparseMemoryBind const& rhs ) const
    {
      return ( resourceOffset == rhs.resourceOffset )
          && ( size == rhs.size )
          && ( memory == rhs.memory )
          && ( memoryOffset == rhs.memoryOffset )
          && ( flags == rhs.flags );
    }

    bool operator!=( SparseMemoryBind const& rhs ) const
    {
      return !operator==( rhs );
    }

    DeviceSize resourceOffset = 0;
    DeviceSize size = 0;
    DeviceMemory memory = DeviceMemory();
    DeviceSize memoryOffset = 0;
    SparseMemoryBindFlags flags = SparseMemoryBindFlags();
  };
  static_assert( sizeof( SparseMemoryBind ) == sizeof( VkSparseMemoryBind ), "struct and wrapper have different size!" );
  static_assert( offsetof( SparseMemoryBind, resourceOffset ) == offsetof( VkSparseMemoryBind, resourceOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseMemoryBind, size ) == offsetof( VkSparseMemoryBind, size ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseMemoryBind, memory ) == offsetof( VkSparseMemoryBind, memory ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseMemoryBind, memoryOffset ) == offsetof( VkSparseMemoryBind, memoryOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseMemoryBind, flags ) == offsetof( VkSparseMemoryBind, flags ), "struct member and wrapper member have different offset!" );

  struct SparseImageMemoryBind
  {
    operator VkSparseImageMemoryBind const&() const
    {
      return *reinterpret_cast<const VkSparseImageMemoryBind*>(this);
    }

    operator VkSparseImageMemoryBind &()
    {
      return *reinterpret_cast<VkSparseImageMemoryBind*>(this);
    }

    bool operator==( SparseImageMemoryBind const& rhs ) const
    {
      return ( subresource == rhs.subresource )
          && ( offset == rhs.offset )
          && ( extent == rhs.extent )
          && ( memory == rhs.memory )
          && ( memoryOffset == rhs.memoryOffset )
          && ( flags == rhs.flags );
    }

    bool operator!=( SparseImageMemoryBind const& rhs ) const
    {
      return !operator==( rhs );
    }

    ImageSubresource subresource = ImageSubresource();
    Offset3D offset = Offset3D();
    Extent3D extent = Extent3D();
    DeviceMemory memory = DeviceMemory();
    DeviceSize memoryOffset = 0;
    SparseMemoryBindFlags flags = SparseMemoryBindFlags();
  };
  static_assert( sizeof( SparseImageMemoryBind ) == sizeof( VkSparseImageMemoryBind ), "struct and wrapper have different size!" );
  static_assert( offsetof( SparseImageMemoryBind, subresource ) == offsetof( VkSparseImageMemoryBind, subresource ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryBind, offset ) == offsetof( VkSparseImageMemoryBind, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryBind, extent ) == offsetof( VkSparseImageMemoryBind, extent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryBind, memory ) == offsetof( VkSparseImageMemoryBind, memory ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryBind, memoryOffset ) == offsetof( VkSparseImageMemoryBind, memoryOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryBind, flags ) == offsetof( VkSparseImageMemoryBind, flags ), "struct member and wrapper member have different offset!" );

  struct SparseBufferMemoryBindInfo
  {
    operator VkSparseBufferMemoryBindInfo const&() const
    {
      return *reinterpret_cast<const VkSparseBufferMemoryBindInfo*>(this);
    }

    operator VkSparseBufferMemoryBindInfo &()
    {
      return *reinterpret_cast<VkSparseBufferMemoryBindInfo*>(this);
    }

    bool operator==( SparseBufferMemoryBindInfo const& rhs ) const
    {
      return ( buffer == rhs.buffer )
          && ( bindCount == rhs.bindCount )
          && ( pBinds == rhs.pBinds );
    }

    bool operator!=( SparseBufferMemoryBindInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    Buffer buffer = Buffer();
    uint32_t bindCount = 0;
    const SparseMemoryBind* pBinds = nullptr;
  };
  static_assert( sizeof( SparseBufferMemoryBindInfo ) == sizeof( VkSparseBufferMemoryBindInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( SparseBufferMemoryBindInfo, buffer ) == offsetof( VkSparseBufferMemoryBindInfo, buffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseBufferMemoryBindInfo, bindCount ) == offsetof( VkSparseBufferMemoryBindInfo, bindCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseBufferMemoryBindInfo, pBinds ) == offsetof( VkSparseBufferMemoryBindInfo, pBinds ), "struct member and wrapper member have different offset!" );

  struct SparseImageOpaqueMemoryBindInfo
  {
    operator VkSparseImageOpaqueMemoryBindInfo const&() const
    {
      return *reinterpret_cast<const VkSparseImageOpaqueMemoryBindInfo*>(this);
    }

    operator VkSparseImageOpaqueMemoryBindInfo &()
    {
      return *reinterpret_cast<VkSparseImageOpaqueMemoryBindInfo*>(this);
    }

    bool operator==( SparseImageOpaqueMemoryBindInfo const& rhs ) const
    {
      return ( image == rhs.image )
          && ( bindCount == rhs.bindCount )
          && ( pBinds == rhs.pBinds );
    }

    bool operator!=( SparseImageOpaqueMemoryBindInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    Image image = Image();
    uint32_t bindCount = 0;
    const SparseMemoryBind* pBinds = nullptr;
  };
  static_assert( sizeof( SparseImageOpaqueMemoryBindInfo ) == sizeof( VkSparseImageOpaqueMemoryBindInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( SparseImageOpaqueMemoryBindInfo, image ) == offsetof( VkSparseImageOpaqueMemoryBindInfo, image ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageOpaqueMemoryBindInfo, bindCount ) == offsetof( VkSparseImageOpaqueMemoryBindInfo, bindCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageOpaqueMemoryBindInfo, pBinds ) == offsetof( VkSparseImageOpaqueMemoryBindInfo, pBinds ), "struct member and wrapper member have different offset!" );

  struct SparseImageMemoryBindInfo
  {
    operator VkSparseImageMemoryBindInfo const&() const
    {
      return *reinterpret_cast<const VkSparseImageMemoryBindInfo*>(this);
    }

    operator VkSparseImageMemoryBindInfo &()
    {
      return *reinterpret_cast<VkSparseImageMemoryBindInfo*>(this);
    }

    bool operator==( SparseImageMemoryBindInfo const& rhs ) const
    {
      return ( image == rhs.image )
          && ( bindCount == rhs.bindCount )
          && ( pBinds == rhs.pBinds );
    }

    bool operator!=( SparseImageMemoryBindInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    Image image = Image();
    uint32_t bindCount = 0;
    const SparseImageMemoryBind* pBinds = nullptr;
  };
  static_assert( sizeof( SparseImageMemoryBindInfo ) == sizeof( VkSparseImageMemoryBindInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( SparseImageMemoryBindInfo, image ) == offsetof( VkSparseImageMemoryBindInfo, image ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryBindInfo, bindCount ) == offsetof( VkSparseImageMemoryBindInfo, bindCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SparseImageMemoryBindInfo, pBinds ) == offsetof( VkSparseImageMemoryBindInfo, pBinds ), "struct member and wrapper member have different offset!" );

  struct BindSparseInfo
  {
    operator VkBindSparseInfo const&() const
    {
      return *reinterpret_cast<const VkBindSparseInfo*>(this);
    }

    operator VkBindSparseInfo &()
    {
      return *reinterpret_cast<VkBindSparseInfo*>(this);
    }

    bool operator==( BindSparseInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( waitSemaphoreCount == rhs.waitSemaphoreCount )
          && ( pWaitSemaphores == rhs.pWaitSemaphores )
          && ( bufferBindCount == rhs.bufferBindCount )
          && ( pBufferBinds == rhs.pBufferBinds )
          && ( imageOpaqueBindCount == rhs.imageOpaqueBindCount )
          && ( pImageOpaqueBinds == rhs.pImageOpaqueBinds )
          && ( imageBindCount == rhs.imageBindCount )
          && ( pImageBinds == rhs.pImageBinds )
          && ( signalSemaphoreCount == rhs.signalSemaphoreCount )
          && ( pSignalSemaphores == rhs.pSignalSemaphores );
    }

    bool operator!=( BindSparseInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eBindSparseInfo;
    const void* pNext = nullptr;
    uint32_t waitSemaphoreCount = 0;
    const Semaphore* pWaitSemaphores = nullptr;
    uint32_t bufferBindCount = 0;
    const SparseBufferMemoryBindInfo* pBufferBinds = nullptr;
    uint32_t imageOpaqueBindCount = 0;
    const SparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds = nullptr;
    uint32_t imageBindCount = 0;
    const SparseImageMemoryBindInfo* pImageBinds = nullptr;
    uint32_t signalSemaphoreCount = 0;
    const Semaphore* pSignalSemaphores = nullptr;
  };
  static_assert( sizeof( BindSparseInfo ) == sizeof( VkBindSparseInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( BindSparseInfo, pNext ) == offsetof( VkBindSparseInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, waitSemaphoreCount ) == offsetof( VkBindSparseInfo, waitSemaphoreCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, pWaitSemaphores ) == offsetof( VkBindSparseInfo, pWaitSemaphores ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, bufferBindCount ) == offsetof( VkBindSparseInfo, bufferBindCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, pBufferBinds ) == offsetof( VkBindSparseInfo, pBufferBinds ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, imageOpaqueBindCount ) == offsetof( VkBindSparseInfo, imageOpaqueBindCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, pImageOpaqueBinds ) == offsetof( VkBindSparseInfo, pImageOpaqueBinds ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, imageBindCount ) == offsetof( VkBindSparseInfo, imageBindCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, pImageBinds ) == offsetof( VkBindSparseInfo, pImageBinds ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, signalSemaphoreCount ) == offsetof( VkBindSparseInfo, signalSemaphoreCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( BindSparseInfo, pSignalSemaphores ) == offsetof( VkBindSparseInfo, pSignalSemaphores ), "struct member and wrapper member have different offset!" );

  enum class PipelineStageFlagBits
  {
    eTopOfPipe = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    eDrawIndirect = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    eVertexInput = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    eVertexShader = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    eTessellationControlShader = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    eTessellationEvaluationShader = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    eGeometryShader = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    eFragmentShader = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    eEarlyFragmentTests = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    eLateFragmentTests = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    eColorAttachmentOutput = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    eComputeShader = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    eTransfer = VK_PIPELINE_STAGE_TRANSFER_BIT,
    eBottomOfPipe = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    eHost = VK_PIPELINE_STAGE_HOST_BIT,
    eAllGraphics = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
    eAllCommands = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    eConditionalRenderingEXT = VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT,
    eCommandProcessNVX = VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX,
    eShadingRateImageNV = VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV,
    eRaytracingNVX = VK_PIPELINE_STAGE_RAYTRACING_BIT_NVX,
    eTaskShaderNV = VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV,
    eMeshShaderNV = VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
  };

  using PipelineStageFlags = Flags<PipelineStageFlagBits, VkPipelineStageFlags>;

  VULKAN_HPP_INLINE PipelineStageFlags operator|( PipelineStageFlagBits bit0, PipelineStageFlagBits bit1 )
  {
    return PipelineStageFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE PipelineStageFlags operator~( PipelineStageFlagBits bits )
  {
    return ~( PipelineStageFlags( bits ) );
  }

  template <> struct FlagTraits<PipelineStageFlagBits>
  {
    enum
    {
      allFlags = VkFlags(PipelineStageFlagBits::eTopOfPipe) | VkFlags(PipelineStageFlagBits::eDrawIndirect) | VkFlags(PipelineStageFlagBits::eVertexInput) | VkFlags(PipelineStageFlagBits::eVertexShader) | VkFlags(PipelineStageFlagBits::eTessellationControlShader) | VkFlags(PipelineStageFlagBits::eTessellationEvaluationShader) | VkFlags(PipelineStageFlagBits::eGeometryShader) | VkFlags(PipelineStageFlagBits::eFragmentShader) | VkFlags(PipelineStageFlagBits::eEarlyFragmentTests) | VkFlags(PipelineStageFlagBits::eLateFragmentTests) | VkFlags(PipelineStageFlagBits::eColorAttachmentOutput) | VkFlags(PipelineStageFlagBits::eComputeShader) | VkFlags(PipelineStageFlagBits::eTransfer) | VkFlags(PipelineStageFlagBits::eBottomOfPipe) | VkFlags(PipelineStageFlagBits::eHost) | VkFlags(PipelineStageFlagBits::eAllGraphics) | VkFlags(PipelineStageFlagBits::eAllCommands) | VkFlags(PipelineStageFlagBits::eConditionalRenderingEXT) | VkFlags(PipelineStageFlagBits::eCommandProcessNVX) | VkFlags(PipelineStageFlagBits::eShadingRateImageNV) | VkFlags(PipelineStageFlagBits::eRaytracingNVX) | VkFlags(PipelineStageFlagBits::eTaskShaderNV) | VkFlags(PipelineStageFlagBits::eMeshShaderNV)
    };
  };

  struct QueueFamilyCheckpointPropertiesNV
  {
    operator VkQueueFamilyCheckpointPropertiesNV const&() const
    {
      return *reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(this);
    }

    operator VkQueueFamilyCheckpointPropertiesNV &()
    {
      return *reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(this);
    }

    bool operator==( QueueFamilyCheckpointPropertiesNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( checkpointExecutionStageMask == rhs.checkpointExecutionStageMask );
    }

    bool operator!=( QueueFamilyCheckpointPropertiesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eQueueFamilyCheckpointPropertiesNV;
    void* pNext = nullptr;
    PipelineStageFlags checkpointExecutionStageMask = PipelineStageFlags();
  };
  static_assert( sizeof( QueueFamilyCheckpointPropertiesNV ) == sizeof( VkQueueFamilyCheckpointPropertiesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( QueueFamilyCheckpointPropertiesNV, pNext ) == offsetof( VkQueueFamilyCheckpointPropertiesNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( QueueFamilyCheckpointPropertiesNV, checkpointExecutionStageMask ) == offsetof( VkQueueFamilyCheckpointPropertiesNV, checkpointExecutionStageMask ), "struct member and wrapper member have different offset!" );

  struct CheckpointDataNV
  {
    operator VkCheckpointDataNV const&() const
    {
      return *reinterpret_cast<const VkCheckpointDataNV*>(this);
    }

    operator VkCheckpointDataNV &()
    {
      return *reinterpret_cast<VkCheckpointDataNV*>(this);
    }

    bool operator==( CheckpointDataNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( stage == rhs.stage )
          && ( pCheckpointMarker == rhs.pCheckpointMarker );
    }

    bool operator!=( CheckpointDataNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eCheckpointDataNV;
    void* pNext = nullptr;
    PipelineStageFlagBits stage = PipelineStageFlagBits::eTopOfPipe;
    void* pCheckpointMarker = nullptr;
  };
  static_assert( sizeof( CheckpointDataNV ) == sizeof( VkCheckpointDataNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( CheckpointDataNV, pNext ) == offsetof( VkCheckpointDataNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CheckpointDataNV, stage ) == offsetof( VkCheckpointDataNV, stage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CheckpointDataNV, pCheckpointMarker ) == offsetof( VkCheckpointDataNV, pCheckpointMarker ), "struct member and wrapper member have different offset!" );

  enum class CommandPoolCreateFlagBits
  {
    eTransient = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
    eResetCommandBuffer = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    eProtected = VK_COMMAND_POOL_CREATE_PROTECTED_BIT
  };

  using CommandPoolCreateFlags = Flags<CommandPoolCreateFlagBits, VkCommandPoolCreateFlags>;

  VULKAN_HPP_INLINE CommandPoolCreateFlags operator|( CommandPoolCreateFlagBits bit0, CommandPoolCreateFlagBits bit1 )
  {
    return CommandPoolCreateFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE CommandPoolCreateFlags operator~( CommandPoolCreateFlagBits bits )
  {
    return ~( CommandPoolCreateFlags( bits ) );
  }

  template <> struct FlagTraits<CommandPoolCreateFlagBits>
  {
    enum
    {
      allFlags = VkFlags(CommandPoolCreateFlagBits::eTransient) | VkFlags(CommandPoolCreateFlagBits::eResetCommandBuffer) | VkFlags(CommandPoolCreateFlagBits::eProtected)
    };
  };

  struct CommandPoolCreateInfo
  {
    operator VkCommandPoolCreateInfo const&() const
    {
      return *reinterpret_cast<const VkCommandPoolCreateInfo*>(this);
    }

    operator VkCommandPoolCreateInfo &()
    {
      return *reinterpret_cast<VkCommandPoolCreateInfo*>(this);
    }

    bool operator==( CommandPoolCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( queueFamilyIndex == rhs.queueFamilyIndex );
    }

    bool operator!=( CommandPoolCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eCommandPoolCreateInfo;
    const void* pNext = nullptr;
    CommandPoolCreateFlags flags = CommandPoolCreateFlags();
    uint32_t queueFamilyIndex = 0;
  };
  static_assert( sizeof( CommandPoolCreateInfo ) == sizeof( VkCommandPoolCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( CommandPoolCreateInfo, pNext ) == offsetof( VkCommandPoolCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandPoolCreateInfo, flags ) == offsetof( VkCommandPoolCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CommandPoolCreateInfo, queueFamilyIndex ) == offsetof( VkCommandPoolCreateInfo, queueFamilyIndex ), "struct member and wrapper member have different offset!" );

  enum class CommandPoolResetFlagBits
  {
    eReleaseResources = VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT
  };

  using CommandPoolResetFlags = Flags<CommandPoolResetFlagBits, VkCommandPoolResetFlags>;

  VULKAN_HPP_INLINE CommandPoolResetFlags operator|( CommandPoolResetFlagBits bit0, CommandPoolResetFlagBits bit1 )
  {
    return CommandPoolResetFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE CommandPoolResetFlags operator~( CommandPoolResetFlagBits bits )
  {
    return ~( CommandPoolResetFlags( bits ) );
  }

  template <> struct FlagTraits<CommandPoolResetFlagBits>
  {
    enum
    {
      allFlags = VkFlags(CommandPoolResetFlagBits::eReleaseResources)
    };
  };

  enum class CommandBufferResetFlagBits
  {
    eReleaseResources = VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT
  };

  using CommandBufferResetFlags = Flags<CommandBufferResetFlagBits, VkCommandBufferResetFlags>;

  VULKAN_HPP_INLINE CommandBufferResetFlags operator|( CommandBufferResetFlagBits bit0, CommandBufferResetFlagBits bit1 )
  {
    return CommandBufferResetFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE CommandBufferResetFlags operator~( CommandBufferResetFlagBits bits )
  {
    return ~( CommandBufferResetFlags( bits ) );
  }

  template <> struct FlagTraits<CommandBufferResetFlagBits>
  {
    enum
    {
      allFlags = VkFlags(CommandBufferResetFlagBits::eReleaseResources)
    };
  };

  enum class SampleCountFlagBits
  {
    e1 = VK_SAMPLE_COUNT_1_BIT,
    e2 = VK_SAMPLE_COUNT_2_BIT,
    e4 = VK_SAMPLE_COUNT_4_BIT,
    e8 = VK_SAMPLE_COUNT_8_BIT,
    e16 = VK_SAMPLE_COUNT_16_BIT,
    e32 = VK_SAMPLE_COUNT_32_BIT,
    e64 = VK_SAMPLE_COUNT_64_BIT
  };

  using SampleCountFlags = Flags<SampleCountFlagBits, VkSampleCountFlags>;

  VULKAN_HPP_INLINE SampleCountFlags operator|( SampleCountFlagBits bit0, SampleCountFlagBits bit1 )
  {
    return SampleCountFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE SampleCountFlags operator~( SampleCountFlagBits bits )
  {
    return ~( SampleCountFlags( bits ) );
  }

  template <> struct FlagTraits<SampleCountFlagBits>
  {
    enum
    {
      allFlags = VkFlags(SampleCountFlagBits::e1) | VkFlags(SampleCountFlagBits::e2) | VkFlags(SampleCountFlagBits::e4) | VkFlags(SampleCountFlagBits::e8) | VkFlags(SampleCountFlagBits::e16) | VkFlags(SampleCountFlagBits::e32) | VkFlags(SampleCountFlagBits::e64)
    };
  };

  struct ImageFormatProperties
  {
    operator VkImageFormatProperties const&() const
    {
      return *reinterpret_cast<const VkImageFormatProperties*>(this);
    }

    operator VkImageFormatProperties &()
    {
      return *reinterpret_cast<VkImageFormatProperties*>(this);
    }

    bool operator==( ImageFormatProperties const& rhs ) const
    {
      return ( maxExtent == rhs.maxExtent )
          && ( maxMipLevels == rhs.maxMipLevels )
          && ( maxArrayLayers == rhs.maxArrayLayers )
          && ( sampleCounts == rhs.sampleCounts )
          && ( maxResourceSize == rhs.maxResourceSize );
    }

    bool operator!=( ImageFormatProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    Extent3D maxExtent = Extent3D();
    uint32_t maxMipLevels = 0;
    uint32_t maxArrayLayers = 0;
    SampleCountFlags sampleCounts = SampleCountFlags();
    DeviceSize maxResourceSize = 0;
  };
  static_assert( sizeof( ImageFormatProperties ) == sizeof( VkImageFormatProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageFormatProperties, maxExtent ) == offsetof( VkImageFormatProperties, maxExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageFormatProperties, maxMipLevels ) == offsetof( VkImageFormatProperties, maxMipLevels ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageFormatProperties, maxArrayLayers ) == offsetof( VkImageFormatProperties, maxArrayLayers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageFormatProperties, sampleCounts ) == offsetof( VkImageFormatProperties, sampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageFormatProperties, maxResourceSize ) == offsetof( VkImageFormatProperties, maxResourceSize ), "struct member and wrapper member have different offset!" );

  struct ImageCreateInfo
  {
    operator VkImageCreateInfo const&() const
    {
      return *reinterpret_cast<const VkImageCreateInfo*>(this);
    }

    operator VkImageCreateInfo &()
    {
      return *reinterpret_cast<VkImageCreateInfo*>(this);
    }

    bool operator==( ImageCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( imageType == rhs.imageType )
          && ( format == rhs.format )
          && ( extent == rhs.extent )
          && ( mipLevels == rhs.mipLevels )
          && ( arrayLayers == rhs.arrayLayers )
          && ( samples == rhs.samples )
          && ( tiling == rhs.tiling )
          && ( usage == rhs.usage )
          && ( sharingMode == rhs.sharingMode )
          && ( queueFamilyIndexCount == rhs.queueFamilyIndexCount )
          && ( pQueueFamilyIndices == rhs.pQueueFamilyIndices )
          && ( initialLayout == rhs.initialLayout );
    }

    bool operator!=( ImageCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageCreateInfo;
    const void* pNext = nullptr;
    ImageCreateFlags flags = ImageCreateFlags();
    ImageType imageType = ImageType::e1D;
    Format format = Format::eUndefined;
    Extent3D extent = Extent3D();
    uint32_t mipLevels = 0;
    uint32_t arrayLayers = 0;
    SampleCountFlagBits samples = SampleCountFlagBits::e1;
    ImageTiling tiling = ImageTiling::eOptimal;
    ImageUsageFlags usage = ImageUsageFlags();
    SharingMode sharingMode = SharingMode::eExclusive;
    uint32_t queueFamilyIndexCount = 0;
    const uint32_t* pQueueFamilyIndices = nullptr;
    ImageLayout initialLayout = ImageLayout::eUndefined;
  };
  static_assert( sizeof( ImageCreateInfo ) == sizeof( VkImageCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageCreateInfo, pNext ) == offsetof( VkImageCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, flags ) == offsetof( VkImageCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, imageType ) == offsetof( VkImageCreateInfo, imageType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, format ) == offsetof( VkImageCreateInfo, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, extent ) == offsetof( VkImageCreateInfo, extent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, mipLevels ) == offsetof( VkImageCreateInfo, mipLevels ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, arrayLayers ) == offsetof( VkImageCreateInfo, arrayLayers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, samples ) == offsetof( VkImageCreateInfo, samples ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, tiling ) == offsetof( VkImageCreateInfo, tiling ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, usage ) == offsetof( VkImageCreateInfo, usage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, sharingMode ) == offsetof( VkImageCreateInfo, sharingMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, queueFamilyIndexCount ) == offsetof( VkImageCreateInfo, queueFamilyIndexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, pQueueFamilyIndices ) == offsetof( VkImageCreateInfo, pQueueFamilyIndices ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageCreateInfo, initialLayout ) == offsetof( VkImageCreateInfo, initialLayout ), "struct member and wrapper member have different offset!" );

  struct PipelineMultisampleStateCreateInfo
  {
    operator VkPipelineMultisampleStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineMultisampleStateCreateInfo*>(this);
    }

    operator VkPipelineMultisampleStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineMultisampleStateCreateInfo*>(this);
    }

    bool operator==( PipelineMultisampleStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( rasterizationSamples == rhs.rasterizationSamples )
          && ( sampleShadingEnable == rhs.sampleShadingEnable )
          && ( minSampleShading == rhs.minSampleShading )
          && ( pSampleMask == rhs.pSampleMask )
          && ( alphaToCoverageEnable == rhs.alphaToCoverageEnable )
          && ( alphaToOneEnable == rhs.alphaToOneEnable );
    }

    bool operator!=( PipelineMultisampleStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineMultisampleStateCreateInfo;
    const void* pNext = nullptr;
    PipelineMultisampleStateCreateFlags flags = PipelineMultisampleStateCreateFlags();
    SampleCountFlagBits rasterizationSamples = SampleCountFlagBits::e1;
    Bool32 sampleShadingEnable = 0;
    float minSampleShading = 0;
    const SampleMask* pSampleMask = nullptr;
    Bool32 alphaToCoverageEnable = 0;
    Bool32 alphaToOneEnable = 0;
  };
  static_assert( sizeof( PipelineMultisampleStateCreateInfo ) == sizeof( VkPipelineMultisampleStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineMultisampleStateCreateInfo, pNext ) == offsetof( VkPipelineMultisampleStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineMultisampleStateCreateInfo, flags ) == offsetof( VkPipelineMultisampleStateCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineMultisampleStateCreateInfo, rasterizationSamples ) == offsetof( VkPipelineMultisampleStateCreateInfo, rasterizationSamples ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineMultisampleStateCreateInfo, sampleShadingEnable ) == offsetof( VkPipelineMultisampleStateCreateInfo, sampleShadingEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineMultisampleStateCreateInfo, minSampleShading ) == offsetof( VkPipelineMultisampleStateCreateInfo, minSampleShading ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineMultisampleStateCreateInfo, pSampleMask ) == offsetof( VkPipelineMultisampleStateCreateInfo, pSampleMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineMultisampleStateCreateInfo, alphaToCoverageEnable ) == offsetof( VkPipelineMultisampleStateCreateInfo, alphaToCoverageEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineMultisampleStateCreateInfo, alphaToOneEnable ) == offsetof( VkPipelineMultisampleStateCreateInfo, alphaToOneEnable ), "struct member and wrapper member have different offset!" );

  struct GraphicsPipelineCreateInfo
  {
    operator VkGraphicsPipelineCreateInfo const&() const
    {
      return *reinterpret_cast<const VkGraphicsPipelineCreateInfo*>(this);
    }

    operator VkGraphicsPipelineCreateInfo &()
    {
      return *reinterpret_cast<VkGraphicsPipelineCreateInfo*>(this);
    }

    bool operator==( GraphicsPipelineCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( stageCount == rhs.stageCount )
          && ( pStages == rhs.pStages )
          && ( pVertexInputState == rhs.pVertexInputState )
          && ( pInputAssemblyState == rhs.pInputAssemblyState )
          && ( pTessellationState == rhs.pTessellationState )
          && ( pViewportState == rhs.pViewportState )
          && ( pRasterizationState == rhs.pRasterizationState )
          && ( pMultisampleState == rhs.pMultisampleState )
          && ( pDepthStencilState == rhs.pDepthStencilState )
          && ( pColorBlendState == rhs.pColorBlendState )
          && ( pDynamicState == rhs.pDynamicState )
          && ( layout == rhs.layout )
          && ( renderPass == rhs.renderPass )
          && ( subpass == rhs.subpass )
          && ( basePipelineHandle == rhs.basePipelineHandle )
          && ( basePipelineIndex == rhs.basePipelineIndex );
    }

    bool operator!=( GraphicsPipelineCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eGraphicsPipelineCreateInfo;
    const void* pNext = nullptr;
    PipelineCreateFlags flags = PipelineCreateFlags();
    uint32_t stageCount = 0;
    const PipelineShaderStageCreateInfo* pStages = nullptr;
    const PipelineVertexInputStateCreateInfo* pVertexInputState = nullptr;
    const PipelineInputAssemblyStateCreateInfo* pInputAssemblyState = nullptr;
    const PipelineTessellationStateCreateInfo* pTessellationState = nullptr;
    const PipelineViewportStateCreateInfo* pViewportState = nullptr;
    const PipelineRasterizationStateCreateInfo* pRasterizationState = nullptr;
    const PipelineMultisampleStateCreateInfo* pMultisampleState = nullptr;
    const PipelineDepthStencilStateCreateInfo* pDepthStencilState = nullptr;
    const PipelineColorBlendStateCreateInfo* pColorBlendState = nullptr;
    const PipelineDynamicStateCreateInfo* pDynamicState = nullptr;
    PipelineLayout layout = PipelineLayout();
    RenderPass renderPass = RenderPass();
    uint32_t subpass = 0;
    Pipeline basePipelineHandle = Pipeline();
    int32_t basePipelineIndex = 0;
  };
  static_assert( sizeof( GraphicsPipelineCreateInfo ) == sizeof( VkGraphicsPipelineCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pNext ) == offsetof( VkGraphicsPipelineCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, flags ) == offsetof( VkGraphicsPipelineCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, stageCount ) == offsetof( VkGraphicsPipelineCreateInfo, stageCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pStages ) == offsetof( VkGraphicsPipelineCreateInfo, pStages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pVertexInputState ) == offsetof( VkGraphicsPipelineCreateInfo, pVertexInputState ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pInputAssemblyState ) == offsetof( VkGraphicsPipelineCreateInfo, pInputAssemblyState ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pTessellationState ) == offsetof( VkGraphicsPipelineCreateInfo, pTessellationState ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pViewportState ) == offsetof( VkGraphicsPipelineCreateInfo, pViewportState ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pRasterizationState ) == offsetof( VkGraphicsPipelineCreateInfo, pRasterizationState ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pMultisampleState ) == offsetof( VkGraphicsPipelineCreateInfo, pMultisampleState ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pDepthStencilState ) == offsetof( VkGraphicsPipelineCreateInfo, pDepthStencilState ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pColorBlendState ) == offsetof( VkGraphicsPipelineCreateInfo, pColorBlendState ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, pDynamicState ) == offsetof( VkGraphicsPipelineCreateInfo, pDynamicState ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, layout ) == offsetof( VkGraphicsPipelineCreateInfo, layout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, renderPass ) == offsetof( VkGraphicsPipelineCreateInfo, renderPass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, subpass ) == offsetof( VkGraphicsPipelineCreateInfo, subpass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, basePipelineHandle ) == offsetof( VkGraphicsPipelineCreateInfo, basePipelineHandle ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GraphicsPipelineCreateInfo, basePipelineIndex ) == offsetof( VkGraphicsPipelineCreateInfo, basePipelineIndex ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceLimits
  {
    operator VkPhysicalDeviceLimits const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceLimits*>(this);
    }

    operator VkPhysicalDeviceLimits &()
    {
      return *reinterpret_cast<VkPhysicalDeviceLimits*>(this);
    }

    bool operator==( PhysicalDeviceLimits const& rhs ) const
    {
      return ( maxImageDimension1D == rhs.maxImageDimension1D )
          && ( maxImageDimension2D == rhs.maxImageDimension2D )
          && ( maxImageDimension3D == rhs.maxImageDimension3D )
          && ( maxImageDimensionCube == rhs.maxImageDimensionCube )
          && ( maxImageArrayLayers == rhs.maxImageArrayLayers )
          && ( maxTexelBufferElements == rhs.maxTexelBufferElements )
          && ( maxUniformBufferRange == rhs.maxUniformBufferRange )
          && ( maxStorageBufferRange == rhs.maxStorageBufferRange )
          && ( maxPushConstantsSize == rhs.maxPushConstantsSize )
          && ( maxMemoryAllocationCount == rhs.maxMemoryAllocationCount )
          && ( maxSamplerAllocationCount == rhs.maxSamplerAllocationCount )
          && ( bufferImageGranularity == rhs.bufferImageGranularity )
          && ( sparseAddressSpaceSize == rhs.sparseAddressSpaceSize )
          && ( maxBoundDescriptorSets == rhs.maxBoundDescriptorSets )
          && ( maxPerStageDescriptorSamplers == rhs.maxPerStageDescriptorSamplers )
          && ( maxPerStageDescriptorUniformBuffers == rhs.maxPerStageDescriptorUniformBuffers )
          && ( maxPerStageDescriptorStorageBuffers == rhs.maxPerStageDescriptorStorageBuffers )
          && ( maxPerStageDescriptorSampledImages == rhs.maxPerStageDescriptorSampledImages )
          && ( maxPerStageDescriptorStorageImages == rhs.maxPerStageDescriptorStorageImages )
          && ( maxPerStageDescriptorInputAttachments == rhs.maxPerStageDescriptorInputAttachments )
          && ( maxPerStageResources == rhs.maxPerStageResources )
          && ( maxDescriptorSetSamplers == rhs.maxDescriptorSetSamplers )
          && ( maxDescriptorSetUniformBuffers == rhs.maxDescriptorSetUniformBuffers )
          && ( maxDescriptorSetUniformBuffersDynamic == rhs.maxDescriptorSetUniformBuffersDynamic )
          && ( maxDescriptorSetStorageBuffers == rhs.maxDescriptorSetStorageBuffers )
          && ( maxDescriptorSetStorageBuffersDynamic == rhs.maxDescriptorSetStorageBuffersDynamic )
          && ( maxDescriptorSetSampledImages == rhs.maxDescriptorSetSampledImages )
          && ( maxDescriptorSetStorageImages == rhs.maxDescriptorSetStorageImages )
          && ( maxDescriptorSetInputAttachments == rhs.maxDescriptorSetInputAttachments )
          && ( maxVertexInputAttributes == rhs.maxVertexInputAttributes )
          && ( maxVertexInputBindings == rhs.maxVertexInputBindings )
          && ( maxVertexInputAttributeOffset == rhs.maxVertexInputAttributeOffset )
          && ( maxVertexInputBindingStride == rhs.maxVertexInputBindingStride )
          && ( maxVertexOutputComponents == rhs.maxVertexOutputComponents )
          && ( maxTessellationGenerationLevel == rhs.maxTessellationGenerationLevel )
          && ( maxTessellationPatchSize == rhs.maxTessellationPatchSize )
          && ( maxTessellationControlPerVertexInputComponents == rhs.maxTessellationControlPerVertexInputComponents )
          && ( maxTessellationControlPerVertexOutputComponents == rhs.maxTessellationControlPerVertexOutputComponents )
          && ( maxTessellationControlPerPatchOutputComponents == rhs.maxTessellationControlPerPatchOutputComponents )
          && ( maxTessellationControlTotalOutputComponents == rhs.maxTessellationControlTotalOutputComponents )
          && ( maxTessellationEvaluationInputComponents == rhs.maxTessellationEvaluationInputComponents )
          && ( maxTessellationEvaluationOutputComponents == rhs.maxTessellationEvaluationOutputComponents )
          && ( maxGeometryShaderInvocations == rhs.maxGeometryShaderInvocations )
          && ( maxGeometryInputComponents == rhs.maxGeometryInputComponents )
          && ( maxGeometryOutputComponents == rhs.maxGeometryOutputComponents )
          && ( maxGeometryOutputVertices == rhs.maxGeometryOutputVertices )
          && ( maxGeometryTotalOutputComponents == rhs.maxGeometryTotalOutputComponents )
          && ( maxFragmentInputComponents == rhs.maxFragmentInputComponents )
          && ( maxFragmentOutputAttachments == rhs.maxFragmentOutputAttachments )
          && ( maxFragmentDualSrcAttachments == rhs.maxFragmentDualSrcAttachments )
          && ( maxFragmentCombinedOutputResources == rhs.maxFragmentCombinedOutputResources )
          && ( maxComputeSharedMemorySize == rhs.maxComputeSharedMemorySize )
          && ( maxComputeWorkGroupCount == rhs.maxComputeWorkGroupCount )
          && ( maxComputeWorkGroupInvocations == rhs.maxComputeWorkGroupInvocations )
          && ( maxComputeWorkGroupSize == rhs.maxComputeWorkGroupSize )
          && ( subPixelPrecisionBits == rhs.subPixelPrecisionBits )
          && ( subTexelPrecisionBits == rhs.subTexelPrecisionBits )
          && ( mipmapPrecisionBits == rhs.mipmapPrecisionBits )
          && ( maxDrawIndexedIndexValue == rhs.maxDrawIndexedIndexValue )
          && ( maxDrawIndirectCount == rhs.maxDrawIndirectCount )
          && ( maxSamplerLodBias == rhs.maxSamplerLodBias )
          && ( maxSamplerAnisotropy == rhs.maxSamplerAnisotropy )
          && ( maxViewports == rhs.maxViewports )
          && ( maxViewportDimensions == rhs.maxViewportDimensions )
          && ( viewportBoundsRange == rhs.viewportBoundsRange )
          && ( viewportSubPixelBits == rhs.viewportSubPixelBits )
          && ( minMemoryMapAlignment == rhs.minMemoryMapAlignment )
          && ( minTexelBufferOffsetAlignment == rhs.minTexelBufferOffsetAlignment )
          && ( minUniformBufferOffsetAlignment == rhs.minUniformBufferOffsetAlignment )
          && ( minStorageBufferOffsetAlignment == rhs.minStorageBufferOffsetAlignment )
          && ( minTexelOffset == rhs.minTexelOffset )
          && ( maxTexelOffset == rhs.maxTexelOffset )
          && ( minTexelGatherOffset == rhs.minTexelGatherOffset )
          && ( maxTexelGatherOffset == rhs.maxTexelGatherOffset )
          && ( minInterpolationOffset == rhs.minInterpolationOffset )
          && ( maxInterpolationOffset == rhs.maxInterpolationOffset )
          && ( subPixelInterpolationOffsetBits == rhs.subPixelInterpolationOffsetBits )
          && ( maxFramebufferWidth == rhs.maxFramebufferWidth )
          && ( maxFramebufferHeight == rhs.maxFramebufferHeight )
          && ( maxFramebufferLayers == rhs.maxFramebufferLayers )
          && ( framebufferColorSampleCounts == rhs.framebufferColorSampleCounts )
          && ( framebufferDepthSampleCounts == rhs.framebufferDepthSampleCounts )
          && ( framebufferStencilSampleCounts == rhs.framebufferStencilSampleCounts )
          && ( framebufferNoAttachmentsSampleCounts == rhs.framebufferNoAttachmentsSampleCounts )
          && ( maxColorAttachments == rhs.maxColorAttachments )
          && ( sampledImageColorSampleCounts == rhs.sampledImageColorSampleCounts )
          && ( sampledImageIntegerSampleCounts == rhs.sampledImageIntegerSampleCounts )
          && ( sampledImageDepthSampleCounts == rhs.sampledImageDepthSampleCounts )
          && ( sampledImageStencilSampleCounts == rhs.sampledImageStencilSampleCounts )
          && ( storageImageSampleCounts == rhs.storageImageSampleCounts )
          && ( maxSampleMaskWords == rhs.maxSampleMaskWords )
          && ( timestampComputeAndGraphics == rhs.timestampComputeAndGraphics )
          && ( timestampPeriod == rhs.timestampPeriod )
          && ( maxClipDistances == rhs.maxClipDistances )
          && ( maxCullDistances == rhs.maxCullDistances )
          && ( maxCombinedClipAndCullDistances == rhs.maxCombinedClipAndCullDistances )
          && ( discreteQueuePriorities == rhs.discreteQueuePriorities )
          && ( pointSizeRange == rhs.pointSizeRange )
          && ( lineWidthRange == rhs.lineWidthRange )
          && ( pointSizeGranularity == rhs.pointSizeGranularity )
          && ( lineWidthGranularity == rhs.lineWidthGranularity )
          && ( strictLines == rhs.strictLines )
          && ( standardSampleLocations == rhs.standardSampleLocations )
          && ( optimalBufferCopyOffsetAlignment == rhs.optimalBufferCopyOffsetAlignment )
          && ( optimalBufferCopyRowPitchAlignment == rhs.optimalBufferCopyRowPitchAlignment )
          && ( nonCoherentAtomSize == rhs.nonCoherentAtomSize );
    }

    bool operator!=( PhysicalDeviceLimits const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t maxImageDimension1D = 0;
    uint32_t maxImageDimension2D = 0;
    uint32_t maxImageDimension3D = 0;
    uint32_t maxImageDimensionCube = 0;
    uint32_t maxImageArrayLayers = 0;
    uint32_t maxTexelBufferElements = 0;
    uint32_t maxUniformBufferRange = 0;
    uint32_t maxStorageBufferRange = 0;
    uint32_t maxPushConstantsSize = 0;
    uint32_t maxMemoryAllocationCount = 0;
    uint32_t maxSamplerAllocationCount = 0;
    DeviceSize bufferImageGranularity = 0;
    DeviceSize sparseAddressSpaceSize = 0;
    uint32_t maxBoundDescriptorSets = 0;
    uint32_t maxPerStageDescriptorSamplers = 0;
    uint32_t maxPerStageDescriptorUniformBuffers = 0;
    uint32_t maxPerStageDescriptorStorageBuffers = 0;
    uint32_t maxPerStageDescriptorSampledImages = 0;
    uint32_t maxPerStageDescriptorStorageImages = 0;
    uint32_t maxPerStageDescriptorInputAttachments = 0;
    uint32_t maxPerStageResources = 0;
    uint32_t maxDescriptorSetSamplers = 0;
    uint32_t maxDescriptorSetUniformBuffers = 0;
    uint32_t maxDescriptorSetUniformBuffersDynamic = 0;
    uint32_t maxDescriptorSetStorageBuffers = 0;
    uint32_t maxDescriptorSetStorageBuffersDynamic = 0;
    uint32_t maxDescriptorSetSampledImages = 0;
    uint32_t maxDescriptorSetStorageImages = 0;
    uint32_t maxDescriptorSetInputAttachments = 0;
    uint32_t maxVertexInputAttributes = 0;
    uint32_t maxVertexInputBindings = 0;
    uint32_t maxVertexInputAttributeOffset = 0;
    uint32_t maxVertexInputBindingStride = 0;
    uint32_t maxVertexOutputComponents = 0;
    uint32_t maxTessellationGenerationLevel = 0;
    uint32_t maxTessellationPatchSize = 0;
    uint32_t maxTessellationControlPerVertexInputComponents = 0;
    uint32_t maxTessellationControlPerVertexOutputComponents = 0;
    uint32_t maxTessellationControlPerPatchOutputComponents = 0;
    uint32_t maxTessellationControlTotalOutputComponents = 0;
    uint32_t maxTessellationEvaluationInputComponents = 0;
    uint32_t maxTessellationEvaluationOutputComponents = 0;
    uint32_t maxGeometryShaderInvocations = 0;
    uint32_t maxGeometryInputComponents = 0;
    uint32_t maxGeometryOutputComponents = 0;
    uint32_t maxGeometryOutputVertices = 0;
    uint32_t maxGeometryTotalOutputComponents = 0;
    uint32_t maxFragmentInputComponents = 0;
    uint32_t maxFragmentOutputAttachments = 0;
    uint32_t maxFragmentDualSrcAttachments = 0;
    uint32_t maxFragmentCombinedOutputResources = 0;
    uint32_t maxComputeSharedMemorySize = 0;
    std::array<uint32_t, 3> maxComputeWorkGroupCount = { { 0, 0, 0 } };
    uint32_t maxComputeWorkGroupInvocations = 0;
    std::array<uint32_t, 3> maxComputeWorkGroupSize = { { 0, 0, 0 } };
    uint32_t subPixelPrecisionBits = 0;
    uint32_t subTexelPrecisionBits = 0;
    uint32_t mipmapPrecisionBits = 0;
    uint32_t maxDrawIndexedIndexValue = 0;
    uint32_t maxDrawIndirectCount = 0;
    float maxSamplerLodBias = 0;
    float maxSamplerAnisotropy = 0;
    uint32_t maxViewports = 0;
    std::array<uint32_t, 2> maxViewportDimensions = { { 0, 0 } };
    std::array<float, 2> viewportBoundsRange = { { 0, 0 } };
    uint32_t viewportSubPixelBits = 0;
    size_t minMemoryMapAlignment = 0;
    DeviceSize minTexelBufferOffsetAlignment = 0;
    DeviceSize minUniformBufferOffsetAlignment = 0;
    DeviceSize minStorageBufferOffsetAlignment = 0;
    int32_t minTexelOffset = 0;
    uint32_t maxTexelOffset = 0;
    int32_t minTexelGatherOffset = 0;
    uint32_t maxTexelGatherOffset = 0;
    float minInterpolationOffset = 0;
    float maxInterpolationOffset = 0;
    uint32_t subPixelInterpolationOffsetBits = 0;
    uint32_t maxFramebufferWidth = 0;
    uint32_t maxFramebufferHeight = 0;
    uint32_t maxFramebufferLayers = 0;
    SampleCountFlags framebufferColorSampleCounts = SampleCountFlags();
    SampleCountFlags framebufferDepthSampleCounts = SampleCountFlags();
    SampleCountFlags framebufferStencilSampleCounts = SampleCountFlags();
    SampleCountFlags framebufferNoAttachmentsSampleCounts = SampleCountFlags();
    uint32_t maxColorAttachments = 0;
    SampleCountFlags sampledImageColorSampleCounts = SampleCountFlags();
    SampleCountFlags sampledImageIntegerSampleCounts = SampleCountFlags();
    SampleCountFlags sampledImageDepthSampleCounts = SampleCountFlags();
    SampleCountFlags sampledImageStencilSampleCounts = SampleCountFlags();
    SampleCountFlags storageImageSampleCounts = SampleCountFlags();
    uint32_t maxSampleMaskWords = 0;
    Bool32 timestampComputeAndGraphics = 0;
    float timestampPeriod = 0;
    uint32_t maxClipDistances = 0;
    uint32_t maxCullDistances = 0;
    uint32_t maxCombinedClipAndCullDistances = 0;
    uint32_t discreteQueuePriorities = 0;
    std::array<float, 2> pointSizeRange = { { 0, 0 } };
    std::array<float, 2> lineWidthRange = { { 0, 0 } };
    float pointSizeGranularity = 0;
    float lineWidthGranularity = 0;
    Bool32 strictLines = 0;
    Bool32 standardSampleLocations = 0;
    DeviceSize optimalBufferCopyOffsetAlignment = 0;
    DeviceSize optimalBufferCopyRowPitchAlignment = 0;
    DeviceSize nonCoherentAtomSize = 0;
  };
  static_assert( sizeof( PhysicalDeviceLimits ) == sizeof( VkPhysicalDeviceLimits ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxImageDimension1D ) == offsetof( VkPhysicalDeviceLimits, maxImageDimension1D ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxImageDimension2D ) == offsetof( VkPhysicalDeviceLimits, maxImageDimension2D ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxImageDimension3D ) == offsetof( VkPhysicalDeviceLimits, maxImageDimension3D ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxImageDimensionCube ) == offsetof( VkPhysicalDeviceLimits, maxImageDimensionCube ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxImageArrayLayers ) == offsetof( VkPhysicalDeviceLimits, maxImageArrayLayers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTexelBufferElements ) == offsetof( VkPhysicalDeviceLimits, maxTexelBufferElements ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxUniformBufferRange ) == offsetof( VkPhysicalDeviceLimits, maxUniformBufferRange ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxStorageBufferRange ) == offsetof( VkPhysicalDeviceLimits, maxStorageBufferRange ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxPushConstantsSize ) == offsetof( VkPhysicalDeviceLimits, maxPushConstantsSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxMemoryAllocationCount ) == offsetof( VkPhysicalDeviceLimits, maxMemoryAllocationCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxSamplerAllocationCount ) == offsetof( VkPhysicalDeviceLimits, maxSamplerAllocationCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, bufferImageGranularity ) == offsetof( VkPhysicalDeviceLimits, bufferImageGranularity ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, sparseAddressSpaceSize ) == offsetof( VkPhysicalDeviceLimits, sparseAddressSpaceSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxBoundDescriptorSets ) == offsetof( VkPhysicalDeviceLimits, maxBoundDescriptorSets ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxPerStageDescriptorSamplers ) == offsetof( VkPhysicalDeviceLimits, maxPerStageDescriptorSamplers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxPerStageDescriptorUniformBuffers ) == offsetof( VkPhysicalDeviceLimits, maxPerStageDescriptorUniformBuffers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxPerStageDescriptorStorageBuffers ) == offsetof( VkPhysicalDeviceLimits, maxPerStageDescriptorStorageBuffers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxPerStageDescriptorSampledImages ) == offsetof( VkPhysicalDeviceLimits, maxPerStageDescriptorSampledImages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxPerStageDescriptorStorageImages ) == offsetof( VkPhysicalDeviceLimits, maxPerStageDescriptorStorageImages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxPerStageDescriptorInputAttachments ) == offsetof( VkPhysicalDeviceLimits, maxPerStageDescriptorInputAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxPerStageResources ) == offsetof( VkPhysicalDeviceLimits, maxPerStageResources ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDescriptorSetSamplers ) == offsetof( VkPhysicalDeviceLimits, maxDescriptorSetSamplers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDescriptorSetUniformBuffers ) == offsetof( VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDescriptorSetUniformBuffersDynamic ) == offsetof( VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffersDynamic ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDescriptorSetStorageBuffers ) == offsetof( VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDescriptorSetStorageBuffersDynamic ) == offsetof( VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffersDynamic ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDescriptorSetSampledImages ) == offsetof( VkPhysicalDeviceLimits, maxDescriptorSetSampledImages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDescriptorSetStorageImages ) == offsetof( VkPhysicalDeviceLimits, maxDescriptorSetStorageImages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDescriptorSetInputAttachments ) == offsetof( VkPhysicalDeviceLimits, maxDescriptorSetInputAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxVertexInputAttributes ) == offsetof( VkPhysicalDeviceLimits, maxVertexInputAttributes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxVertexInputBindings ) == offsetof( VkPhysicalDeviceLimits, maxVertexInputBindings ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxVertexInputAttributeOffset ) == offsetof( VkPhysicalDeviceLimits, maxVertexInputAttributeOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxVertexInputBindingStride ) == offsetof( VkPhysicalDeviceLimits, maxVertexInputBindingStride ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxVertexOutputComponents ) == offsetof( VkPhysicalDeviceLimits, maxVertexOutputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTessellationGenerationLevel ) == offsetof( VkPhysicalDeviceLimits, maxTessellationGenerationLevel ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTessellationPatchSize ) == offsetof( VkPhysicalDeviceLimits, maxTessellationPatchSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTessellationControlPerVertexInputComponents ) == offsetof( VkPhysicalDeviceLimits, maxTessellationControlPerVertexInputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTessellationControlPerVertexOutputComponents ) == offsetof( VkPhysicalDeviceLimits, maxTessellationControlPerVertexOutputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTessellationControlPerPatchOutputComponents ) == offsetof( VkPhysicalDeviceLimits, maxTessellationControlPerPatchOutputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTessellationControlTotalOutputComponents ) == offsetof( VkPhysicalDeviceLimits, maxTessellationControlTotalOutputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTessellationEvaluationInputComponents ) == offsetof( VkPhysicalDeviceLimits, maxTessellationEvaluationInputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTessellationEvaluationOutputComponents ) == offsetof( VkPhysicalDeviceLimits, maxTessellationEvaluationOutputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxGeometryShaderInvocations ) == offsetof( VkPhysicalDeviceLimits, maxGeometryShaderInvocations ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxGeometryInputComponents ) == offsetof( VkPhysicalDeviceLimits, maxGeometryInputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxGeometryOutputComponents ) == offsetof( VkPhysicalDeviceLimits, maxGeometryOutputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxGeometryOutputVertices ) == offsetof( VkPhysicalDeviceLimits, maxGeometryOutputVertices ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxGeometryTotalOutputComponents ) == offsetof( VkPhysicalDeviceLimits, maxGeometryTotalOutputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxFragmentInputComponents ) == offsetof( VkPhysicalDeviceLimits, maxFragmentInputComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxFragmentOutputAttachments ) == offsetof( VkPhysicalDeviceLimits, maxFragmentOutputAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxFragmentDualSrcAttachments ) == offsetof( VkPhysicalDeviceLimits, maxFragmentDualSrcAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxFragmentCombinedOutputResources ) == offsetof( VkPhysicalDeviceLimits, maxFragmentCombinedOutputResources ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxComputeSharedMemorySize ) == offsetof( VkPhysicalDeviceLimits, maxComputeSharedMemorySize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxComputeWorkGroupCount ) == offsetof( VkPhysicalDeviceLimits, maxComputeWorkGroupCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxComputeWorkGroupInvocations ) == offsetof( VkPhysicalDeviceLimits, maxComputeWorkGroupInvocations ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxComputeWorkGroupSize ) == offsetof( VkPhysicalDeviceLimits, maxComputeWorkGroupSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, subPixelPrecisionBits ) == offsetof( VkPhysicalDeviceLimits, subPixelPrecisionBits ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, subTexelPrecisionBits ) == offsetof( VkPhysicalDeviceLimits, subTexelPrecisionBits ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, mipmapPrecisionBits ) == offsetof( VkPhysicalDeviceLimits, mipmapPrecisionBits ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDrawIndexedIndexValue ) == offsetof( VkPhysicalDeviceLimits, maxDrawIndexedIndexValue ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxDrawIndirectCount ) == offsetof( VkPhysicalDeviceLimits, maxDrawIndirectCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxSamplerLodBias ) == offsetof( VkPhysicalDeviceLimits, maxSamplerLodBias ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxSamplerAnisotropy ) == offsetof( VkPhysicalDeviceLimits, maxSamplerAnisotropy ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxViewports ) == offsetof( VkPhysicalDeviceLimits, maxViewports ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxViewportDimensions ) == offsetof( VkPhysicalDeviceLimits, maxViewportDimensions ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, viewportBoundsRange ) == offsetof( VkPhysicalDeviceLimits, viewportBoundsRange ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, viewportSubPixelBits ) == offsetof( VkPhysicalDeviceLimits, viewportSubPixelBits ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, minMemoryMapAlignment ) == offsetof( VkPhysicalDeviceLimits, minMemoryMapAlignment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, minTexelBufferOffsetAlignment ) == offsetof( VkPhysicalDeviceLimits, minTexelBufferOffsetAlignment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, minUniformBufferOffsetAlignment ) == offsetof( VkPhysicalDeviceLimits, minUniformBufferOffsetAlignment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, minStorageBufferOffsetAlignment ) == offsetof( VkPhysicalDeviceLimits, minStorageBufferOffsetAlignment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, minTexelOffset ) == offsetof( VkPhysicalDeviceLimits, minTexelOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTexelOffset ) == offsetof( VkPhysicalDeviceLimits, maxTexelOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, minTexelGatherOffset ) == offsetof( VkPhysicalDeviceLimits, minTexelGatherOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxTexelGatherOffset ) == offsetof( VkPhysicalDeviceLimits, maxTexelGatherOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, minInterpolationOffset ) == offsetof( VkPhysicalDeviceLimits, minInterpolationOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxInterpolationOffset ) == offsetof( VkPhysicalDeviceLimits, maxInterpolationOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, subPixelInterpolationOffsetBits ) == offsetof( VkPhysicalDeviceLimits, subPixelInterpolationOffsetBits ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxFramebufferWidth ) == offsetof( VkPhysicalDeviceLimits, maxFramebufferWidth ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxFramebufferHeight ) == offsetof( VkPhysicalDeviceLimits, maxFramebufferHeight ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxFramebufferLayers ) == offsetof( VkPhysicalDeviceLimits, maxFramebufferLayers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, framebufferColorSampleCounts ) == offsetof( VkPhysicalDeviceLimits, framebufferColorSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, framebufferDepthSampleCounts ) == offsetof( VkPhysicalDeviceLimits, framebufferDepthSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, framebufferStencilSampleCounts ) == offsetof( VkPhysicalDeviceLimits, framebufferStencilSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, framebufferNoAttachmentsSampleCounts ) == offsetof( VkPhysicalDeviceLimits, framebufferNoAttachmentsSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxColorAttachments ) == offsetof( VkPhysicalDeviceLimits, maxColorAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, sampledImageColorSampleCounts ) == offsetof( VkPhysicalDeviceLimits, sampledImageColorSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, sampledImageIntegerSampleCounts ) == offsetof( VkPhysicalDeviceLimits, sampledImageIntegerSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, sampledImageDepthSampleCounts ) == offsetof( VkPhysicalDeviceLimits, sampledImageDepthSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, sampledImageStencilSampleCounts ) == offsetof( VkPhysicalDeviceLimits, sampledImageStencilSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, storageImageSampleCounts ) == offsetof( VkPhysicalDeviceLimits, storageImageSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxSampleMaskWords ) == offsetof( VkPhysicalDeviceLimits, maxSampleMaskWords ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, timestampComputeAndGraphics ) == offsetof( VkPhysicalDeviceLimits, timestampComputeAndGraphics ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, timestampPeriod ) == offsetof( VkPhysicalDeviceLimits, timestampPeriod ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxClipDistances ) == offsetof( VkPhysicalDeviceLimits, maxClipDistances ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxCullDistances ) == offsetof( VkPhysicalDeviceLimits, maxCullDistances ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, maxCombinedClipAndCullDistances ) == offsetof( VkPhysicalDeviceLimits, maxCombinedClipAndCullDistances ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, discreteQueuePriorities ) == offsetof( VkPhysicalDeviceLimits, discreteQueuePriorities ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, pointSizeRange ) == offsetof( VkPhysicalDeviceLimits, pointSizeRange ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, lineWidthRange ) == offsetof( VkPhysicalDeviceLimits, lineWidthRange ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, pointSizeGranularity ) == offsetof( VkPhysicalDeviceLimits, pointSizeGranularity ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, lineWidthGranularity ) == offsetof( VkPhysicalDeviceLimits, lineWidthGranularity ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, strictLines ) == offsetof( VkPhysicalDeviceLimits, strictLines ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, standardSampleLocations ) == offsetof( VkPhysicalDeviceLimits, standardSampleLocations ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, optimalBufferCopyOffsetAlignment ) == offsetof( VkPhysicalDeviceLimits, optimalBufferCopyOffsetAlignment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, optimalBufferCopyRowPitchAlignment ) == offsetof( VkPhysicalDeviceLimits, optimalBufferCopyRowPitchAlignment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceLimits, nonCoherentAtomSize ) == offsetof( VkPhysicalDeviceLimits, nonCoherentAtomSize ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceProperties
  {
    operator VkPhysicalDeviceProperties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceProperties*>(this);
    }

    operator VkPhysicalDeviceProperties &()
    {
      return *reinterpret_cast<VkPhysicalDeviceProperties*>(this);
    }

    bool operator==( PhysicalDeviceProperties const& rhs ) const
    {
      return ( apiVersion == rhs.apiVersion )
          && ( driverVersion == rhs.driverVersion )
          && ( vendorID == rhs.vendorID )
          && ( deviceID == rhs.deviceID )
          && ( deviceType == rhs.deviceType )
          && ( deviceName == rhs.deviceName )
          && ( pipelineCacheUUID == rhs.pipelineCacheUUID )
          && ( limits == rhs.limits )
          && ( sparseProperties == rhs.sparseProperties );
    }

    bool operator!=( PhysicalDeviceProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t apiVersion = 0;
    uint32_t driverVersion = 0;
    uint32_t vendorID = 0;
    uint32_t deviceID = 0;
    PhysicalDeviceType deviceType = PhysicalDeviceType::eOther;
    std::array<char, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE> deviceName = { { 0 } };
    std::array<uint8_t, VK_UUID_SIZE> pipelineCacheUUID = { { 0 } };
    PhysicalDeviceLimits limits = PhysicalDeviceLimits();
    PhysicalDeviceSparseProperties sparseProperties = PhysicalDeviceSparseProperties();
  };
  static_assert( sizeof( PhysicalDeviceProperties ) == sizeof( VkPhysicalDeviceProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceProperties, apiVersion ) == offsetof( VkPhysicalDeviceProperties, apiVersion ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProperties, driverVersion ) == offsetof( VkPhysicalDeviceProperties, driverVersion ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProperties, vendorID ) == offsetof( VkPhysicalDeviceProperties, vendorID ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProperties, deviceID ) == offsetof( VkPhysicalDeviceProperties, deviceID ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProperties, deviceType ) == offsetof( VkPhysicalDeviceProperties, deviceType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProperties, deviceName ) == offsetof( VkPhysicalDeviceProperties, deviceName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProperties, pipelineCacheUUID ) == offsetof( VkPhysicalDeviceProperties, pipelineCacheUUID ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProperties, limits ) == offsetof( VkPhysicalDeviceProperties, limits ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProperties, sparseProperties ) == offsetof( VkPhysicalDeviceProperties, sparseProperties ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceProperties2
  {
    operator VkPhysicalDeviceProperties2 const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceProperties2*>(this);
    }

    operator VkPhysicalDeviceProperties2 &()
    {
      return *reinterpret_cast<VkPhysicalDeviceProperties2*>(this);
    }

    bool operator==( PhysicalDeviceProperties2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( properties == rhs.properties );
    }

    bool operator!=( PhysicalDeviceProperties2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceProperties2;
    void* pNext = nullptr;
    PhysicalDeviceProperties properties = PhysicalDeviceProperties();
  };
  static_assert( sizeof( PhysicalDeviceProperties2 ) == sizeof( VkPhysicalDeviceProperties2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceProperties2, pNext ) == offsetof( VkPhysicalDeviceProperties2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceProperties2, properties ) == offsetof( VkPhysicalDeviceProperties2, properties ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;

  struct ImageFormatProperties2
  {
    operator VkImageFormatProperties2 const&() const
    {
      return *reinterpret_cast<const VkImageFormatProperties2*>(this);
    }

    operator VkImageFormatProperties2 &()
    {
      return *reinterpret_cast<VkImageFormatProperties2*>(this);
    }

    bool operator==( ImageFormatProperties2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( imageFormatProperties == rhs.imageFormatProperties );
    }

    bool operator!=( ImageFormatProperties2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImageFormatProperties2;
    void* pNext = nullptr;
    ImageFormatProperties imageFormatProperties = ImageFormatProperties();
  };
  static_assert( sizeof( ImageFormatProperties2 ) == sizeof( VkImageFormatProperties2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImageFormatProperties2, pNext ) == offsetof( VkImageFormatProperties2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImageFormatProperties2, imageFormatProperties ) == offsetof( VkImageFormatProperties2, imageFormatProperties ), "struct member and wrapper member have different offset!" );

  using ImageFormatProperties2KHR = ImageFormatProperties2;

  struct PhysicalDeviceSparseImageFormatInfo2
  {
    operator VkPhysicalDeviceSparseImageFormatInfo2 const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>(this);
    }

    operator VkPhysicalDeviceSparseImageFormatInfo2 &()
    {
      return *reinterpret_cast<VkPhysicalDeviceSparseImageFormatInfo2*>(this);
    }

    bool operator==( PhysicalDeviceSparseImageFormatInfo2 const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( format == rhs.format )
          && ( type == rhs.type )
          && ( samples == rhs.samples )
          && ( usage == rhs.usage )
          && ( tiling == rhs.tiling );
    }

    bool operator!=( PhysicalDeviceSparseImageFormatInfo2 const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceSparseImageFormatInfo2;
    const void* pNext = nullptr;
    Format format = Format::eUndefined;
    ImageType type = ImageType::e1D;
    SampleCountFlagBits samples = SampleCountFlagBits::e1;
    ImageUsageFlags usage = ImageUsageFlags();
    ImageTiling tiling = ImageTiling::eOptimal;
  };
  static_assert( sizeof( PhysicalDeviceSparseImageFormatInfo2 ) == sizeof( VkPhysicalDeviceSparseImageFormatInfo2 ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceSparseImageFormatInfo2, pNext ) == offsetof( VkPhysicalDeviceSparseImageFormatInfo2, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSparseImageFormatInfo2, format ) == offsetof( VkPhysicalDeviceSparseImageFormatInfo2, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSparseImageFormatInfo2, type ) == offsetof( VkPhysicalDeviceSparseImageFormatInfo2, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSparseImageFormatInfo2, samples ) == offsetof( VkPhysicalDeviceSparseImageFormatInfo2, samples ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSparseImageFormatInfo2, usage ) == offsetof( VkPhysicalDeviceSparseImageFormatInfo2, usage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSparseImageFormatInfo2, tiling ) == offsetof( VkPhysicalDeviceSparseImageFormatInfo2, tiling ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;

  struct SampleLocationsInfoEXT
  {
    operator VkSampleLocationsInfoEXT const&() const
    {
      return *reinterpret_cast<const VkSampleLocationsInfoEXT*>(this);
    }

    operator VkSampleLocationsInfoEXT &()
    {
      return *reinterpret_cast<VkSampleLocationsInfoEXT*>(this);
    }

    bool operator==( SampleLocationsInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( sampleLocationsPerPixel == rhs.sampleLocationsPerPixel )
          && ( sampleLocationGridSize == rhs.sampleLocationGridSize )
          && ( sampleLocationsCount == rhs.sampleLocationsCount )
          && ( pSampleLocations == rhs.pSampleLocations );
    }

    bool operator!=( SampleLocationsInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSampleLocationsInfoEXT;
    const void* pNext = nullptr;
    SampleCountFlagBits sampleLocationsPerPixel = SampleCountFlagBits::e1;
    Extent2D sampleLocationGridSize = Extent2D();
    uint32_t sampleLocationsCount = 0;
    const SampleLocationEXT* pSampleLocations = nullptr;
  };
  static_assert( sizeof( SampleLocationsInfoEXT ) == sizeof( VkSampleLocationsInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( SampleLocationsInfoEXT, pNext ) == offsetof( VkSampleLocationsInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SampleLocationsInfoEXT, sampleLocationsPerPixel ) == offsetof( VkSampleLocationsInfoEXT, sampleLocationsPerPixel ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SampleLocationsInfoEXT, sampleLocationGridSize ) == offsetof( VkSampleLocationsInfoEXT, sampleLocationGridSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SampleLocationsInfoEXT, sampleLocationsCount ) == offsetof( VkSampleLocationsInfoEXT, sampleLocationsCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SampleLocationsInfoEXT, pSampleLocations ) == offsetof( VkSampleLocationsInfoEXT, pSampleLocations ), "struct member and wrapper member have different offset!" );

  struct AttachmentSampleLocationsEXT
  {
    operator VkAttachmentSampleLocationsEXT const&() const
    {
      return *reinterpret_cast<const VkAttachmentSampleLocationsEXT*>(this);
    }

    operator VkAttachmentSampleLocationsEXT &()
    {
      return *reinterpret_cast<VkAttachmentSampleLocationsEXT*>(this);
    }

    bool operator==( AttachmentSampleLocationsEXT const& rhs ) const
    {
      return ( attachmentIndex == rhs.attachmentIndex )
          && ( sampleLocationsInfo == rhs.sampleLocationsInfo );
    }

    bool operator!=( AttachmentSampleLocationsEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t attachmentIndex = 0;
    SampleLocationsInfoEXT sampleLocationsInfo = SampleLocationsInfoEXT();
  };
  static_assert( sizeof( AttachmentSampleLocationsEXT ) == sizeof( VkAttachmentSampleLocationsEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( AttachmentSampleLocationsEXT, attachmentIndex ) == offsetof( VkAttachmentSampleLocationsEXT, attachmentIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentSampleLocationsEXT, sampleLocationsInfo ) == offsetof( VkAttachmentSampleLocationsEXT, sampleLocationsInfo ), "struct member and wrapper member have different offset!" );

  struct SubpassSampleLocationsEXT
  {
    operator VkSubpassSampleLocationsEXT const&() const
    {
      return *reinterpret_cast<const VkSubpassSampleLocationsEXT*>(this);
    }

    operator VkSubpassSampleLocationsEXT &()
    {
      return *reinterpret_cast<VkSubpassSampleLocationsEXT*>(this);
    }

    bool operator==( SubpassSampleLocationsEXT const& rhs ) const
    {
      return ( subpassIndex == rhs.subpassIndex )
          && ( sampleLocationsInfo == rhs.sampleLocationsInfo );
    }

    bool operator!=( SubpassSampleLocationsEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t subpassIndex = 0;
    SampleLocationsInfoEXT sampleLocationsInfo = SampleLocationsInfoEXT();
  };
  static_assert( sizeof( SubpassSampleLocationsEXT ) == sizeof( VkSubpassSampleLocationsEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( SubpassSampleLocationsEXT, subpassIndex ) == offsetof( VkSubpassSampleLocationsEXT, subpassIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassSampleLocationsEXT, sampleLocationsInfo ) == offsetof( VkSubpassSampleLocationsEXT, sampleLocationsInfo ), "struct member and wrapper member have different offset!" );

  struct RenderPassSampleLocationsBeginInfoEXT
  {
    operator VkRenderPassSampleLocationsBeginInfoEXT const&() const
    {
      return *reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(this);
    }

    operator VkRenderPassSampleLocationsBeginInfoEXT &()
    {
      return *reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(this);
    }

    bool operator==( RenderPassSampleLocationsBeginInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( attachmentInitialSampleLocationsCount == rhs.attachmentInitialSampleLocationsCount )
          && ( pAttachmentInitialSampleLocations == rhs.pAttachmentInitialSampleLocations )
          && ( postSubpassSampleLocationsCount == rhs.postSubpassSampleLocationsCount )
          && ( pPostSubpassSampleLocations == rhs.pPostSubpassSampleLocations );
    }

    bool operator!=( RenderPassSampleLocationsBeginInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eRenderPassSampleLocationsBeginInfoEXT;
    const void* pNext = nullptr;
    uint32_t attachmentInitialSampleLocationsCount = 0;
    const AttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations = nullptr;
    uint32_t postSubpassSampleLocationsCount = 0;
    const SubpassSampleLocationsEXT* pPostSubpassSampleLocations = nullptr;
  };
  static_assert( sizeof( RenderPassSampleLocationsBeginInfoEXT ) == sizeof( VkRenderPassSampleLocationsBeginInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( RenderPassSampleLocationsBeginInfoEXT, pNext ) == offsetof( VkRenderPassSampleLocationsBeginInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassSampleLocationsBeginInfoEXT, attachmentInitialSampleLocationsCount ) == offsetof( VkRenderPassSampleLocationsBeginInfoEXT, attachmentInitialSampleLocationsCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassSampleLocationsBeginInfoEXT, pAttachmentInitialSampleLocations ) == offsetof( VkRenderPassSampleLocationsBeginInfoEXT, pAttachmentInitialSampleLocations ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassSampleLocationsBeginInfoEXT, postSubpassSampleLocationsCount ) == offsetof( VkRenderPassSampleLocationsBeginInfoEXT, postSubpassSampleLocationsCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassSampleLocationsBeginInfoEXT, pPostSubpassSampleLocations ) == offsetof( VkRenderPassSampleLocationsBeginInfoEXT, pPostSubpassSampleLocations ), "struct member and wrapper member have different offset!" );

  struct PipelineSampleLocationsStateCreateInfoEXT
  {
    operator VkPipelineSampleLocationsStateCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(this);
    }

    operator VkPipelineSampleLocationsStateCreateInfoEXT &()
    {
      return *reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(this);
    }

    bool operator==( PipelineSampleLocationsStateCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( sampleLocationsEnable == rhs.sampleLocationsEnable )
          && ( sampleLocationsInfo == rhs.sampleLocationsInfo );
    }

    bool operator!=( PipelineSampleLocationsStateCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineSampleLocationsStateCreateInfoEXT;
    const void* pNext = nullptr;
    Bool32 sampleLocationsEnable = 0;
    SampleLocationsInfoEXT sampleLocationsInfo = SampleLocationsInfoEXT();
  };
  static_assert( sizeof( PipelineSampleLocationsStateCreateInfoEXT ) == sizeof( VkPipelineSampleLocationsStateCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineSampleLocationsStateCreateInfoEXT, pNext ) == offsetof( VkPipelineSampleLocationsStateCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineSampleLocationsStateCreateInfoEXT, sampleLocationsEnable ) == offsetof( VkPipelineSampleLocationsStateCreateInfoEXT, sampleLocationsEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineSampleLocationsStateCreateInfoEXT, sampleLocationsInfo ) == offsetof( VkPipelineSampleLocationsStateCreateInfoEXT, sampleLocationsInfo ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceSampleLocationsPropertiesEXT
  {
    operator VkPhysicalDeviceSampleLocationsPropertiesEXT const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(this);
    }

    operator VkPhysicalDeviceSampleLocationsPropertiesEXT &()
    {
      return *reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(this);
    }

    bool operator==( PhysicalDeviceSampleLocationsPropertiesEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( sampleLocationSampleCounts == rhs.sampleLocationSampleCounts )
          && ( maxSampleLocationGridSize == rhs.maxSampleLocationGridSize )
          && ( sampleLocationCoordinateRange == rhs.sampleLocationCoordinateRange )
          && ( sampleLocationSubPixelBits == rhs.sampleLocationSubPixelBits )
          && ( variableSampleLocations == rhs.variableSampleLocations );
    }

    bool operator!=( PhysicalDeviceSampleLocationsPropertiesEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceSampleLocationsPropertiesEXT;
    void* pNext = nullptr;
    SampleCountFlags sampleLocationSampleCounts = SampleCountFlags();
    Extent2D maxSampleLocationGridSize = Extent2D();
    std::array<float, 2> sampleLocationCoordinateRange = { { 0, 0 } };
    uint32_t sampleLocationSubPixelBits = 0;
    Bool32 variableSampleLocations = 0;
  };
  static_assert( sizeof( PhysicalDeviceSampleLocationsPropertiesEXT ) == sizeof( VkPhysicalDeviceSampleLocationsPropertiesEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceSampleLocationsPropertiesEXT, pNext ) == offsetof( VkPhysicalDeviceSampleLocationsPropertiesEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationSampleCounts ) == offsetof( VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationSampleCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSampleLocationsPropertiesEXT, maxSampleLocationGridSize ) == offsetof( VkPhysicalDeviceSampleLocationsPropertiesEXT, maxSampleLocationGridSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationCoordinateRange ) == offsetof( VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationCoordinateRange ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationSubPixelBits ) == offsetof( VkPhysicalDeviceSampleLocationsPropertiesEXT, sampleLocationSubPixelBits ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSampleLocationsPropertiesEXT, variableSampleLocations ) == offsetof( VkPhysicalDeviceSampleLocationsPropertiesEXT, variableSampleLocations ), "struct member and wrapper member have different offset!" );

  enum class AttachmentDescriptionFlagBits
  {
    eMayAlias = VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT
  };

  using AttachmentDescriptionFlags = Flags<AttachmentDescriptionFlagBits, VkAttachmentDescriptionFlags>;

  VULKAN_HPP_INLINE AttachmentDescriptionFlags operator|( AttachmentDescriptionFlagBits bit0, AttachmentDescriptionFlagBits bit1 )
  {
    return AttachmentDescriptionFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE AttachmentDescriptionFlags operator~( AttachmentDescriptionFlagBits bits )
  {
    return ~( AttachmentDescriptionFlags( bits ) );
  }

  template <> struct FlagTraits<AttachmentDescriptionFlagBits>
  {
    enum
    {
      allFlags = VkFlags(AttachmentDescriptionFlagBits::eMayAlias)
    };
  };

  struct AttachmentDescription
  {
    operator VkAttachmentDescription const&() const
    {
      return *reinterpret_cast<const VkAttachmentDescription*>(this);
    }

    operator VkAttachmentDescription &()
    {
      return *reinterpret_cast<VkAttachmentDescription*>(this);
    }

    bool operator==( AttachmentDescription const& rhs ) const
    {
      return ( flags == rhs.flags )
          && ( format == rhs.format )
          && ( samples == rhs.samples )
          && ( loadOp == rhs.loadOp )
          && ( storeOp == rhs.storeOp )
          && ( stencilLoadOp == rhs.stencilLoadOp )
          && ( stencilStoreOp == rhs.stencilStoreOp )
          && ( initialLayout == rhs.initialLayout )
          && ( finalLayout == rhs.finalLayout );
    }

    bool operator!=( AttachmentDescription const& rhs ) const
    {
      return !operator==( rhs );
    }

    AttachmentDescriptionFlags flags = AttachmentDescriptionFlags();
    Format format = Format::eUndefined;
    SampleCountFlagBits samples = SampleCountFlagBits::e1;
    AttachmentLoadOp loadOp = AttachmentLoadOp::eLoad;
    AttachmentStoreOp storeOp = AttachmentStoreOp::eStore;
    AttachmentLoadOp stencilLoadOp = AttachmentLoadOp::eLoad;
    AttachmentStoreOp stencilStoreOp = AttachmentStoreOp::eStore;
    ImageLayout initialLayout = ImageLayout::eUndefined;
    ImageLayout finalLayout = ImageLayout::eUndefined;
  };
  static_assert( sizeof( AttachmentDescription ) == sizeof( VkAttachmentDescription ), "struct and wrapper have different size!" );
  static_assert( offsetof( AttachmentDescription, flags ) == offsetof( VkAttachmentDescription, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription, format ) == offsetof( VkAttachmentDescription, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription, samples ) == offsetof( VkAttachmentDescription, samples ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription, loadOp ) == offsetof( VkAttachmentDescription, loadOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription, storeOp ) == offsetof( VkAttachmentDescription, storeOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription, stencilLoadOp ) == offsetof( VkAttachmentDescription, stencilLoadOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription, stencilStoreOp ) == offsetof( VkAttachmentDescription, stencilStoreOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription, initialLayout ) == offsetof( VkAttachmentDescription, initialLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription, finalLayout ) == offsetof( VkAttachmentDescription, finalLayout ), "struct member and wrapper member have different offset!" );

  struct AttachmentDescription2KHR
  {
    operator VkAttachmentDescription2KHR const&() const
    {
      return *reinterpret_cast<const VkAttachmentDescription2KHR*>(this);
    }

    operator VkAttachmentDescription2KHR &()
    {
      return *reinterpret_cast<VkAttachmentDescription2KHR*>(this);
    }

    bool operator==( AttachmentDescription2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( format == rhs.format )
          && ( samples == rhs.samples )
          && ( loadOp == rhs.loadOp )
          && ( storeOp == rhs.storeOp )
          && ( stencilLoadOp == rhs.stencilLoadOp )
          && ( stencilStoreOp == rhs.stencilStoreOp )
          && ( initialLayout == rhs.initialLayout )
          && ( finalLayout == rhs.finalLayout );
    }

    bool operator!=( AttachmentDescription2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eAttachmentDescription2KHR;
    const void* pNext = nullptr;
    AttachmentDescriptionFlags flags = AttachmentDescriptionFlags();
    Format format = Format::eUndefined;
    SampleCountFlagBits samples = SampleCountFlagBits::e1;
    AttachmentLoadOp loadOp = AttachmentLoadOp::eLoad;
    AttachmentStoreOp storeOp = AttachmentStoreOp::eStore;
    AttachmentLoadOp stencilLoadOp = AttachmentLoadOp::eLoad;
    AttachmentStoreOp stencilStoreOp = AttachmentStoreOp::eStore;
    ImageLayout initialLayout = ImageLayout::eUndefined;
    ImageLayout finalLayout = ImageLayout::eUndefined;
  };
  static_assert( sizeof( AttachmentDescription2KHR ) == sizeof( VkAttachmentDescription2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( AttachmentDescription2KHR, pNext ) == offsetof( VkAttachmentDescription2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription2KHR, flags ) == offsetof( VkAttachmentDescription2KHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription2KHR, format ) == offsetof( VkAttachmentDescription2KHR, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription2KHR, samples ) == offsetof( VkAttachmentDescription2KHR, samples ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription2KHR, loadOp ) == offsetof( VkAttachmentDescription2KHR, loadOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription2KHR, storeOp ) == offsetof( VkAttachmentDescription2KHR, storeOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription2KHR, stencilLoadOp ) == offsetof( VkAttachmentDescription2KHR, stencilLoadOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription2KHR, stencilStoreOp ) == offsetof( VkAttachmentDescription2KHR, stencilStoreOp ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription2KHR, initialLayout ) == offsetof( VkAttachmentDescription2KHR, initialLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AttachmentDescription2KHR, finalLayout ) == offsetof( VkAttachmentDescription2KHR, finalLayout ), "struct member and wrapper member have different offset!" );

  enum class StencilFaceFlagBits
  {
    eFront = VK_STENCIL_FACE_FRONT_BIT,
    eBack = VK_STENCIL_FACE_BACK_BIT,
    eVkStencilFrontAndBack = VK_STENCIL_FRONT_AND_BACK
  };

  using StencilFaceFlags = Flags<StencilFaceFlagBits, VkStencilFaceFlags>;

  VULKAN_HPP_INLINE StencilFaceFlags operator|( StencilFaceFlagBits bit0, StencilFaceFlagBits bit1 )
  {
    return StencilFaceFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE StencilFaceFlags operator~( StencilFaceFlagBits bits )
  {
    return ~( StencilFaceFlags( bits ) );
  }

  template <> struct FlagTraits<StencilFaceFlagBits>
  {
    enum
    {
      allFlags = VkFlags(StencilFaceFlagBits::eFront) | VkFlags(StencilFaceFlagBits::eBack) | VkFlags(StencilFaceFlagBits::eVkStencilFrontAndBack)
    };
  };

  enum class DescriptorPoolCreateFlagBits
  {
    eFreeDescriptorSet = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
    eUpdateAfterBindEXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT
  };

  using DescriptorPoolCreateFlags = Flags<DescriptorPoolCreateFlagBits, VkDescriptorPoolCreateFlags>;

  VULKAN_HPP_INLINE DescriptorPoolCreateFlags operator|( DescriptorPoolCreateFlagBits bit0, DescriptorPoolCreateFlagBits bit1 )
  {
    return DescriptorPoolCreateFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DescriptorPoolCreateFlags operator~( DescriptorPoolCreateFlagBits bits )
  {
    return ~( DescriptorPoolCreateFlags( bits ) );
  }

  template <> struct FlagTraits<DescriptorPoolCreateFlagBits>
  {
    enum
    {
      allFlags = VkFlags(DescriptorPoolCreateFlagBits::eFreeDescriptorSet) | VkFlags(DescriptorPoolCreateFlagBits::eUpdateAfterBindEXT)
    };
  };

  struct DescriptorPoolCreateInfo
  {
    operator VkDescriptorPoolCreateInfo const&() const
    {
      return *reinterpret_cast<const VkDescriptorPoolCreateInfo*>(this);
    }

    operator VkDescriptorPoolCreateInfo &()
    {
      return *reinterpret_cast<VkDescriptorPoolCreateInfo*>(this);
    }

    bool operator==( DescriptorPoolCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( maxSets == rhs.maxSets )
          && ( poolSizeCount == rhs.poolSizeCount )
          && ( pPoolSizes == rhs.pPoolSizes );
    }

    bool operator!=( DescriptorPoolCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorPoolCreateInfo;
    const void* pNext = nullptr;
    DescriptorPoolCreateFlags flags = DescriptorPoolCreateFlags();
    uint32_t maxSets = 0;
    uint32_t poolSizeCount = 0;
    const DescriptorPoolSize* pPoolSizes = nullptr;
  };
  static_assert( sizeof( DescriptorPoolCreateInfo ) == sizeof( VkDescriptorPoolCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorPoolCreateInfo, pNext ) == offsetof( VkDescriptorPoolCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorPoolCreateInfo, flags ) == offsetof( VkDescriptorPoolCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorPoolCreateInfo, maxSets ) == offsetof( VkDescriptorPoolCreateInfo, maxSets ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorPoolCreateInfo, poolSizeCount ) == offsetof( VkDescriptorPoolCreateInfo, poolSizeCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorPoolCreateInfo, pPoolSizes ) == offsetof( VkDescriptorPoolCreateInfo, pPoolSizes ), "struct member and wrapper member have different offset!" );

  enum class DependencyFlagBits
  {
    eByRegion = VK_DEPENDENCY_BY_REGION_BIT,
    eDeviceGroup = VK_DEPENDENCY_DEVICE_GROUP_BIT,
    eDeviceGroupKHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,
    eViewLocal = VK_DEPENDENCY_VIEW_LOCAL_BIT,
    eViewLocalKHR = VK_DEPENDENCY_VIEW_LOCAL_BIT
  };

  using DependencyFlags = Flags<DependencyFlagBits, VkDependencyFlags>;

  VULKAN_HPP_INLINE DependencyFlags operator|( DependencyFlagBits bit0, DependencyFlagBits bit1 )
  {
    return DependencyFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DependencyFlags operator~( DependencyFlagBits bits )
  {
    return ~( DependencyFlags( bits ) );
  }

  template <> struct FlagTraits<DependencyFlagBits>
  {
    enum
    {
      allFlags = VkFlags(DependencyFlagBits::eByRegion) | VkFlags(DependencyFlagBits::eDeviceGroup) | VkFlags(DependencyFlagBits::eViewLocal)
    };
  };

  struct SubpassDependency
  {
    operator VkSubpassDependency const&() const
    {
      return *reinterpret_cast<const VkSubpassDependency*>(this);
    }

    operator VkSubpassDependency &()
    {
      return *reinterpret_cast<VkSubpassDependency*>(this);
    }

    bool operator==( SubpassDependency const& rhs ) const
    {
      return ( srcSubpass == rhs.srcSubpass )
          && ( dstSubpass == rhs.dstSubpass )
          && ( srcStageMask == rhs.srcStageMask )
          && ( dstStageMask == rhs.dstStageMask )
          && ( srcAccessMask == rhs.srcAccessMask )
          && ( dstAccessMask == rhs.dstAccessMask )
          && ( dependencyFlags == rhs.dependencyFlags );
    }

    bool operator!=( SubpassDependency const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t srcSubpass = 0;
    uint32_t dstSubpass = 0;
    PipelineStageFlags srcStageMask = PipelineStageFlags();
    PipelineStageFlags dstStageMask = PipelineStageFlags();
    AccessFlags srcAccessMask = AccessFlags();
    AccessFlags dstAccessMask = AccessFlags();
    DependencyFlags dependencyFlags = DependencyFlags();
  };
  static_assert( sizeof( SubpassDependency ) == sizeof( VkSubpassDependency ), "struct and wrapper have different size!" );
  static_assert( offsetof( SubpassDependency, srcSubpass ) == offsetof( VkSubpassDependency, srcSubpass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency, dstSubpass ) == offsetof( VkSubpassDependency, dstSubpass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency, srcStageMask ) == offsetof( VkSubpassDependency, srcStageMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency, dstStageMask ) == offsetof( VkSubpassDependency, dstStageMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency, srcAccessMask ) == offsetof( VkSubpassDependency, srcAccessMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency, dstAccessMask ) == offsetof( VkSubpassDependency, dstAccessMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency, dependencyFlags ) == offsetof( VkSubpassDependency, dependencyFlags ), "struct member and wrapper member have different offset!" );

  struct SubpassDependency2KHR
  {
    operator VkSubpassDependency2KHR const&() const
    {
      return *reinterpret_cast<const VkSubpassDependency2KHR*>(this);
    }

    operator VkSubpassDependency2KHR &()
    {
      return *reinterpret_cast<VkSubpassDependency2KHR*>(this);
    }

    bool operator==( SubpassDependency2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( srcSubpass == rhs.srcSubpass )
          && ( dstSubpass == rhs.dstSubpass )
          && ( srcStageMask == rhs.srcStageMask )
          && ( dstStageMask == rhs.dstStageMask )
          && ( srcAccessMask == rhs.srcAccessMask )
          && ( dstAccessMask == rhs.dstAccessMask )
          && ( dependencyFlags == rhs.dependencyFlags )
          && ( viewOffset == rhs.viewOffset );
    }

    bool operator!=( SubpassDependency2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSubpassDependency2KHR;
    const void* pNext = nullptr;
    uint32_t srcSubpass = 0;
    uint32_t dstSubpass = 0;
    PipelineStageFlags srcStageMask = PipelineStageFlags();
    PipelineStageFlags dstStageMask = PipelineStageFlags();
    AccessFlags srcAccessMask = AccessFlags();
    AccessFlags dstAccessMask = AccessFlags();
    DependencyFlags dependencyFlags = DependencyFlags();
    int32_t viewOffset = 0;
  };
  static_assert( sizeof( SubpassDependency2KHR ) == sizeof( VkSubpassDependency2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SubpassDependency2KHR, pNext ) == offsetof( VkSubpassDependency2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency2KHR, srcSubpass ) == offsetof( VkSubpassDependency2KHR, srcSubpass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency2KHR, dstSubpass ) == offsetof( VkSubpassDependency2KHR, dstSubpass ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency2KHR, srcStageMask ) == offsetof( VkSubpassDependency2KHR, srcStageMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency2KHR, dstStageMask ) == offsetof( VkSubpassDependency2KHR, dstStageMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency2KHR, srcAccessMask ) == offsetof( VkSubpassDependency2KHR, srcAccessMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency2KHR, dstAccessMask ) == offsetof( VkSubpassDependency2KHR, dstAccessMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency2KHR, dependencyFlags ) == offsetof( VkSubpassDependency2KHR, dependencyFlags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDependency2KHR, viewOffset ) == offsetof( VkSubpassDependency2KHR, viewOffset ), "struct member and wrapper member have different offset!" );

  enum class PresentModeKHR
  {
    eImmediate = VK_PRESENT_MODE_IMMEDIATE_KHR,
    eMailbox = VK_PRESENT_MODE_MAILBOX_KHR,
    eFifo = VK_PRESENT_MODE_FIFO_KHR,
    eFifoRelaxed = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    eSharedDemandRefresh = VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,
    eSharedContinuousRefresh = VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR
  };

  enum class ColorSpaceKHR
  {
    eSrgbNonlinear = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    eVkColorspaceSrgbNonlinear = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    eDisplayP3NonlinearEXT = VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,
    eExtendedSrgbLinearEXT = VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,
    eDciP3LinearEXT = VK_COLOR_SPACE_DCI_P3_LINEAR_EXT,
    eDciP3NonlinearEXT = VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,
    eBt709LinearEXT = VK_COLOR_SPACE_BT709_LINEAR_EXT,
    eBt709NonlinearEXT = VK_COLOR_SPACE_BT709_NONLINEAR_EXT,
    eBt2020LinearEXT = VK_COLOR_SPACE_BT2020_LINEAR_EXT,
    eHdr10St2084EXT = VK_COLOR_SPACE_HDR10_ST2084_EXT,
    eDolbyvisionEXT = VK_COLOR_SPACE_DOLBYVISION_EXT,
    eHdr10HlgEXT = VK_COLOR_SPACE_HDR10_HLG_EXT,
    eAdobergbLinearEXT = VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,
    eAdobergbNonlinearEXT = VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,
    ePassThroughEXT = VK_COLOR_SPACE_PASS_THROUGH_EXT,
    eExtendedSrgbNonlinearEXT = VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT
  };

  struct SurfaceFormatKHR
  {
    operator VkSurfaceFormatKHR const&() const
    {
      return *reinterpret_cast<const VkSurfaceFormatKHR*>(this);
    }

    operator VkSurfaceFormatKHR &()
    {
      return *reinterpret_cast<VkSurfaceFormatKHR*>(this);
    }

    bool operator==( SurfaceFormatKHR const& rhs ) const
    {
      return ( format == rhs.format )
          && ( colorSpace == rhs.colorSpace );
    }

    bool operator!=( SurfaceFormatKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    Format format = Format::eUndefined;
    ColorSpaceKHR colorSpace = ColorSpaceKHR::eSrgbNonlinear;
  };
  static_assert( sizeof( SurfaceFormatKHR ) == sizeof( VkSurfaceFormatKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SurfaceFormatKHR, format ) == offsetof( VkSurfaceFormatKHR, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceFormatKHR, colorSpace ) == offsetof( VkSurfaceFormatKHR, colorSpace ), "struct member and wrapper member have different offset!" );

  struct SurfaceFormat2KHR
  {
    operator VkSurfaceFormat2KHR const&() const
    {
      return *reinterpret_cast<const VkSurfaceFormat2KHR*>(this);
    }

    operator VkSurfaceFormat2KHR &()
    {
      return *reinterpret_cast<VkSurfaceFormat2KHR*>(this);
    }

    bool operator==( SurfaceFormat2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( surfaceFormat == rhs.surfaceFormat );
    }

    bool operator!=( SurfaceFormat2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSurfaceFormat2KHR;
    void* pNext = nullptr;
    SurfaceFormatKHR surfaceFormat = SurfaceFormatKHR();
  };
  static_assert( sizeof( SurfaceFormat2KHR ) == sizeof( VkSurfaceFormat2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SurfaceFormat2KHR, pNext ) == offsetof( VkSurfaceFormat2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceFormat2KHR, surfaceFormat ) == offsetof( VkSurfaceFormat2KHR, surfaceFormat ), "struct member and wrapper member have different offset!" );

  enum class DisplayPlaneAlphaFlagBitsKHR
  {
    eOpaque = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
    eGlobal = VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR,
    ePerPixel = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR,
    ePerPixelPremultiplied = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR
  };

  using DisplayPlaneAlphaFlagsKHR = Flags<DisplayPlaneAlphaFlagBitsKHR, VkDisplayPlaneAlphaFlagsKHR>;

  VULKAN_HPP_INLINE DisplayPlaneAlphaFlagsKHR operator|( DisplayPlaneAlphaFlagBitsKHR bit0, DisplayPlaneAlphaFlagBitsKHR bit1 )
  {
    return DisplayPlaneAlphaFlagsKHR( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DisplayPlaneAlphaFlagsKHR operator~( DisplayPlaneAlphaFlagBitsKHR bits )
  {
    return ~( DisplayPlaneAlphaFlagsKHR( bits ) );
  }

  template <> struct FlagTraits<DisplayPlaneAlphaFlagBitsKHR>
  {
    enum
    {
      allFlags = VkFlags(DisplayPlaneAlphaFlagBitsKHR::eOpaque) | VkFlags(DisplayPlaneAlphaFlagBitsKHR::eGlobal) | VkFlags(DisplayPlaneAlphaFlagBitsKHR::ePerPixel) | VkFlags(DisplayPlaneAlphaFlagBitsKHR::ePerPixelPremultiplied)
    };
  };

  struct DisplayPlaneCapabilitiesKHR
  {
    operator VkDisplayPlaneCapabilitiesKHR const&() const
    {
      return *reinterpret_cast<const VkDisplayPlaneCapabilitiesKHR*>(this);
    }

    operator VkDisplayPlaneCapabilitiesKHR &()
    {
      return *reinterpret_cast<VkDisplayPlaneCapabilitiesKHR*>(this);
    }

    bool operator==( DisplayPlaneCapabilitiesKHR const& rhs ) const
    {
      return ( supportedAlpha == rhs.supportedAlpha )
          && ( minSrcPosition == rhs.minSrcPosition )
          && ( maxSrcPosition == rhs.maxSrcPosition )
          && ( minSrcExtent == rhs.minSrcExtent )
          && ( maxSrcExtent == rhs.maxSrcExtent )
          && ( minDstPosition == rhs.minDstPosition )
          && ( maxDstPosition == rhs.maxDstPosition )
          && ( minDstExtent == rhs.minDstExtent )
          && ( maxDstExtent == rhs.maxDstExtent );
    }

    bool operator!=( DisplayPlaneCapabilitiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    DisplayPlaneAlphaFlagsKHR supportedAlpha = DisplayPlaneAlphaFlagsKHR();
    Offset2D minSrcPosition = Offset2D();
    Offset2D maxSrcPosition = Offset2D();
    Extent2D minSrcExtent = Extent2D();
    Extent2D maxSrcExtent = Extent2D();
    Offset2D minDstPosition = Offset2D();
    Offset2D maxDstPosition = Offset2D();
    Extent2D minDstExtent = Extent2D();
    Extent2D maxDstExtent = Extent2D();
  };
  static_assert( sizeof( DisplayPlaneCapabilitiesKHR ) == sizeof( VkDisplayPlaneCapabilitiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayPlaneCapabilitiesKHR, supportedAlpha ) == offsetof( VkDisplayPlaneCapabilitiesKHR, supportedAlpha ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneCapabilitiesKHR, minSrcPosition ) == offsetof( VkDisplayPlaneCapabilitiesKHR, minSrcPosition ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneCapabilitiesKHR, maxSrcPosition ) == offsetof( VkDisplayPlaneCapabilitiesKHR, maxSrcPosition ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneCapabilitiesKHR, minSrcExtent ) == offsetof( VkDisplayPlaneCapabilitiesKHR, minSrcExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneCapabilitiesKHR, maxSrcExtent ) == offsetof( VkDisplayPlaneCapabilitiesKHR, maxSrcExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneCapabilitiesKHR, minDstPosition ) == offsetof( VkDisplayPlaneCapabilitiesKHR, minDstPosition ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneCapabilitiesKHR, maxDstPosition ) == offsetof( VkDisplayPlaneCapabilitiesKHR, maxDstPosition ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneCapabilitiesKHR, minDstExtent ) == offsetof( VkDisplayPlaneCapabilitiesKHR, minDstExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneCapabilitiesKHR, maxDstExtent ) == offsetof( VkDisplayPlaneCapabilitiesKHR, maxDstExtent ), "struct member and wrapper member have different offset!" );

  struct DisplayPlaneCapabilities2KHR
  {
    operator VkDisplayPlaneCapabilities2KHR const&() const
    {
      return *reinterpret_cast<const VkDisplayPlaneCapabilities2KHR*>(this);
    }

    operator VkDisplayPlaneCapabilities2KHR &()
    {
      return *reinterpret_cast<VkDisplayPlaneCapabilities2KHR*>(this);
    }

    bool operator==( DisplayPlaneCapabilities2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( capabilities == rhs.capabilities );
    }

    bool operator!=( DisplayPlaneCapabilities2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplayPlaneCapabilities2KHR;
    void* pNext = nullptr;
    DisplayPlaneCapabilitiesKHR capabilities = DisplayPlaneCapabilitiesKHR();
  };
  static_assert( sizeof( DisplayPlaneCapabilities2KHR ) == sizeof( VkDisplayPlaneCapabilities2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayPlaneCapabilities2KHR, pNext ) == offsetof( VkDisplayPlaneCapabilities2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPlaneCapabilities2KHR, capabilities ) == offsetof( VkDisplayPlaneCapabilities2KHR, capabilities ), "struct member and wrapper member have different offset!" );

  enum class CompositeAlphaFlagBitsKHR
  {
    eOpaque = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
    ePreMultiplied = VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
    ePostMultiplied = VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
    eInherit = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR
  };

  using CompositeAlphaFlagsKHR = Flags<CompositeAlphaFlagBitsKHR, VkCompositeAlphaFlagsKHR>;

  VULKAN_HPP_INLINE CompositeAlphaFlagsKHR operator|( CompositeAlphaFlagBitsKHR bit0, CompositeAlphaFlagBitsKHR bit1 )
  {
    return CompositeAlphaFlagsKHR( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE CompositeAlphaFlagsKHR operator~( CompositeAlphaFlagBitsKHR bits )
  {
    return ~( CompositeAlphaFlagsKHR( bits ) );
  }

  template <> struct FlagTraits<CompositeAlphaFlagBitsKHR>
  {
    enum
    {
      allFlags = VkFlags(CompositeAlphaFlagBitsKHR::eOpaque) | VkFlags(CompositeAlphaFlagBitsKHR::ePreMultiplied) | VkFlags(CompositeAlphaFlagBitsKHR::ePostMultiplied) | VkFlags(CompositeAlphaFlagBitsKHR::eInherit)
    };
  };

  enum class SurfaceTransformFlagBitsKHR
  {
    eIdentity = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
    eRotate90 = VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
    eRotate180 = VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
    eRotate270 = VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
    eHorizontalMirror = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
    eHorizontalMirrorRotate90 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
    eHorizontalMirrorRotate180 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
    eHorizontalMirrorRotate270 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
    eInherit = VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR
  };

  using SurfaceTransformFlagsKHR = Flags<SurfaceTransformFlagBitsKHR, VkSurfaceTransformFlagsKHR>;

  VULKAN_HPP_INLINE SurfaceTransformFlagsKHR operator|( SurfaceTransformFlagBitsKHR bit0, SurfaceTransformFlagBitsKHR bit1 )
  {
    return SurfaceTransformFlagsKHR( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE SurfaceTransformFlagsKHR operator~( SurfaceTransformFlagBitsKHR bits )
  {
    return ~( SurfaceTransformFlagsKHR( bits ) );
  }

  template <> struct FlagTraits<SurfaceTransformFlagBitsKHR>
  {
    enum
    {
      allFlags = VkFlags(SurfaceTransformFlagBitsKHR::eIdentity) | VkFlags(SurfaceTransformFlagBitsKHR::eRotate90) | VkFlags(SurfaceTransformFlagBitsKHR::eRotate180) | VkFlags(SurfaceTransformFlagBitsKHR::eRotate270) | VkFlags(SurfaceTransformFlagBitsKHR::eHorizontalMirror) | VkFlags(SurfaceTransformFlagBitsKHR::eHorizontalMirrorRotate90) | VkFlags(SurfaceTransformFlagBitsKHR::eHorizontalMirrorRotate180) | VkFlags(SurfaceTransformFlagBitsKHR::eHorizontalMirrorRotate270) | VkFlags(SurfaceTransformFlagBitsKHR::eInherit)
    };
  };

  struct DisplayPropertiesKHR
  {
    operator VkDisplayPropertiesKHR const&() const
    {
      return *reinterpret_cast<const VkDisplayPropertiesKHR*>(this);
    }

    operator VkDisplayPropertiesKHR &()
    {
      return *reinterpret_cast<VkDisplayPropertiesKHR*>(this);
    }

    bool operator==( DisplayPropertiesKHR const& rhs ) const
    {
      return ( display == rhs.display )
          && ( displayName == rhs.displayName )
          && ( physicalDimensions == rhs.physicalDimensions )
          && ( physicalResolution == rhs.physicalResolution )
          && ( supportedTransforms == rhs.supportedTransforms )
          && ( planeReorderPossible == rhs.planeReorderPossible )
          && ( persistentContent == rhs.persistentContent );
    }

    bool operator!=( DisplayPropertiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    DisplayKHR display = DisplayKHR();
    const char* displayName = nullptr;
    Extent2D physicalDimensions = Extent2D();
    Extent2D physicalResolution = Extent2D();
    SurfaceTransformFlagsKHR supportedTransforms = SurfaceTransformFlagsKHR();
    Bool32 planeReorderPossible = 0;
    Bool32 persistentContent = 0;
  };
  static_assert( sizeof( DisplayPropertiesKHR ) == sizeof( VkDisplayPropertiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayPropertiesKHR, display ) == offsetof( VkDisplayPropertiesKHR, display ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPropertiesKHR, displayName ) == offsetof( VkDisplayPropertiesKHR, displayName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPropertiesKHR, physicalDimensions ) == offsetof( VkDisplayPropertiesKHR, physicalDimensions ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPropertiesKHR, physicalResolution ) == offsetof( VkDisplayPropertiesKHR, physicalResolution ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPropertiesKHR, supportedTransforms ) == offsetof( VkDisplayPropertiesKHR, supportedTransforms ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPropertiesKHR, planeReorderPossible ) == offsetof( VkDisplayPropertiesKHR, planeReorderPossible ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPropertiesKHR, persistentContent ) == offsetof( VkDisplayPropertiesKHR, persistentContent ), "struct member and wrapper member have different offset!" );

  struct DisplaySurfaceCreateInfoKHR
  {
    operator VkDisplaySurfaceCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkDisplaySurfaceCreateInfoKHR*>(this);
    }

    operator VkDisplaySurfaceCreateInfoKHR &()
    {
      return *reinterpret_cast<VkDisplaySurfaceCreateInfoKHR*>(this);
    }

    bool operator==( DisplaySurfaceCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( displayMode == rhs.displayMode )
          && ( planeIndex == rhs.planeIndex )
          && ( planeStackIndex == rhs.planeStackIndex )
          && ( transform == rhs.transform )
          && ( globalAlpha == rhs.globalAlpha )
          && ( alphaMode == rhs.alphaMode )
          && ( imageExtent == rhs.imageExtent );
    }

    bool operator!=( DisplaySurfaceCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplaySurfaceCreateInfoKHR;
    const void* pNext = nullptr;
    DisplaySurfaceCreateFlagsKHR flags = DisplaySurfaceCreateFlagsKHR();
    DisplayModeKHR displayMode = DisplayModeKHR();
    uint32_t planeIndex = 0;
    uint32_t planeStackIndex = 0;
    SurfaceTransformFlagBitsKHR transform = SurfaceTransformFlagBitsKHR::eIdentity;
    float globalAlpha = 0;
    DisplayPlaneAlphaFlagBitsKHR alphaMode = DisplayPlaneAlphaFlagBitsKHR::eOpaque;
    Extent2D imageExtent = Extent2D();
  };
  static_assert( sizeof( DisplaySurfaceCreateInfoKHR ) == sizeof( VkDisplaySurfaceCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplaySurfaceCreateInfoKHR, pNext ) == offsetof( VkDisplaySurfaceCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplaySurfaceCreateInfoKHR, flags ) == offsetof( VkDisplaySurfaceCreateInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplaySurfaceCreateInfoKHR, displayMode ) == offsetof( VkDisplaySurfaceCreateInfoKHR, displayMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplaySurfaceCreateInfoKHR, planeIndex ) == offsetof( VkDisplaySurfaceCreateInfoKHR, planeIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplaySurfaceCreateInfoKHR, planeStackIndex ) == offsetof( VkDisplaySurfaceCreateInfoKHR, planeStackIndex ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplaySurfaceCreateInfoKHR, transform ) == offsetof( VkDisplaySurfaceCreateInfoKHR, transform ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplaySurfaceCreateInfoKHR, globalAlpha ) == offsetof( VkDisplaySurfaceCreateInfoKHR, globalAlpha ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplaySurfaceCreateInfoKHR, alphaMode ) == offsetof( VkDisplaySurfaceCreateInfoKHR, alphaMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplaySurfaceCreateInfoKHR, imageExtent ) == offsetof( VkDisplaySurfaceCreateInfoKHR, imageExtent ), "struct member and wrapper member have different offset!" );

  struct SurfaceCapabilitiesKHR
  {
    operator VkSurfaceCapabilitiesKHR const&() const
    {
      return *reinterpret_cast<const VkSurfaceCapabilitiesKHR*>(this);
    }

    operator VkSurfaceCapabilitiesKHR &()
    {
      return *reinterpret_cast<VkSurfaceCapabilitiesKHR*>(this);
    }

    bool operator==( SurfaceCapabilitiesKHR const& rhs ) const
    {
      return ( minImageCount == rhs.minImageCount )
          && ( maxImageCount == rhs.maxImageCount )
          && ( currentExtent == rhs.currentExtent )
          && ( minImageExtent == rhs.minImageExtent )
          && ( maxImageExtent == rhs.maxImageExtent )
          && ( maxImageArrayLayers == rhs.maxImageArrayLayers )
          && ( supportedTransforms == rhs.supportedTransforms )
          && ( currentTransform == rhs.currentTransform )
          && ( supportedCompositeAlpha == rhs.supportedCompositeAlpha )
          && ( supportedUsageFlags == rhs.supportedUsageFlags );
    }

    bool operator!=( SurfaceCapabilitiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t minImageCount = 0;
    uint32_t maxImageCount = 0;
    Extent2D currentExtent = Extent2D();
    Extent2D minImageExtent = Extent2D();
    Extent2D maxImageExtent = Extent2D();
    uint32_t maxImageArrayLayers = 0;
    SurfaceTransformFlagsKHR supportedTransforms = SurfaceTransformFlagsKHR();
    SurfaceTransformFlagBitsKHR currentTransform = SurfaceTransformFlagBitsKHR::eIdentity;
    CompositeAlphaFlagsKHR supportedCompositeAlpha = CompositeAlphaFlagsKHR();
    ImageUsageFlags supportedUsageFlags = ImageUsageFlags();
  };
  static_assert( sizeof( SurfaceCapabilitiesKHR ) == sizeof( VkSurfaceCapabilitiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, minImageCount ) == offsetof( VkSurfaceCapabilitiesKHR, minImageCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, maxImageCount ) == offsetof( VkSurfaceCapabilitiesKHR, maxImageCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, currentExtent ) == offsetof( VkSurfaceCapabilitiesKHR, currentExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, minImageExtent ) == offsetof( VkSurfaceCapabilitiesKHR, minImageExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, maxImageExtent ) == offsetof( VkSurfaceCapabilitiesKHR, maxImageExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, maxImageArrayLayers ) == offsetof( VkSurfaceCapabilitiesKHR, maxImageArrayLayers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, supportedTransforms ) == offsetof( VkSurfaceCapabilitiesKHR, supportedTransforms ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, currentTransform ) == offsetof( VkSurfaceCapabilitiesKHR, currentTransform ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, supportedCompositeAlpha ) == offsetof( VkSurfaceCapabilitiesKHR, supportedCompositeAlpha ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilitiesKHR, supportedUsageFlags ) == offsetof( VkSurfaceCapabilitiesKHR, supportedUsageFlags ), "struct member and wrapper member have different offset!" );

  struct SurfaceCapabilities2KHR
  {
    operator VkSurfaceCapabilities2KHR const&() const
    {
      return *reinterpret_cast<const VkSurfaceCapabilities2KHR*>(this);
    }

    operator VkSurfaceCapabilities2KHR &()
    {
      return *reinterpret_cast<VkSurfaceCapabilities2KHR*>(this);
    }

    bool operator==( SurfaceCapabilities2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( surfaceCapabilities == rhs.surfaceCapabilities );
    }

    bool operator!=( SurfaceCapabilities2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSurfaceCapabilities2KHR;
    void* pNext = nullptr;
    SurfaceCapabilitiesKHR surfaceCapabilities = SurfaceCapabilitiesKHR();
  };
  static_assert( sizeof( SurfaceCapabilities2KHR ) == sizeof( VkSurfaceCapabilities2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SurfaceCapabilities2KHR, pNext ) == offsetof( VkSurfaceCapabilities2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2KHR, surfaceCapabilities ) == offsetof( VkSurfaceCapabilities2KHR, surfaceCapabilities ), "struct member and wrapper member have different offset!" );

  struct DisplayProperties2KHR
  {
    operator VkDisplayProperties2KHR const&() const
    {
      return *reinterpret_cast<const VkDisplayProperties2KHR*>(this);
    }

    operator VkDisplayProperties2KHR &()
    {
      return *reinterpret_cast<VkDisplayProperties2KHR*>(this);
    }

    bool operator==( DisplayProperties2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( displayProperties == rhs.displayProperties );
    }

    bool operator!=( DisplayProperties2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplayProperties2KHR;
    void* pNext = nullptr;
    DisplayPropertiesKHR displayProperties = DisplayPropertiesKHR();
  };
  static_assert( sizeof( DisplayProperties2KHR ) == sizeof( VkDisplayProperties2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayProperties2KHR, pNext ) == offsetof( VkDisplayProperties2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayProperties2KHR, displayProperties ) == offsetof( VkDisplayProperties2KHR, displayProperties ), "struct member and wrapper member have different offset!" );

  enum class DebugReportFlagBitsEXT
  {
    eInformation = VK_DEBUG_REPORT_INFORMATION_BIT_EXT,
    eWarning = VK_DEBUG_REPORT_WARNING_BIT_EXT,
    ePerformanceWarning = VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
    eError = VK_DEBUG_REPORT_ERROR_BIT_EXT,
    eDebug = VK_DEBUG_REPORT_DEBUG_BIT_EXT
  };

  using DebugReportFlagsEXT = Flags<DebugReportFlagBitsEXT, VkDebugReportFlagsEXT>;

  VULKAN_HPP_INLINE DebugReportFlagsEXT operator|( DebugReportFlagBitsEXT bit0, DebugReportFlagBitsEXT bit1 )
  {
    return DebugReportFlagsEXT( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DebugReportFlagsEXT operator~( DebugReportFlagBitsEXT bits )
  {
    return ~( DebugReportFlagsEXT( bits ) );
  }

  template <> struct FlagTraits<DebugReportFlagBitsEXT>
  {
    enum
    {
      allFlags = VkFlags(DebugReportFlagBitsEXT::eInformation) | VkFlags(DebugReportFlagBitsEXT::eWarning) | VkFlags(DebugReportFlagBitsEXT::ePerformanceWarning) | VkFlags(DebugReportFlagBitsEXT::eError) | VkFlags(DebugReportFlagBitsEXT::eDebug)
    };
  };

  struct DebugReportCallbackCreateInfoEXT
  {
    operator VkDebugReportCallbackCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(this);
    }

    operator VkDebugReportCallbackCreateInfoEXT &()
    {
      return *reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(this);
    }

    bool operator==( DebugReportCallbackCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( pfnCallback == rhs.pfnCallback )
          && ( pUserData == rhs.pUserData );
    }

    bool operator!=( DebugReportCallbackCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDebugReportCallbackCreateInfoEXT;
    const void* pNext = nullptr;
    DebugReportFlagsEXT flags = DebugReportFlagsEXT();
    PFN_vkDebugReportCallbackEXT pfnCallback = nullptr;
    void* pUserData = nullptr;
  };
  static_assert( sizeof( DebugReportCallbackCreateInfoEXT ) == sizeof( VkDebugReportCallbackCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DebugReportCallbackCreateInfoEXT, pNext ) == offsetof( VkDebugReportCallbackCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugReportCallbackCreateInfoEXT, flags ) == offsetof( VkDebugReportCallbackCreateInfoEXT, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugReportCallbackCreateInfoEXT, pfnCallback ) == offsetof( VkDebugReportCallbackCreateInfoEXT, pfnCallback ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugReportCallbackCreateInfoEXT, pUserData ) == offsetof( VkDebugReportCallbackCreateInfoEXT, pUserData ), "struct member and wrapper member have different offset!" );

  enum class DebugReportObjectTypeEXT
  {
    eUnknown = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    eInstance = VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
    ePhysicalDevice = VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
    eDevice = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
    eQueue = VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
    eSemaphore = VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
    eCommandBuffer = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
    eFence = VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
    eDeviceMemory = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
    eBuffer = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
    eImage = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
    eEvent = VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
    eQueryPool = VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
    eBufferView = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
    eImageView = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
    eShaderModule = VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
    ePipelineCache = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
    ePipelineLayout = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
    eRenderPass = VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
    ePipeline = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
    eDescriptorSetLayout = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
    eSampler = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
    eDescriptorPool = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
    eDescriptorSet = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
    eFramebuffer = VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
    eCommandPool = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
    eSurfaceKhr = VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
    eSwapchainKhr = VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
    eDebugReportCallbackExt = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    eDebugReport = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    eDisplayKhr = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
    eDisplayModeKhr = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
    eObjectTableNvx = VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT,
    eIndirectCommandsLayoutNvx = VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT,
    eValidationCacheExt = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    eValidationCache = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    eSamplerYcbcrConversion = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
    eSamplerYcbcrConversionKHR = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
    eDescriptorUpdateTemplate = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    eDescriptorUpdateTemplateKHR = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    eAccelerationStructureNVX = VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NVX_EXT
  };

  struct DebugMarkerObjectNameInfoEXT
  {
    operator VkDebugMarkerObjectNameInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDebugMarkerObjectNameInfoEXT*>(this);
    }

    operator VkDebugMarkerObjectNameInfoEXT &()
    {
      return *reinterpret_cast<VkDebugMarkerObjectNameInfoEXT*>(this);
    }

    bool operator==( DebugMarkerObjectNameInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( objectType == rhs.objectType )
          && ( object == rhs.object )
          && ( pObjectName == rhs.pObjectName );
    }

    bool operator!=( DebugMarkerObjectNameInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDebugMarkerObjectNameInfoEXT;
    const void* pNext = nullptr;
    DebugReportObjectTypeEXT objectType = DebugReportObjectTypeEXT::eUnknown;
    uint64_t object = 0;
    const char* pObjectName = nullptr;
  };
  static_assert( sizeof( DebugMarkerObjectNameInfoEXT ) == sizeof( VkDebugMarkerObjectNameInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DebugMarkerObjectNameInfoEXT, pNext ) == offsetof( VkDebugMarkerObjectNameInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerObjectNameInfoEXT, objectType ) == offsetof( VkDebugMarkerObjectNameInfoEXT, objectType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerObjectNameInfoEXT, object ) == offsetof( VkDebugMarkerObjectNameInfoEXT, object ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerObjectNameInfoEXT, pObjectName ) == offsetof( VkDebugMarkerObjectNameInfoEXT, pObjectName ), "struct member and wrapper member have different offset!" );

  struct DebugMarkerObjectTagInfoEXT
  {
    operator VkDebugMarkerObjectTagInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDebugMarkerObjectTagInfoEXT*>(this);
    }

    operator VkDebugMarkerObjectTagInfoEXT &()
    {
      return *reinterpret_cast<VkDebugMarkerObjectTagInfoEXT*>(this);
    }

    bool operator==( DebugMarkerObjectTagInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( objectType == rhs.objectType )
          && ( object == rhs.object )
          && ( tagName == rhs.tagName )
          && ( tagSize == rhs.tagSize )
          && ( pTag == rhs.pTag );
    }

    bool operator!=( DebugMarkerObjectTagInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDebugMarkerObjectTagInfoEXT;
    const void* pNext = nullptr;
    DebugReportObjectTypeEXT objectType = DebugReportObjectTypeEXT::eUnknown;
    uint64_t object = 0;
    uint64_t tagName = 0;
    size_t tagSize = 0;
    const void* pTag = nullptr;
  };
  static_assert( sizeof( DebugMarkerObjectTagInfoEXT ) == sizeof( VkDebugMarkerObjectTagInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DebugMarkerObjectTagInfoEXT, pNext ) == offsetof( VkDebugMarkerObjectTagInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerObjectTagInfoEXT, objectType ) == offsetof( VkDebugMarkerObjectTagInfoEXT, objectType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerObjectTagInfoEXT, object ) == offsetof( VkDebugMarkerObjectTagInfoEXT, object ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerObjectTagInfoEXT, tagName ) == offsetof( VkDebugMarkerObjectTagInfoEXT, tagName ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerObjectTagInfoEXT, tagSize ) == offsetof( VkDebugMarkerObjectTagInfoEXT, tagSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugMarkerObjectTagInfoEXT, pTag ) == offsetof( VkDebugMarkerObjectTagInfoEXT, pTag ), "struct member and wrapper member have different offset!" );

  enum class RasterizationOrderAMD
  {
    eStrict = VK_RASTERIZATION_ORDER_STRICT_AMD,
    eRelaxed = VK_RASTERIZATION_ORDER_RELAXED_AMD
  };

  struct PipelineRasterizationStateRasterizationOrderAMD
  {
    operator VkPipelineRasterizationStateRasterizationOrderAMD const&() const
    {
      return *reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(this);
    }

    operator VkPipelineRasterizationStateRasterizationOrderAMD &()
    {
      return *reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(this);
    }

    bool operator==( PipelineRasterizationStateRasterizationOrderAMD const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( rasterizationOrder == rhs.rasterizationOrder );
    }

    bool operator!=( PipelineRasterizationStateRasterizationOrderAMD const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineRasterizationStateRasterizationOrderAMD;
    const void* pNext = nullptr;
    RasterizationOrderAMD rasterizationOrder = RasterizationOrderAMD::eStrict;
  };
  static_assert( sizeof( PipelineRasterizationStateRasterizationOrderAMD ) == sizeof( VkPipelineRasterizationStateRasterizationOrderAMD ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineRasterizationStateRasterizationOrderAMD, pNext ) == offsetof( VkPipelineRasterizationStateRasterizationOrderAMD, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationStateRasterizationOrderAMD, rasterizationOrder ) == offsetof( VkPipelineRasterizationStateRasterizationOrderAMD, rasterizationOrder ), "struct member and wrapper member have different offset!" );

  enum class ExternalMemoryHandleTypeFlagBitsNV
  {
    eOpaqueWin32 = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV,
    eOpaqueWin32Kmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV,
    eD3D11Image = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV,
    eD3D11ImageKmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV
  };

  using ExternalMemoryHandleTypeFlagsNV = Flags<ExternalMemoryHandleTypeFlagBitsNV, VkExternalMemoryHandleTypeFlagsNV>;

  VULKAN_HPP_INLINE ExternalMemoryHandleTypeFlagsNV operator|( ExternalMemoryHandleTypeFlagBitsNV bit0, ExternalMemoryHandleTypeFlagBitsNV bit1 )
  {
    return ExternalMemoryHandleTypeFlagsNV( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ExternalMemoryHandleTypeFlagsNV operator~( ExternalMemoryHandleTypeFlagBitsNV bits )
  {
    return ~( ExternalMemoryHandleTypeFlagsNV( bits ) );
  }

  template <> struct FlagTraits<ExternalMemoryHandleTypeFlagBitsNV>
  {
    enum
    {
      allFlags = VkFlags(ExternalMemoryHandleTypeFlagBitsNV::eOpaqueWin32) | VkFlags(ExternalMemoryHandleTypeFlagBitsNV::eOpaqueWin32Kmt) | VkFlags(ExternalMemoryHandleTypeFlagBitsNV::eD3D11Image) | VkFlags(ExternalMemoryHandleTypeFlagBitsNV::eD3D11ImageKmt)
    };
  };

  struct ExternalMemoryImageCreateInfoNV
  {
    operator VkExternalMemoryImageCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(this);
    }

    operator VkExternalMemoryImageCreateInfoNV &()
    {
      return *reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(this);
    }

    bool operator==( ExternalMemoryImageCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExternalMemoryImageCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExternalMemoryImageCreateInfoNV;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagsNV handleTypes = ExternalMemoryHandleTypeFlagsNV();
  };
  static_assert( sizeof( ExternalMemoryImageCreateInfoNV ) == sizeof( VkExternalMemoryImageCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalMemoryImageCreateInfoNV, pNext ) == offsetof( VkExternalMemoryImageCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalMemoryImageCreateInfoNV, handleTypes ) == offsetof( VkExternalMemoryImageCreateInfoNV, handleTypes ), "struct member and wrapper member have different offset!" );

  struct ExportMemoryAllocateInfoNV
  {
    operator VkExportMemoryAllocateInfoNV const&() const
    {
      return *reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(this);
    }

    operator VkExportMemoryAllocateInfoNV &()
    {
      return *reinterpret_cast<VkExportMemoryAllocateInfoNV*>(this);
    }

    bool operator==( ExportMemoryAllocateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExportMemoryAllocateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExportMemoryAllocateInfoNV;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagsNV handleTypes = ExternalMemoryHandleTypeFlagsNV();
  };
  static_assert( sizeof( ExportMemoryAllocateInfoNV ) == sizeof( VkExportMemoryAllocateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExportMemoryAllocateInfoNV, pNext ) == offsetof( VkExportMemoryAllocateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportMemoryAllocateInfoNV, handleTypes ) == offsetof( VkExportMemoryAllocateInfoNV, handleTypes ), "struct member and wrapper member have different offset!" );

#ifdef VK_USE_PLATFORM_WIN32_NV
  struct ImportMemoryWin32HandleInfoNV
  {
    operator VkImportMemoryWin32HandleInfoNV const&() const
    {
      return *reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(this);
    }

    operator VkImportMemoryWin32HandleInfoNV &()
    {
      return *reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(this);
    }

    bool operator==( ImportMemoryWin32HandleInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleType == rhs.handleType )
          && ( handle == rhs.handle );
    }

    bool operator!=( ImportMemoryWin32HandleInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImportMemoryWin32HandleInfoNV;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagsNV handleType = ExternalMemoryHandleTypeFlagsNV();
    HANDLE handle = 0;
  };
  static_assert( sizeof( ImportMemoryWin32HandleInfoNV ) == sizeof( VkImportMemoryWin32HandleInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImportMemoryWin32HandleInfoNV, pNext ) == offsetof( VkImportMemoryWin32HandleInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportMemoryWin32HandleInfoNV, handleType ) == offsetof( VkImportMemoryWin32HandleInfoNV, handleType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportMemoryWin32HandleInfoNV, handle ) == offsetof( VkImportMemoryWin32HandleInfoNV, handle ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_NV*/

  enum class ExternalMemoryFeatureFlagBitsNV
  {
    eDedicatedOnly = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV,
    eExportable = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV,
    eImportable = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV
  };

  using ExternalMemoryFeatureFlagsNV = Flags<ExternalMemoryFeatureFlagBitsNV, VkExternalMemoryFeatureFlagsNV>;

  VULKAN_HPP_INLINE ExternalMemoryFeatureFlagsNV operator|( ExternalMemoryFeatureFlagBitsNV bit0, ExternalMemoryFeatureFlagBitsNV bit1 )
  {
    return ExternalMemoryFeatureFlagsNV( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ExternalMemoryFeatureFlagsNV operator~( ExternalMemoryFeatureFlagBitsNV bits )
  {
    return ~( ExternalMemoryFeatureFlagsNV( bits ) );
  }

  template <> struct FlagTraits<ExternalMemoryFeatureFlagBitsNV>
  {
    enum
    {
      allFlags = VkFlags(ExternalMemoryFeatureFlagBitsNV::eDedicatedOnly) | VkFlags(ExternalMemoryFeatureFlagBitsNV::eExportable) | VkFlags(ExternalMemoryFeatureFlagBitsNV::eImportable)
    };
  };

  struct ExternalImageFormatPropertiesNV
  {
    operator VkExternalImageFormatPropertiesNV const&() const
    {
      return *reinterpret_cast<const VkExternalImageFormatPropertiesNV*>(this);
    }

    operator VkExternalImageFormatPropertiesNV &()
    {
      return *reinterpret_cast<VkExternalImageFormatPropertiesNV*>(this);
    }

    bool operator==( ExternalImageFormatPropertiesNV const& rhs ) const
    {
      return ( imageFormatProperties == rhs.imageFormatProperties )
          && ( externalMemoryFeatures == rhs.externalMemoryFeatures )
          && ( exportFromImportedHandleTypes == rhs.exportFromImportedHandleTypes )
          && ( compatibleHandleTypes == rhs.compatibleHandleTypes );
    }

    bool operator!=( ExternalImageFormatPropertiesNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    ImageFormatProperties imageFormatProperties = ImageFormatProperties();
    ExternalMemoryFeatureFlagsNV externalMemoryFeatures = ExternalMemoryFeatureFlagsNV();
    ExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes = ExternalMemoryHandleTypeFlagsNV();
    ExternalMemoryHandleTypeFlagsNV compatibleHandleTypes = ExternalMemoryHandleTypeFlagsNV();
  };
  static_assert( sizeof( ExternalImageFormatPropertiesNV ) == sizeof( VkExternalImageFormatPropertiesNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalImageFormatPropertiesNV, imageFormatProperties ) == offsetof( VkExternalImageFormatPropertiesNV, imageFormatProperties ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalImageFormatPropertiesNV, externalMemoryFeatures ) == offsetof( VkExternalImageFormatPropertiesNV, externalMemoryFeatures ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalImageFormatPropertiesNV, exportFromImportedHandleTypes ) == offsetof( VkExternalImageFormatPropertiesNV, exportFromImportedHandleTypes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalImageFormatPropertiesNV, compatibleHandleTypes ) == offsetof( VkExternalImageFormatPropertiesNV, compatibleHandleTypes ), "struct member and wrapper member have different offset!" );

  enum class ValidationCheckEXT
  {
    eAll = VK_VALIDATION_CHECK_ALL_EXT,
    eShaders = VK_VALIDATION_CHECK_SHADERS_EXT
  };

  struct ValidationFlagsEXT
  {
    operator VkValidationFlagsEXT const&() const
    {
      return *reinterpret_cast<const VkValidationFlagsEXT*>(this);
    }

    operator VkValidationFlagsEXT &()
    {
      return *reinterpret_cast<VkValidationFlagsEXT*>(this);
    }

    bool operator==( ValidationFlagsEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( disabledValidationCheckCount == rhs.disabledValidationCheckCount )
          && ( pDisabledValidationChecks == rhs.pDisabledValidationChecks );
    }

    bool operator!=( ValidationFlagsEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eValidationFlagsEXT;
    const void* pNext = nullptr;
    uint32_t disabledValidationCheckCount = 0;
    const ValidationCheckEXT* pDisabledValidationChecks = nullptr;
  };
  static_assert( sizeof( ValidationFlagsEXT ) == sizeof( VkValidationFlagsEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( ValidationFlagsEXT, pNext ) == offsetof( VkValidationFlagsEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ValidationFlagsEXT, disabledValidationCheckCount ) == offsetof( VkValidationFlagsEXT, disabledValidationCheckCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ValidationFlagsEXT, pDisabledValidationChecks ) == offsetof( VkValidationFlagsEXT, pDisabledValidationChecks ), "struct member and wrapper member have different offset!" );

  enum class SubgroupFeatureFlagBits
  {
    eBasic = VK_SUBGROUP_FEATURE_BASIC_BIT,
    eVote = VK_SUBGROUP_FEATURE_VOTE_BIT,
    eArithmetic = VK_SUBGROUP_FEATURE_ARITHMETIC_BIT,
    eBallot = VK_SUBGROUP_FEATURE_BALLOT_BIT,
    eShuffle = VK_SUBGROUP_FEATURE_SHUFFLE_BIT,
    eShuffleRelative = VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
    eClustered = VK_SUBGROUP_FEATURE_CLUSTERED_BIT,
    eQuad = VK_SUBGROUP_FEATURE_QUAD_BIT,
    ePartitionedNV = VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV
  };

  using SubgroupFeatureFlags = Flags<SubgroupFeatureFlagBits, VkSubgroupFeatureFlags>;

  VULKAN_HPP_INLINE SubgroupFeatureFlags operator|( SubgroupFeatureFlagBits bit0, SubgroupFeatureFlagBits bit1 )
  {
    return SubgroupFeatureFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE SubgroupFeatureFlags operator~( SubgroupFeatureFlagBits bits )
  {
    return ~( SubgroupFeatureFlags( bits ) );
  }

  template <> struct FlagTraits<SubgroupFeatureFlagBits>
  {
    enum
    {
      allFlags = VkFlags(SubgroupFeatureFlagBits::eBasic) | VkFlags(SubgroupFeatureFlagBits::eVote) | VkFlags(SubgroupFeatureFlagBits::eArithmetic) | VkFlags(SubgroupFeatureFlagBits::eBallot) | VkFlags(SubgroupFeatureFlagBits::eShuffle) | VkFlags(SubgroupFeatureFlagBits::eShuffleRelative) | VkFlags(SubgroupFeatureFlagBits::eClustered) | VkFlags(SubgroupFeatureFlagBits::eQuad) | VkFlags(SubgroupFeatureFlagBits::ePartitionedNV)
    };
  };

  struct PhysicalDeviceSubgroupProperties
  {
    operator VkPhysicalDeviceSubgroupProperties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(this);
    }

    operator VkPhysicalDeviceSubgroupProperties &()
    {
      return *reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(this);
    }

    bool operator==( PhysicalDeviceSubgroupProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( subgroupSize == rhs.subgroupSize )
          && ( supportedStages == rhs.supportedStages )
          && ( supportedOperations == rhs.supportedOperations )
          && ( quadOperationsInAllStages == rhs.quadOperationsInAllStages );
    }

    bool operator!=( PhysicalDeviceSubgroupProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceSubgroupProperties;
    void* pNext = nullptr;
    uint32_t subgroupSize = 0;
    ShaderStageFlags supportedStages = ShaderStageFlags();
    SubgroupFeatureFlags supportedOperations = SubgroupFeatureFlags();
    Bool32 quadOperationsInAllStages = 0;
  };
  static_assert( sizeof( PhysicalDeviceSubgroupProperties ) == sizeof( VkPhysicalDeviceSubgroupProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceSubgroupProperties, pNext ) == offsetof( VkPhysicalDeviceSubgroupProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSubgroupProperties, subgroupSize ) == offsetof( VkPhysicalDeviceSubgroupProperties, subgroupSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSubgroupProperties, supportedStages ) == offsetof( VkPhysicalDeviceSubgroupProperties, supportedStages ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSubgroupProperties, supportedOperations ) == offsetof( VkPhysicalDeviceSubgroupProperties, supportedOperations ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceSubgroupProperties, quadOperationsInAllStages ) == offsetof( VkPhysicalDeviceSubgroupProperties, quadOperationsInAllStages ), "struct member and wrapper member have different offset!" );

  enum class IndirectCommandsLayoutUsageFlagBitsNVX
  {
    eUnorderedSequences = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX,
    eSparseSequences = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX,
    eEmptyExecutions = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX,
    eIndexedSequences = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX
  };

  using IndirectCommandsLayoutUsageFlagsNVX = Flags<IndirectCommandsLayoutUsageFlagBitsNVX, VkIndirectCommandsLayoutUsageFlagsNVX>;

  VULKAN_HPP_INLINE IndirectCommandsLayoutUsageFlagsNVX operator|( IndirectCommandsLayoutUsageFlagBitsNVX bit0, IndirectCommandsLayoutUsageFlagBitsNVX bit1 )
  {
    return IndirectCommandsLayoutUsageFlagsNVX( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE IndirectCommandsLayoutUsageFlagsNVX operator~( IndirectCommandsLayoutUsageFlagBitsNVX bits )
  {
    return ~( IndirectCommandsLayoutUsageFlagsNVX( bits ) );
  }

  template <> struct FlagTraits<IndirectCommandsLayoutUsageFlagBitsNVX>
  {
    enum
    {
      allFlags = VkFlags(IndirectCommandsLayoutUsageFlagBitsNVX::eUnorderedSequences) | VkFlags(IndirectCommandsLayoutUsageFlagBitsNVX::eSparseSequences) | VkFlags(IndirectCommandsLayoutUsageFlagBitsNVX::eEmptyExecutions) | VkFlags(IndirectCommandsLayoutUsageFlagBitsNVX::eIndexedSequences)
    };
  };

  enum class ObjectEntryUsageFlagBitsNVX
  {
    eGraphics = VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX,
    eCompute = VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX
  };

  using ObjectEntryUsageFlagsNVX = Flags<ObjectEntryUsageFlagBitsNVX, VkObjectEntryUsageFlagsNVX>;

  VULKAN_HPP_INLINE ObjectEntryUsageFlagsNVX operator|( ObjectEntryUsageFlagBitsNVX bit0, ObjectEntryUsageFlagBitsNVX bit1 )
  {
    return ObjectEntryUsageFlagsNVX( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ObjectEntryUsageFlagsNVX operator~( ObjectEntryUsageFlagBitsNVX bits )
  {
    return ~( ObjectEntryUsageFlagsNVX( bits ) );
  }

  template <> struct FlagTraits<ObjectEntryUsageFlagBitsNVX>
  {
    enum
    {
      allFlags = VkFlags(ObjectEntryUsageFlagBitsNVX::eGraphics) | VkFlags(ObjectEntryUsageFlagBitsNVX::eCompute)
    };
  };

  enum class IndirectCommandsTokenTypeNVX
  {
    ePipeline = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX,
    eDescriptorSet = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX,
    eIndexBuffer = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX,
    eVertexBuffer = VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX,
    ePushConstant = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX,
    eDrawIndexed = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX,
    eDraw = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX,
    eDispatch = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX
  };

  struct IndirectCommandsTokenNVX
  {
    operator VkIndirectCommandsTokenNVX const&() const
    {
      return *reinterpret_cast<const VkIndirectCommandsTokenNVX*>(this);
    }

    operator VkIndirectCommandsTokenNVX &()
    {
      return *reinterpret_cast<VkIndirectCommandsTokenNVX*>(this);
    }

    bool operator==( IndirectCommandsTokenNVX const& rhs ) const
    {
      return ( tokenType == rhs.tokenType )
          && ( buffer == rhs.buffer )
          && ( offset == rhs.offset );
    }

    bool operator!=( IndirectCommandsTokenNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    IndirectCommandsTokenTypeNVX tokenType = IndirectCommandsTokenTypeNVX::ePipeline;
    Buffer buffer = Buffer();
    DeviceSize offset = 0;
  };
  static_assert( sizeof( IndirectCommandsTokenNVX ) == sizeof( VkIndirectCommandsTokenNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( IndirectCommandsTokenNVX, tokenType ) == offsetof( VkIndirectCommandsTokenNVX, tokenType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IndirectCommandsTokenNVX, buffer ) == offsetof( VkIndirectCommandsTokenNVX, buffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IndirectCommandsTokenNVX, offset ) == offsetof( VkIndirectCommandsTokenNVX, offset ), "struct member and wrapper member have different offset!" );

  struct IndirectCommandsLayoutTokenNVX
  {
    operator VkIndirectCommandsLayoutTokenNVX const&() const
    {
      return *reinterpret_cast<const VkIndirectCommandsLayoutTokenNVX*>(this);
    }

    operator VkIndirectCommandsLayoutTokenNVX &()
    {
      return *reinterpret_cast<VkIndirectCommandsLayoutTokenNVX*>(this);
    }

    bool operator==( IndirectCommandsLayoutTokenNVX const& rhs ) const
    {
      return ( tokenType == rhs.tokenType )
          && ( bindingUnit == rhs.bindingUnit )
          && ( dynamicCount == rhs.dynamicCount )
          && ( divisor == rhs.divisor );
    }

    bool operator!=( IndirectCommandsLayoutTokenNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    IndirectCommandsTokenTypeNVX tokenType = IndirectCommandsTokenTypeNVX::ePipeline;
    uint32_t bindingUnit = 0;
    uint32_t dynamicCount = 0;
    uint32_t divisor = 0;
  };
  static_assert( sizeof( IndirectCommandsLayoutTokenNVX ) == sizeof( VkIndirectCommandsLayoutTokenNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( IndirectCommandsLayoutTokenNVX, tokenType ) == offsetof( VkIndirectCommandsLayoutTokenNVX, tokenType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IndirectCommandsLayoutTokenNVX, bindingUnit ) == offsetof( VkIndirectCommandsLayoutTokenNVX, bindingUnit ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IndirectCommandsLayoutTokenNVX, dynamicCount ) == offsetof( VkIndirectCommandsLayoutTokenNVX, dynamicCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IndirectCommandsLayoutTokenNVX, divisor ) == offsetof( VkIndirectCommandsLayoutTokenNVX, divisor ), "struct member and wrapper member have different offset!" );

  struct IndirectCommandsLayoutCreateInfoNVX
  {
    operator VkIndirectCommandsLayoutCreateInfoNVX const&() const
    {
      return *reinterpret_cast<const VkIndirectCommandsLayoutCreateInfoNVX*>(this);
    }

    operator VkIndirectCommandsLayoutCreateInfoNVX &()
    {
      return *reinterpret_cast<VkIndirectCommandsLayoutCreateInfoNVX*>(this);
    }

    bool operator==( IndirectCommandsLayoutCreateInfoNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( pipelineBindPoint == rhs.pipelineBindPoint )
          && ( flags == rhs.flags )
          && ( tokenCount == rhs.tokenCount )
          && ( pTokens == rhs.pTokens );
    }

    bool operator!=( IndirectCommandsLayoutCreateInfoNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eIndirectCommandsLayoutCreateInfoNVX;
    const void* pNext = nullptr;
    PipelineBindPoint pipelineBindPoint = PipelineBindPoint::eGraphics;
    IndirectCommandsLayoutUsageFlagsNVX flags = IndirectCommandsLayoutUsageFlagsNVX();
    uint32_t tokenCount = 0;
    const IndirectCommandsLayoutTokenNVX* pTokens = nullptr;
  };
  static_assert( sizeof( IndirectCommandsLayoutCreateInfoNVX ) == sizeof( VkIndirectCommandsLayoutCreateInfoNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( IndirectCommandsLayoutCreateInfoNVX, pNext ) == offsetof( VkIndirectCommandsLayoutCreateInfoNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IndirectCommandsLayoutCreateInfoNVX, pipelineBindPoint ) == offsetof( VkIndirectCommandsLayoutCreateInfoNVX, pipelineBindPoint ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IndirectCommandsLayoutCreateInfoNVX, flags ) == offsetof( VkIndirectCommandsLayoutCreateInfoNVX, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IndirectCommandsLayoutCreateInfoNVX, tokenCount ) == offsetof( VkIndirectCommandsLayoutCreateInfoNVX, tokenCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( IndirectCommandsLayoutCreateInfoNVX, pTokens ) == offsetof( VkIndirectCommandsLayoutCreateInfoNVX, pTokens ), "struct member and wrapper member have different offset!" );

  enum class ObjectEntryTypeNVX
  {
    eDescriptorSet = VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX,
    ePipeline = VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX,
    eIndexBuffer = VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX,
    eVertexBuffer = VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX,
    ePushConstant = VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX
  };

  struct ObjectTableCreateInfoNVX
  {
    operator VkObjectTableCreateInfoNVX const&() const
    {
      return *reinterpret_cast<const VkObjectTableCreateInfoNVX*>(this);
    }

    operator VkObjectTableCreateInfoNVX &()
    {
      return *reinterpret_cast<VkObjectTableCreateInfoNVX*>(this);
    }

    bool operator==( ObjectTableCreateInfoNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( objectCount == rhs.objectCount )
          && ( pObjectEntryTypes == rhs.pObjectEntryTypes )
          && ( pObjectEntryCounts == rhs.pObjectEntryCounts )
          && ( pObjectEntryUsageFlags == rhs.pObjectEntryUsageFlags )
          && ( maxUniformBuffersPerDescriptor == rhs.maxUniformBuffersPerDescriptor )
          && ( maxStorageBuffersPerDescriptor == rhs.maxStorageBuffersPerDescriptor )
          && ( maxStorageImagesPerDescriptor == rhs.maxStorageImagesPerDescriptor )
          && ( maxSampledImagesPerDescriptor == rhs.maxSampledImagesPerDescriptor )
          && ( maxPipelineLayouts == rhs.maxPipelineLayouts );
    }

    bool operator!=( ObjectTableCreateInfoNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eObjectTableCreateInfoNVX;
    const void* pNext = nullptr;
    uint32_t objectCount = 0;
    const ObjectEntryTypeNVX* pObjectEntryTypes = nullptr;
    const uint32_t* pObjectEntryCounts = nullptr;
    const ObjectEntryUsageFlagsNVX* pObjectEntryUsageFlags = nullptr;
    uint32_t maxUniformBuffersPerDescriptor = 0;
    uint32_t maxStorageBuffersPerDescriptor = 0;
    uint32_t maxStorageImagesPerDescriptor = 0;
    uint32_t maxSampledImagesPerDescriptor = 0;
    uint32_t maxPipelineLayouts = 0;
  };
  static_assert( sizeof( ObjectTableCreateInfoNVX ) == sizeof( VkObjectTableCreateInfoNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, pNext ) == offsetof( VkObjectTableCreateInfoNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, objectCount ) == offsetof( VkObjectTableCreateInfoNVX, objectCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, pObjectEntryTypes ) == offsetof( VkObjectTableCreateInfoNVX, pObjectEntryTypes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, pObjectEntryCounts ) == offsetof( VkObjectTableCreateInfoNVX, pObjectEntryCounts ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, pObjectEntryUsageFlags ) == offsetof( VkObjectTableCreateInfoNVX, pObjectEntryUsageFlags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, maxUniformBuffersPerDescriptor ) == offsetof( VkObjectTableCreateInfoNVX, maxUniformBuffersPerDescriptor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, maxStorageBuffersPerDescriptor ) == offsetof( VkObjectTableCreateInfoNVX, maxStorageBuffersPerDescriptor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, maxStorageImagesPerDescriptor ) == offsetof( VkObjectTableCreateInfoNVX, maxStorageImagesPerDescriptor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, maxSampledImagesPerDescriptor ) == offsetof( VkObjectTableCreateInfoNVX, maxSampledImagesPerDescriptor ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableCreateInfoNVX, maxPipelineLayouts ) == offsetof( VkObjectTableCreateInfoNVX, maxPipelineLayouts ), "struct member and wrapper member have different offset!" );

  struct ObjectTableEntryNVX
  {
    operator VkObjectTableEntryNVX const&() const
    {
      return *reinterpret_cast<const VkObjectTableEntryNVX*>(this);
    }

    operator VkObjectTableEntryNVX &()
    {
      return *reinterpret_cast<VkObjectTableEntryNVX*>(this);
    }

    bool operator==( ObjectTableEntryNVX const& rhs ) const
    {
      return ( type == rhs.type )
          && ( flags == rhs.flags );
    }

    bool operator!=( ObjectTableEntryNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    ObjectEntryTypeNVX type = ObjectEntryTypeNVX::eDescriptorSet;
    ObjectEntryUsageFlagsNVX flags = ObjectEntryUsageFlagsNVX();
  };
  static_assert( sizeof( ObjectTableEntryNVX ) == sizeof( VkObjectTableEntryNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( ObjectTableEntryNVX, type ) == offsetof( VkObjectTableEntryNVX, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableEntryNVX, flags ) == offsetof( VkObjectTableEntryNVX, flags ), "struct member and wrapper member have different offset!" );

  struct ObjectTablePipelineEntryNVX
  {
    operator VkObjectTablePipelineEntryNVX const&() const
    {
      return *reinterpret_cast<const VkObjectTablePipelineEntryNVX*>(this);
    }

    operator VkObjectTablePipelineEntryNVX &()
    {
      return *reinterpret_cast<VkObjectTablePipelineEntryNVX*>(this);
    }

    bool operator==( ObjectTablePipelineEntryNVX const& rhs ) const
    {
      return ( type == rhs.type )
          && ( flags == rhs.flags )
          && ( pipeline == rhs.pipeline );
    }

    bool operator!=( ObjectTablePipelineEntryNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    ObjectEntryTypeNVX type = ObjectEntryTypeNVX::eDescriptorSet;
    ObjectEntryUsageFlagsNVX flags = ObjectEntryUsageFlagsNVX();
    Pipeline pipeline = Pipeline();
  };
  static_assert( sizeof( ObjectTablePipelineEntryNVX ) == sizeof( VkObjectTablePipelineEntryNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( ObjectTablePipelineEntryNVX, type ) == offsetof( VkObjectTablePipelineEntryNVX, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTablePipelineEntryNVX, flags ) == offsetof( VkObjectTablePipelineEntryNVX, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTablePipelineEntryNVX, pipeline ) == offsetof( VkObjectTablePipelineEntryNVX, pipeline ), "struct member and wrapper member have different offset!" );

  struct ObjectTableDescriptorSetEntryNVX
  {
    operator VkObjectTableDescriptorSetEntryNVX const&() const
    {
      return *reinterpret_cast<const VkObjectTableDescriptorSetEntryNVX*>(this);
    }

    operator VkObjectTableDescriptorSetEntryNVX &()
    {
      return *reinterpret_cast<VkObjectTableDescriptorSetEntryNVX*>(this);
    }

    bool operator==( ObjectTableDescriptorSetEntryNVX const& rhs ) const
    {
      return ( type == rhs.type )
          && ( flags == rhs.flags )
          && ( pipelineLayout == rhs.pipelineLayout )
          && ( descriptorSet == rhs.descriptorSet );
    }

    bool operator!=( ObjectTableDescriptorSetEntryNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    ObjectEntryTypeNVX type = ObjectEntryTypeNVX::eDescriptorSet;
    ObjectEntryUsageFlagsNVX flags = ObjectEntryUsageFlagsNVX();
    PipelineLayout pipelineLayout = PipelineLayout();
    DescriptorSet descriptorSet = DescriptorSet();
  };
  static_assert( sizeof( ObjectTableDescriptorSetEntryNVX ) == sizeof( VkObjectTableDescriptorSetEntryNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( ObjectTableDescriptorSetEntryNVX, type ) == offsetof( VkObjectTableDescriptorSetEntryNVX, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableDescriptorSetEntryNVX, flags ) == offsetof( VkObjectTableDescriptorSetEntryNVX, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableDescriptorSetEntryNVX, pipelineLayout ) == offsetof( VkObjectTableDescriptorSetEntryNVX, pipelineLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableDescriptorSetEntryNVX, descriptorSet ) == offsetof( VkObjectTableDescriptorSetEntryNVX, descriptorSet ), "struct member and wrapper member have different offset!" );

  struct ObjectTableVertexBufferEntryNVX
  {
    operator VkObjectTableVertexBufferEntryNVX const&() const
    {
      return *reinterpret_cast<const VkObjectTableVertexBufferEntryNVX*>(this);
    }

    operator VkObjectTableVertexBufferEntryNVX &()
    {
      return *reinterpret_cast<VkObjectTableVertexBufferEntryNVX*>(this);
    }

    bool operator==( ObjectTableVertexBufferEntryNVX const& rhs ) const
    {
      return ( type == rhs.type )
          && ( flags == rhs.flags )
          && ( buffer == rhs.buffer );
    }

    bool operator!=( ObjectTableVertexBufferEntryNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    ObjectEntryTypeNVX type = ObjectEntryTypeNVX::eDescriptorSet;
    ObjectEntryUsageFlagsNVX flags = ObjectEntryUsageFlagsNVX();
    Buffer buffer = Buffer();
  };
  static_assert( sizeof( ObjectTableVertexBufferEntryNVX ) == sizeof( VkObjectTableVertexBufferEntryNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( ObjectTableVertexBufferEntryNVX, type ) == offsetof( VkObjectTableVertexBufferEntryNVX, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableVertexBufferEntryNVX, flags ) == offsetof( VkObjectTableVertexBufferEntryNVX, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableVertexBufferEntryNVX, buffer ) == offsetof( VkObjectTableVertexBufferEntryNVX, buffer ), "struct member and wrapper member have different offset!" );

  struct ObjectTableIndexBufferEntryNVX
  {
    operator VkObjectTableIndexBufferEntryNVX const&() const
    {
      return *reinterpret_cast<const VkObjectTableIndexBufferEntryNVX*>(this);
    }

    operator VkObjectTableIndexBufferEntryNVX &()
    {
      return *reinterpret_cast<VkObjectTableIndexBufferEntryNVX*>(this);
    }

    bool operator==( ObjectTableIndexBufferEntryNVX const& rhs ) const
    {
      return ( type == rhs.type )
          && ( flags == rhs.flags )
          && ( buffer == rhs.buffer )
          && ( indexType == rhs.indexType );
    }

    bool operator!=( ObjectTableIndexBufferEntryNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    ObjectEntryTypeNVX type = ObjectEntryTypeNVX::eDescriptorSet;
    ObjectEntryUsageFlagsNVX flags = ObjectEntryUsageFlagsNVX();
    Buffer buffer = Buffer();
    IndexType indexType = IndexType::eUint16;
  };
  static_assert( sizeof( ObjectTableIndexBufferEntryNVX ) == sizeof( VkObjectTableIndexBufferEntryNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( ObjectTableIndexBufferEntryNVX, type ) == offsetof( VkObjectTableIndexBufferEntryNVX, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableIndexBufferEntryNVX, flags ) == offsetof( VkObjectTableIndexBufferEntryNVX, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableIndexBufferEntryNVX, buffer ) == offsetof( VkObjectTableIndexBufferEntryNVX, buffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTableIndexBufferEntryNVX, indexType ) == offsetof( VkObjectTableIndexBufferEntryNVX, indexType ), "struct member and wrapper member have different offset!" );

  struct ObjectTablePushConstantEntryNVX
  {
    operator VkObjectTablePushConstantEntryNVX const&() const
    {
      return *reinterpret_cast<const VkObjectTablePushConstantEntryNVX*>(this);
    }

    operator VkObjectTablePushConstantEntryNVX &()
    {
      return *reinterpret_cast<VkObjectTablePushConstantEntryNVX*>(this);
    }

    bool operator==( ObjectTablePushConstantEntryNVX const& rhs ) const
    {
      return ( type == rhs.type )
          && ( flags == rhs.flags )
          && ( pipelineLayout == rhs.pipelineLayout )
          && ( stageFlags == rhs.stageFlags );
    }

    bool operator!=( ObjectTablePushConstantEntryNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    ObjectEntryTypeNVX type = ObjectEntryTypeNVX::eDescriptorSet;
    ObjectEntryUsageFlagsNVX flags = ObjectEntryUsageFlagsNVX();
    PipelineLayout pipelineLayout = PipelineLayout();
    ShaderStageFlags stageFlags = ShaderStageFlags();
  };
  static_assert( sizeof( ObjectTablePushConstantEntryNVX ) == sizeof( VkObjectTablePushConstantEntryNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( ObjectTablePushConstantEntryNVX, type ) == offsetof( VkObjectTablePushConstantEntryNVX, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTablePushConstantEntryNVX, flags ) == offsetof( VkObjectTablePushConstantEntryNVX, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTablePushConstantEntryNVX, pipelineLayout ) == offsetof( VkObjectTablePushConstantEntryNVX, pipelineLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ObjectTablePushConstantEntryNVX, stageFlags ) == offsetof( VkObjectTablePushConstantEntryNVX, stageFlags ), "struct member and wrapper member have different offset!" );

  enum class DescriptorSetLayoutCreateFlagBits
  {
    ePushDescriptorKHR = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,
    eUpdateAfterBindPoolEXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT
  };

  using DescriptorSetLayoutCreateFlags = Flags<DescriptorSetLayoutCreateFlagBits, VkDescriptorSetLayoutCreateFlags>;

  VULKAN_HPP_INLINE DescriptorSetLayoutCreateFlags operator|( DescriptorSetLayoutCreateFlagBits bit0, DescriptorSetLayoutCreateFlagBits bit1 )
  {
    return DescriptorSetLayoutCreateFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DescriptorSetLayoutCreateFlags operator~( DescriptorSetLayoutCreateFlagBits bits )
  {
    return ~( DescriptorSetLayoutCreateFlags( bits ) );
  }

  template <> struct FlagTraits<DescriptorSetLayoutCreateFlagBits>
  {
    enum
    {
      allFlags = VkFlags(DescriptorSetLayoutCreateFlagBits::ePushDescriptorKHR) | VkFlags(DescriptorSetLayoutCreateFlagBits::eUpdateAfterBindPoolEXT)
    };
  };

  struct DescriptorSetLayoutCreateInfo
  {
    operator VkDescriptorSetLayoutCreateInfo const&() const
    {
      return *reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>(this);
    }

    operator VkDescriptorSetLayoutCreateInfo &()
    {
      return *reinterpret_cast<VkDescriptorSetLayoutCreateInfo*>(this);
    }

    bool operator==( DescriptorSetLayoutCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( bindingCount == rhs.bindingCount )
          && ( pBindings == rhs.pBindings );
    }

    bool operator!=( DescriptorSetLayoutCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorSetLayoutCreateInfo;
    const void* pNext = nullptr;
    DescriptorSetLayoutCreateFlags flags = DescriptorSetLayoutCreateFlags();
    uint32_t bindingCount = 0;
    const DescriptorSetLayoutBinding* pBindings = nullptr;
  };
  static_assert( sizeof( DescriptorSetLayoutCreateInfo ) == sizeof( VkDescriptorSetLayoutCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorSetLayoutCreateInfo, pNext ) == offsetof( VkDescriptorSetLayoutCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutCreateInfo, flags ) == offsetof( VkDescriptorSetLayoutCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutCreateInfo, bindingCount ) == offsetof( VkDescriptorSetLayoutCreateInfo, bindingCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutCreateInfo, pBindings ) == offsetof( VkDescriptorSetLayoutCreateInfo, pBindings ), "struct member and wrapper member have different offset!" );

  enum class ExternalMemoryHandleTypeFlagBits
  {
    eOpaqueFd = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    eOpaqueFdKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    eOpaqueWin32 = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    eOpaqueWin32KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    eOpaqueWin32Kmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    eOpaqueWin32KmtKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    eD3D11Texture = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    eD3D11TextureKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    eD3D11TextureKmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    eD3D11TextureKmtKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    eD3D12Heap = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    eD3D12HeapKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    eD3D12Resource = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    eD3D12ResourceKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    eDmaBufEXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
    eAndroidHardwareBufferANDROID = VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
    eHostAllocationEXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
    eHostMappedForeignMemoryEXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
  };

  using ExternalMemoryHandleTypeFlags = Flags<ExternalMemoryHandleTypeFlagBits, VkExternalMemoryHandleTypeFlags>;

  VULKAN_HPP_INLINE ExternalMemoryHandleTypeFlags operator|( ExternalMemoryHandleTypeFlagBits bit0, ExternalMemoryHandleTypeFlagBits bit1 )
  {
    return ExternalMemoryHandleTypeFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ExternalMemoryHandleTypeFlags operator~( ExternalMemoryHandleTypeFlagBits bits )
  {
    return ~( ExternalMemoryHandleTypeFlags( bits ) );
  }

  template <> struct FlagTraits<ExternalMemoryHandleTypeFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ExternalMemoryHandleTypeFlagBits::eOpaqueFd) | VkFlags(ExternalMemoryHandleTypeFlagBits::eOpaqueWin32) | VkFlags(ExternalMemoryHandleTypeFlagBits::eOpaqueWin32Kmt) | VkFlags(ExternalMemoryHandleTypeFlagBits::eD3D11Texture) | VkFlags(ExternalMemoryHandleTypeFlagBits::eD3D11TextureKmt) | VkFlags(ExternalMemoryHandleTypeFlagBits::eD3D12Heap) | VkFlags(ExternalMemoryHandleTypeFlagBits::eD3D12Resource) | VkFlags(ExternalMemoryHandleTypeFlagBits::eDmaBufEXT) | VkFlags(ExternalMemoryHandleTypeFlagBits::eAndroidHardwareBufferANDROID) | VkFlags(ExternalMemoryHandleTypeFlagBits::eHostAllocationEXT) | VkFlags(ExternalMemoryHandleTypeFlagBits::eHostMappedForeignMemoryEXT)
    };
  };

  using ExternalMemoryHandleTypeFlagsKHR = ExternalMemoryHandleTypeFlags;

  struct PhysicalDeviceExternalImageFormatInfo
  {
    operator VkPhysicalDeviceExternalImageFormatInfo const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(this);
    }

    operator VkPhysicalDeviceExternalImageFormatInfo &()
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(this);
    }

    bool operator==( PhysicalDeviceExternalImageFormatInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( PhysicalDeviceExternalImageFormatInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceExternalImageFormatInfo;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagBits handleType = ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( PhysicalDeviceExternalImageFormatInfo ) == sizeof( VkPhysicalDeviceExternalImageFormatInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceExternalImageFormatInfo, pNext ) == offsetof( VkPhysicalDeviceExternalImageFormatInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceExternalImageFormatInfo, handleType ) == offsetof( VkPhysicalDeviceExternalImageFormatInfo, handleType ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;

  struct PhysicalDeviceExternalBufferInfo
  {
    operator VkPhysicalDeviceExternalBufferInfo const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalBufferInfo*>(this);
    }

    operator VkPhysicalDeviceExternalBufferInfo &()
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalBufferInfo*>(this);
    }

    bool operator==( PhysicalDeviceExternalBufferInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( usage == rhs.usage )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( PhysicalDeviceExternalBufferInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceExternalBufferInfo;
    const void* pNext = nullptr;
    BufferCreateFlags flags = BufferCreateFlags();
    BufferUsageFlags usage = BufferUsageFlags();
    ExternalMemoryHandleTypeFlagBits handleType = ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( PhysicalDeviceExternalBufferInfo ) == sizeof( VkPhysicalDeviceExternalBufferInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceExternalBufferInfo, pNext ) == offsetof( VkPhysicalDeviceExternalBufferInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceExternalBufferInfo, flags ) == offsetof( VkPhysicalDeviceExternalBufferInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceExternalBufferInfo, usage ) == offsetof( VkPhysicalDeviceExternalBufferInfo, usage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceExternalBufferInfo, handleType ) == offsetof( VkPhysicalDeviceExternalBufferInfo, handleType ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;

  struct ExternalMemoryImageCreateInfo
  {
    operator VkExternalMemoryImageCreateInfo const&() const
    {
      return *reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(this);
    }

    operator VkExternalMemoryImageCreateInfo &()
    {
      return *reinterpret_cast<VkExternalMemoryImageCreateInfo*>(this);
    }

    bool operator==( ExternalMemoryImageCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExternalMemoryImageCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExternalMemoryImageCreateInfo;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlags handleTypes = ExternalMemoryHandleTypeFlags();
  };
  static_assert( sizeof( ExternalMemoryImageCreateInfo ) == sizeof( VkExternalMemoryImageCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalMemoryImageCreateInfo, pNext ) == offsetof( VkExternalMemoryImageCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalMemoryImageCreateInfo, handleTypes ) == offsetof( VkExternalMemoryImageCreateInfo, handleTypes ), "struct member and wrapper member have different offset!" );

  using ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;

  struct ExternalMemoryBufferCreateInfo
  {
    operator VkExternalMemoryBufferCreateInfo const&() const
    {
      return *reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(this);
    }

    operator VkExternalMemoryBufferCreateInfo &()
    {
      return *reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(this);
    }

    bool operator==( ExternalMemoryBufferCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExternalMemoryBufferCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExternalMemoryBufferCreateInfo;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlags handleTypes = ExternalMemoryHandleTypeFlags();
  };
  static_assert( sizeof( ExternalMemoryBufferCreateInfo ) == sizeof( VkExternalMemoryBufferCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalMemoryBufferCreateInfo, pNext ) == offsetof( VkExternalMemoryBufferCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalMemoryBufferCreateInfo, handleTypes ) == offsetof( VkExternalMemoryBufferCreateInfo, handleTypes ), "struct member and wrapper member have different offset!" );

  using ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;

  struct ExportMemoryAllocateInfo
  {
    operator VkExportMemoryAllocateInfo const&() const
    {
      return *reinterpret_cast<const VkExportMemoryAllocateInfo*>(this);
    }

    operator VkExportMemoryAllocateInfo &()
    {
      return *reinterpret_cast<VkExportMemoryAllocateInfo*>(this);
    }

    bool operator==( ExportMemoryAllocateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExportMemoryAllocateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExportMemoryAllocateInfo;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlags handleTypes = ExternalMemoryHandleTypeFlags();
  };
  static_assert( sizeof( ExportMemoryAllocateInfo ) == sizeof( VkExportMemoryAllocateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExportMemoryAllocateInfo, pNext ) == offsetof( VkExportMemoryAllocateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportMemoryAllocateInfo, handleTypes ) == offsetof( VkExportMemoryAllocateInfo, handleTypes ), "struct member and wrapper member have different offset!" );

  using ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct ImportMemoryWin32HandleInfoKHR
  {
    operator VkImportMemoryWin32HandleInfoKHR const&() const
    {
      return *reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(this);
    }

    operator VkImportMemoryWin32HandleInfoKHR &()
    {
      return *reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(this);
    }

    bool operator==( ImportMemoryWin32HandleInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleType == rhs.handleType )
          && ( handle == rhs.handle )
          && ( name == rhs.name );
    }

    bool operator!=( ImportMemoryWin32HandleInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImportMemoryWin32HandleInfoKHR;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagBits handleType = ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
    HANDLE handle = 0;
    LPCWSTR name = 0;
  };
  static_assert( sizeof( ImportMemoryWin32HandleInfoKHR ) == sizeof( VkImportMemoryWin32HandleInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImportMemoryWin32HandleInfoKHR, pNext ) == offsetof( VkImportMemoryWin32HandleInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportMemoryWin32HandleInfoKHR, handleType ) == offsetof( VkImportMemoryWin32HandleInfoKHR, handleType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportMemoryWin32HandleInfoKHR, handle ) == offsetof( VkImportMemoryWin32HandleInfoKHR, handle ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportMemoryWin32HandleInfoKHR, name ) == offsetof( VkImportMemoryWin32HandleInfoKHR, name ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct MemoryGetWin32HandleInfoKHR
  {
    operator VkMemoryGetWin32HandleInfoKHR const&() const
    {
      return *reinterpret_cast<const VkMemoryGetWin32HandleInfoKHR*>(this);
    }

    operator VkMemoryGetWin32HandleInfoKHR &()
    {
      return *reinterpret_cast<VkMemoryGetWin32HandleInfoKHR*>(this);
    }

    bool operator==( MemoryGetWin32HandleInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memory == rhs.memory )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( MemoryGetWin32HandleInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryGetWin32HandleInfoKHR;
    const void* pNext = nullptr;
    DeviceMemory memory = DeviceMemory();
    ExternalMemoryHandleTypeFlagBits handleType = ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( MemoryGetWin32HandleInfoKHR ) == sizeof( VkMemoryGetWin32HandleInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryGetWin32HandleInfoKHR, pNext ) == offsetof( VkMemoryGetWin32HandleInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryGetWin32HandleInfoKHR, memory ) == offsetof( VkMemoryGetWin32HandleInfoKHR, memory ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryGetWin32HandleInfoKHR, handleType ) == offsetof( VkMemoryGetWin32HandleInfoKHR, handleType ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct ImportMemoryFdInfoKHR
  {
    operator VkImportMemoryFdInfoKHR const&() const
    {
      return *reinterpret_cast<const VkImportMemoryFdInfoKHR*>(this);
    }

    operator VkImportMemoryFdInfoKHR &()
    {
      return *reinterpret_cast<VkImportMemoryFdInfoKHR*>(this);
    }

    bool operator==( ImportMemoryFdInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleType == rhs.handleType )
          && ( fd == rhs.fd );
    }

    bool operator!=( ImportMemoryFdInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImportMemoryFdInfoKHR;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagBits handleType = ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
    int fd = 0;
  };
  static_assert( sizeof( ImportMemoryFdInfoKHR ) == sizeof( VkImportMemoryFdInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImportMemoryFdInfoKHR, pNext ) == offsetof( VkImportMemoryFdInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportMemoryFdInfoKHR, handleType ) == offsetof( VkImportMemoryFdInfoKHR, handleType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportMemoryFdInfoKHR, fd ) == offsetof( VkImportMemoryFdInfoKHR, fd ), "struct member and wrapper member have different offset!" );

  struct MemoryGetFdInfoKHR
  {
    operator VkMemoryGetFdInfoKHR const&() const
    {
      return *reinterpret_cast<const VkMemoryGetFdInfoKHR*>(this);
    }

    operator VkMemoryGetFdInfoKHR &()
    {
      return *reinterpret_cast<VkMemoryGetFdInfoKHR*>(this);
    }

    bool operator==( MemoryGetFdInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( memory == rhs.memory )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( MemoryGetFdInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryGetFdInfoKHR;
    const void* pNext = nullptr;
    DeviceMemory memory = DeviceMemory();
    ExternalMemoryHandleTypeFlagBits handleType = ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( MemoryGetFdInfoKHR ) == sizeof( VkMemoryGetFdInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryGetFdInfoKHR, pNext ) == offsetof( VkMemoryGetFdInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryGetFdInfoKHR, memory ) == offsetof( VkMemoryGetFdInfoKHR, memory ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryGetFdInfoKHR, handleType ) == offsetof( VkMemoryGetFdInfoKHR, handleType ), "struct member and wrapper member have different offset!" );

  struct ImportMemoryHostPointerInfoEXT
  {
    operator VkImportMemoryHostPointerInfoEXT const&() const
    {
      return *reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(this);
    }

    operator VkImportMemoryHostPointerInfoEXT &()
    {
      return *reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(this);
    }

    bool operator==( ImportMemoryHostPointerInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleType == rhs.handleType )
          && ( pHostPointer == rhs.pHostPointer );
    }

    bool operator!=( ImportMemoryHostPointerInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImportMemoryHostPointerInfoEXT;
    const void* pNext = nullptr;
    ExternalMemoryHandleTypeFlagBits handleType = ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
    void* pHostPointer = nullptr;
  };
  static_assert( sizeof( ImportMemoryHostPointerInfoEXT ) == sizeof( VkImportMemoryHostPointerInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImportMemoryHostPointerInfoEXT, pNext ) == offsetof( VkImportMemoryHostPointerInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportMemoryHostPointerInfoEXT, handleType ) == offsetof( VkImportMemoryHostPointerInfoEXT, handleType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportMemoryHostPointerInfoEXT, pHostPointer ) == offsetof( VkImportMemoryHostPointerInfoEXT, pHostPointer ), "struct member and wrapper member have different offset!" );

  enum class ExternalMemoryFeatureFlagBits
  {
    eDedicatedOnly = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    eDedicatedOnlyKHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    eExportable = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    eExportableKHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    eImportable = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
    eImportableKHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT
  };

  using ExternalMemoryFeatureFlags = Flags<ExternalMemoryFeatureFlagBits, VkExternalMemoryFeatureFlags>;

  VULKAN_HPP_INLINE ExternalMemoryFeatureFlags operator|( ExternalMemoryFeatureFlagBits bit0, ExternalMemoryFeatureFlagBits bit1 )
  {
    return ExternalMemoryFeatureFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ExternalMemoryFeatureFlags operator~( ExternalMemoryFeatureFlagBits bits )
  {
    return ~( ExternalMemoryFeatureFlags( bits ) );
  }

  template <> struct FlagTraits<ExternalMemoryFeatureFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ExternalMemoryFeatureFlagBits::eDedicatedOnly) | VkFlags(ExternalMemoryFeatureFlagBits::eExportable) | VkFlags(ExternalMemoryFeatureFlagBits::eImportable)
    };
  };

  using ExternalMemoryFeatureFlagsKHR = ExternalMemoryFeatureFlags;

  struct ExternalMemoryProperties
  {
    operator VkExternalMemoryProperties const&() const
    {
      return *reinterpret_cast<const VkExternalMemoryProperties*>(this);
    }

    operator VkExternalMemoryProperties &()
    {
      return *reinterpret_cast<VkExternalMemoryProperties*>(this);
    }

    bool operator==( ExternalMemoryProperties const& rhs ) const
    {
      return ( externalMemoryFeatures == rhs.externalMemoryFeatures )
          && ( exportFromImportedHandleTypes == rhs.exportFromImportedHandleTypes )
          && ( compatibleHandleTypes == rhs.compatibleHandleTypes );
    }

    bool operator!=( ExternalMemoryProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    ExternalMemoryFeatureFlags externalMemoryFeatures = ExternalMemoryFeatureFlags();
    ExternalMemoryHandleTypeFlags exportFromImportedHandleTypes = ExternalMemoryHandleTypeFlags();
    ExternalMemoryHandleTypeFlags compatibleHandleTypes = ExternalMemoryHandleTypeFlags();
  };
  static_assert( sizeof( ExternalMemoryProperties ) == sizeof( VkExternalMemoryProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalMemoryProperties, externalMemoryFeatures ) == offsetof( VkExternalMemoryProperties, externalMemoryFeatures ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalMemoryProperties, exportFromImportedHandleTypes ) == offsetof( VkExternalMemoryProperties, exportFromImportedHandleTypes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalMemoryProperties, compatibleHandleTypes ) == offsetof( VkExternalMemoryProperties, compatibleHandleTypes ), "struct member and wrapper member have different offset!" );

  using ExternalMemoryPropertiesKHR = ExternalMemoryProperties;

  struct ExternalImageFormatProperties
  {
    operator VkExternalImageFormatProperties const&() const
    {
      return *reinterpret_cast<const VkExternalImageFormatProperties*>(this);
    }

    operator VkExternalImageFormatProperties &()
    {
      return *reinterpret_cast<VkExternalImageFormatProperties*>(this);
    }

    bool operator==( ExternalImageFormatProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( externalMemoryProperties == rhs.externalMemoryProperties );
    }

    bool operator!=( ExternalImageFormatProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExternalImageFormatProperties;
    void* pNext = nullptr;
    ExternalMemoryProperties externalMemoryProperties = ExternalMemoryProperties();
  };
  static_assert( sizeof( ExternalImageFormatProperties ) == sizeof( VkExternalImageFormatProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalImageFormatProperties, pNext ) == offsetof( VkExternalImageFormatProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalImageFormatProperties, externalMemoryProperties ) == offsetof( VkExternalImageFormatProperties, externalMemoryProperties ), "struct member and wrapper member have different offset!" );

  using ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;

  struct ExternalBufferProperties
  {
    operator VkExternalBufferProperties const&() const
    {
      return *reinterpret_cast<const VkExternalBufferProperties*>(this);
    }

    operator VkExternalBufferProperties &()
    {
      return *reinterpret_cast<VkExternalBufferProperties*>(this);
    }

    bool operator==( ExternalBufferProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( externalMemoryProperties == rhs.externalMemoryProperties );
    }

    bool operator!=( ExternalBufferProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExternalBufferProperties;
    void* pNext = nullptr;
    ExternalMemoryProperties externalMemoryProperties = ExternalMemoryProperties();
  };
  static_assert( sizeof( ExternalBufferProperties ) == sizeof( VkExternalBufferProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalBufferProperties, pNext ) == offsetof( VkExternalBufferProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalBufferProperties, externalMemoryProperties ) == offsetof( VkExternalBufferProperties, externalMemoryProperties ), "struct member and wrapper member have different offset!" );

  using ExternalBufferPropertiesKHR = ExternalBufferProperties;

  enum class ExternalSemaphoreHandleTypeFlagBits
  {
    eOpaqueFd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    eOpaqueFdKHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    eOpaqueWin32 = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    eOpaqueWin32KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    eOpaqueWin32Kmt = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    eOpaqueWin32KmtKHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    eD3D12Fence = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    eD3D12FenceKHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    eSyncFd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
    eSyncFdKHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
  };

  using ExternalSemaphoreHandleTypeFlags = Flags<ExternalSemaphoreHandleTypeFlagBits, VkExternalSemaphoreHandleTypeFlags>;

  VULKAN_HPP_INLINE ExternalSemaphoreHandleTypeFlags operator|( ExternalSemaphoreHandleTypeFlagBits bit0, ExternalSemaphoreHandleTypeFlagBits bit1 )
  {
    return ExternalSemaphoreHandleTypeFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ExternalSemaphoreHandleTypeFlags operator~( ExternalSemaphoreHandleTypeFlagBits bits )
  {
    return ~( ExternalSemaphoreHandleTypeFlags( bits ) );
  }

  template <> struct FlagTraits<ExternalSemaphoreHandleTypeFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd) | VkFlags(ExternalSemaphoreHandleTypeFlagBits::eOpaqueWin32) | VkFlags(ExternalSemaphoreHandleTypeFlagBits::eOpaqueWin32Kmt) | VkFlags(ExternalSemaphoreHandleTypeFlagBits::eD3D12Fence) | VkFlags(ExternalSemaphoreHandleTypeFlagBits::eSyncFd)
    };
  };

  using ExternalSemaphoreHandleTypeFlagsKHR = ExternalSemaphoreHandleTypeFlags;

  struct PhysicalDeviceExternalSemaphoreInfo
  {
    operator VkPhysicalDeviceExternalSemaphoreInfo const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalSemaphoreInfo*>(this);
    }

    operator VkPhysicalDeviceExternalSemaphoreInfo &()
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalSemaphoreInfo*>(this);
    }

    bool operator==( PhysicalDeviceExternalSemaphoreInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( PhysicalDeviceExternalSemaphoreInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceExternalSemaphoreInfo;
    const void* pNext = nullptr;
    ExternalSemaphoreHandleTypeFlagBits handleType = ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( PhysicalDeviceExternalSemaphoreInfo ) == sizeof( VkPhysicalDeviceExternalSemaphoreInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceExternalSemaphoreInfo, pNext ) == offsetof( VkPhysicalDeviceExternalSemaphoreInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceExternalSemaphoreInfo, handleType ) == offsetof( VkPhysicalDeviceExternalSemaphoreInfo, handleType ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;

  struct ExportSemaphoreCreateInfo
  {
    operator VkExportSemaphoreCreateInfo const&() const
    {
      return *reinterpret_cast<const VkExportSemaphoreCreateInfo*>(this);
    }

    operator VkExportSemaphoreCreateInfo &()
    {
      return *reinterpret_cast<VkExportSemaphoreCreateInfo*>(this);
    }

    bool operator==( ExportSemaphoreCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExportSemaphoreCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExportSemaphoreCreateInfo;
    const void* pNext = nullptr;
    ExternalSemaphoreHandleTypeFlags handleTypes = ExternalSemaphoreHandleTypeFlags();
  };
  static_assert( sizeof( ExportSemaphoreCreateInfo ) == sizeof( VkExportSemaphoreCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExportSemaphoreCreateInfo, pNext ) == offsetof( VkExportSemaphoreCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportSemaphoreCreateInfo, handleTypes ) == offsetof( VkExportSemaphoreCreateInfo, handleTypes ), "struct member and wrapper member have different offset!" );

  using ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct SemaphoreGetWin32HandleInfoKHR
  {
    operator VkSemaphoreGetWin32HandleInfoKHR const&() const
    {
      return *reinterpret_cast<const VkSemaphoreGetWin32HandleInfoKHR*>(this);
    }

    operator VkSemaphoreGetWin32HandleInfoKHR &()
    {
      return *reinterpret_cast<VkSemaphoreGetWin32HandleInfoKHR*>(this);
    }

    bool operator==( SemaphoreGetWin32HandleInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( semaphore == rhs.semaphore )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( SemaphoreGetWin32HandleInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSemaphoreGetWin32HandleInfoKHR;
    const void* pNext = nullptr;
    Semaphore semaphore = Semaphore();
    ExternalSemaphoreHandleTypeFlagBits handleType = ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( SemaphoreGetWin32HandleInfoKHR ) == sizeof( VkSemaphoreGetWin32HandleInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SemaphoreGetWin32HandleInfoKHR, pNext ) == offsetof( VkSemaphoreGetWin32HandleInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SemaphoreGetWin32HandleInfoKHR, semaphore ) == offsetof( VkSemaphoreGetWin32HandleInfoKHR, semaphore ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SemaphoreGetWin32HandleInfoKHR, handleType ) == offsetof( VkSemaphoreGetWin32HandleInfoKHR, handleType ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct SemaphoreGetFdInfoKHR
  {
    operator VkSemaphoreGetFdInfoKHR const&() const
    {
      return *reinterpret_cast<const VkSemaphoreGetFdInfoKHR*>(this);
    }

    operator VkSemaphoreGetFdInfoKHR &()
    {
      return *reinterpret_cast<VkSemaphoreGetFdInfoKHR*>(this);
    }

    bool operator==( SemaphoreGetFdInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( semaphore == rhs.semaphore )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( SemaphoreGetFdInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSemaphoreGetFdInfoKHR;
    const void* pNext = nullptr;
    Semaphore semaphore = Semaphore();
    ExternalSemaphoreHandleTypeFlagBits handleType = ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( SemaphoreGetFdInfoKHR ) == sizeof( VkSemaphoreGetFdInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SemaphoreGetFdInfoKHR, pNext ) == offsetof( VkSemaphoreGetFdInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SemaphoreGetFdInfoKHR, semaphore ) == offsetof( VkSemaphoreGetFdInfoKHR, semaphore ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SemaphoreGetFdInfoKHR, handleType ) == offsetof( VkSemaphoreGetFdInfoKHR, handleType ), "struct member and wrapper member have different offset!" );

  enum class ExternalSemaphoreFeatureFlagBits
  {
    eExportable = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    eExportableKHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    eImportable = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
    eImportableKHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
  };

  using ExternalSemaphoreFeatureFlags = Flags<ExternalSemaphoreFeatureFlagBits, VkExternalSemaphoreFeatureFlags>;

  VULKAN_HPP_INLINE ExternalSemaphoreFeatureFlags operator|( ExternalSemaphoreFeatureFlagBits bit0, ExternalSemaphoreFeatureFlagBits bit1 )
  {
    return ExternalSemaphoreFeatureFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ExternalSemaphoreFeatureFlags operator~( ExternalSemaphoreFeatureFlagBits bits )
  {
    return ~( ExternalSemaphoreFeatureFlags( bits ) );
  }

  template <> struct FlagTraits<ExternalSemaphoreFeatureFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ExternalSemaphoreFeatureFlagBits::eExportable) | VkFlags(ExternalSemaphoreFeatureFlagBits::eImportable)
    };
  };

  using ExternalSemaphoreFeatureFlagsKHR = ExternalSemaphoreFeatureFlags;

  struct ExternalSemaphoreProperties
  {
    operator VkExternalSemaphoreProperties const&() const
    {
      return *reinterpret_cast<const VkExternalSemaphoreProperties*>(this);
    }

    operator VkExternalSemaphoreProperties &()
    {
      return *reinterpret_cast<VkExternalSemaphoreProperties*>(this);
    }

    bool operator==( ExternalSemaphoreProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( exportFromImportedHandleTypes == rhs.exportFromImportedHandleTypes )
          && ( compatibleHandleTypes == rhs.compatibleHandleTypes )
          && ( externalSemaphoreFeatures == rhs.externalSemaphoreFeatures );
    }

    bool operator!=( ExternalSemaphoreProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExternalSemaphoreProperties;
    void* pNext = nullptr;
    ExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes = ExternalSemaphoreHandleTypeFlags();
    ExternalSemaphoreHandleTypeFlags compatibleHandleTypes = ExternalSemaphoreHandleTypeFlags();
    ExternalSemaphoreFeatureFlags externalSemaphoreFeatures = ExternalSemaphoreFeatureFlags();
  };
  static_assert( sizeof( ExternalSemaphoreProperties ) == sizeof( VkExternalSemaphoreProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalSemaphoreProperties, pNext ) == offsetof( VkExternalSemaphoreProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalSemaphoreProperties, exportFromImportedHandleTypes ) == offsetof( VkExternalSemaphoreProperties, exportFromImportedHandleTypes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalSemaphoreProperties, compatibleHandleTypes ) == offsetof( VkExternalSemaphoreProperties, compatibleHandleTypes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalSemaphoreProperties, externalSemaphoreFeatures ) == offsetof( VkExternalSemaphoreProperties, externalSemaphoreFeatures ), "struct member and wrapper member have different offset!" );

  using ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;

  enum class SemaphoreImportFlagBits
  {
    eTemporary = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
    eTemporaryKHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT
  };

  using SemaphoreImportFlags = Flags<SemaphoreImportFlagBits, VkSemaphoreImportFlags>;

  VULKAN_HPP_INLINE SemaphoreImportFlags operator|( SemaphoreImportFlagBits bit0, SemaphoreImportFlagBits bit1 )
  {
    return SemaphoreImportFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE SemaphoreImportFlags operator~( SemaphoreImportFlagBits bits )
  {
    return ~( SemaphoreImportFlags( bits ) );
  }

  template <> struct FlagTraits<SemaphoreImportFlagBits>
  {
    enum
    {
      allFlags = VkFlags(SemaphoreImportFlagBits::eTemporary)
    };
  };

  using SemaphoreImportFlagsKHR = SemaphoreImportFlags;

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct ImportSemaphoreWin32HandleInfoKHR
  {
    operator VkImportSemaphoreWin32HandleInfoKHR const&() const
    {
      return *reinterpret_cast<const VkImportSemaphoreWin32HandleInfoKHR*>(this);
    }

    operator VkImportSemaphoreWin32HandleInfoKHR &()
    {
      return *reinterpret_cast<VkImportSemaphoreWin32HandleInfoKHR*>(this);
    }

    bool operator==( ImportSemaphoreWin32HandleInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( semaphore == rhs.semaphore )
          && ( flags == rhs.flags )
          && ( handleType == rhs.handleType )
          && ( handle == rhs.handle )
          && ( name == rhs.name );
    }

    bool operator!=( ImportSemaphoreWin32HandleInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImportSemaphoreWin32HandleInfoKHR;
    const void* pNext = nullptr;
    Semaphore semaphore = Semaphore();
    SemaphoreImportFlags flags = SemaphoreImportFlags();
    ExternalSemaphoreHandleTypeFlagBits handleType = ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
    HANDLE handle = 0;
    LPCWSTR name = 0;
  };
  static_assert( sizeof( ImportSemaphoreWin32HandleInfoKHR ) == sizeof( VkImportSemaphoreWin32HandleInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImportSemaphoreWin32HandleInfoKHR, pNext ) == offsetof( VkImportSemaphoreWin32HandleInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportSemaphoreWin32HandleInfoKHR, semaphore ) == offsetof( VkImportSemaphoreWin32HandleInfoKHR, semaphore ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportSemaphoreWin32HandleInfoKHR, flags ) == offsetof( VkImportSemaphoreWin32HandleInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportSemaphoreWin32HandleInfoKHR, handleType ) == offsetof( VkImportSemaphoreWin32HandleInfoKHR, handleType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportSemaphoreWin32HandleInfoKHR, handle ) == offsetof( VkImportSemaphoreWin32HandleInfoKHR, handle ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportSemaphoreWin32HandleInfoKHR, name ) == offsetof( VkImportSemaphoreWin32HandleInfoKHR, name ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct ImportSemaphoreFdInfoKHR
  {
    operator VkImportSemaphoreFdInfoKHR const&() const
    {
      return *reinterpret_cast<const VkImportSemaphoreFdInfoKHR*>(this);
    }

    operator VkImportSemaphoreFdInfoKHR &()
    {
      return *reinterpret_cast<VkImportSemaphoreFdInfoKHR*>(this);
    }

    bool operator==( ImportSemaphoreFdInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( semaphore == rhs.semaphore )
          && ( flags == rhs.flags )
          && ( handleType == rhs.handleType )
          && ( fd == rhs.fd );
    }

    bool operator!=( ImportSemaphoreFdInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImportSemaphoreFdInfoKHR;
    const void* pNext = nullptr;
    Semaphore semaphore = Semaphore();
    SemaphoreImportFlags flags = SemaphoreImportFlags();
    ExternalSemaphoreHandleTypeFlagBits handleType = ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
    int fd = 0;
  };
  static_assert( sizeof( ImportSemaphoreFdInfoKHR ) == sizeof( VkImportSemaphoreFdInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImportSemaphoreFdInfoKHR, pNext ) == offsetof( VkImportSemaphoreFdInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportSemaphoreFdInfoKHR, semaphore ) == offsetof( VkImportSemaphoreFdInfoKHR, semaphore ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportSemaphoreFdInfoKHR, flags ) == offsetof( VkImportSemaphoreFdInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportSemaphoreFdInfoKHR, handleType ) == offsetof( VkImportSemaphoreFdInfoKHR, handleType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportSemaphoreFdInfoKHR, fd ) == offsetof( VkImportSemaphoreFdInfoKHR, fd ), "struct member and wrapper member have different offset!" );

  enum class ExternalFenceHandleTypeFlagBits
  {
    eOpaqueFd = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    eOpaqueFdKHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    eOpaqueWin32 = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    eOpaqueWin32KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    eOpaqueWin32Kmt = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    eOpaqueWin32KmtKHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    eSyncFd = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
    eSyncFdKHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
  };

  using ExternalFenceHandleTypeFlags = Flags<ExternalFenceHandleTypeFlagBits, VkExternalFenceHandleTypeFlags>;

  VULKAN_HPP_INLINE ExternalFenceHandleTypeFlags operator|( ExternalFenceHandleTypeFlagBits bit0, ExternalFenceHandleTypeFlagBits bit1 )
  {
    return ExternalFenceHandleTypeFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ExternalFenceHandleTypeFlags operator~( ExternalFenceHandleTypeFlagBits bits )
  {
    return ~( ExternalFenceHandleTypeFlags( bits ) );
  }

  template <> struct FlagTraits<ExternalFenceHandleTypeFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ExternalFenceHandleTypeFlagBits::eOpaqueFd) | VkFlags(ExternalFenceHandleTypeFlagBits::eOpaqueWin32) | VkFlags(ExternalFenceHandleTypeFlagBits::eOpaqueWin32Kmt) | VkFlags(ExternalFenceHandleTypeFlagBits::eSyncFd)
    };
  };

  using ExternalFenceHandleTypeFlagsKHR = ExternalFenceHandleTypeFlags;

  struct PhysicalDeviceExternalFenceInfo
  {
    operator VkPhysicalDeviceExternalFenceInfo const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalFenceInfo*>(this);
    }

    operator VkPhysicalDeviceExternalFenceInfo &()
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalFenceInfo*>(this);
    }

    bool operator==( PhysicalDeviceExternalFenceInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( PhysicalDeviceExternalFenceInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceExternalFenceInfo;
    const void* pNext = nullptr;
    ExternalFenceHandleTypeFlagBits handleType = ExternalFenceHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( PhysicalDeviceExternalFenceInfo ) == sizeof( VkPhysicalDeviceExternalFenceInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceExternalFenceInfo, pNext ) == offsetof( VkPhysicalDeviceExternalFenceInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceExternalFenceInfo, handleType ) == offsetof( VkPhysicalDeviceExternalFenceInfo, handleType ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;

  struct ExportFenceCreateInfo
  {
    operator VkExportFenceCreateInfo const&() const
    {
      return *reinterpret_cast<const VkExportFenceCreateInfo*>(this);
    }

    operator VkExportFenceCreateInfo &()
    {
      return *reinterpret_cast<VkExportFenceCreateInfo*>(this);
    }

    bool operator==( ExportFenceCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExportFenceCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExportFenceCreateInfo;
    const void* pNext = nullptr;
    ExternalFenceHandleTypeFlags handleTypes = ExternalFenceHandleTypeFlags();
  };
  static_assert( sizeof( ExportFenceCreateInfo ) == sizeof( VkExportFenceCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExportFenceCreateInfo, pNext ) == offsetof( VkExportFenceCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExportFenceCreateInfo, handleTypes ) == offsetof( VkExportFenceCreateInfo, handleTypes ), "struct member and wrapper member have different offset!" );

  using ExportFenceCreateInfoKHR = ExportFenceCreateInfo;

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct FenceGetWin32HandleInfoKHR
  {
    operator VkFenceGetWin32HandleInfoKHR const&() const
    {
      return *reinterpret_cast<const VkFenceGetWin32HandleInfoKHR*>(this);
    }

    operator VkFenceGetWin32HandleInfoKHR &()
    {
      return *reinterpret_cast<VkFenceGetWin32HandleInfoKHR*>(this);
    }

    bool operator==( FenceGetWin32HandleInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( fence == rhs.fence )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( FenceGetWin32HandleInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eFenceGetWin32HandleInfoKHR;
    const void* pNext = nullptr;
    Fence fence = Fence();
    ExternalFenceHandleTypeFlagBits handleType = ExternalFenceHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( FenceGetWin32HandleInfoKHR ) == sizeof( VkFenceGetWin32HandleInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( FenceGetWin32HandleInfoKHR, pNext ) == offsetof( VkFenceGetWin32HandleInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FenceGetWin32HandleInfoKHR, fence ) == offsetof( VkFenceGetWin32HandleInfoKHR, fence ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FenceGetWin32HandleInfoKHR, handleType ) == offsetof( VkFenceGetWin32HandleInfoKHR, handleType ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct FenceGetFdInfoKHR
  {
    operator VkFenceGetFdInfoKHR const&() const
    {
      return *reinterpret_cast<const VkFenceGetFdInfoKHR*>(this);
    }

    operator VkFenceGetFdInfoKHR &()
    {
      return *reinterpret_cast<VkFenceGetFdInfoKHR*>(this);
    }

    bool operator==( FenceGetFdInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( fence == rhs.fence )
          && ( handleType == rhs.handleType );
    }

    bool operator!=( FenceGetFdInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eFenceGetFdInfoKHR;
    const void* pNext = nullptr;
    Fence fence = Fence();
    ExternalFenceHandleTypeFlagBits handleType = ExternalFenceHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( FenceGetFdInfoKHR ) == sizeof( VkFenceGetFdInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( FenceGetFdInfoKHR, pNext ) == offsetof( VkFenceGetFdInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FenceGetFdInfoKHR, fence ) == offsetof( VkFenceGetFdInfoKHR, fence ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( FenceGetFdInfoKHR, handleType ) == offsetof( VkFenceGetFdInfoKHR, handleType ), "struct member and wrapper member have different offset!" );

  enum class ExternalFenceFeatureFlagBits
  {
    eExportable = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    eExportableKHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    eImportable = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
    eImportableKHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
  };

  using ExternalFenceFeatureFlags = Flags<ExternalFenceFeatureFlagBits, VkExternalFenceFeatureFlags>;

  VULKAN_HPP_INLINE ExternalFenceFeatureFlags operator|( ExternalFenceFeatureFlagBits bit0, ExternalFenceFeatureFlagBits bit1 )
  {
    return ExternalFenceFeatureFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ExternalFenceFeatureFlags operator~( ExternalFenceFeatureFlagBits bits )
  {
    return ~( ExternalFenceFeatureFlags( bits ) );
  }

  template <> struct FlagTraits<ExternalFenceFeatureFlagBits>
  {
    enum
    {
      allFlags = VkFlags(ExternalFenceFeatureFlagBits::eExportable) | VkFlags(ExternalFenceFeatureFlagBits::eImportable)
    };
  };

  using ExternalFenceFeatureFlagsKHR = ExternalFenceFeatureFlags;

  struct ExternalFenceProperties
  {
    operator VkExternalFenceProperties const&() const
    {
      return *reinterpret_cast<const VkExternalFenceProperties*>(this);
    }

    operator VkExternalFenceProperties &()
    {
      return *reinterpret_cast<VkExternalFenceProperties*>(this);
    }

    bool operator==( ExternalFenceProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( exportFromImportedHandleTypes == rhs.exportFromImportedHandleTypes )
          && ( compatibleHandleTypes == rhs.compatibleHandleTypes )
          && ( externalFenceFeatures == rhs.externalFenceFeatures );
    }

    bool operator!=( ExternalFenceProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eExternalFenceProperties;
    void* pNext = nullptr;
    ExternalFenceHandleTypeFlags exportFromImportedHandleTypes = ExternalFenceHandleTypeFlags();
    ExternalFenceHandleTypeFlags compatibleHandleTypes = ExternalFenceHandleTypeFlags();
    ExternalFenceFeatureFlags externalFenceFeatures = ExternalFenceFeatureFlags();
  };
  static_assert( sizeof( ExternalFenceProperties ) == sizeof( VkExternalFenceProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( ExternalFenceProperties, pNext ) == offsetof( VkExternalFenceProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalFenceProperties, exportFromImportedHandleTypes ) == offsetof( VkExternalFenceProperties, exportFromImportedHandleTypes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalFenceProperties, compatibleHandleTypes ) == offsetof( VkExternalFenceProperties, compatibleHandleTypes ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ExternalFenceProperties, externalFenceFeatures ) == offsetof( VkExternalFenceProperties, externalFenceFeatures ), "struct member and wrapper member have different offset!" );

  using ExternalFencePropertiesKHR = ExternalFenceProperties;

  enum class FenceImportFlagBits
  {
    eTemporary = VK_FENCE_IMPORT_TEMPORARY_BIT,
    eTemporaryKHR = VK_FENCE_IMPORT_TEMPORARY_BIT
  };

  using FenceImportFlags = Flags<FenceImportFlagBits, VkFenceImportFlags>;

  VULKAN_HPP_INLINE FenceImportFlags operator|( FenceImportFlagBits bit0, FenceImportFlagBits bit1 )
  {
    return FenceImportFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE FenceImportFlags operator~( FenceImportFlagBits bits )
  {
    return ~( FenceImportFlags( bits ) );
  }

  template <> struct FlagTraits<FenceImportFlagBits>
  {
    enum
    {
      allFlags = VkFlags(FenceImportFlagBits::eTemporary)
    };
  };

  using FenceImportFlagsKHR = FenceImportFlags;

#ifdef VK_USE_PLATFORM_WIN32_KHR
  struct ImportFenceWin32HandleInfoKHR
  {
    operator VkImportFenceWin32HandleInfoKHR const&() const
    {
      return *reinterpret_cast<const VkImportFenceWin32HandleInfoKHR*>(this);
    }

    operator VkImportFenceWin32HandleInfoKHR &()
    {
      return *reinterpret_cast<VkImportFenceWin32HandleInfoKHR*>(this);
    }

    bool operator==( ImportFenceWin32HandleInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( fence == rhs.fence )
          && ( flags == rhs.flags )
          && ( handleType == rhs.handleType )
          && ( handle == rhs.handle )
          && ( name == rhs.name );
    }

    bool operator!=( ImportFenceWin32HandleInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImportFenceWin32HandleInfoKHR;
    const void* pNext = nullptr;
    Fence fence = Fence();
    FenceImportFlags flags = FenceImportFlags();
    ExternalFenceHandleTypeFlagBits handleType = ExternalFenceHandleTypeFlagBits::eOpaqueFd;
    HANDLE handle = 0;
    LPCWSTR name = 0;
  };
  static_assert( sizeof( ImportFenceWin32HandleInfoKHR ) == sizeof( VkImportFenceWin32HandleInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImportFenceWin32HandleInfoKHR, pNext ) == offsetof( VkImportFenceWin32HandleInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportFenceWin32HandleInfoKHR, fence ) == offsetof( VkImportFenceWin32HandleInfoKHR, fence ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportFenceWin32HandleInfoKHR, flags ) == offsetof( VkImportFenceWin32HandleInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportFenceWin32HandleInfoKHR, handleType ) == offsetof( VkImportFenceWin32HandleInfoKHR, handleType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportFenceWin32HandleInfoKHR, handle ) == offsetof( VkImportFenceWin32HandleInfoKHR, handle ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportFenceWin32HandleInfoKHR, name ) == offsetof( VkImportFenceWin32HandleInfoKHR, name ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct ImportFenceFdInfoKHR
  {
    operator VkImportFenceFdInfoKHR const&() const
    {
      return *reinterpret_cast<const VkImportFenceFdInfoKHR*>(this);
    }

    operator VkImportFenceFdInfoKHR &()
    {
      return *reinterpret_cast<VkImportFenceFdInfoKHR*>(this);
    }

    bool operator==( ImportFenceFdInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( fence == rhs.fence )
          && ( flags == rhs.flags )
          && ( handleType == rhs.handleType )
          && ( fd == rhs.fd );
    }

    bool operator!=( ImportFenceFdInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eImportFenceFdInfoKHR;
    const void* pNext = nullptr;
    Fence fence = Fence();
    FenceImportFlags flags = FenceImportFlags();
    ExternalFenceHandleTypeFlagBits handleType = ExternalFenceHandleTypeFlagBits::eOpaqueFd;
    int fd = 0;
  };
  static_assert( sizeof( ImportFenceFdInfoKHR ) == sizeof( VkImportFenceFdInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( ImportFenceFdInfoKHR, pNext ) == offsetof( VkImportFenceFdInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportFenceFdInfoKHR, fence ) == offsetof( VkImportFenceFdInfoKHR, fence ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportFenceFdInfoKHR, flags ) == offsetof( VkImportFenceFdInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportFenceFdInfoKHR, handleType ) == offsetof( VkImportFenceFdInfoKHR, handleType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ImportFenceFdInfoKHR, fd ) == offsetof( VkImportFenceFdInfoKHR, fd ), "struct member and wrapper member have different offset!" );

  enum class SurfaceCounterFlagBitsEXT
  {
    eVblank = VK_SURFACE_COUNTER_VBLANK_EXT
  };

  using SurfaceCounterFlagsEXT = Flags<SurfaceCounterFlagBitsEXT, VkSurfaceCounterFlagsEXT>;

  VULKAN_HPP_INLINE SurfaceCounterFlagsEXT operator|( SurfaceCounterFlagBitsEXT bit0, SurfaceCounterFlagBitsEXT bit1 )
  {
    return SurfaceCounterFlagsEXT( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE SurfaceCounterFlagsEXT operator~( SurfaceCounterFlagBitsEXT bits )
  {
    return ~( SurfaceCounterFlagsEXT( bits ) );
  }

  template <> struct FlagTraits<SurfaceCounterFlagBitsEXT>
  {
    enum
    {
      allFlags = VkFlags(SurfaceCounterFlagBitsEXT::eVblank)
    };
  };

  struct SurfaceCapabilities2EXT
  {
    operator VkSurfaceCapabilities2EXT const&() const
    {
      return *reinterpret_cast<const VkSurfaceCapabilities2EXT*>(this);
    }

    operator VkSurfaceCapabilities2EXT &()
    {
      return *reinterpret_cast<VkSurfaceCapabilities2EXT*>(this);
    }

    bool operator==( SurfaceCapabilities2EXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( minImageCount == rhs.minImageCount )
          && ( maxImageCount == rhs.maxImageCount )
          && ( currentExtent == rhs.currentExtent )
          && ( minImageExtent == rhs.minImageExtent )
          && ( maxImageExtent == rhs.maxImageExtent )
          && ( maxImageArrayLayers == rhs.maxImageArrayLayers )
          && ( supportedTransforms == rhs.supportedTransforms )
          && ( currentTransform == rhs.currentTransform )
          && ( supportedCompositeAlpha == rhs.supportedCompositeAlpha )
          && ( supportedUsageFlags == rhs.supportedUsageFlags )
          && ( supportedSurfaceCounters == rhs.supportedSurfaceCounters );
    }

    bool operator!=( SurfaceCapabilities2EXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSurfaceCapabilities2EXT;
    void* pNext = nullptr;
    uint32_t minImageCount = 0;
    uint32_t maxImageCount = 0;
    Extent2D currentExtent = Extent2D();
    Extent2D minImageExtent = Extent2D();
    Extent2D maxImageExtent = Extent2D();
    uint32_t maxImageArrayLayers = 0;
    SurfaceTransformFlagsKHR supportedTransforms = SurfaceTransformFlagsKHR();
    SurfaceTransformFlagBitsKHR currentTransform = SurfaceTransformFlagBitsKHR::eIdentity;
    CompositeAlphaFlagsKHR supportedCompositeAlpha = CompositeAlphaFlagsKHR();
    ImageUsageFlags supportedUsageFlags = ImageUsageFlags();
    SurfaceCounterFlagsEXT supportedSurfaceCounters = SurfaceCounterFlagsEXT();
  };
  static_assert( sizeof( SurfaceCapabilities2EXT ) == sizeof( VkSurfaceCapabilities2EXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, pNext ) == offsetof( VkSurfaceCapabilities2EXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, minImageCount ) == offsetof( VkSurfaceCapabilities2EXT, minImageCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, maxImageCount ) == offsetof( VkSurfaceCapabilities2EXT, maxImageCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, currentExtent ) == offsetof( VkSurfaceCapabilities2EXT, currentExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, minImageExtent ) == offsetof( VkSurfaceCapabilities2EXT, minImageExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, maxImageExtent ) == offsetof( VkSurfaceCapabilities2EXT, maxImageExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, maxImageArrayLayers ) == offsetof( VkSurfaceCapabilities2EXT, maxImageArrayLayers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, supportedTransforms ) == offsetof( VkSurfaceCapabilities2EXT, supportedTransforms ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, currentTransform ) == offsetof( VkSurfaceCapabilities2EXT, currentTransform ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, supportedCompositeAlpha ) == offsetof( VkSurfaceCapabilities2EXT, supportedCompositeAlpha ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, supportedUsageFlags ) == offsetof( VkSurfaceCapabilities2EXT, supportedUsageFlags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SurfaceCapabilities2EXT, supportedSurfaceCounters ) == offsetof( VkSurfaceCapabilities2EXT, supportedSurfaceCounters ), "struct member and wrapper member have different offset!" );

  struct SwapchainCounterCreateInfoEXT
  {
    operator VkSwapchainCounterCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(this);
    }

    operator VkSwapchainCounterCreateInfoEXT &()
    {
      return *reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(this);
    }

    bool operator==( SwapchainCounterCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( surfaceCounters == rhs.surfaceCounters );
    }

    bool operator!=( SwapchainCounterCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSwapchainCounterCreateInfoEXT;
    const void* pNext = nullptr;
    SurfaceCounterFlagsEXT surfaceCounters = SurfaceCounterFlagsEXT();
  };
  static_assert( sizeof( SwapchainCounterCreateInfoEXT ) == sizeof( VkSwapchainCounterCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( SwapchainCounterCreateInfoEXT, pNext ) == offsetof( VkSwapchainCounterCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCounterCreateInfoEXT, surfaceCounters ) == offsetof( VkSwapchainCounterCreateInfoEXT, surfaceCounters ), "struct member and wrapper member have different offset!" );

  enum class DisplayPowerStateEXT
  {
    eOff = VK_DISPLAY_POWER_STATE_OFF_EXT,
    eSuspend = VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
    eOn = VK_DISPLAY_POWER_STATE_ON_EXT
  };

  struct DisplayPowerInfoEXT
  {
    operator VkDisplayPowerInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDisplayPowerInfoEXT*>(this);
    }

    operator VkDisplayPowerInfoEXT &()
    {
      return *reinterpret_cast<VkDisplayPowerInfoEXT*>(this);
    }

    bool operator==( DisplayPowerInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( powerState == rhs.powerState );
    }

    bool operator!=( DisplayPowerInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplayPowerInfoEXT;
    const void* pNext = nullptr;
    DisplayPowerStateEXT powerState = DisplayPowerStateEXT::eOff;
  };
  static_assert( sizeof( DisplayPowerInfoEXT ) == sizeof( VkDisplayPowerInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayPowerInfoEXT, pNext ) == offsetof( VkDisplayPowerInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayPowerInfoEXT, powerState ) == offsetof( VkDisplayPowerInfoEXT, powerState ), "struct member and wrapper member have different offset!" );

  enum class DeviceEventTypeEXT
  {
    eDisplayHotplug = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT
  };

  struct DeviceEventInfoEXT
  {
    operator VkDeviceEventInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDeviceEventInfoEXT*>(this);
    }

    operator VkDeviceEventInfoEXT &()
    {
      return *reinterpret_cast<VkDeviceEventInfoEXT*>(this);
    }

    bool operator==( DeviceEventInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( deviceEvent == rhs.deviceEvent );
    }

    bool operator!=( DeviceEventInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceEventInfoEXT;
    const void* pNext = nullptr;
    DeviceEventTypeEXT deviceEvent = DeviceEventTypeEXT::eDisplayHotplug;
  };
  static_assert( sizeof( DeviceEventInfoEXT ) == sizeof( VkDeviceEventInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceEventInfoEXT, pNext ) == offsetof( VkDeviceEventInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceEventInfoEXT, deviceEvent ) == offsetof( VkDeviceEventInfoEXT, deviceEvent ), "struct member and wrapper member have different offset!" );

  enum class DisplayEventTypeEXT
  {
    eFirstPixelOut = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT
  };

  struct DisplayEventInfoEXT
  {
    operator VkDisplayEventInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDisplayEventInfoEXT*>(this);
    }

    operator VkDisplayEventInfoEXT &()
    {
      return *reinterpret_cast<VkDisplayEventInfoEXT*>(this);
    }

    bool operator==( DisplayEventInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( displayEvent == rhs.displayEvent );
    }

    bool operator!=( DisplayEventInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDisplayEventInfoEXT;
    const void* pNext = nullptr;
    DisplayEventTypeEXT displayEvent = DisplayEventTypeEXT::eFirstPixelOut;
  };
  static_assert( sizeof( DisplayEventInfoEXT ) == sizeof( VkDisplayEventInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DisplayEventInfoEXT, pNext ) == offsetof( VkDisplayEventInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DisplayEventInfoEXT, displayEvent ) == offsetof( VkDisplayEventInfoEXT, displayEvent ), "struct member and wrapper member have different offset!" );

  enum class PeerMemoryFeatureFlagBits
  {
    eCopySrc = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    eCopySrcKHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    eCopyDst = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    eCopyDstKHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    eGenericSrc = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    eGenericSrcKHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    eGenericDst = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
    eGenericDstKHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT
  };

  using PeerMemoryFeatureFlags = Flags<PeerMemoryFeatureFlagBits, VkPeerMemoryFeatureFlags>;

  VULKAN_HPP_INLINE PeerMemoryFeatureFlags operator|( PeerMemoryFeatureFlagBits bit0, PeerMemoryFeatureFlagBits bit1 )
  {
    return PeerMemoryFeatureFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE PeerMemoryFeatureFlags operator~( PeerMemoryFeatureFlagBits bits )
  {
    return ~( PeerMemoryFeatureFlags( bits ) );
  }

  template <> struct FlagTraits<PeerMemoryFeatureFlagBits>
  {
    enum
    {
      allFlags = VkFlags(PeerMemoryFeatureFlagBits::eCopySrc) | VkFlags(PeerMemoryFeatureFlagBits::eCopyDst) | VkFlags(PeerMemoryFeatureFlagBits::eGenericSrc) | VkFlags(PeerMemoryFeatureFlagBits::eGenericDst)
    };
  };

  using PeerMemoryFeatureFlagsKHR = PeerMemoryFeatureFlags;

  enum class MemoryAllocateFlagBits
  {
    eDeviceMask = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    eDeviceMaskKHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT
  };

  using MemoryAllocateFlags = Flags<MemoryAllocateFlagBits, VkMemoryAllocateFlags>;

  VULKAN_HPP_INLINE MemoryAllocateFlags operator|( MemoryAllocateFlagBits bit0, MemoryAllocateFlagBits bit1 )
  {
    return MemoryAllocateFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE MemoryAllocateFlags operator~( MemoryAllocateFlagBits bits )
  {
    return ~( MemoryAllocateFlags( bits ) );
  }

  template <> struct FlagTraits<MemoryAllocateFlagBits>
  {
    enum
    {
      allFlags = VkFlags(MemoryAllocateFlagBits::eDeviceMask)
    };
  };

  using MemoryAllocateFlagsKHR = MemoryAllocateFlags;

  struct MemoryAllocateFlagsInfo
  {
    operator VkMemoryAllocateFlagsInfo const&() const
    {
      return *reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(this);
    }

    operator VkMemoryAllocateFlagsInfo &()
    {
      return *reinterpret_cast<VkMemoryAllocateFlagsInfo*>(this);
    }

    bool operator==( MemoryAllocateFlagsInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( deviceMask == rhs.deviceMask );
    }

    bool operator!=( MemoryAllocateFlagsInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eMemoryAllocateFlagsInfo;
    const void* pNext = nullptr;
    MemoryAllocateFlags flags = MemoryAllocateFlags();
    uint32_t deviceMask = 0;
  };
  static_assert( sizeof( MemoryAllocateFlagsInfo ) == sizeof( VkMemoryAllocateFlagsInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( MemoryAllocateFlagsInfo, pNext ) == offsetof( VkMemoryAllocateFlagsInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryAllocateFlagsInfo, flags ) == offsetof( VkMemoryAllocateFlagsInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( MemoryAllocateFlagsInfo, deviceMask ) == offsetof( VkMemoryAllocateFlagsInfo, deviceMask ), "struct member and wrapper member have different offset!" );

  using MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;

  enum class DeviceGroupPresentModeFlagBitsKHR
  {
    eLocal = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR,
    eRemote = VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR,
    eSum = VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR,
    eLocalMultiDevice = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR
  };

  using DeviceGroupPresentModeFlagsKHR = Flags<DeviceGroupPresentModeFlagBitsKHR, VkDeviceGroupPresentModeFlagsKHR>;

  VULKAN_HPP_INLINE DeviceGroupPresentModeFlagsKHR operator|( DeviceGroupPresentModeFlagBitsKHR bit0, DeviceGroupPresentModeFlagBitsKHR bit1 )
  {
    return DeviceGroupPresentModeFlagsKHR( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DeviceGroupPresentModeFlagsKHR operator~( DeviceGroupPresentModeFlagBitsKHR bits )
  {
    return ~( DeviceGroupPresentModeFlagsKHR( bits ) );
  }

  template <> struct FlagTraits<DeviceGroupPresentModeFlagBitsKHR>
  {
    enum
    {
      allFlags = VkFlags(DeviceGroupPresentModeFlagBitsKHR::eLocal) | VkFlags(DeviceGroupPresentModeFlagBitsKHR::eRemote) | VkFlags(DeviceGroupPresentModeFlagBitsKHR::eSum) | VkFlags(DeviceGroupPresentModeFlagBitsKHR::eLocalMultiDevice)
    };
  };

  struct DeviceGroupPresentCapabilitiesKHR
  {
    operator VkDeviceGroupPresentCapabilitiesKHR const&() const
    {
      return *reinterpret_cast<const VkDeviceGroupPresentCapabilitiesKHR*>(this);
    }

    operator VkDeviceGroupPresentCapabilitiesKHR &()
    {
      return *reinterpret_cast<VkDeviceGroupPresentCapabilitiesKHR*>(this);
    }

    bool operator==( DeviceGroupPresentCapabilitiesKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( presentMask == rhs.presentMask )
          && ( modes == rhs.modes );
    }

    bool operator!=( DeviceGroupPresentCapabilitiesKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGroupPresentCapabilitiesKHR;
    const void* pNext = nullptr;
    std::array<uint32_t, VK_MAX_DEVICE_GROUP_SIZE> presentMask = { { 0 } };
    DeviceGroupPresentModeFlagsKHR modes = DeviceGroupPresentModeFlagsKHR();
  };
  static_assert( sizeof( DeviceGroupPresentCapabilitiesKHR ) == sizeof( VkDeviceGroupPresentCapabilitiesKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGroupPresentCapabilitiesKHR, pNext ) == offsetof( VkDeviceGroupPresentCapabilitiesKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupPresentCapabilitiesKHR, presentMask ) == offsetof( VkDeviceGroupPresentCapabilitiesKHR, presentMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupPresentCapabilitiesKHR, modes ) == offsetof( VkDeviceGroupPresentCapabilitiesKHR, modes ), "struct member and wrapper member have different offset!" );

  struct DeviceGroupPresentInfoKHR
  {
    operator VkDeviceGroupPresentInfoKHR const&() const
    {
      return *reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(this);
    }

    operator VkDeviceGroupPresentInfoKHR &()
    {
      return *reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(this);
    }

    bool operator==( DeviceGroupPresentInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( swapchainCount == rhs.swapchainCount )
          && ( pDeviceMasks == rhs.pDeviceMasks )
          && ( mode == rhs.mode );
    }

    bool operator!=( DeviceGroupPresentInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGroupPresentInfoKHR;
    const void* pNext = nullptr;
    uint32_t swapchainCount = 0;
    const uint32_t* pDeviceMasks = nullptr;
    DeviceGroupPresentModeFlagBitsKHR mode = DeviceGroupPresentModeFlagBitsKHR::eLocal;
  };
  static_assert( sizeof( DeviceGroupPresentInfoKHR ) == sizeof( VkDeviceGroupPresentInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGroupPresentInfoKHR, pNext ) == offsetof( VkDeviceGroupPresentInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupPresentInfoKHR, swapchainCount ) == offsetof( VkDeviceGroupPresentInfoKHR, swapchainCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupPresentInfoKHR, pDeviceMasks ) == offsetof( VkDeviceGroupPresentInfoKHR, pDeviceMasks ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupPresentInfoKHR, mode ) == offsetof( VkDeviceGroupPresentInfoKHR, mode ), "struct member and wrapper member have different offset!" );

  struct DeviceGroupSwapchainCreateInfoKHR
  {
    operator VkDeviceGroupSwapchainCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(this);
    }

    operator VkDeviceGroupSwapchainCreateInfoKHR &()
    {
      return *reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(this);
    }

    bool operator==( DeviceGroupSwapchainCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( modes == rhs.modes );
    }

    bool operator!=( DeviceGroupSwapchainCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGroupSwapchainCreateInfoKHR;
    const void* pNext = nullptr;
    DeviceGroupPresentModeFlagsKHR modes = DeviceGroupPresentModeFlagsKHR();
  };
  static_assert( sizeof( DeviceGroupSwapchainCreateInfoKHR ) == sizeof( VkDeviceGroupSwapchainCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGroupSwapchainCreateInfoKHR, pNext ) == offsetof( VkDeviceGroupSwapchainCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupSwapchainCreateInfoKHR, modes ) == offsetof( VkDeviceGroupSwapchainCreateInfoKHR, modes ), "struct member and wrapper member have different offset!" );

  enum class SwapchainCreateFlagBitsKHR
  {
    eSplitInstanceBindRegions = VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    eProtected = VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR
  };

  using SwapchainCreateFlagsKHR = Flags<SwapchainCreateFlagBitsKHR, VkSwapchainCreateFlagsKHR>;

  VULKAN_HPP_INLINE SwapchainCreateFlagsKHR operator|( SwapchainCreateFlagBitsKHR bit0, SwapchainCreateFlagBitsKHR bit1 )
  {
    return SwapchainCreateFlagsKHR( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE SwapchainCreateFlagsKHR operator~( SwapchainCreateFlagBitsKHR bits )
  {
    return ~( SwapchainCreateFlagsKHR( bits ) );
  }

  template <> struct FlagTraits<SwapchainCreateFlagBitsKHR>
  {
    enum
    {
      allFlags = VkFlags(SwapchainCreateFlagBitsKHR::eSplitInstanceBindRegions) | VkFlags(SwapchainCreateFlagBitsKHR::eProtected)
    };
  };

  struct SwapchainCreateInfoKHR
  {
    operator VkSwapchainCreateInfoKHR const&() const
    {
      return *reinterpret_cast<const VkSwapchainCreateInfoKHR*>(this);
    }

    operator VkSwapchainCreateInfoKHR &()
    {
      return *reinterpret_cast<VkSwapchainCreateInfoKHR*>(this);
    }

    bool operator==( SwapchainCreateInfoKHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( surface == rhs.surface )
          && ( minImageCount == rhs.minImageCount )
          && ( imageFormat == rhs.imageFormat )
          && ( imageColorSpace == rhs.imageColorSpace )
          && ( imageExtent == rhs.imageExtent )
          && ( imageArrayLayers == rhs.imageArrayLayers )
          && ( imageUsage == rhs.imageUsage )
          && ( imageSharingMode == rhs.imageSharingMode )
          && ( queueFamilyIndexCount == rhs.queueFamilyIndexCount )
          && ( pQueueFamilyIndices == rhs.pQueueFamilyIndices )
          && ( preTransform == rhs.preTransform )
          && ( compositeAlpha == rhs.compositeAlpha )
          && ( presentMode == rhs.presentMode )
          && ( clipped == rhs.clipped )
          && ( oldSwapchain == rhs.oldSwapchain );
    }

    bool operator!=( SwapchainCreateInfoKHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSwapchainCreateInfoKHR;
    const void* pNext = nullptr;
    SwapchainCreateFlagsKHR flags = SwapchainCreateFlagsKHR();
    SurfaceKHR surface = SurfaceKHR();
    uint32_t minImageCount = 0;
    Format imageFormat = Format::eUndefined;
    ColorSpaceKHR imageColorSpace = ColorSpaceKHR::eSrgbNonlinear;
    Extent2D imageExtent = Extent2D();
    uint32_t imageArrayLayers = 0;
    ImageUsageFlags imageUsage = ImageUsageFlags();
    SharingMode imageSharingMode = SharingMode::eExclusive;
    uint32_t queueFamilyIndexCount = 0;
    const uint32_t* pQueueFamilyIndices = nullptr;
    SurfaceTransformFlagBitsKHR preTransform = SurfaceTransformFlagBitsKHR::eIdentity;
    CompositeAlphaFlagBitsKHR compositeAlpha = CompositeAlphaFlagBitsKHR::eOpaque;
    PresentModeKHR presentMode = PresentModeKHR::eImmediate;
    Bool32 clipped = 0;
    SwapchainKHR oldSwapchain = SwapchainKHR();
  };
  static_assert( sizeof( SwapchainCreateInfoKHR ) == sizeof( VkSwapchainCreateInfoKHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, pNext ) == offsetof( VkSwapchainCreateInfoKHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, flags ) == offsetof( VkSwapchainCreateInfoKHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, surface ) == offsetof( VkSwapchainCreateInfoKHR, surface ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, minImageCount ) == offsetof( VkSwapchainCreateInfoKHR, minImageCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, imageFormat ) == offsetof( VkSwapchainCreateInfoKHR, imageFormat ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, imageColorSpace ) == offsetof( VkSwapchainCreateInfoKHR, imageColorSpace ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, imageExtent ) == offsetof( VkSwapchainCreateInfoKHR, imageExtent ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, imageArrayLayers ) == offsetof( VkSwapchainCreateInfoKHR, imageArrayLayers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, imageUsage ) == offsetof( VkSwapchainCreateInfoKHR, imageUsage ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, imageSharingMode ) == offsetof( VkSwapchainCreateInfoKHR, imageSharingMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, queueFamilyIndexCount ) == offsetof( VkSwapchainCreateInfoKHR, queueFamilyIndexCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, pQueueFamilyIndices ) == offsetof( VkSwapchainCreateInfoKHR, pQueueFamilyIndices ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, preTransform ) == offsetof( VkSwapchainCreateInfoKHR, preTransform ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, compositeAlpha ) == offsetof( VkSwapchainCreateInfoKHR, compositeAlpha ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, presentMode ) == offsetof( VkSwapchainCreateInfoKHR, presentMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, clipped ) == offsetof( VkSwapchainCreateInfoKHR, clipped ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SwapchainCreateInfoKHR, oldSwapchain ) == offsetof( VkSwapchainCreateInfoKHR, oldSwapchain ), "struct member and wrapper member have different offset!" );

  enum class ViewportCoordinateSwizzleNV
  {
    ePositiveX = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
    eNegativeX = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
    ePositiveY = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
    eNegativeY = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
    ePositiveZ = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
    eNegativeZ = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
    ePositiveW = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
    eNegativeW = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV
  };

  struct ViewportSwizzleNV
  {
    operator VkViewportSwizzleNV const&() const
    {
      return *reinterpret_cast<const VkViewportSwizzleNV*>(this);
    }

    operator VkViewportSwizzleNV &()
    {
      return *reinterpret_cast<VkViewportSwizzleNV*>(this);
    }

    bool operator==( ViewportSwizzleNV const& rhs ) const
    {
      return ( x == rhs.x )
          && ( y == rhs.y )
          && ( z == rhs.z )
          && ( w == rhs.w );
    }

    bool operator!=( ViewportSwizzleNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    ViewportCoordinateSwizzleNV x = ViewportCoordinateSwizzleNV::ePositiveX;
    ViewportCoordinateSwizzleNV y = ViewportCoordinateSwizzleNV::ePositiveX;
    ViewportCoordinateSwizzleNV z = ViewportCoordinateSwizzleNV::ePositiveX;
    ViewportCoordinateSwizzleNV w = ViewportCoordinateSwizzleNV::ePositiveX;
  };
  static_assert( sizeof( ViewportSwizzleNV ) == sizeof( VkViewportSwizzleNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( ViewportSwizzleNV, x ) == offsetof( VkViewportSwizzleNV, x ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ViewportSwizzleNV, y ) == offsetof( VkViewportSwizzleNV, y ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ViewportSwizzleNV, z ) == offsetof( VkViewportSwizzleNV, z ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ViewportSwizzleNV, w ) == offsetof( VkViewportSwizzleNV, w ), "struct member and wrapper member have different offset!" );

  struct PipelineViewportSwizzleStateCreateInfoNV
  {
    operator VkPipelineViewportSwizzleStateCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(this);
    }

    operator VkPipelineViewportSwizzleStateCreateInfoNV &()
    {
      return *reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(this);
    }

    bool operator==( PipelineViewportSwizzleStateCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( viewportCount == rhs.viewportCount )
          && ( pViewportSwizzles == rhs.pViewportSwizzles );
    }

    bool operator!=( PipelineViewportSwizzleStateCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineViewportSwizzleStateCreateInfoNV;
    const void* pNext = nullptr;
    PipelineViewportSwizzleStateCreateFlagsNV flags = PipelineViewportSwizzleStateCreateFlagsNV();
    uint32_t viewportCount = 0;
    const ViewportSwizzleNV* pViewportSwizzles = nullptr;
  };
  static_assert( sizeof( PipelineViewportSwizzleStateCreateInfoNV ) == sizeof( VkPipelineViewportSwizzleStateCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineViewportSwizzleStateCreateInfoNV, pNext ) == offsetof( VkPipelineViewportSwizzleStateCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportSwizzleStateCreateInfoNV, flags ) == offsetof( VkPipelineViewportSwizzleStateCreateInfoNV, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportSwizzleStateCreateInfoNV, viewportCount ) == offsetof( VkPipelineViewportSwizzleStateCreateInfoNV, viewportCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportSwizzleStateCreateInfoNV, pViewportSwizzles ) == offsetof( VkPipelineViewportSwizzleStateCreateInfoNV, pViewportSwizzles ), "struct member and wrapper member have different offset!" );

  enum class DiscardRectangleModeEXT
  {
    eInclusive = VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
    eExclusive = VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT
  };

  struct PipelineDiscardRectangleStateCreateInfoEXT
  {
    operator VkPipelineDiscardRectangleStateCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(this);
    }

    operator VkPipelineDiscardRectangleStateCreateInfoEXT &()
    {
      return *reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(this);
    }

    bool operator==( PipelineDiscardRectangleStateCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( discardRectangleMode == rhs.discardRectangleMode )
          && ( discardRectangleCount == rhs.discardRectangleCount )
          && ( pDiscardRectangles == rhs.pDiscardRectangles );
    }

    bool operator!=( PipelineDiscardRectangleStateCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineDiscardRectangleStateCreateInfoEXT;
    const void* pNext = nullptr;
    PipelineDiscardRectangleStateCreateFlagsEXT flags = PipelineDiscardRectangleStateCreateFlagsEXT();
    DiscardRectangleModeEXT discardRectangleMode = DiscardRectangleModeEXT::eInclusive;
    uint32_t discardRectangleCount = 0;
    const Rect2D* pDiscardRectangles = nullptr;
  };
  static_assert( sizeof( PipelineDiscardRectangleStateCreateInfoEXT ) == sizeof( VkPipelineDiscardRectangleStateCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineDiscardRectangleStateCreateInfoEXT, pNext ) == offsetof( VkPipelineDiscardRectangleStateCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDiscardRectangleStateCreateInfoEXT, flags ) == offsetof( VkPipelineDiscardRectangleStateCreateInfoEXT, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDiscardRectangleStateCreateInfoEXT, discardRectangleMode ) == offsetof( VkPipelineDiscardRectangleStateCreateInfoEXT, discardRectangleMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDiscardRectangleStateCreateInfoEXT, discardRectangleCount ) == offsetof( VkPipelineDiscardRectangleStateCreateInfoEXT, discardRectangleCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineDiscardRectangleStateCreateInfoEXT, pDiscardRectangles ) == offsetof( VkPipelineDiscardRectangleStateCreateInfoEXT, pDiscardRectangles ), "struct member and wrapper member have different offset!" );

  enum class SubpassDescriptionFlagBits
  {
    ePerViewAttributesNVX = VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX,
    ePerViewPositionXOnlyNVX = VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX
  };

  using SubpassDescriptionFlags = Flags<SubpassDescriptionFlagBits, VkSubpassDescriptionFlags>;

  VULKAN_HPP_INLINE SubpassDescriptionFlags operator|( SubpassDescriptionFlagBits bit0, SubpassDescriptionFlagBits bit1 )
  {
    return SubpassDescriptionFlags( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE SubpassDescriptionFlags operator~( SubpassDescriptionFlagBits bits )
  {
    return ~( SubpassDescriptionFlags( bits ) );
  }

  template <> struct FlagTraits<SubpassDescriptionFlagBits>
  {
    enum
    {
      allFlags = VkFlags(SubpassDescriptionFlagBits::ePerViewAttributesNVX) | VkFlags(SubpassDescriptionFlagBits::ePerViewPositionXOnlyNVX)
    };
  };

  struct SubpassDescription
  {
    operator VkSubpassDescription const&() const
    {
      return *reinterpret_cast<const VkSubpassDescription*>(this);
    }

    operator VkSubpassDescription &()
    {
      return *reinterpret_cast<VkSubpassDescription*>(this);
    }

    bool operator==( SubpassDescription const& rhs ) const
    {
      return ( flags == rhs.flags )
          && ( pipelineBindPoint == rhs.pipelineBindPoint )
          && ( inputAttachmentCount == rhs.inputAttachmentCount )
          && ( pInputAttachments == rhs.pInputAttachments )
          && ( colorAttachmentCount == rhs.colorAttachmentCount )
          && ( pColorAttachments == rhs.pColorAttachments )
          && ( pResolveAttachments == rhs.pResolveAttachments )
          && ( pDepthStencilAttachment == rhs.pDepthStencilAttachment )
          && ( preserveAttachmentCount == rhs.preserveAttachmentCount )
          && ( pPreserveAttachments == rhs.pPreserveAttachments );
    }

    bool operator!=( SubpassDescription const& rhs ) const
    {
      return !operator==( rhs );
    }

    SubpassDescriptionFlags flags = SubpassDescriptionFlags();
    PipelineBindPoint pipelineBindPoint = PipelineBindPoint::eGraphics;
    uint32_t inputAttachmentCount = 0;
    const AttachmentReference* pInputAttachments = nullptr;
    uint32_t colorAttachmentCount = 0;
    const AttachmentReference* pColorAttachments = nullptr;
    const AttachmentReference* pResolveAttachments = nullptr;
    const AttachmentReference* pDepthStencilAttachment = nullptr;
    uint32_t preserveAttachmentCount = 0;
    const uint32_t* pPreserveAttachments = nullptr;
  };
  static_assert( sizeof( SubpassDescription ) == sizeof( VkSubpassDescription ), "struct and wrapper have different size!" );
  static_assert( offsetof( SubpassDescription, flags ) == offsetof( VkSubpassDescription, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription, pipelineBindPoint ) == offsetof( VkSubpassDescription, pipelineBindPoint ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription, inputAttachmentCount ) == offsetof( VkSubpassDescription, inputAttachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription, pInputAttachments ) == offsetof( VkSubpassDescription, pInputAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription, colorAttachmentCount ) == offsetof( VkSubpassDescription, colorAttachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription, pColorAttachments ) == offsetof( VkSubpassDescription, pColorAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription, pResolveAttachments ) == offsetof( VkSubpassDescription, pResolveAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription, pDepthStencilAttachment ) == offsetof( VkSubpassDescription, pDepthStencilAttachment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription, preserveAttachmentCount ) == offsetof( VkSubpassDescription, preserveAttachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription, pPreserveAttachments ) == offsetof( VkSubpassDescription, pPreserveAttachments ), "struct member and wrapper member have different offset!" );

  struct RenderPassCreateInfo
  {
    operator VkRenderPassCreateInfo const&() const
    {
      return *reinterpret_cast<const VkRenderPassCreateInfo*>(this);
    }

    operator VkRenderPassCreateInfo &()
    {
      return *reinterpret_cast<VkRenderPassCreateInfo*>(this);
    }

    bool operator==( RenderPassCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( attachmentCount == rhs.attachmentCount )
          && ( pAttachments == rhs.pAttachments )
          && ( subpassCount == rhs.subpassCount )
          && ( pSubpasses == rhs.pSubpasses )
          && ( dependencyCount == rhs.dependencyCount )
          && ( pDependencies == rhs.pDependencies );
    }

    bool operator!=( RenderPassCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eRenderPassCreateInfo;
    const void* pNext = nullptr;
    RenderPassCreateFlags flags = RenderPassCreateFlags();
    uint32_t attachmentCount = 0;
    const AttachmentDescription* pAttachments = nullptr;
    uint32_t subpassCount = 0;
    const SubpassDescription* pSubpasses = nullptr;
    uint32_t dependencyCount = 0;
    const SubpassDependency* pDependencies = nullptr;
  };
  static_assert( sizeof( RenderPassCreateInfo ) == sizeof( VkRenderPassCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( RenderPassCreateInfo, pNext ) == offsetof( VkRenderPassCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo, flags ) == offsetof( VkRenderPassCreateInfo, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo, attachmentCount ) == offsetof( VkRenderPassCreateInfo, attachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo, pAttachments ) == offsetof( VkRenderPassCreateInfo, pAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo, subpassCount ) == offsetof( VkRenderPassCreateInfo, subpassCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo, pSubpasses ) == offsetof( VkRenderPassCreateInfo, pSubpasses ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo, dependencyCount ) == offsetof( VkRenderPassCreateInfo, dependencyCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo, pDependencies ) == offsetof( VkRenderPassCreateInfo, pDependencies ), "struct member and wrapper member have different offset!" );

  struct SubpassDescription2KHR
  {
    operator VkSubpassDescription2KHR const&() const
    {
      return *reinterpret_cast<const VkSubpassDescription2KHR*>(this);
    }

    operator VkSubpassDescription2KHR &()
    {
      return *reinterpret_cast<VkSubpassDescription2KHR*>(this);
    }

    bool operator==( SubpassDescription2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( pipelineBindPoint == rhs.pipelineBindPoint )
          && ( viewMask == rhs.viewMask )
          && ( inputAttachmentCount == rhs.inputAttachmentCount )
          && ( pInputAttachments == rhs.pInputAttachments )
          && ( colorAttachmentCount == rhs.colorAttachmentCount )
          && ( pColorAttachments == rhs.pColorAttachments )
          && ( pResolveAttachments == rhs.pResolveAttachments )
          && ( pDepthStencilAttachment == rhs.pDepthStencilAttachment )
          && ( preserveAttachmentCount == rhs.preserveAttachmentCount )
          && ( pPreserveAttachments == rhs.pPreserveAttachments );
    }

    bool operator!=( SubpassDescription2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSubpassDescription2KHR;
    const void* pNext = nullptr;
    SubpassDescriptionFlags flags = SubpassDescriptionFlags();
    PipelineBindPoint pipelineBindPoint = PipelineBindPoint::eGraphics;
    uint32_t viewMask = 0;
    uint32_t inputAttachmentCount = 0;
    const AttachmentReference2KHR* pInputAttachments = nullptr;
    uint32_t colorAttachmentCount = 0;
    const AttachmentReference2KHR* pColorAttachments = nullptr;
    const AttachmentReference2KHR* pResolveAttachments = nullptr;
    const AttachmentReference2KHR* pDepthStencilAttachment = nullptr;
    uint32_t preserveAttachmentCount = 0;
    const uint32_t* pPreserveAttachments = nullptr;
  };
  static_assert( sizeof( SubpassDescription2KHR ) == sizeof( VkSubpassDescription2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( SubpassDescription2KHR, pNext ) == offsetof( VkSubpassDescription2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, flags ) == offsetof( VkSubpassDescription2KHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, pipelineBindPoint ) == offsetof( VkSubpassDescription2KHR, pipelineBindPoint ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, viewMask ) == offsetof( VkSubpassDescription2KHR, viewMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, inputAttachmentCount ) == offsetof( VkSubpassDescription2KHR, inputAttachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, pInputAttachments ) == offsetof( VkSubpassDescription2KHR, pInputAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, colorAttachmentCount ) == offsetof( VkSubpassDescription2KHR, colorAttachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, pColorAttachments ) == offsetof( VkSubpassDescription2KHR, pColorAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, pResolveAttachments ) == offsetof( VkSubpassDescription2KHR, pResolveAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, pDepthStencilAttachment ) == offsetof( VkSubpassDescription2KHR, pDepthStencilAttachment ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, preserveAttachmentCount ) == offsetof( VkSubpassDescription2KHR, preserveAttachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubpassDescription2KHR, pPreserveAttachments ) == offsetof( VkSubpassDescription2KHR, pPreserveAttachments ), "struct member and wrapper member have different offset!" );

  struct RenderPassCreateInfo2KHR
  {
    operator VkRenderPassCreateInfo2KHR const&() const
    {
      return *reinterpret_cast<const VkRenderPassCreateInfo2KHR*>(this);
    }

    operator VkRenderPassCreateInfo2KHR &()
    {
      return *reinterpret_cast<VkRenderPassCreateInfo2KHR*>(this);
    }

    bool operator==( RenderPassCreateInfo2KHR const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( attachmentCount == rhs.attachmentCount )
          && ( pAttachments == rhs.pAttachments )
          && ( subpassCount == rhs.subpassCount )
          && ( pSubpasses == rhs.pSubpasses )
          && ( dependencyCount == rhs.dependencyCount )
          && ( pDependencies == rhs.pDependencies )
          && ( correlatedViewMaskCount == rhs.correlatedViewMaskCount )
          && ( pCorrelatedViewMasks == rhs.pCorrelatedViewMasks );
    }

    bool operator!=( RenderPassCreateInfo2KHR const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eRenderPassCreateInfo2KHR;
    const void* pNext = nullptr;
    RenderPassCreateFlags flags = RenderPassCreateFlags();
    uint32_t attachmentCount = 0;
    const AttachmentDescription2KHR* pAttachments = nullptr;
    uint32_t subpassCount = 0;
    const SubpassDescription2KHR* pSubpasses = nullptr;
    uint32_t dependencyCount = 0;
    const SubpassDependency2KHR* pDependencies = nullptr;
    uint32_t correlatedViewMaskCount = 0;
    const uint32_t* pCorrelatedViewMasks = nullptr;
  };
  static_assert( sizeof( RenderPassCreateInfo2KHR ) == sizeof( VkRenderPassCreateInfo2KHR ), "struct and wrapper have different size!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, pNext ) == offsetof( VkRenderPassCreateInfo2KHR, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, flags ) == offsetof( VkRenderPassCreateInfo2KHR, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, attachmentCount ) == offsetof( VkRenderPassCreateInfo2KHR, attachmentCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, pAttachments ) == offsetof( VkRenderPassCreateInfo2KHR, pAttachments ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, subpassCount ) == offsetof( VkRenderPassCreateInfo2KHR, subpassCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, pSubpasses ) == offsetof( VkRenderPassCreateInfo2KHR, pSubpasses ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, dependencyCount ) == offsetof( VkRenderPassCreateInfo2KHR, dependencyCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, pDependencies ) == offsetof( VkRenderPassCreateInfo2KHR, pDependencies ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, correlatedViewMaskCount ) == offsetof( VkRenderPassCreateInfo2KHR, correlatedViewMaskCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( RenderPassCreateInfo2KHR, pCorrelatedViewMasks ) == offsetof( VkRenderPassCreateInfo2KHR, pCorrelatedViewMasks ), "struct member and wrapper member have different offset!" );

  enum class PointClippingBehavior
  {
    eAllClipPlanes = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    eAllClipPlanesKHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    eUserClipPlanesOnly = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    eUserClipPlanesOnlyKHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY
  };

  struct PhysicalDevicePointClippingProperties
  {
    operator VkPhysicalDevicePointClippingProperties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(this);
    }

    operator VkPhysicalDevicePointClippingProperties &()
    {
      return *reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(this);
    }

    bool operator==( PhysicalDevicePointClippingProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( pointClippingBehavior == rhs.pointClippingBehavior );
    }

    bool operator!=( PhysicalDevicePointClippingProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDevicePointClippingProperties;
    void* pNext = nullptr;
    PointClippingBehavior pointClippingBehavior = PointClippingBehavior::eAllClipPlanes;
  };
  static_assert( sizeof( PhysicalDevicePointClippingProperties ) == sizeof( VkPhysicalDevicePointClippingProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDevicePointClippingProperties, pNext ) == offsetof( VkPhysicalDevicePointClippingProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDevicePointClippingProperties, pointClippingBehavior ) == offsetof( VkPhysicalDevicePointClippingProperties, pointClippingBehavior ), "struct member and wrapper member have different offset!" );

  using PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;

  enum class SamplerReductionModeEXT
  {
    eWeightedAverage = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT,
    eMin = VK_SAMPLER_REDUCTION_MODE_MIN_EXT,
    eMax = VK_SAMPLER_REDUCTION_MODE_MAX_EXT
  };

  struct SamplerReductionModeCreateInfoEXT
  {
    operator VkSamplerReductionModeCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkSamplerReductionModeCreateInfoEXT*>(this);
    }

    operator VkSamplerReductionModeCreateInfoEXT &()
    {
      return *reinterpret_cast<VkSamplerReductionModeCreateInfoEXT*>(this);
    }

    bool operator==( SamplerReductionModeCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( reductionMode == rhs.reductionMode );
    }

    bool operator!=( SamplerReductionModeCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSamplerReductionModeCreateInfoEXT;
    const void* pNext = nullptr;
    SamplerReductionModeEXT reductionMode = SamplerReductionModeEXT::eWeightedAverage;
  };
  static_assert( sizeof( SamplerReductionModeCreateInfoEXT ) == sizeof( VkSamplerReductionModeCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( SamplerReductionModeCreateInfoEXT, pNext ) == offsetof( VkSamplerReductionModeCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerReductionModeCreateInfoEXT, reductionMode ) == offsetof( VkSamplerReductionModeCreateInfoEXT, reductionMode ), "struct member and wrapper member have different offset!" );

  enum class TessellationDomainOrigin
  {
    eUpperLeft = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    eUpperLeftKHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    eLowerLeft = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    eLowerLeftKHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT
  };

  struct PipelineTessellationDomainOriginStateCreateInfo
  {
    operator VkPipelineTessellationDomainOriginStateCreateInfo const&() const
    {
      return *reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(this);
    }

    operator VkPipelineTessellationDomainOriginStateCreateInfo &()
    {
      return *reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(this);
    }

    bool operator==( PipelineTessellationDomainOriginStateCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( domainOrigin == rhs.domainOrigin );
    }

    bool operator!=( PipelineTessellationDomainOriginStateCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineTessellationDomainOriginStateCreateInfo;
    const void* pNext = nullptr;
    TessellationDomainOrigin domainOrigin = TessellationDomainOrigin::eUpperLeft;
  };
  static_assert( sizeof( PipelineTessellationDomainOriginStateCreateInfo ) == sizeof( VkPipelineTessellationDomainOriginStateCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineTessellationDomainOriginStateCreateInfo, pNext ) == offsetof( VkPipelineTessellationDomainOriginStateCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineTessellationDomainOriginStateCreateInfo, domainOrigin ) == offsetof( VkPipelineTessellationDomainOriginStateCreateInfo, domainOrigin ), "struct member and wrapper member have different offset!" );

  using PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;

  enum class SamplerYcbcrModelConversion
  {
    eRgbIdentity = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    eRgbIdentityKHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    eYcbcrIdentity = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    eYcbcrIdentityKHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    eYcbcr709 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    eYcbcr709KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    eYcbcr601 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    eYcbcr601KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    eYcbcr2020 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    eYcbcr2020KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020
  };

  enum class SamplerYcbcrRange
  {
    eItuFull = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    eItuFullKHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    eItuNarrow = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    eItuNarrowKHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW
  };

  enum class ChromaLocation
  {
    eCositedEven = VK_CHROMA_LOCATION_COSITED_EVEN,
    eCositedEvenKHR = VK_CHROMA_LOCATION_COSITED_EVEN,
    eMidpoint = VK_CHROMA_LOCATION_MIDPOINT,
    eMidpointKHR = VK_CHROMA_LOCATION_MIDPOINT
  };

  struct SamplerYcbcrConversionCreateInfo
  {
    operator VkSamplerYcbcrConversionCreateInfo const&() const
    {
      return *reinterpret_cast<const VkSamplerYcbcrConversionCreateInfo*>(this);
    }

    operator VkSamplerYcbcrConversionCreateInfo &()
    {
      return *reinterpret_cast<VkSamplerYcbcrConversionCreateInfo*>(this);
    }

    bool operator==( SamplerYcbcrConversionCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( format == rhs.format )
          && ( ycbcrModel == rhs.ycbcrModel )
          && ( ycbcrRange == rhs.ycbcrRange )
          && ( components == rhs.components )
          && ( xChromaOffset == rhs.xChromaOffset )
          && ( yChromaOffset == rhs.yChromaOffset )
          && ( chromaFilter == rhs.chromaFilter )
          && ( forceExplicitReconstruction == rhs.forceExplicitReconstruction );
    }

    bool operator!=( SamplerYcbcrConversionCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSamplerYcbcrConversionCreateInfo;
    const void* pNext = nullptr;
    Format format = Format::eUndefined;
    SamplerYcbcrModelConversion ycbcrModel = SamplerYcbcrModelConversion::eRgbIdentity;
    SamplerYcbcrRange ycbcrRange = SamplerYcbcrRange::eItuFull;
    ComponentMapping components = ComponentMapping();
    ChromaLocation xChromaOffset = ChromaLocation::eCositedEven;
    ChromaLocation yChromaOffset = ChromaLocation::eCositedEven;
    Filter chromaFilter = Filter::eNearest;
    Bool32 forceExplicitReconstruction = 0;
  };
  static_assert( sizeof( SamplerYcbcrConversionCreateInfo ) == sizeof( VkSamplerYcbcrConversionCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( SamplerYcbcrConversionCreateInfo, pNext ) == offsetof( VkSamplerYcbcrConversionCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionCreateInfo, format ) == offsetof( VkSamplerYcbcrConversionCreateInfo, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionCreateInfo, ycbcrModel ) == offsetof( VkSamplerYcbcrConversionCreateInfo, ycbcrModel ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionCreateInfo, ycbcrRange ) == offsetof( VkSamplerYcbcrConversionCreateInfo, ycbcrRange ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionCreateInfo, components ) == offsetof( VkSamplerYcbcrConversionCreateInfo, components ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionCreateInfo, xChromaOffset ) == offsetof( VkSamplerYcbcrConversionCreateInfo, xChromaOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionCreateInfo, yChromaOffset ) == offsetof( VkSamplerYcbcrConversionCreateInfo, yChromaOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionCreateInfo, chromaFilter ) == offsetof( VkSamplerYcbcrConversionCreateInfo, chromaFilter ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SamplerYcbcrConversionCreateInfo, forceExplicitReconstruction ) == offsetof( VkSamplerYcbcrConversionCreateInfo, forceExplicitReconstruction ), "struct member and wrapper member have different offset!" );

  using SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  struct AndroidHardwareBufferFormatPropertiesANDROID
  {
    operator VkAndroidHardwareBufferFormatPropertiesANDROID const&() const
    {
      return *reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(this);
    }

    operator VkAndroidHardwareBufferFormatPropertiesANDROID &()
    {
      return *reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(this);
    }

    bool operator==( AndroidHardwareBufferFormatPropertiesANDROID const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( format == rhs.format )
          && ( externalFormat == rhs.externalFormat )
          && ( formatFeatures == rhs.formatFeatures )
          && ( samplerYcbcrConversionComponents == rhs.samplerYcbcrConversionComponents )
          && ( suggestedYcbcrModel == rhs.suggestedYcbcrModel )
          && ( suggestedYcbcrRange == rhs.suggestedYcbcrRange )
          && ( suggestedXChromaOffset == rhs.suggestedXChromaOffset )
          && ( suggestedYChromaOffset == rhs.suggestedYChromaOffset );
    }

    bool operator!=( AndroidHardwareBufferFormatPropertiesANDROID const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eAndroidHardwareBufferFormatPropertiesANDROID;
    void* pNext = nullptr;
    Format format = Format::eUndefined;
    uint64_t externalFormat = 0;
    FormatFeatureFlags formatFeatures = FormatFeatureFlags();
    ComponentMapping samplerYcbcrConversionComponents = ComponentMapping();
    SamplerYcbcrModelConversion suggestedYcbcrModel = SamplerYcbcrModelConversion::eRgbIdentity;
    SamplerYcbcrRange suggestedYcbcrRange = SamplerYcbcrRange::eItuFull;
    ChromaLocation suggestedXChromaOffset = ChromaLocation::eCositedEven;
    ChromaLocation suggestedYChromaOffset = ChromaLocation::eCositedEven;
  };
  static_assert( sizeof( AndroidHardwareBufferFormatPropertiesANDROID ) == sizeof( VkAndroidHardwareBufferFormatPropertiesANDROID ), "struct and wrapper have different size!" );
  static_assert( offsetof( AndroidHardwareBufferFormatPropertiesANDROID, pNext ) == offsetof( VkAndroidHardwareBufferFormatPropertiesANDROID, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferFormatPropertiesANDROID, format ) == offsetof( VkAndroidHardwareBufferFormatPropertiesANDROID, format ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferFormatPropertiesANDROID, externalFormat ) == offsetof( VkAndroidHardwareBufferFormatPropertiesANDROID, externalFormat ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferFormatPropertiesANDROID, formatFeatures ) == offsetof( VkAndroidHardwareBufferFormatPropertiesANDROID, formatFeatures ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferFormatPropertiesANDROID, samplerYcbcrConversionComponents ) == offsetof( VkAndroidHardwareBufferFormatPropertiesANDROID, samplerYcbcrConversionComponents ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferFormatPropertiesANDROID, suggestedYcbcrModel ) == offsetof( VkAndroidHardwareBufferFormatPropertiesANDROID, suggestedYcbcrModel ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferFormatPropertiesANDROID, suggestedYcbcrRange ) == offsetof( VkAndroidHardwareBufferFormatPropertiesANDROID, suggestedYcbcrRange ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferFormatPropertiesANDROID, suggestedXChromaOffset ) == offsetof( VkAndroidHardwareBufferFormatPropertiesANDROID, suggestedXChromaOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AndroidHardwareBufferFormatPropertiesANDROID, suggestedYChromaOffset ) == offsetof( VkAndroidHardwareBufferFormatPropertiesANDROID, suggestedYChromaOffset ), "struct member and wrapper member have different offset!" );
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

  enum class BlendOverlapEXT
  {
    eUncorrelated = VK_BLEND_OVERLAP_UNCORRELATED_EXT,
    eDisjoint = VK_BLEND_OVERLAP_DISJOINT_EXT,
    eConjoint = VK_BLEND_OVERLAP_CONJOINT_EXT
  };

  struct PipelineColorBlendAdvancedStateCreateInfoEXT
  {
    operator VkPipelineColorBlendAdvancedStateCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(this);
    }

    operator VkPipelineColorBlendAdvancedStateCreateInfoEXT &()
    {
      return *reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(this);
    }

    bool operator==( PipelineColorBlendAdvancedStateCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( srcPremultiplied == rhs.srcPremultiplied )
          && ( dstPremultiplied == rhs.dstPremultiplied )
          && ( blendOverlap == rhs.blendOverlap );
    }

    bool operator!=( PipelineColorBlendAdvancedStateCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineColorBlendAdvancedStateCreateInfoEXT;
    const void* pNext = nullptr;
    Bool32 srcPremultiplied = 0;
    Bool32 dstPremultiplied = 0;
    BlendOverlapEXT blendOverlap = BlendOverlapEXT::eUncorrelated;
  };
  static_assert( sizeof( PipelineColorBlendAdvancedStateCreateInfoEXT ) == sizeof( VkPipelineColorBlendAdvancedStateCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineColorBlendAdvancedStateCreateInfoEXT, pNext ) == offsetof( VkPipelineColorBlendAdvancedStateCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAdvancedStateCreateInfoEXT, srcPremultiplied ) == offsetof( VkPipelineColorBlendAdvancedStateCreateInfoEXT, srcPremultiplied ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAdvancedStateCreateInfoEXT, dstPremultiplied ) == offsetof( VkPipelineColorBlendAdvancedStateCreateInfoEXT, dstPremultiplied ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineColorBlendAdvancedStateCreateInfoEXT, blendOverlap ) == offsetof( VkPipelineColorBlendAdvancedStateCreateInfoEXT, blendOverlap ), "struct member and wrapper member have different offset!" );

  enum class CoverageModulationModeNV
  {
    eNone = VK_COVERAGE_MODULATION_MODE_NONE_NV,
    eRgb = VK_COVERAGE_MODULATION_MODE_RGB_NV,
    eAlpha = VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
    eRgba = VK_COVERAGE_MODULATION_MODE_RGBA_NV
  };

  struct PipelineCoverageModulationStateCreateInfoNV
  {
    operator VkPipelineCoverageModulationStateCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(this);
    }

    operator VkPipelineCoverageModulationStateCreateInfoNV &()
    {
      return *reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(this);
    }

    bool operator==( PipelineCoverageModulationStateCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( coverageModulationMode == rhs.coverageModulationMode )
          && ( coverageModulationTableEnable == rhs.coverageModulationTableEnable )
          && ( coverageModulationTableCount == rhs.coverageModulationTableCount )
          && ( pCoverageModulationTable == rhs.pCoverageModulationTable );
    }

    bool operator!=( PipelineCoverageModulationStateCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineCoverageModulationStateCreateInfoNV;
    const void* pNext = nullptr;
    PipelineCoverageModulationStateCreateFlagsNV flags = PipelineCoverageModulationStateCreateFlagsNV();
    CoverageModulationModeNV coverageModulationMode = CoverageModulationModeNV::eNone;
    Bool32 coverageModulationTableEnable = 0;
    uint32_t coverageModulationTableCount = 0;
    const float* pCoverageModulationTable = nullptr;
  };
  static_assert( sizeof( PipelineCoverageModulationStateCreateInfoNV ) == sizeof( VkPipelineCoverageModulationStateCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineCoverageModulationStateCreateInfoNV, pNext ) == offsetof( VkPipelineCoverageModulationStateCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCoverageModulationStateCreateInfoNV, flags ) == offsetof( VkPipelineCoverageModulationStateCreateInfoNV, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCoverageModulationStateCreateInfoNV, coverageModulationMode ) == offsetof( VkPipelineCoverageModulationStateCreateInfoNV, coverageModulationMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCoverageModulationStateCreateInfoNV, coverageModulationTableEnable ) == offsetof( VkPipelineCoverageModulationStateCreateInfoNV, coverageModulationTableEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCoverageModulationStateCreateInfoNV, coverageModulationTableCount ) == offsetof( VkPipelineCoverageModulationStateCreateInfoNV, coverageModulationTableCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineCoverageModulationStateCreateInfoNV, pCoverageModulationTable ) == offsetof( VkPipelineCoverageModulationStateCreateInfoNV, pCoverageModulationTable ), "struct member and wrapper member have different offset!" );

  enum class ValidationCacheHeaderVersionEXT
  {
    eOne = VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT
  };

  enum class ShaderInfoTypeAMD
  {
    eStatistics = VK_SHADER_INFO_TYPE_STATISTICS_AMD,
    eBinary = VK_SHADER_INFO_TYPE_BINARY_AMD,
    eDisassembly = VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD
  };

  enum class QueueGlobalPriorityEXT
  {
    eLow = VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT,
    eMedium = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT,
    eHigh = VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT,
    eRealtime = VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT
  };

  struct DeviceQueueGlobalPriorityCreateInfoEXT
  {
    operator VkDeviceQueueGlobalPriorityCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(this);
    }

    operator VkDeviceQueueGlobalPriorityCreateInfoEXT &()
    {
      return *reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT*>(this);
    }

    bool operator==( DeviceQueueGlobalPriorityCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( globalPriority == rhs.globalPriority );
    }

    bool operator!=( DeviceQueueGlobalPriorityCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceQueueGlobalPriorityCreateInfoEXT;
    const void* pNext = nullptr;
    QueueGlobalPriorityEXT globalPriority = QueueGlobalPriorityEXT::eLow;
  };
  static_assert( sizeof( DeviceQueueGlobalPriorityCreateInfoEXT ) == sizeof( VkDeviceQueueGlobalPriorityCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceQueueGlobalPriorityCreateInfoEXT, pNext ) == offsetof( VkDeviceQueueGlobalPriorityCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceQueueGlobalPriorityCreateInfoEXT, globalPriority ) == offsetof( VkDeviceQueueGlobalPriorityCreateInfoEXT, globalPriority ), "struct member and wrapper member have different offset!" );

  enum class DebugUtilsMessageSeverityFlagBitsEXT
  {
    eVerbose = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
    eInfo = VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT,
    eWarning = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
    eError = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT
  };

  using DebugUtilsMessageSeverityFlagsEXT = Flags<DebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageSeverityFlagsEXT>;

  VULKAN_HPP_INLINE DebugUtilsMessageSeverityFlagsEXT operator|( DebugUtilsMessageSeverityFlagBitsEXT bit0, DebugUtilsMessageSeverityFlagBitsEXT bit1 )
  {
    return DebugUtilsMessageSeverityFlagsEXT( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DebugUtilsMessageSeverityFlagsEXT operator~( DebugUtilsMessageSeverityFlagBitsEXT bits )
  {
    return ~( DebugUtilsMessageSeverityFlagsEXT( bits ) );
  }

  template <> struct FlagTraits<DebugUtilsMessageSeverityFlagBitsEXT>
  {
    enum
    {
      allFlags = VkFlags(DebugUtilsMessageSeverityFlagBitsEXT::eVerbose) | VkFlags(DebugUtilsMessageSeverityFlagBitsEXT::eInfo) | VkFlags(DebugUtilsMessageSeverityFlagBitsEXT::eWarning) | VkFlags(DebugUtilsMessageSeverityFlagBitsEXT::eError)
    };
  };

  enum class DebugUtilsMessageTypeFlagBitsEXT
  {
    eGeneral = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
    eValidation = VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
    ePerformance = VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT
  };

  using DebugUtilsMessageTypeFlagsEXT = Flags<DebugUtilsMessageTypeFlagBitsEXT, VkDebugUtilsMessageTypeFlagsEXT>;

  VULKAN_HPP_INLINE DebugUtilsMessageTypeFlagsEXT operator|( DebugUtilsMessageTypeFlagBitsEXT bit0, DebugUtilsMessageTypeFlagBitsEXT bit1 )
  {
    return DebugUtilsMessageTypeFlagsEXT( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DebugUtilsMessageTypeFlagsEXT operator~( DebugUtilsMessageTypeFlagBitsEXT bits )
  {
    return ~( DebugUtilsMessageTypeFlagsEXT( bits ) );
  }

  template <> struct FlagTraits<DebugUtilsMessageTypeFlagBitsEXT>
  {
    enum
    {
      allFlags = VkFlags(DebugUtilsMessageTypeFlagBitsEXT::eGeneral) | VkFlags(DebugUtilsMessageTypeFlagBitsEXT::eValidation) | VkFlags(DebugUtilsMessageTypeFlagBitsEXT::ePerformance)
    };
  };

  struct DebugUtilsMessengerCreateInfoEXT
  {
    operator VkDebugUtilsMessengerCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(this);
    }

    operator VkDebugUtilsMessengerCreateInfoEXT &()
    {
      return *reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(this);
    }

    bool operator==( DebugUtilsMessengerCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( messageSeverity == rhs.messageSeverity )
          && ( messageType == rhs.messageType )
          && ( pfnUserCallback == rhs.pfnUserCallback )
          && ( pUserData == rhs.pUserData );
    }

    bool operator!=( DebugUtilsMessengerCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDebugUtilsMessengerCreateInfoEXT;
    const void* pNext = nullptr;
    DebugUtilsMessengerCreateFlagsEXT flags = DebugUtilsMessengerCreateFlagsEXT();
    DebugUtilsMessageSeverityFlagsEXT messageSeverity = DebugUtilsMessageSeverityFlagsEXT();
    DebugUtilsMessageTypeFlagsEXT messageType = DebugUtilsMessageTypeFlagsEXT();
    PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback = nullptr;
    void* pUserData = nullptr;
  };
  static_assert( sizeof( DebugUtilsMessengerCreateInfoEXT ) == sizeof( VkDebugUtilsMessengerCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DebugUtilsMessengerCreateInfoEXT, pNext ) == offsetof( VkDebugUtilsMessengerCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCreateInfoEXT, flags ) == offsetof( VkDebugUtilsMessengerCreateInfoEXT, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCreateInfoEXT, messageSeverity ) == offsetof( VkDebugUtilsMessengerCreateInfoEXT, messageSeverity ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCreateInfoEXT, messageType ) == offsetof( VkDebugUtilsMessengerCreateInfoEXT, messageType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCreateInfoEXT, pfnUserCallback ) == offsetof( VkDebugUtilsMessengerCreateInfoEXT, pfnUserCallback ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DebugUtilsMessengerCreateInfoEXT, pUserData ) == offsetof( VkDebugUtilsMessengerCreateInfoEXT, pUserData ), "struct member and wrapper member have different offset!" );

  enum class ConservativeRasterizationModeEXT
  {
    eDisabled = VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
    eOverestimate = VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
    eUnderestimate = VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT
  };

  struct PipelineRasterizationConservativeStateCreateInfoEXT
  {
    operator VkPipelineRasterizationConservativeStateCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(this);
    }

    operator VkPipelineRasterizationConservativeStateCreateInfoEXT &()
    {
      return *reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(this);
    }

    bool operator==( PipelineRasterizationConservativeStateCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( flags == rhs.flags )
          && ( conservativeRasterizationMode == rhs.conservativeRasterizationMode )
          && ( extraPrimitiveOverestimationSize == rhs.extraPrimitiveOverestimationSize );
    }

    bool operator!=( PipelineRasterizationConservativeStateCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineRasterizationConservativeStateCreateInfoEXT;
    const void* pNext = nullptr;
    PipelineRasterizationConservativeStateCreateFlagsEXT flags = PipelineRasterizationConservativeStateCreateFlagsEXT();
    ConservativeRasterizationModeEXT conservativeRasterizationMode = ConservativeRasterizationModeEXT::eDisabled;
    float extraPrimitiveOverestimationSize = 0;
  };
  static_assert( sizeof( PipelineRasterizationConservativeStateCreateInfoEXT ) == sizeof( VkPipelineRasterizationConservativeStateCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineRasterizationConservativeStateCreateInfoEXT, pNext ) == offsetof( VkPipelineRasterizationConservativeStateCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationConservativeStateCreateInfoEXT, flags ) == offsetof( VkPipelineRasterizationConservativeStateCreateInfoEXT, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationConservativeStateCreateInfoEXT, conservativeRasterizationMode ) == offsetof( VkPipelineRasterizationConservativeStateCreateInfoEXT, conservativeRasterizationMode ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineRasterizationConservativeStateCreateInfoEXT, extraPrimitiveOverestimationSize ) == offsetof( VkPipelineRasterizationConservativeStateCreateInfoEXT, extraPrimitiveOverestimationSize ), "struct member and wrapper member have different offset!" );

  enum class DescriptorBindingFlagBitsEXT
  {
    eUpdateAfterBind = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,
    eUpdateUnusedWhilePending = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
    ePartiallyBound = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT,
    eVariableDescriptorCount = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
  };

  using DescriptorBindingFlagsEXT = Flags<DescriptorBindingFlagBitsEXT, VkDescriptorBindingFlagsEXT>;

  VULKAN_HPP_INLINE DescriptorBindingFlagsEXT operator|( DescriptorBindingFlagBitsEXT bit0, DescriptorBindingFlagBitsEXT bit1 )
  {
    return DescriptorBindingFlagsEXT( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE DescriptorBindingFlagsEXT operator~( DescriptorBindingFlagBitsEXT bits )
  {
    return ~( DescriptorBindingFlagsEXT( bits ) );
  }

  template <> struct FlagTraits<DescriptorBindingFlagBitsEXT>
  {
    enum
    {
      allFlags = VkFlags(DescriptorBindingFlagBitsEXT::eUpdateAfterBind) | VkFlags(DescriptorBindingFlagBitsEXT::eUpdateUnusedWhilePending) | VkFlags(DescriptorBindingFlagBitsEXT::ePartiallyBound) | VkFlags(DescriptorBindingFlagBitsEXT::eVariableDescriptorCount)
    };
  };

  struct DescriptorSetLayoutBindingFlagsCreateInfoEXT
  {
    operator VkDescriptorSetLayoutBindingFlagsCreateInfoEXT const&() const
    {
      return *reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(this);
    }

    operator VkDescriptorSetLayoutBindingFlagsCreateInfoEXT &()
    {
      return *reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(this);
    }

    bool operator==( DescriptorSetLayoutBindingFlagsCreateInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( bindingCount == rhs.bindingCount )
          && ( pBindingFlags == rhs.pBindingFlags );
    }

    bool operator!=( DescriptorSetLayoutBindingFlagsCreateInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDescriptorSetLayoutBindingFlagsCreateInfoEXT;
    const void* pNext = nullptr;
    uint32_t bindingCount = 0;
    const DescriptorBindingFlagsEXT* pBindingFlags = nullptr;
  };
  static_assert( sizeof( DescriptorSetLayoutBindingFlagsCreateInfoEXT ) == sizeof( VkDescriptorSetLayoutBindingFlagsCreateInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( DescriptorSetLayoutBindingFlagsCreateInfoEXT, pNext ) == offsetof( VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutBindingFlagsCreateInfoEXT, bindingCount ) == offsetof( VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, bindingCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DescriptorSetLayoutBindingFlagsCreateInfoEXT, pBindingFlags ) == offsetof( VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, pBindingFlags ), "struct member and wrapper member have different offset!" );

  enum class VendorId
  {
    eViv = VK_VENDOR_ID_VIV,
    eVsi = VK_VENDOR_ID_VSI,
    eKazan = VK_VENDOR_ID_KAZAN
  };

  enum class ConditionalRenderingFlagBitsEXT
  {
    eInverted = VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT
  };

  using ConditionalRenderingFlagsEXT = Flags<ConditionalRenderingFlagBitsEXT, VkConditionalRenderingFlagsEXT>;

  VULKAN_HPP_INLINE ConditionalRenderingFlagsEXT operator|( ConditionalRenderingFlagBitsEXT bit0, ConditionalRenderingFlagBitsEXT bit1 )
  {
    return ConditionalRenderingFlagsEXT( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE ConditionalRenderingFlagsEXT operator~( ConditionalRenderingFlagBitsEXT bits )
  {
    return ~( ConditionalRenderingFlagsEXT( bits ) );
  }

  template <> struct FlagTraits<ConditionalRenderingFlagBitsEXT>
  {
    enum
    {
      allFlags = VkFlags(ConditionalRenderingFlagBitsEXT::eInverted)
    };
  };

  struct ConditionalRenderingBeginInfoEXT
  {
    operator VkConditionalRenderingBeginInfoEXT const&() const
    {
      return *reinterpret_cast<const VkConditionalRenderingBeginInfoEXT*>(this);
    }

    operator VkConditionalRenderingBeginInfoEXT &()
    {
      return *reinterpret_cast<VkConditionalRenderingBeginInfoEXT*>(this);
    }

    bool operator==( ConditionalRenderingBeginInfoEXT const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( buffer == rhs.buffer )
          && ( offset == rhs.offset )
          && ( flags == rhs.flags );
    }

    bool operator!=( ConditionalRenderingBeginInfoEXT const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eConditionalRenderingBeginInfoEXT;
    const void* pNext = nullptr;
    Buffer buffer = Buffer();
    DeviceSize offset = 0;
    ConditionalRenderingFlagsEXT flags = ConditionalRenderingFlagsEXT();
  };
  static_assert( sizeof( ConditionalRenderingBeginInfoEXT ) == sizeof( VkConditionalRenderingBeginInfoEXT ), "struct and wrapper have different size!" );
  static_assert( offsetof( ConditionalRenderingBeginInfoEXT, pNext ) == offsetof( VkConditionalRenderingBeginInfoEXT, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ConditionalRenderingBeginInfoEXT, buffer ) == offsetof( VkConditionalRenderingBeginInfoEXT, buffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ConditionalRenderingBeginInfoEXT, offset ) == offsetof( VkConditionalRenderingBeginInfoEXT, offset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ConditionalRenderingBeginInfoEXT, flags ) == offsetof( VkConditionalRenderingBeginInfoEXT, flags ), "struct member and wrapper member have different offset!" );

  enum class ShadingRatePaletteEntryNV
  {
    eNoInvocations = VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
    e16InvocationsPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
    e8InvocationsPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
    e4InvocationsPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
    e2InvocationsPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
    e1InvocationPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
    e1InvocationPer2X1Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
    e1InvocationPer1X2Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
    e1InvocationPer2X2Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
    e1InvocationPer4X2Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
    e1InvocationPer2X4Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
    e1InvocationPer4X4Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV
  };

  struct ShadingRatePaletteNV
  {
    operator VkShadingRatePaletteNV const&() const
    {
      return *reinterpret_cast<const VkShadingRatePaletteNV*>(this);
    }

    operator VkShadingRatePaletteNV &()
    {
      return *reinterpret_cast<VkShadingRatePaletteNV*>(this);
    }

    bool operator==( ShadingRatePaletteNV const& rhs ) const
    {
      return ( shadingRatePaletteEntryCount == rhs.shadingRatePaletteEntryCount )
          && ( pShadingRatePaletteEntries == rhs.pShadingRatePaletteEntries );
    }

    bool operator!=( ShadingRatePaletteNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    uint32_t shadingRatePaletteEntryCount = 0;
    const ShadingRatePaletteEntryNV* pShadingRatePaletteEntries = nullptr;
  };
  static_assert( sizeof( ShadingRatePaletteNV ) == sizeof( VkShadingRatePaletteNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( ShadingRatePaletteNV, shadingRatePaletteEntryCount ) == offsetof( VkShadingRatePaletteNV, shadingRatePaletteEntryCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( ShadingRatePaletteNV, pShadingRatePaletteEntries ) == offsetof( VkShadingRatePaletteNV, pShadingRatePaletteEntries ), "struct member and wrapper member have different offset!" );

  struct PipelineViewportShadingRateImageStateCreateInfoNV
  {
    operator VkPipelineViewportShadingRateImageStateCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkPipelineViewportShadingRateImageStateCreateInfoNV*>(this);
    }

    operator VkPipelineViewportShadingRateImageStateCreateInfoNV &()
    {
      return *reinterpret_cast<VkPipelineViewportShadingRateImageStateCreateInfoNV*>(this);
    }

    bool operator==( PipelineViewportShadingRateImageStateCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( shadingRateImageEnable == rhs.shadingRateImageEnable )
          && ( viewportCount == rhs.viewportCount )
          && ( pShadingRatePalettes == rhs.pShadingRatePalettes );
    }

    bool operator!=( PipelineViewportShadingRateImageStateCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineViewportShadingRateImageStateCreateInfoNV;
    const void* pNext = nullptr;
    Bool32 shadingRateImageEnable = 0;
    uint32_t viewportCount = 0;
    const ShadingRatePaletteNV* pShadingRatePalettes = nullptr;
  };
  static_assert( sizeof( PipelineViewportShadingRateImageStateCreateInfoNV ) == sizeof( VkPipelineViewportShadingRateImageStateCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineViewportShadingRateImageStateCreateInfoNV, pNext ) == offsetof( VkPipelineViewportShadingRateImageStateCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportShadingRateImageStateCreateInfoNV, shadingRateImageEnable ) == offsetof( VkPipelineViewportShadingRateImageStateCreateInfoNV, shadingRateImageEnable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportShadingRateImageStateCreateInfoNV, viewportCount ) == offsetof( VkPipelineViewportShadingRateImageStateCreateInfoNV, viewportCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportShadingRateImageStateCreateInfoNV, pShadingRatePalettes ) == offsetof( VkPipelineViewportShadingRateImageStateCreateInfoNV, pShadingRatePalettes ), "struct member and wrapper member have different offset!" );

  struct CoarseSampleOrderCustomNV
  {
    operator VkCoarseSampleOrderCustomNV const&() const
    {
      return *reinterpret_cast<const VkCoarseSampleOrderCustomNV*>(this);
    }

    operator VkCoarseSampleOrderCustomNV &()
    {
      return *reinterpret_cast<VkCoarseSampleOrderCustomNV*>(this);
    }

    bool operator==( CoarseSampleOrderCustomNV const& rhs ) const
    {
      return ( shadingRate == rhs.shadingRate )
          && ( sampleCount == rhs.sampleCount )
          && ( sampleLocationCount == rhs.sampleLocationCount )
          && ( pSampleLocations == rhs.pSampleLocations );
    }

    bool operator!=( CoarseSampleOrderCustomNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    ShadingRatePaletteEntryNV shadingRate = ShadingRatePaletteEntryNV::eNoInvocations;
    uint32_t sampleCount = 0;
    uint32_t sampleLocationCount = 0;
    const CoarseSampleLocationNV* pSampleLocations = nullptr;
  };
  static_assert( sizeof( CoarseSampleOrderCustomNV ) == sizeof( VkCoarseSampleOrderCustomNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( CoarseSampleOrderCustomNV, shadingRate ) == offsetof( VkCoarseSampleOrderCustomNV, shadingRate ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CoarseSampleOrderCustomNV, sampleCount ) == offsetof( VkCoarseSampleOrderCustomNV, sampleCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CoarseSampleOrderCustomNV, sampleLocationCount ) == offsetof( VkCoarseSampleOrderCustomNV, sampleLocationCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CoarseSampleOrderCustomNV, pSampleLocations ) == offsetof( VkCoarseSampleOrderCustomNV, pSampleLocations ), "struct member and wrapper member have different offset!" );

  enum class CoarseSampleOrderTypeNV
  {
    eDefault = VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
    eCustom = VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
    ePixelMajor = VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
    eSampleMajor = VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV
  };

  struct PipelineViewportCoarseSampleOrderStateCreateInfoNV
  {
    operator VkPipelineViewportCoarseSampleOrderStateCreateInfoNV const&() const
    {
      return *reinterpret_cast<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(this);
    }

    operator VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &()
    {
      return *reinterpret_cast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(this);
    }

    bool operator==( PipelineViewportCoarseSampleOrderStateCreateInfoNV const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( sampleOrderType == rhs.sampleOrderType )
          && ( customSampleOrderCount == rhs.customSampleOrderCount )
          && ( pCustomSampleOrders == rhs.pCustomSampleOrders );
    }

    bool operator!=( PipelineViewportCoarseSampleOrderStateCreateInfoNV const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePipelineViewportCoarseSampleOrderStateCreateInfoNV;
    const void* pNext = nullptr;
    CoarseSampleOrderTypeNV sampleOrderType = CoarseSampleOrderTypeNV::eDefault;
    uint32_t customSampleOrderCount = 0;
    const CoarseSampleOrderCustomNV* pCustomSampleOrders = nullptr;
  };
  static_assert( sizeof( PipelineViewportCoarseSampleOrderStateCreateInfoNV ) == sizeof( VkPipelineViewportCoarseSampleOrderStateCreateInfoNV ), "struct and wrapper have different size!" );
  static_assert( offsetof( PipelineViewportCoarseSampleOrderStateCreateInfoNV, pNext ) == offsetof( VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportCoarseSampleOrderStateCreateInfoNV, sampleOrderType ) == offsetof( VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, sampleOrderType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportCoarseSampleOrderStateCreateInfoNV, customSampleOrderCount ) == offsetof( VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, customSampleOrderCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PipelineViewportCoarseSampleOrderStateCreateInfoNV, pCustomSampleOrders ) == offsetof( VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, pCustomSampleOrders ), "struct member and wrapper member have different offset!" );

  enum class GeometryInstanceFlagBitsNVX
  {
    eTriangleCullDisable = VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NVX,
    eTriangleCullFlipWinding = VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_FLIP_WINDING_BIT_NVX,
    eForceOpaque = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NVX,
    eForceNoOpaque = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NVX
  };

  using GeometryInstanceFlagsNVX = Flags<GeometryInstanceFlagBitsNVX, VkGeometryInstanceFlagsNVX>;

  VULKAN_HPP_INLINE GeometryInstanceFlagsNVX operator|( GeometryInstanceFlagBitsNVX bit0, GeometryInstanceFlagBitsNVX bit1 )
  {
    return GeometryInstanceFlagsNVX( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE GeometryInstanceFlagsNVX operator~( GeometryInstanceFlagBitsNVX bits )
  {
    return ~( GeometryInstanceFlagsNVX( bits ) );
  }

  template <> struct FlagTraits<GeometryInstanceFlagBitsNVX>
  {
    enum
    {
      allFlags = VkFlags(GeometryInstanceFlagBitsNVX::eTriangleCullDisable) | VkFlags(GeometryInstanceFlagBitsNVX::eTriangleCullFlipWinding) | VkFlags(GeometryInstanceFlagBitsNVX::eForceOpaque) | VkFlags(GeometryInstanceFlagBitsNVX::eForceNoOpaque)
    };
  };

  enum class GeometryFlagBitsNVX
  {
    eOpaque = VK_GEOMETRY_OPAQUE_BIT_NVX,
    eNoDuplicateAnyHitInvocation = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NVX
  };

  using GeometryFlagsNVX = Flags<GeometryFlagBitsNVX, VkGeometryFlagsNVX>;

  VULKAN_HPP_INLINE GeometryFlagsNVX operator|( GeometryFlagBitsNVX bit0, GeometryFlagBitsNVX bit1 )
  {
    return GeometryFlagsNVX( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE GeometryFlagsNVX operator~( GeometryFlagBitsNVX bits )
  {
    return ~( GeometryFlagsNVX( bits ) );
  }

  template <> struct FlagTraits<GeometryFlagBitsNVX>
  {
    enum
    {
      allFlags = VkFlags(GeometryFlagBitsNVX::eOpaque) | VkFlags(GeometryFlagBitsNVX::eNoDuplicateAnyHitInvocation)
    };
  };

  enum class BuildAccelerationStructureFlagBitsNVX
  {
    eAllowUpdate = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NVX,
    eAllowCompaction = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NVX,
    ePreferFastTrace = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NVX,
    ePreferFastBuild = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NVX,
    eLowMemory = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NVX
  };

  using BuildAccelerationStructureFlagsNVX = Flags<BuildAccelerationStructureFlagBitsNVX, VkBuildAccelerationStructureFlagsNVX>;

  VULKAN_HPP_INLINE BuildAccelerationStructureFlagsNVX operator|( BuildAccelerationStructureFlagBitsNVX bit0, BuildAccelerationStructureFlagBitsNVX bit1 )
  {
    return BuildAccelerationStructureFlagsNVX( bit0 ) | bit1;
  }

  VULKAN_HPP_INLINE BuildAccelerationStructureFlagsNVX operator~( BuildAccelerationStructureFlagBitsNVX bits )
  {
    return ~( BuildAccelerationStructureFlagsNVX( bits ) );
  }

  template <> struct FlagTraits<BuildAccelerationStructureFlagBitsNVX>
  {
    enum
    {
      allFlags = VkFlags(BuildAccelerationStructureFlagBitsNVX::eAllowUpdate) | VkFlags(BuildAccelerationStructureFlagBitsNVX::eAllowCompaction) | VkFlags(BuildAccelerationStructureFlagBitsNVX::ePreferFastTrace) | VkFlags(BuildAccelerationStructureFlagBitsNVX::ePreferFastBuild) | VkFlags(BuildAccelerationStructureFlagBitsNVX::eLowMemory)
    };
  };

  enum class CopyAccelerationStructureModeNVX
  {
    eClone = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NVX,
    eCompact = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NVX
  };

  enum class AccelerationStructureTypeNVX
  {
    eTopLevel = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NVX,
    eBottomLevel = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NVX
  };

  enum class GeometryTypeNVX
  {
    eTriangles = VK_GEOMETRY_TYPE_TRIANGLES_NVX,
    eAabbs = VK_GEOMETRY_TYPE_AABBS_NVX
  };

  struct GeometryNVX
  {
    operator VkGeometryNVX const&() const
    {
      return *reinterpret_cast<const VkGeometryNVX*>(this);
    }

    operator VkGeometryNVX &()
    {
      return *reinterpret_cast<VkGeometryNVX*>(this);
    }

    bool operator==( GeometryNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( geometryType == rhs.geometryType )
          && ( geometry == rhs.geometry )
          && ( flags == rhs.flags );
    }

    bool operator!=( GeometryNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eGeometryNVX;
    const void* pNext = nullptr;
    GeometryTypeNVX geometryType = GeometryTypeNVX::eTriangles;
    GeometryDataNVX geometry = GeometryDataNVX();
    GeometryFlagsNVX flags = GeometryFlagsNVX();
  };
  static_assert( sizeof( GeometryNVX ) == sizeof( VkGeometryNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( GeometryNVX, pNext ) == offsetof( VkGeometryNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryNVX, geometryType ) == offsetof( VkGeometryNVX, geometryType ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryNVX, geometry ) == offsetof( VkGeometryNVX, geometry ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( GeometryNVX, flags ) == offsetof( VkGeometryNVX, flags ), "struct member and wrapper member have different offset!" );

  struct AccelerationStructureCreateInfoNVX
  {
    operator VkAccelerationStructureCreateInfoNVX const&() const
    {
      return *reinterpret_cast<const VkAccelerationStructureCreateInfoNVX*>(this);
    }

    operator VkAccelerationStructureCreateInfoNVX &()
    {
      return *reinterpret_cast<VkAccelerationStructureCreateInfoNVX*>(this);
    }

    bool operator==( AccelerationStructureCreateInfoNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( type == rhs.type )
          && ( flags == rhs.flags )
          && ( compactedSize == rhs.compactedSize )
          && ( instanceCount == rhs.instanceCount )
          && ( geometryCount == rhs.geometryCount )
          && ( pGeometries == rhs.pGeometries );
    }

    bool operator!=( AccelerationStructureCreateInfoNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eAccelerationStructureCreateInfoNVX;
    const void* pNext = nullptr;
    AccelerationStructureTypeNVX type = AccelerationStructureTypeNVX::eTopLevel;
    BuildAccelerationStructureFlagsNVX flags = BuildAccelerationStructureFlagsNVX();
    DeviceSize compactedSize = 0;
    uint32_t instanceCount = 0;
    uint32_t geometryCount = 0;
    const GeometryNVX* pGeometries = nullptr;
  };
  static_assert( sizeof( AccelerationStructureCreateInfoNVX ) == sizeof( VkAccelerationStructureCreateInfoNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( AccelerationStructureCreateInfoNVX, pNext ) == offsetof( VkAccelerationStructureCreateInfoNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AccelerationStructureCreateInfoNVX, type ) == offsetof( VkAccelerationStructureCreateInfoNVX, type ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AccelerationStructureCreateInfoNVX, flags ) == offsetof( VkAccelerationStructureCreateInfoNVX, flags ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AccelerationStructureCreateInfoNVX, compactedSize ) == offsetof( VkAccelerationStructureCreateInfoNVX, compactedSize ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AccelerationStructureCreateInfoNVX, instanceCount ) == offsetof( VkAccelerationStructureCreateInfoNVX, instanceCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AccelerationStructureCreateInfoNVX, geometryCount ) == offsetof( VkAccelerationStructureCreateInfoNVX, geometryCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( AccelerationStructureCreateInfoNVX, pGeometries ) == offsetof( VkAccelerationStructureCreateInfoNVX, pGeometries ), "struct member and wrapper member have different offset!" );

  template<typename Dispatch = DispatchLoaderStatic>
  Result enumerateInstanceVersion( uint32_t* pApiVersion, Dispatch const &d = Dispatch() );
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch = DispatchLoaderStatic>
  ResultValueType<uint32_t>::type enumerateInstanceVersion(Dispatch const &d = Dispatch() );
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result enumerateInstanceVersion( uint32_t* pApiVersion, Dispatch const &d)
  {
    return static_cast<Result>( d.vkEnumerateInstanceVersion( pApiVersion ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<uint32_t>::type enumerateInstanceVersion(Dispatch const &d )
  {
    uint32_t apiVersion;
    Result result = static_cast<Result>( d.vkEnumerateInstanceVersion( &apiVersion ) );
    return createResultValue( result, apiVersion, VULKAN_HPP_NAMESPACE_STRING"::enumerateInstanceVersion" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/


  template<typename Dispatch = DispatchLoaderStatic>
  Result enumerateInstanceLayerProperties( uint32_t* pPropertyCount, LayerProperties* pProperties, Dispatch const &d = Dispatch() );
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator = std::allocator<LayerProperties>, typename Dispatch = DispatchLoaderStatic> 
  typename ResultValueType<std::vector<LayerProperties,Allocator>>::type enumerateInstanceLayerProperties(Dispatch const &d = Dispatch() );
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result enumerateInstanceLayerProperties( uint32_t* pPropertyCount, LayerProperties* pProperties, Dispatch const &d)
  {
    return static_cast<Result>( d.vkEnumerateInstanceLayerProperties( pPropertyCount, reinterpret_cast<VkLayerProperties*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<LayerProperties,Allocator>>::type enumerateInstanceLayerProperties(Dispatch const &d )
  {
    std::vector<LayerProperties,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkEnumerateInstanceLayerProperties( &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkEnumerateInstanceLayerProperties( &propertyCount, reinterpret_cast<VkLayerProperties*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::enumerateInstanceLayerProperties" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/


  template<typename Dispatch = DispatchLoaderStatic>
  Result enumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, ExtensionProperties* pProperties, Dispatch const &d = Dispatch() );
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator = std::allocator<ExtensionProperties>, typename Dispatch = DispatchLoaderStatic> 
  typename ResultValueType<std::vector<ExtensionProperties,Allocator>>::type enumerateInstanceExtensionProperties( Optional<const std::string> layerName = nullptr, Dispatch const &d = Dispatch() );
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result enumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, ExtensionProperties* pProperties, Dispatch const &d)
  {
    return static_cast<Result>( d.vkEnumerateInstanceExtensionProperties( pLayerName, pPropertyCount, reinterpret_cast<VkExtensionProperties*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<ExtensionProperties,Allocator>>::type enumerateInstanceExtensionProperties( Optional<const std::string> layerName, Dispatch const &d )
  {
    std::vector<ExtensionProperties,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkEnumerateInstanceExtensionProperties( layerName ? layerName->c_str() : nullptr, &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkEnumerateInstanceExtensionProperties( layerName ? layerName->c_str() : nullptr, &propertyCount, reinterpret_cast<VkExtensionProperties*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::enumerateInstanceExtensionProperties" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/


  // forward declarations
  struct CmdProcessCommandsInfoNVX;

  class CommandBuffer
  {
  public:
    VULKAN_HPP_CONSTEXPR CommandBuffer()
      : m_commandBuffer(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR CommandBuffer( std::nullptr_t )
      : m_commandBuffer(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT CommandBuffer( VkCommandBuffer commandBuffer )
      : m_commandBuffer( commandBuffer )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    CommandBuffer & operator=(VkCommandBuffer commandBuffer)
    {
      m_commandBuffer = commandBuffer;
      return *this; 
    }
#endif

    CommandBuffer & operator=( std::nullptr_t )
    {
      m_commandBuffer = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( CommandBuffer const & rhs ) const
    {
      return m_commandBuffer == rhs.m_commandBuffer;
    }

    bool operator!=(CommandBuffer const & rhs ) const
    {
      return m_commandBuffer != rhs.m_commandBuffer;
    }

    bool operator<(CommandBuffer const & rhs ) const
    {
      return m_commandBuffer < rhs.m_commandBuffer;
    }

    template<typename Dispatch = DispatchLoaderStatic>
    Result begin( const CommandBufferBeginInfo* pBeginInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type begin( const CommandBufferBeginInfo & beginInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result end(Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type end(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result reset( CommandBufferResetFlags flags, Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type reset( CommandBufferResetFlags flags, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void bindPipeline( PipelineBindPoint pipelineBindPoint, Pipeline pipeline, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setViewport( uint32_t firstViewport, uint32_t viewportCount, const Viewport* pViewports, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void setViewport( uint32_t firstViewport, ArrayProxy<const Viewport> viewports, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void setScissor( uint32_t firstScissor, uint32_t scissorCount, const Rect2D* pScissors, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void setScissor( uint32_t firstScissor, ArrayProxy<const Rect2D> scissors, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void setLineWidth( float lineWidth, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setDepthBias( float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setBlendConstants( const float blendConstants[4], Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setDepthBounds( float minDepthBounds, float maxDepthBounds, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setStencilCompareMask( StencilFaceFlags faceMask, uint32_t compareMask, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setStencilWriteMask( StencilFaceFlags faceMask, uint32_t writeMask, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setStencilReference( StencilFaceFlags faceMask, uint32_t reference, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void bindDescriptorSets( PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void bindDescriptorSets( PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, ArrayProxy<const DescriptorSet> descriptorSets, ArrayProxy<const uint32_t> dynamicOffsets, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void bindIndexBuffer( Buffer buffer, DeviceSize offset, IndexType indexType, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void bindVertexBuffers( uint32_t firstBinding, uint32_t bindingCount, const Buffer* pBuffers, const DeviceSize* pOffsets, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void bindVertexBuffers( uint32_t firstBinding, ArrayProxy<const Buffer> buffers, ArrayProxy<const DeviceSize> offsets, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void draw( uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void drawIndexed( uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void drawIndirect( Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void drawIndexedIndirect( Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void dispatch( uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void dispatchIndirect( Buffer buffer, DeviceSize offset, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void copyBuffer( Buffer srcBuffer, Buffer dstBuffer, uint32_t regionCount, const BufferCopy* pRegions, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void copyBuffer( Buffer srcBuffer, Buffer dstBuffer, ArrayProxy<const BufferCopy> regions, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void copyImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageCopy* pRegions, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void copyImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, ArrayProxy<const ImageCopy> regions, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void blitImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageBlit* pRegions, Filter filter, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void blitImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, ArrayProxy<const ImageBlit> regions, Filter filter, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void copyBufferToImage( Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const BufferImageCopy* pRegions, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void copyBufferToImage( Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, ArrayProxy<const BufferImageCopy> regions, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void copyImageToBuffer( Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, uint32_t regionCount, const BufferImageCopy* pRegions, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void copyImageToBuffer( Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, ArrayProxy<const BufferImageCopy> regions, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void updateBuffer( Buffer dstBuffer, DeviceSize dstOffset, DeviceSize dataSize, const void* pData, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename T, typename Dispatch = DispatchLoaderStatic>
    void updateBuffer( Buffer dstBuffer, DeviceSize dstOffset, ArrayProxy<const T> data, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void fillBuffer( Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void clearColorImage( Image image, ImageLayout imageLayout, const ClearColorValue* pColor, uint32_t rangeCount, const ImageSubresourceRange* pRanges, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void clearColorImage( Image image, ImageLayout imageLayout, const ClearColorValue & color, ArrayProxy<const ImageSubresourceRange> ranges, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void clearDepthStencilImage( Image image, ImageLayout imageLayout, const ClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const ImageSubresourceRange* pRanges, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void clearDepthStencilImage( Image image, ImageLayout imageLayout, const ClearDepthStencilValue & depthStencil, ArrayProxy<const ImageSubresourceRange> ranges, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void clearAttachments( uint32_t attachmentCount, const ClearAttachment* pAttachments, uint32_t rectCount, const ClearRect* pRects, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void clearAttachments( ArrayProxy<const ClearAttachment> attachments, ArrayProxy<const ClearRect> rects, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void resolveImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageResolve* pRegions, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void resolveImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, ArrayProxy<const ImageResolve> regions, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void setEvent( Event event, PipelineStageFlags stageMask, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void resetEvent( Event event, PipelineStageFlags stageMask, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void waitEvents( uint32_t eventCount, const Event* pEvents, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const MemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier* pImageMemoryBarriers, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void waitEvents( ArrayProxy<const Event> events, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, ArrayProxy<const MemoryBarrier> memoryBarriers, ArrayProxy<const BufferMemoryBarrier> bufferMemoryBarriers, ArrayProxy<const ImageMemoryBarrier> imageMemoryBarriers, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void pipelineBarrier( PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const MemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier* pImageMemoryBarriers, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void pipelineBarrier( PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, ArrayProxy<const MemoryBarrier> memoryBarriers, ArrayProxy<const BufferMemoryBarrier> bufferMemoryBarriers, ArrayProxy<const ImageMemoryBarrier> imageMemoryBarriers, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void beginQuery( QueryPool queryPool, uint32_t query, QueryControlFlags flags, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void endQuery( QueryPool queryPool, uint32_t query, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void beginConditionalRenderingEXT( const ConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void beginConditionalRenderingEXT( const ConditionalRenderingBeginInfoEXT & conditionalRenderingBegin, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void endConditionalRenderingEXT(Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void resetQueryPool( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void writeTimestamp( PipelineStageFlagBits pipelineStage, QueryPool queryPool, uint32_t query, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void copyQueryPoolResults( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void pushConstants( PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename T, typename Dispatch = DispatchLoaderStatic>
    void pushConstants( PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, ArrayProxy<const T> values, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void beginRenderPass( const RenderPassBeginInfo* pRenderPassBegin, SubpassContents contents, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void beginRenderPass( const RenderPassBeginInfo & renderPassBegin, SubpassContents contents, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void nextSubpass( SubpassContents contents, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void endRenderPass(Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void executeCommands( uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void executeCommands( ArrayProxy<const CommandBuffer> commandBuffers, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void debugMarkerBeginEXT( const DebugMarkerMarkerInfoEXT* pMarkerInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void debugMarkerBeginEXT( const DebugMarkerMarkerInfoEXT & markerInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void debugMarkerEndEXT(Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void debugMarkerInsertEXT( const DebugMarkerMarkerInfoEXT* pMarkerInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void debugMarkerInsertEXT( const DebugMarkerMarkerInfoEXT & markerInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void drawIndirectCountAMD( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void drawIndexedIndirectCountAMD( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void processCommandsNVX( const CmdProcessCommandsInfoNVX* pProcessCommandsInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void processCommandsNVX( const CmdProcessCommandsInfoNVX & processCommandsInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void reserveSpaceForCommandsNVX( const CmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void reserveSpaceForCommandsNVX( const CmdReserveSpaceForCommandsInfoNVX & reserveSpaceInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void pushDescriptorSetKHR( PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const WriteDescriptorSet* pDescriptorWrites, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void pushDescriptorSetKHR( PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, ArrayProxy<const WriteDescriptorSet> descriptorWrites, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void setDeviceMask( uint32_t deviceMask, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setDeviceMaskKHR( uint32_t deviceMask, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void dispatchBase( uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void dispatchBaseKHR( uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void pushDescriptorSetWithTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate, PipelineLayout layout, uint32_t set, const void* pData, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setViewportWScalingNV( uint32_t firstViewport, uint32_t viewportCount, const ViewportWScalingNV* pViewportWScalings, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void setViewportWScalingNV( uint32_t firstViewport, ArrayProxy<const ViewportWScalingNV> viewportWScalings, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void setDiscardRectangleEXT( uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const Rect2D* pDiscardRectangles, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void setDiscardRectangleEXT( uint32_t firstDiscardRectangle, ArrayProxy<const Rect2D> discardRectangles, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void setSampleLocationsEXT( const SampleLocationsInfoEXT* pSampleLocationsInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void setSampleLocationsEXT( const SampleLocationsInfoEXT & sampleLocationsInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void beginDebugUtilsLabelEXT( const DebugUtilsLabelEXT* pLabelInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void beginDebugUtilsLabelEXT( const DebugUtilsLabelEXT & labelInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void endDebugUtilsLabelEXT(Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void insertDebugUtilsLabelEXT( const DebugUtilsLabelEXT* pLabelInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void insertDebugUtilsLabelEXT( const DebugUtilsLabelEXT & labelInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void writeBufferMarkerAMD( PipelineStageFlagBits pipelineStage, Buffer dstBuffer, DeviceSize dstOffset, uint32_t marker, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void beginRenderPass2KHR( const RenderPassBeginInfo* pRenderPassBegin, const SubpassBeginInfoKHR* pSubpassBeginInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void beginRenderPass2KHR( const RenderPassBeginInfo & renderPassBegin, const SubpassBeginInfoKHR & subpassBeginInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void nextSubpass2KHR( const SubpassBeginInfoKHR* pSubpassBeginInfo, const SubpassEndInfoKHR* pSubpassEndInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void nextSubpass2KHR( const SubpassBeginInfoKHR & subpassBeginInfo, const SubpassEndInfoKHR & subpassEndInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void endRenderPass2KHR( const SubpassEndInfoKHR* pSubpassEndInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void endRenderPass2KHR( const SubpassEndInfoKHR & subpassEndInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void drawIndirectCountKHR( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void drawIndexedIndirectCountKHR( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setCheckpointNV( const void* pCheckpointMarker, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setExclusiveScissorNV( uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const Rect2D* pExclusiveScissors, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void setExclusiveScissorNV( uint32_t firstExclusiveScissor, ArrayProxy<const Rect2D> exclusiveScissors, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void bindShadingRateImageNV( ImageView imageView, ImageLayout imageLayout, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setViewportShadingRatePaletteNV( uint32_t firstViewport, uint32_t viewportCount, const ShadingRatePaletteNV* pShadingRatePalettes, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void setViewportShadingRatePaletteNV( uint32_t firstViewport, ArrayProxy<const ShadingRatePaletteNV> shadingRatePalettes, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void setCoarseSampleOrderNV( CoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const CoarseSampleOrderCustomNV* pCustomSampleOrders, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void setCoarseSampleOrderNV( CoarseSampleOrderTypeNV sampleOrderType, ArrayProxy<const CoarseSampleOrderCustomNV> customSampleOrders, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void drawMeshTasksNV( uint32_t taskCount, uint32_t firstTask, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void drawMeshTasksIndirectNV( Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void drawMeshTasksIndirectCountNV( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void copyAccelerationStructureNVX( AccelerationStructureNVX dst, AccelerationStructureNVX src, CopyAccelerationStructureModeNVX mode, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void writeAccelerationStructurePropertiesNVX( AccelerationStructureNVX accelerationStructure, QueryType queryType, QueryPool queryPool, uint32_t query, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void buildAccelerationStructureNVX( AccelerationStructureTypeNVX type, uint32_t instanceCount, Buffer instanceData, DeviceSize instanceOffset, uint32_t geometryCount, const GeometryNVX* pGeometries, BuildAccelerationStructureFlagsNVX flags, Bool32 update, AccelerationStructureNVX dst, AccelerationStructureNVX src, Buffer scratch, DeviceSize scratchOffset, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void buildAccelerationStructureNVX( AccelerationStructureTypeNVX type, uint32_t instanceCount, Buffer instanceData, DeviceSize instanceOffset, ArrayProxy<const GeometryNVX> geometries, BuildAccelerationStructureFlagsNVX flags, Bool32 update, AccelerationStructureNVX dst, AccelerationStructureNVX src, Buffer scratch, DeviceSize scratchOffset, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void traceRaysNVX( Buffer raygenShaderBindingTableBuffer, DeviceSize raygenShaderBindingOffset, Buffer missShaderBindingTableBuffer, DeviceSize missShaderBindingOffset, DeviceSize missShaderBindingStride, Buffer hitShaderBindingTableBuffer, DeviceSize hitShaderBindingOffset, DeviceSize hitShaderBindingStride, uint32_t width, uint32_t height, Dispatch const &d = Dispatch() ) const;



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkCommandBuffer() const
    {
      return m_commandBuffer;
    }

    explicit operator bool() const
    {
      return m_commandBuffer != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_commandBuffer == VK_NULL_HANDLE;
    }

  private:
    VkCommandBuffer m_commandBuffer;
  };

  static_assert( sizeof( CommandBuffer ) == sizeof( VkCommandBuffer ), "handle and wrapper have different size!" );

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result CommandBuffer::begin( const CommandBufferBeginInfo* pBeginInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkBeginCommandBuffer( m_commandBuffer, reinterpret_cast<const VkCommandBufferBeginInfo*>( pBeginInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type CommandBuffer::begin( const CommandBufferBeginInfo & beginInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkBeginCommandBuffer( m_commandBuffer, reinterpret_cast<const VkCommandBufferBeginInfo*>( &beginInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::CommandBuffer::begin" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result CommandBuffer::end(Dispatch const &d) const
  {
    return static_cast<Result>( d.vkEndCommandBuffer( m_commandBuffer ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type CommandBuffer::end(Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkEndCommandBuffer( m_commandBuffer ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::CommandBuffer::end" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result CommandBuffer::reset( CommandBufferResetFlags flags, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkResetCommandBuffer( m_commandBuffer, static_cast<VkCommandBufferResetFlags>( flags ) ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type CommandBuffer::reset( CommandBufferResetFlags flags, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkResetCommandBuffer( m_commandBuffer, static_cast<VkCommandBufferResetFlags>( flags ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::CommandBuffer::reset" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindPipeline( PipelineBindPoint pipelineBindPoint, Pipeline pipeline, Dispatch const &d) const
  {
    d.vkCmdBindPipeline( m_commandBuffer, static_cast<VkPipelineBindPoint>( pipelineBindPoint ), static_cast<VkPipeline>( pipeline ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindPipeline( PipelineBindPoint pipelineBindPoint, Pipeline pipeline, Dispatch const &d ) const
  {
    d.vkCmdBindPipeline( m_commandBuffer, static_cast<VkPipelineBindPoint>( pipelineBindPoint ), static_cast<VkPipeline>( pipeline ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setViewport( uint32_t firstViewport, uint32_t viewportCount, const Viewport* pViewports, Dispatch const &d) const
  {
    d.vkCmdSetViewport( m_commandBuffer, firstViewport, viewportCount, reinterpret_cast<const VkViewport*>( pViewports ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setViewport( uint32_t firstViewport, ArrayProxy<const Viewport> viewports, Dispatch const &d ) const
  {
    d.vkCmdSetViewport( m_commandBuffer, firstViewport, viewports.size() , reinterpret_cast<const VkViewport*>( viewports.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setScissor( uint32_t firstScissor, uint32_t scissorCount, const Rect2D* pScissors, Dispatch const &d) const
  {
    d.vkCmdSetScissor( m_commandBuffer, firstScissor, scissorCount, reinterpret_cast<const VkRect2D*>( pScissors ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setScissor( uint32_t firstScissor, ArrayProxy<const Rect2D> scissors, Dispatch const &d ) const
  {
    d.vkCmdSetScissor( m_commandBuffer, firstScissor, scissors.size() , reinterpret_cast<const VkRect2D*>( scissors.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setLineWidth( float lineWidth, Dispatch const &d) const
  {
    d.vkCmdSetLineWidth( m_commandBuffer, lineWidth );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setLineWidth( float lineWidth, Dispatch const &d ) const
  {
    d.vkCmdSetLineWidth( m_commandBuffer, lineWidth );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDepthBias( float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor, Dispatch const &d) const
  {
    d.vkCmdSetDepthBias( m_commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDepthBias( float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor, Dispatch const &d ) const
  {
    d.vkCmdSetDepthBias( m_commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setBlendConstants( const float blendConstants[4], Dispatch const &d) const
  {
    d.vkCmdSetBlendConstants( m_commandBuffer, blendConstants );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setBlendConstants( const float blendConstants[4], Dispatch const &d ) const
  {
    d.vkCmdSetBlendConstants( m_commandBuffer, blendConstants );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDepthBounds( float minDepthBounds, float maxDepthBounds, Dispatch const &d) const
  {
    d.vkCmdSetDepthBounds( m_commandBuffer, minDepthBounds, maxDepthBounds );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDepthBounds( float minDepthBounds, float maxDepthBounds, Dispatch const &d ) const
  {
    d.vkCmdSetDepthBounds( m_commandBuffer, minDepthBounds, maxDepthBounds );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setStencilCompareMask( StencilFaceFlags faceMask, uint32_t compareMask, Dispatch const &d) const
  {
    d.vkCmdSetStencilCompareMask( m_commandBuffer, static_cast<VkStencilFaceFlags>( faceMask ), compareMask );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setStencilCompareMask( StencilFaceFlags faceMask, uint32_t compareMask, Dispatch const &d ) const
  {
    d.vkCmdSetStencilCompareMask( m_commandBuffer, static_cast<VkStencilFaceFlags>( faceMask ), compareMask );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setStencilWriteMask( StencilFaceFlags faceMask, uint32_t writeMask, Dispatch const &d) const
  {
    d.vkCmdSetStencilWriteMask( m_commandBuffer, static_cast<VkStencilFaceFlags>( faceMask ), writeMask );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setStencilWriteMask( StencilFaceFlags faceMask, uint32_t writeMask, Dispatch const &d ) const
  {
    d.vkCmdSetStencilWriteMask( m_commandBuffer, static_cast<VkStencilFaceFlags>( faceMask ), writeMask );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setStencilReference( StencilFaceFlags faceMask, uint32_t reference, Dispatch const &d) const
  {
    d.vkCmdSetStencilReference( m_commandBuffer, static_cast<VkStencilFaceFlags>( faceMask ), reference );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setStencilReference( StencilFaceFlags faceMask, uint32_t reference, Dispatch const &d ) const
  {
    d.vkCmdSetStencilReference( m_commandBuffer, static_cast<VkStencilFaceFlags>( faceMask ), reference );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindDescriptorSets( PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets, Dispatch const &d) const
  {
    d.vkCmdBindDescriptorSets( m_commandBuffer, static_cast<VkPipelineBindPoint>( pipelineBindPoint ), static_cast<VkPipelineLayout>( layout ), firstSet, descriptorSetCount, reinterpret_cast<const VkDescriptorSet*>( pDescriptorSets ), dynamicOffsetCount, pDynamicOffsets );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindDescriptorSets( PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, ArrayProxy<const DescriptorSet> descriptorSets, ArrayProxy<const uint32_t> dynamicOffsets, Dispatch const &d ) const
  {
    d.vkCmdBindDescriptorSets( m_commandBuffer, static_cast<VkPipelineBindPoint>( pipelineBindPoint ), static_cast<VkPipelineLayout>( layout ), firstSet, descriptorSets.size() , reinterpret_cast<const VkDescriptorSet*>( descriptorSets.data() ), dynamicOffsets.size() , dynamicOffsets.data() );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindIndexBuffer( Buffer buffer, DeviceSize offset, IndexType indexType, Dispatch const &d) const
  {
    d.vkCmdBindIndexBuffer( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkIndexType>( indexType ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindIndexBuffer( Buffer buffer, DeviceSize offset, IndexType indexType, Dispatch const &d ) const
  {
    d.vkCmdBindIndexBuffer( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkIndexType>( indexType ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindVertexBuffers( uint32_t firstBinding, uint32_t bindingCount, const Buffer* pBuffers, const DeviceSize* pOffsets, Dispatch const &d) const
  {
    d.vkCmdBindVertexBuffers( m_commandBuffer, firstBinding, bindingCount, reinterpret_cast<const VkBuffer*>( pBuffers ), pOffsets );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindVertexBuffers( uint32_t firstBinding, ArrayProxy<const Buffer> buffers, ArrayProxy<const DeviceSize> offsets, Dispatch const &d ) const
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( buffers.size() == offsets.size() );
#else
    if ( buffers.size() != offsets.size() )
    {
      throw LogicError( VULKAN_HPP_NAMESPACE_STRING "::CommandBuffer::bindVertexBuffers: buffers.size() != offsets.size()" );
    }
#endif  // VULKAN_HPP_NO_EXCEPTIONS
    d.vkCmdBindVertexBuffers( m_commandBuffer, firstBinding, buffers.size() , reinterpret_cast<const VkBuffer*>( buffers.data() ), offsets.data() );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::draw( uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance, Dispatch const &d) const
  {
    d.vkCmdDraw( m_commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::draw( uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance, Dispatch const &d ) const
  {
    d.vkCmdDraw( m_commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndexed( uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance, Dispatch const &d) const
  {
    d.vkCmdDrawIndexed( m_commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndexed( uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance, Dispatch const &d ) const
  {
    d.vkCmdDrawIndexed( m_commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndirect( Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, Dispatch const &d) const
  {
    d.vkCmdDrawIndirect( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, drawCount, stride );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndirect( Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, Dispatch const &d ) const
  {
    d.vkCmdDrawIndirect( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, drawCount, stride );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndexedIndirect( Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, Dispatch const &d) const
  {
    d.vkCmdDrawIndexedIndirect( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, drawCount, stride );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndexedIndirect( Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, Dispatch const &d ) const
  {
    d.vkCmdDrawIndexedIndirect( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, drawCount, stride );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::dispatch( uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, Dispatch const &d) const
  {
    d.vkCmdDispatch( m_commandBuffer, groupCountX, groupCountY, groupCountZ );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::dispatch( uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, Dispatch const &d ) const
  {
    d.vkCmdDispatch( m_commandBuffer, groupCountX, groupCountY, groupCountZ );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::dispatchIndirect( Buffer buffer, DeviceSize offset, Dispatch const &d) const
  {
    d.vkCmdDispatchIndirect( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::dispatchIndirect( Buffer buffer, DeviceSize offset, Dispatch const &d ) const
  {
    d.vkCmdDispatchIndirect( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyBuffer( Buffer srcBuffer, Buffer dstBuffer, uint32_t regionCount, const BufferCopy* pRegions, Dispatch const &d) const
  {
    d.vkCmdCopyBuffer( m_commandBuffer, static_cast<VkBuffer>( srcBuffer ), static_cast<VkBuffer>( dstBuffer ), regionCount, reinterpret_cast<const VkBufferCopy*>( pRegions ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyBuffer( Buffer srcBuffer, Buffer dstBuffer, ArrayProxy<const BufferCopy> regions, Dispatch const &d ) const
  {
    d.vkCmdCopyBuffer( m_commandBuffer, static_cast<VkBuffer>( srcBuffer ), static_cast<VkBuffer>( dstBuffer ), regions.size() , reinterpret_cast<const VkBufferCopy*>( regions.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageCopy* pRegions, Dispatch const &d) const
  {
    d.vkCmdCopyImage( m_commandBuffer, static_cast<VkImage>( srcImage ), static_cast<VkImageLayout>( srcImageLayout ), static_cast<VkImage>( dstImage ), static_cast<VkImageLayout>( dstImageLayout ), regionCount, reinterpret_cast<const VkImageCopy*>( pRegions ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, ArrayProxy<const ImageCopy> regions, Dispatch const &d ) const
  {
    d.vkCmdCopyImage( m_commandBuffer, static_cast<VkImage>( srcImage ), static_cast<VkImageLayout>( srcImageLayout ), static_cast<VkImage>( dstImage ), static_cast<VkImageLayout>( dstImageLayout ), regions.size() , reinterpret_cast<const VkImageCopy*>( regions.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::blitImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageBlit* pRegions, Filter filter, Dispatch const &d) const
  {
    d.vkCmdBlitImage( m_commandBuffer, static_cast<VkImage>( srcImage ), static_cast<VkImageLayout>( srcImageLayout ), static_cast<VkImage>( dstImage ), static_cast<VkImageLayout>( dstImageLayout ), regionCount, reinterpret_cast<const VkImageBlit*>( pRegions ), static_cast<VkFilter>( filter ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::blitImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, ArrayProxy<const ImageBlit> regions, Filter filter, Dispatch const &d ) const
  {
    d.vkCmdBlitImage( m_commandBuffer, static_cast<VkImage>( srcImage ), static_cast<VkImageLayout>( srcImageLayout ), static_cast<VkImage>( dstImage ), static_cast<VkImageLayout>( dstImageLayout ), regions.size() , reinterpret_cast<const VkImageBlit*>( regions.data() ), static_cast<VkFilter>( filter ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyBufferToImage( Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const BufferImageCopy* pRegions, Dispatch const &d) const
  {
    d.vkCmdCopyBufferToImage( m_commandBuffer, static_cast<VkBuffer>( srcBuffer ), static_cast<VkImage>( dstImage ), static_cast<VkImageLayout>( dstImageLayout ), regionCount, reinterpret_cast<const VkBufferImageCopy*>( pRegions ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyBufferToImage( Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, ArrayProxy<const BufferImageCopy> regions, Dispatch const &d ) const
  {
    d.vkCmdCopyBufferToImage( m_commandBuffer, static_cast<VkBuffer>( srcBuffer ), static_cast<VkImage>( dstImage ), static_cast<VkImageLayout>( dstImageLayout ), regions.size() , reinterpret_cast<const VkBufferImageCopy*>( regions.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyImageToBuffer( Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, uint32_t regionCount, const BufferImageCopy* pRegions, Dispatch const &d) const
  {
    d.vkCmdCopyImageToBuffer( m_commandBuffer, static_cast<VkImage>( srcImage ), static_cast<VkImageLayout>( srcImageLayout ), static_cast<VkBuffer>( dstBuffer ), regionCount, reinterpret_cast<const VkBufferImageCopy*>( pRegions ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyImageToBuffer( Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, ArrayProxy<const BufferImageCopy> regions, Dispatch const &d ) const
  {
    d.vkCmdCopyImageToBuffer( m_commandBuffer, static_cast<VkImage>( srcImage ), static_cast<VkImageLayout>( srcImageLayout ), static_cast<VkBuffer>( dstBuffer ), regions.size() , reinterpret_cast<const VkBufferImageCopy*>( regions.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::updateBuffer( Buffer dstBuffer, DeviceSize dstOffset, DeviceSize dataSize, const void* pData, Dispatch const &d) const
  {
    d.vkCmdUpdateBuffer( m_commandBuffer, static_cast<VkBuffer>( dstBuffer ), dstOffset, dataSize, pData );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename T, typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::updateBuffer( Buffer dstBuffer, DeviceSize dstOffset, ArrayProxy<const T> data, Dispatch const &d ) const
  {
    d.vkCmdUpdateBuffer( m_commandBuffer, static_cast<VkBuffer>( dstBuffer ), dstOffset, data.size() * sizeof( T ) , reinterpret_cast<const void*>( data.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::fillBuffer( Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data, Dispatch const &d) const
  {
    d.vkCmdFillBuffer( m_commandBuffer, static_cast<VkBuffer>( dstBuffer ), dstOffset, size, data );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::fillBuffer( Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data, Dispatch const &d ) const
  {
    d.vkCmdFillBuffer( m_commandBuffer, static_cast<VkBuffer>( dstBuffer ), dstOffset, size, data );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::clearColorImage( Image image, ImageLayout imageLayout, const ClearColorValue* pColor, uint32_t rangeCount, const ImageSubresourceRange* pRanges, Dispatch const &d) const
  {
    d.vkCmdClearColorImage( m_commandBuffer, static_cast<VkImage>( image ), static_cast<VkImageLayout>( imageLayout ), reinterpret_cast<const VkClearColorValue*>( pColor ), rangeCount, reinterpret_cast<const VkImageSubresourceRange*>( pRanges ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::clearColorImage( Image image, ImageLayout imageLayout, const ClearColorValue & color, ArrayProxy<const ImageSubresourceRange> ranges, Dispatch const &d ) const
  {
    d.vkCmdClearColorImage( m_commandBuffer, static_cast<VkImage>( image ), static_cast<VkImageLayout>( imageLayout ), reinterpret_cast<const VkClearColorValue*>( &color ), ranges.size() , reinterpret_cast<const VkImageSubresourceRange*>( ranges.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::clearDepthStencilImage( Image image, ImageLayout imageLayout, const ClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const ImageSubresourceRange* pRanges, Dispatch const &d) const
  {
    d.vkCmdClearDepthStencilImage( m_commandBuffer, static_cast<VkImage>( image ), static_cast<VkImageLayout>( imageLayout ), reinterpret_cast<const VkClearDepthStencilValue*>( pDepthStencil ), rangeCount, reinterpret_cast<const VkImageSubresourceRange*>( pRanges ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::clearDepthStencilImage( Image image, ImageLayout imageLayout, const ClearDepthStencilValue & depthStencil, ArrayProxy<const ImageSubresourceRange> ranges, Dispatch const &d ) const
  {
    d.vkCmdClearDepthStencilImage( m_commandBuffer, static_cast<VkImage>( image ), static_cast<VkImageLayout>( imageLayout ), reinterpret_cast<const VkClearDepthStencilValue*>( &depthStencil ), ranges.size() , reinterpret_cast<const VkImageSubresourceRange*>( ranges.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::clearAttachments( uint32_t attachmentCount, const ClearAttachment* pAttachments, uint32_t rectCount, const ClearRect* pRects, Dispatch const &d) const
  {
    d.vkCmdClearAttachments( m_commandBuffer, attachmentCount, reinterpret_cast<const VkClearAttachment*>( pAttachments ), rectCount, reinterpret_cast<const VkClearRect*>( pRects ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::clearAttachments( ArrayProxy<const ClearAttachment> attachments, ArrayProxy<const ClearRect> rects, Dispatch const &d ) const
  {
    d.vkCmdClearAttachments( m_commandBuffer, attachments.size() , reinterpret_cast<const VkClearAttachment*>( attachments.data() ), rects.size() , reinterpret_cast<const VkClearRect*>( rects.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::resolveImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageResolve* pRegions, Dispatch const &d) const
  {
    d.vkCmdResolveImage( m_commandBuffer, static_cast<VkImage>( srcImage ), static_cast<VkImageLayout>( srcImageLayout ), static_cast<VkImage>( dstImage ), static_cast<VkImageLayout>( dstImageLayout ), regionCount, reinterpret_cast<const VkImageResolve*>( pRegions ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::resolveImage( Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, ArrayProxy<const ImageResolve> regions, Dispatch const &d ) const
  {
    d.vkCmdResolveImage( m_commandBuffer, static_cast<VkImage>( srcImage ), static_cast<VkImageLayout>( srcImageLayout ), static_cast<VkImage>( dstImage ), static_cast<VkImageLayout>( dstImageLayout ), regions.size() , reinterpret_cast<const VkImageResolve*>( regions.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setEvent( Event event, PipelineStageFlags stageMask, Dispatch const &d) const
  {
    d.vkCmdSetEvent( m_commandBuffer, static_cast<VkEvent>( event ), static_cast<VkPipelineStageFlags>( stageMask ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setEvent( Event event, PipelineStageFlags stageMask, Dispatch const &d ) const
  {
    d.vkCmdSetEvent( m_commandBuffer, static_cast<VkEvent>( event ), static_cast<VkPipelineStageFlags>( stageMask ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::resetEvent( Event event, PipelineStageFlags stageMask, Dispatch const &d) const
  {
    d.vkCmdResetEvent( m_commandBuffer, static_cast<VkEvent>( event ), static_cast<VkPipelineStageFlags>( stageMask ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::resetEvent( Event event, PipelineStageFlags stageMask, Dispatch const &d ) const
  {
    d.vkCmdResetEvent( m_commandBuffer, static_cast<VkEvent>( event ), static_cast<VkPipelineStageFlags>( stageMask ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::waitEvents( uint32_t eventCount, const Event* pEvents, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const MemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier* pImageMemoryBarriers, Dispatch const &d) const
  {
    d.vkCmdWaitEvents( m_commandBuffer, eventCount, reinterpret_cast<const VkEvent*>( pEvents ), static_cast<VkPipelineStageFlags>( srcStageMask ), static_cast<VkPipelineStageFlags>( dstStageMask ), memoryBarrierCount, reinterpret_cast<const VkMemoryBarrier*>( pMemoryBarriers ), bufferMemoryBarrierCount, reinterpret_cast<const VkBufferMemoryBarrier*>( pBufferMemoryBarriers ), imageMemoryBarrierCount, reinterpret_cast<const VkImageMemoryBarrier*>( pImageMemoryBarriers ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::waitEvents( ArrayProxy<const Event> events, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, ArrayProxy<const MemoryBarrier> memoryBarriers, ArrayProxy<const BufferMemoryBarrier> bufferMemoryBarriers, ArrayProxy<const ImageMemoryBarrier> imageMemoryBarriers, Dispatch const &d ) const
  {
    d.vkCmdWaitEvents( m_commandBuffer, events.size() , reinterpret_cast<const VkEvent*>( events.data() ), static_cast<VkPipelineStageFlags>( srcStageMask ), static_cast<VkPipelineStageFlags>( dstStageMask ), memoryBarriers.size() , reinterpret_cast<const VkMemoryBarrier*>( memoryBarriers.data() ), bufferMemoryBarriers.size() , reinterpret_cast<const VkBufferMemoryBarrier*>( bufferMemoryBarriers.data() ), imageMemoryBarriers.size() , reinterpret_cast<const VkImageMemoryBarrier*>( imageMemoryBarriers.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::pipelineBarrier( PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const MemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier* pImageMemoryBarriers, Dispatch const &d) const
  {
    d.vkCmdPipelineBarrier( m_commandBuffer, static_cast<VkPipelineStageFlags>( srcStageMask ), static_cast<VkPipelineStageFlags>( dstStageMask ), static_cast<VkDependencyFlags>( dependencyFlags ), memoryBarrierCount, reinterpret_cast<const VkMemoryBarrier*>( pMemoryBarriers ), bufferMemoryBarrierCount, reinterpret_cast<const VkBufferMemoryBarrier*>( pBufferMemoryBarriers ), imageMemoryBarrierCount, reinterpret_cast<const VkImageMemoryBarrier*>( pImageMemoryBarriers ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::pipelineBarrier( PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, ArrayProxy<const MemoryBarrier> memoryBarriers, ArrayProxy<const BufferMemoryBarrier> bufferMemoryBarriers, ArrayProxy<const ImageMemoryBarrier> imageMemoryBarriers, Dispatch const &d ) const
  {
    d.vkCmdPipelineBarrier( m_commandBuffer, static_cast<VkPipelineStageFlags>( srcStageMask ), static_cast<VkPipelineStageFlags>( dstStageMask ), static_cast<VkDependencyFlags>( dependencyFlags ), memoryBarriers.size() , reinterpret_cast<const VkMemoryBarrier*>( memoryBarriers.data() ), bufferMemoryBarriers.size() , reinterpret_cast<const VkBufferMemoryBarrier*>( bufferMemoryBarriers.data() ), imageMemoryBarriers.size() , reinterpret_cast<const VkImageMemoryBarrier*>( imageMemoryBarriers.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginQuery( QueryPool queryPool, uint32_t query, QueryControlFlags flags, Dispatch const &d) const
  {
    d.vkCmdBeginQuery( m_commandBuffer, static_cast<VkQueryPool>( queryPool ), query, static_cast<VkQueryControlFlags>( flags ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginQuery( QueryPool queryPool, uint32_t query, QueryControlFlags flags, Dispatch const &d ) const
  {
    d.vkCmdBeginQuery( m_commandBuffer, static_cast<VkQueryPool>( queryPool ), query, static_cast<VkQueryControlFlags>( flags ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endQuery( QueryPool queryPool, uint32_t query, Dispatch const &d) const
  {
    d.vkCmdEndQuery( m_commandBuffer, static_cast<VkQueryPool>( queryPool ), query );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endQuery( QueryPool queryPool, uint32_t query, Dispatch const &d ) const
  {
    d.vkCmdEndQuery( m_commandBuffer, static_cast<VkQueryPool>( queryPool ), query );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginConditionalRenderingEXT( const ConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin, Dispatch const &d) const
  {
    d.vkCmdBeginConditionalRenderingEXT( m_commandBuffer, reinterpret_cast<const VkConditionalRenderingBeginInfoEXT*>( pConditionalRenderingBegin ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginConditionalRenderingEXT( const ConditionalRenderingBeginInfoEXT & conditionalRenderingBegin, Dispatch const &d ) const
  {
    d.vkCmdBeginConditionalRenderingEXT( m_commandBuffer, reinterpret_cast<const VkConditionalRenderingBeginInfoEXT*>( &conditionalRenderingBegin ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endConditionalRenderingEXT(Dispatch const &d) const
  {
    d.vkCmdEndConditionalRenderingEXT( m_commandBuffer );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endConditionalRenderingEXT(Dispatch const &d ) const
  {
    d.vkCmdEndConditionalRenderingEXT( m_commandBuffer );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::resetQueryPool( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Dispatch const &d) const
  {
    d.vkCmdResetQueryPool( m_commandBuffer, static_cast<VkQueryPool>( queryPool ), firstQuery, queryCount );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::resetQueryPool( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Dispatch const &d ) const
  {
    d.vkCmdResetQueryPool( m_commandBuffer, static_cast<VkQueryPool>( queryPool ), firstQuery, queryCount );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::writeTimestamp( PipelineStageFlagBits pipelineStage, QueryPool queryPool, uint32_t query, Dispatch const &d) const
  {
    d.vkCmdWriteTimestamp( m_commandBuffer, static_cast<VkPipelineStageFlagBits>( pipelineStage ), static_cast<VkQueryPool>( queryPool ), query );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::writeTimestamp( PipelineStageFlagBits pipelineStage, QueryPool queryPool, uint32_t query, Dispatch const &d ) const
  {
    d.vkCmdWriteTimestamp( m_commandBuffer, static_cast<VkPipelineStageFlagBits>( pipelineStage ), static_cast<VkQueryPool>( queryPool ), query );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyQueryPoolResults( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags, Dispatch const &d) const
  {
    d.vkCmdCopyQueryPoolResults( m_commandBuffer, static_cast<VkQueryPool>( queryPool ), firstQuery, queryCount, static_cast<VkBuffer>( dstBuffer ), dstOffset, stride, static_cast<VkQueryResultFlags>( flags ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyQueryPoolResults( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags, Dispatch const &d ) const
  {
    d.vkCmdCopyQueryPoolResults( m_commandBuffer, static_cast<VkQueryPool>( queryPool ), firstQuery, queryCount, static_cast<VkBuffer>( dstBuffer ), dstOffset, stride, static_cast<VkQueryResultFlags>( flags ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::pushConstants( PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues, Dispatch const &d) const
  {
    d.vkCmdPushConstants( m_commandBuffer, static_cast<VkPipelineLayout>( layout ), static_cast<VkShaderStageFlags>( stageFlags ), offset, size, pValues );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename T, typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::pushConstants( PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, ArrayProxy<const T> values, Dispatch const &d ) const
  {
    d.vkCmdPushConstants( m_commandBuffer, static_cast<VkPipelineLayout>( layout ), static_cast<VkShaderStageFlags>( stageFlags ), offset, values.size() * sizeof( T ) , reinterpret_cast<const void*>( values.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginRenderPass( const RenderPassBeginInfo* pRenderPassBegin, SubpassContents contents, Dispatch const &d) const
  {
    d.vkCmdBeginRenderPass( m_commandBuffer, reinterpret_cast<const VkRenderPassBeginInfo*>( pRenderPassBegin ), static_cast<VkSubpassContents>( contents ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginRenderPass( const RenderPassBeginInfo & renderPassBegin, SubpassContents contents, Dispatch const &d ) const
  {
    d.vkCmdBeginRenderPass( m_commandBuffer, reinterpret_cast<const VkRenderPassBeginInfo*>( &renderPassBegin ), static_cast<VkSubpassContents>( contents ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::nextSubpass( SubpassContents contents, Dispatch const &d) const
  {
    d.vkCmdNextSubpass( m_commandBuffer, static_cast<VkSubpassContents>( contents ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::nextSubpass( SubpassContents contents, Dispatch const &d ) const
  {
    d.vkCmdNextSubpass( m_commandBuffer, static_cast<VkSubpassContents>( contents ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endRenderPass(Dispatch const &d) const
  {
    d.vkCmdEndRenderPass( m_commandBuffer );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endRenderPass(Dispatch const &d ) const
  {
    d.vkCmdEndRenderPass( m_commandBuffer );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::executeCommands( uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers, Dispatch const &d) const
  {
    d.vkCmdExecuteCommands( m_commandBuffer, commandBufferCount, reinterpret_cast<const VkCommandBuffer*>( pCommandBuffers ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::executeCommands( ArrayProxy<const CommandBuffer> commandBuffers, Dispatch const &d ) const
  {
    d.vkCmdExecuteCommands( m_commandBuffer, commandBuffers.size() , reinterpret_cast<const VkCommandBuffer*>( commandBuffers.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::debugMarkerBeginEXT( const DebugMarkerMarkerInfoEXT* pMarkerInfo, Dispatch const &d) const
  {
    d.vkCmdDebugMarkerBeginEXT( m_commandBuffer, reinterpret_cast<const VkDebugMarkerMarkerInfoEXT*>( pMarkerInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::debugMarkerBeginEXT( const DebugMarkerMarkerInfoEXT & markerInfo, Dispatch const &d ) const
  {
    d.vkCmdDebugMarkerBeginEXT( m_commandBuffer, reinterpret_cast<const VkDebugMarkerMarkerInfoEXT*>( &markerInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::debugMarkerEndEXT(Dispatch const &d) const
  {
    d.vkCmdDebugMarkerEndEXT( m_commandBuffer );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::debugMarkerEndEXT(Dispatch const &d ) const
  {
    d.vkCmdDebugMarkerEndEXT( m_commandBuffer );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::debugMarkerInsertEXT( const DebugMarkerMarkerInfoEXT* pMarkerInfo, Dispatch const &d) const
  {
    d.vkCmdDebugMarkerInsertEXT( m_commandBuffer, reinterpret_cast<const VkDebugMarkerMarkerInfoEXT*>( pMarkerInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::debugMarkerInsertEXT( const DebugMarkerMarkerInfoEXT & markerInfo, Dispatch const &d ) const
  {
    d.vkCmdDebugMarkerInsertEXT( m_commandBuffer, reinterpret_cast<const VkDebugMarkerMarkerInfoEXT*>( &markerInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndirectCountAMD( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d) const
  {
    d.vkCmdDrawIndirectCountAMD( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndirectCountAMD( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d ) const
  {
    d.vkCmdDrawIndirectCountAMD( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndexedIndirectCountAMD( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d) const
  {
    d.vkCmdDrawIndexedIndirectCountAMD( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndexedIndirectCountAMD( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d ) const
  {
    d.vkCmdDrawIndexedIndirectCountAMD( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::processCommandsNVX( const CmdProcessCommandsInfoNVX* pProcessCommandsInfo, Dispatch const &d) const
  {
    d.vkCmdProcessCommandsNVX( m_commandBuffer, reinterpret_cast<const VkCmdProcessCommandsInfoNVX*>( pProcessCommandsInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::processCommandsNVX( const CmdProcessCommandsInfoNVX & processCommandsInfo, Dispatch const &d ) const
  {
    d.vkCmdProcessCommandsNVX( m_commandBuffer, reinterpret_cast<const VkCmdProcessCommandsInfoNVX*>( &processCommandsInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::reserveSpaceForCommandsNVX( const CmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo, Dispatch const &d) const
  {
    d.vkCmdReserveSpaceForCommandsNVX( m_commandBuffer, reinterpret_cast<const VkCmdReserveSpaceForCommandsInfoNVX*>( pReserveSpaceInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::reserveSpaceForCommandsNVX( const CmdReserveSpaceForCommandsInfoNVX & reserveSpaceInfo, Dispatch const &d ) const
  {
    d.vkCmdReserveSpaceForCommandsNVX( m_commandBuffer, reinterpret_cast<const VkCmdReserveSpaceForCommandsInfoNVX*>( &reserveSpaceInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::pushDescriptorSetKHR( PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const WriteDescriptorSet* pDescriptorWrites, Dispatch const &d) const
  {
    d.vkCmdPushDescriptorSetKHR( m_commandBuffer, static_cast<VkPipelineBindPoint>( pipelineBindPoint ), static_cast<VkPipelineLayout>( layout ), set, descriptorWriteCount, reinterpret_cast<const VkWriteDescriptorSet*>( pDescriptorWrites ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::pushDescriptorSetKHR( PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, ArrayProxy<const WriteDescriptorSet> descriptorWrites, Dispatch const &d ) const
  {
    d.vkCmdPushDescriptorSetKHR( m_commandBuffer, static_cast<VkPipelineBindPoint>( pipelineBindPoint ), static_cast<VkPipelineLayout>( layout ), set, descriptorWrites.size() , reinterpret_cast<const VkWriteDescriptorSet*>( descriptorWrites.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDeviceMask( uint32_t deviceMask, Dispatch const &d) const
  {
    d.vkCmdSetDeviceMask( m_commandBuffer, deviceMask );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDeviceMask( uint32_t deviceMask, Dispatch const &d ) const
  {
    d.vkCmdSetDeviceMask( m_commandBuffer, deviceMask );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDeviceMaskKHR( uint32_t deviceMask, Dispatch const &d) const
  {
    d.vkCmdSetDeviceMaskKHR( m_commandBuffer, deviceMask );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDeviceMaskKHR( uint32_t deviceMask, Dispatch const &d ) const
  {
    d.vkCmdSetDeviceMaskKHR( m_commandBuffer, deviceMask );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::dispatchBase( uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, Dispatch const &d) const
  {
    d.vkCmdDispatchBase( m_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::dispatchBase( uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, Dispatch const &d ) const
  {
    d.vkCmdDispatchBase( m_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::dispatchBaseKHR( uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, Dispatch const &d) const
  {
    d.vkCmdDispatchBaseKHR( m_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::dispatchBaseKHR( uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, Dispatch const &d ) const
  {
    d.vkCmdDispatchBaseKHR( m_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::pushDescriptorSetWithTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate, PipelineLayout layout, uint32_t set, const void* pData, Dispatch const &d) const
  {
    d.vkCmdPushDescriptorSetWithTemplateKHR( m_commandBuffer, static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), static_cast<VkPipelineLayout>( layout ), set, pData );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::pushDescriptorSetWithTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate, PipelineLayout layout, uint32_t set, const void* pData, Dispatch const &d ) const
  {
    d.vkCmdPushDescriptorSetWithTemplateKHR( m_commandBuffer, static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), static_cast<VkPipelineLayout>( layout ), set, pData );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setViewportWScalingNV( uint32_t firstViewport, uint32_t viewportCount, const ViewportWScalingNV* pViewportWScalings, Dispatch const &d) const
  {
    d.vkCmdSetViewportWScalingNV( m_commandBuffer, firstViewport, viewportCount, reinterpret_cast<const VkViewportWScalingNV*>( pViewportWScalings ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setViewportWScalingNV( uint32_t firstViewport, ArrayProxy<const ViewportWScalingNV> viewportWScalings, Dispatch const &d ) const
  {
    d.vkCmdSetViewportWScalingNV( m_commandBuffer, firstViewport, viewportWScalings.size() , reinterpret_cast<const VkViewportWScalingNV*>( viewportWScalings.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDiscardRectangleEXT( uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const Rect2D* pDiscardRectangles, Dispatch const &d) const
  {
    d.vkCmdSetDiscardRectangleEXT( m_commandBuffer, firstDiscardRectangle, discardRectangleCount, reinterpret_cast<const VkRect2D*>( pDiscardRectangles ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setDiscardRectangleEXT( uint32_t firstDiscardRectangle, ArrayProxy<const Rect2D> discardRectangles, Dispatch const &d ) const
  {
    d.vkCmdSetDiscardRectangleEXT( m_commandBuffer, firstDiscardRectangle, discardRectangles.size() , reinterpret_cast<const VkRect2D*>( discardRectangles.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setSampleLocationsEXT( const SampleLocationsInfoEXT* pSampleLocationsInfo, Dispatch const &d) const
  {
    d.vkCmdSetSampleLocationsEXT( m_commandBuffer, reinterpret_cast<const VkSampleLocationsInfoEXT*>( pSampleLocationsInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setSampleLocationsEXT( const SampleLocationsInfoEXT & sampleLocationsInfo, Dispatch const &d ) const
  {
    d.vkCmdSetSampleLocationsEXT( m_commandBuffer, reinterpret_cast<const VkSampleLocationsInfoEXT*>( &sampleLocationsInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginDebugUtilsLabelEXT( const DebugUtilsLabelEXT* pLabelInfo, Dispatch const &d) const
  {
    d.vkCmdBeginDebugUtilsLabelEXT( m_commandBuffer, reinterpret_cast<const VkDebugUtilsLabelEXT*>( pLabelInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginDebugUtilsLabelEXT( const DebugUtilsLabelEXT & labelInfo, Dispatch const &d ) const
  {
    d.vkCmdBeginDebugUtilsLabelEXT( m_commandBuffer, reinterpret_cast<const VkDebugUtilsLabelEXT*>( &labelInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endDebugUtilsLabelEXT(Dispatch const &d) const
  {
    d.vkCmdEndDebugUtilsLabelEXT( m_commandBuffer );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endDebugUtilsLabelEXT(Dispatch const &d ) const
  {
    d.vkCmdEndDebugUtilsLabelEXT( m_commandBuffer );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::insertDebugUtilsLabelEXT( const DebugUtilsLabelEXT* pLabelInfo, Dispatch const &d) const
  {
    d.vkCmdInsertDebugUtilsLabelEXT( m_commandBuffer, reinterpret_cast<const VkDebugUtilsLabelEXT*>( pLabelInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::insertDebugUtilsLabelEXT( const DebugUtilsLabelEXT & labelInfo, Dispatch const &d ) const
  {
    d.vkCmdInsertDebugUtilsLabelEXT( m_commandBuffer, reinterpret_cast<const VkDebugUtilsLabelEXT*>( &labelInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::writeBufferMarkerAMD( PipelineStageFlagBits pipelineStage, Buffer dstBuffer, DeviceSize dstOffset, uint32_t marker, Dispatch const &d) const
  {
    d.vkCmdWriteBufferMarkerAMD( m_commandBuffer, static_cast<VkPipelineStageFlagBits>( pipelineStage ), static_cast<VkBuffer>( dstBuffer ), dstOffset, marker );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::writeBufferMarkerAMD( PipelineStageFlagBits pipelineStage, Buffer dstBuffer, DeviceSize dstOffset, uint32_t marker, Dispatch const &d ) const
  {
    d.vkCmdWriteBufferMarkerAMD( m_commandBuffer, static_cast<VkPipelineStageFlagBits>( pipelineStage ), static_cast<VkBuffer>( dstBuffer ), dstOffset, marker );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginRenderPass2KHR( const RenderPassBeginInfo* pRenderPassBegin, const SubpassBeginInfoKHR* pSubpassBeginInfo, Dispatch const &d) const
  {
    d.vkCmdBeginRenderPass2KHR( m_commandBuffer, reinterpret_cast<const VkRenderPassBeginInfo*>( pRenderPassBegin ), reinterpret_cast<const VkSubpassBeginInfoKHR*>( pSubpassBeginInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::beginRenderPass2KHR( const RenderPassBeginInfo & renderPassBegin, const SubpassBeginInfoKHR & subpassBeginInfo, Dispatch const &d ) const
  {
    d.vkCmdBeginRenderPass2KHR( m_commandBuffer, reinterpret_cast<const VkRenderPassBeginInfo*>( &renderPassBegin ), reinterpret_cast<const VkSubpassBeginInfoKHR*>( &subpassBeginInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::nextSubpass2KHR( const SubpassBeginInfoKHR* pSubpassBeginInfo, const SubpassEndInfoKHR* pSubpassEndInfo, Dispatch const &d) const
  {
    d.vkCmdNextSubpass2KHR( m_commandBuffer, reinterpret_cast<const VkSubpassBeginInfoKHR*>( pSubpassBeginInfo ), reinterpret_cast<const VkSubpassEndInfoKHR*>( pSubpassEndInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::nextSubpass2KHR( const SubpassBeginInfoKHR & subpassBeginInfo, const SubpassEndInfoKHR & subpassEndInfo, Dispatch const &d ) const
  {
    d.vkCmdNextSubpass2KHR( m_commandBuffer, reinterpret_cast<const VkSubpassBeginInfoKHR*>( &subpassBeginInfo ), reinterpret_cast<const VkSubpassEndInfoKHR*>( &subpassEndInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endRenderPass2KHR( const SubpassEndInfoKHR* pSubpassEndInfo, Dispatch const &d) const
  {
    d.vkCmdEndRenderPass2KHR( m_commandBuffer, reinterpret_cast<const VkSubpassEndInfoKHR*>( pSubpassEndInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::endRenderPass2KHR( const SubpassEndInfoKHR & subpassEndInfo, Dispatch const &d ) const
  {
    d.vkCmdEndRenderPass2KHR( m_commandBuffer, reinterpret_cast<const VkSubpassEndInfoKHR*>( &subpassEndInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndirectCountKHR( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d) const
  {
    d.vkCmdDrawIndirectCountKHR( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndirectCountKHR( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d ) const
  {
    d.vkCmdDrawIndirectCountKHR( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndexedIndirectCountKHR( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d) const
  {
    d.vkCmdDrawIndexedIndirectCountKHR( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawIndexedIndirectCountKHR( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d ) const
  {
    d.vkCmdDrawIndexedIndirectCountKHR( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setCheckpointNV( const void* pCheckpointMarker, Dispatch const &d) const
  {
    d.vkCmdSetCheckpointNV( m_commandBuffer, pCheckpointMarker );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setCheckpointNV( const void* pCheckpointMarker, Dispatch const &d ) const
  {
    d.vkCmdSetCheckpointNV( m_commandBuffer, pCheckpointMarker );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setExclusiveScissorNV( uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const Rect2D* pExclusiveScissors, Dispatch const &d) const
  {
    d.vkCmdSetExclusiveScissorNV( m_commandBuffer, firstExclusiveScissor, exclusiveScissorCount, reinterpret_cast<const VkRect2D*>( pExclusiveScissors ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setExclusiveScissorNV( uint32_t firstExclusiveScissor, ArrayProxy<const Rect2D> exclusiveScissors, Dispatch const &d ) const
  {
    d.vkCmdSetExclusiveScissorNV( m_commandBuffer, firstExclusiveScissor, exclusiveScissors.size() , reinterpret_cast<const VkRect2D*>( exclusiveScissors.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindShadingRateImageNV( ImageView imageView, ImageLayout imageLayout, Dispatch const &d) const
  {
    d.vkCmdBindShadingRateImageNV( m_commandBuffer, static_cast<VkImageView>( imageView ), static_cast<VkImageLayout>( imageLayout ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::bindShadingRateImageNV( ImageView imageView, ImageLayout imageLayout, Dispatch const &d ) const
  {
    d.vkCmdBindShadingRateImageNV( m_commandBuffer, static_cast<VkImageView>( imageView ), static_cast<VkImageLayout>( imageLayout ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setViewportShadingRatePaletteNV( uint32_t firstViewport, uint32_t viewportCount, const ShadingRatePaletteNV* pShadingRatePalettes, Dispatch const &d) const
  {
    d.vkCmdSetViewportShadingRatePaletteNV( m_commandBuffer, firstViewport, viewportCount, reinterpret_cast<const VkShadingRatePaletteNV*>( pShadingRatePalettes ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setViewportShadingRatePaletteNV( uint32_t firstViewport, ArrayProxy<const ShadingRatePaletteNV> shadingRatePalettes, Dispatch const &d ) const
  {
    d.vkCmdSetViewportShadingRatePaletteNV( m_commandBuffer, firstViewport, shadingRatePalettes.size() , reinterpret_cast<const VkShadingRatePaletteNV*>( shadingRatePalettes.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setCoarseSampleOrderNV( CoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const CoarseSampleOrderCustomNV* pCustomSampleOrders, Dispatch const &d) const
  {
    d.vkCmdSetCoarseSampleOrderNV( m_commandBuffer, static_cast<VkCoarseSampleOrderTypeNV>( sampleOrderType ), customSampleOrderCount, reinterpret_cast<const VkCoarseSampleOrderCustomNV*>( pCustomSampleOrders ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::setCoarseSampleOrderNV( CoarseSampleOrderTypeNV sampleOrderType, ArrayProxy<const CoarseSampleOrderCustomNV> customSampleOrders, Dispatch const &d ) const
  {
    d.vkCmdSetCoarseSampleOrderNV( m_commandBuffer, static_cast<VkCoarseSampleOrderTypeNV>( sampleOrderType ), customSampleOrders.size() , reinterpret_cast<const VkCoarseSampleOrderCustomNV*>( customSampleOrders.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawMeshTasksNV( uint32_t taskCount, uint32_t firstTask, Dispatch const &d) const
  {
    d.vkCmdDrawMeshTasksNV( m_commandBuffer, taskCount, firstTask );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawMeshTasksNV( uint32_t taskCount, uint32_t firstTask, Dispatch const &d ) const
  {
    d.vkCmdDrawMeshTasksNV( m_commandBuffer, taskCount, firstTask );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawMeshTasksIndirectNV( Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, Dispatch const &d) const
  {
    d.vkCmdDrawMeshTasksIndirectNV( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, drawCount, stride );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawMeshTasksIndirectNV( Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, Dispatch const &d ) const
  {
    d.vkCmdDrawMeshTasksIndirectNV( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, drawCount, stride );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawMeshTasksIndirectCountNV( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d) const
  {
    d.vkCmdDrawMeshTasksIndirectCountNV( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::drawMeshTasksIndirectCountNV( Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, Dispatch const &d ) const
  {
    d.vkCmdDrawMeshTasksIndirectCountNV( m_commandBuffer, static_cast<VkBuffer>( buffer ), offset, static_cast<VkBuffer>( countBuffer ), countBufferOffset, maxDrawCount, stride );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyAccelerationStructureNVX( AccelerationStructureNVX dst, AccelerationStructureNVX src, CopyAccelerationStructureModeNVX mode, Dispatch const &d) const
  {
    d.vkCmdCopyAccelerationStructureNVX( m_commandBuffer, static_cast<VkAccelerationStructureNVX>( dst ), static_cast<VkAccelerationStructureNVX>( src ), static_cast<VkCopyAccelerationStructureModeNVX>( mode ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::copyAccelerationStructureNVX( AccelerationStructureNVX dst, AccelerationStructureNVX src, CopyAccelerationStructureModeNVX mode, Dispatch const &d ) const
  {
    d.vkCmdCopyAccelerationStructureNVX( m_commandBuffer, static_cast<VkAccelerationStructureNVX>( dst ), static_cast<VkAccelerationStructureNVX>( src ), static_cast<VkCopyAccelerationStructureModeNVX>( mode ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::writeAccelerationStructurePropertiesNVX( AccelerationStructureNVX accelerationStructure, QueryType queryType, QueryPool queryPool, uint32_t query, Dispatch const &d) const
  {
    d.vkCmdWriteAccelerationStructurePropertiesNVX( m_commandBuffer, static_cast<VkAccelerationStructureNVX>( accelerationStructure ), static_cast<VkQueryType>( queryType ), static_cast<VkQueryPool>( queryPool ), query );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::writeAccelerationStructurePropertiesNVX( AccelerationStructureNVX accelerationStructure, QueryType queryType, QueryPool queryPool, uint32_t query, Dispatch const &d ) const
  {
    d.vkCmdWriteAccelerationStructurePropertiesNVX( m_commandBuffer, static_cast<VkAccelerationStructureNVX>( accelerationStructure ), static_cast<VkQueryType>( queryType ), static_cast<VkQueryPool>( queryPool ), query );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::buildAccelerationStructureNVX( AccelerationStructureTypeNVX type, uint32_t instanceCount, Buffer instanceData, DeviceSize instanceOffset, uint32_t geometryCount, const GeometryNVX* pGeometries, BuildAccelerationStructureFlagsNVX flags, Bool32 update, AccelerationStructureNVX dst, AccelerationStructureNVX src, Buffer scratch, DeviceSize scratchOffset, Dispatch const &d) const
  {
    d.vkCmdBuildAccelerationStructureNVX( m_commandBuffer, static_cast<VkAccelerationStructureTypeNVX>( type ), instanceCount, static_cast<VkBuffer>( instanceData ), instanceOffset, geometryCount, reinterpret_cast<const VkGeometryNVX*>( pGeometries ), static_cast<VkBuildAccelerationStructureFlagsNVX>( flags ), update, static_cast<VkAccelerationStructureNVX>( dst ), static_cast<VkAccelerationStructureNVX>( src ), static_cast<VkBuffer>( scratch ), scratchOffset );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::buildAccelerationStructureNVX( AccelerationStructureTypeNVX type, uint32_t instanceCount, Buffer instanceData, DeviceSize instanceOffset, ArrayProxy<const GeometryNVX> geometries, BuildAccelerationStructureFlagsNVX flags, Bool32 update, AccelerationStructureNVX dst, AccelerationStructureNVX src, Buffer scratch, DeviceSize scratchOffset, Dispatch const &d ) const
  {
    d.vkCmdBuildAccelerationStructureNVX( m_commandBuffer, static_cast<VkAccelerationStructureTypeNVX>( type ), instanceCount, static_cast<VkBuffer>( instanceData ), instanceOffset, geometries.size() , reinterpret_cast<const VkGeometryNVX*>( geometries.data() ), static_cast<VkBuildAccelerationStructureFlagsNVX>( flags ), update, static_cast<VkAccelerationStructureNVX>( dst ), static_cast<VkAccelerationStructureNVX>( src ), static_cast<VkBuffer>( scratch ), scratchOffset );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::traceRaysNVX( Buffer raygenShaderBindingTableBuffer, DeviceSize raygenShaderBindingOffset, Buffer missShaderBindingTableBuffer, DeviceSize missShaderBindingOffset, DeviceSize missShaderBindingStride, Buffer hitShaderBindingTableBuffer, DeviceSize hitShaderBindingOffset, DeviceSize hitShaderBindingStride, uint32_t width, uint32_t height, Dispatch const &d) const
  {
    d.vkCmdTraceRaysNVX( m_commandBuffer, static_cast<VkBuffer>( raygenShaderBindingTableBuffer ), raygenShaderBindingOffset, static_cast<VkBuffer>( missShaderBindingTableBuffer ), missShaderBindingOffset, missShaderBindingStride, static_cast<VkBuffer>( hitShaderBindingTableBuffer ), hitShaderBindingOffset, hitShaderBindingStride, width, height );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void CommandBuffer::traceRaysNVX( Buffer raygenShaderBindingTableBuffer, DeviceSize raygenShaderBindingOffset, Buffer missShaderBindingTableBuffer, DeviceSize missShaderBindingOffset, DeviceSize missShaderBindingStride, Buffer hitShaderBindingTableBuffer, DeviceSize hitShaderBindingOffset, DeviceSize hitShaderBindingStride, uint32_t width, uint32_t height, Dispatch const &d ) const
  {
    d.vkCmdTraceRaysNVX( m_commandBuffer, static_cast<VkBuffer>( raygenShaderBindingTableBuffer ), raygenShaderBindingOffset, static_cast<VkBuffer>( missShaderBindingTableBuffer ), missShaderBindingOffset, missShaderBindingStride, static_cast<VkBuffer>( hitShaderBindingTableBuffer ), hitShaderBindingOffset, hitShaderBindingStride, width, height );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  struct SubmitInfo
  {
    operator VkSubmitInfo const&() const
    {
      return *reinterpret_cast<const VkSubmitInfo*>(this);
    }

    operator VkSubmitInfo &()
    {
      return *reinterpret_cast<VkSubmitInfo*>(this);
    }

    bool operator==( SubmitInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( waitSemaphoreCount == rhs.waitSemaphoreCount )
          && ( pWaitSemaphores == rhs.pWaitSemaphores )
          && ( pWaitDstStageMask == rhs.pWaitDstStageMask )
          && ( commandBufferCount == rhs.commandBufferCount )
          && ( pCommandBuffers == rhs.pCommandBuffers )
          && ( signalSemaphoreCount == rhs.signalSemaphoreCount )
          && ( pSignalSemaphores == rhs.pSignalSemaphores );
    }

    bool operator!=( SubmitInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eSubmitInfo;
    const void* pNext = nullptr;
    uint32_t waitSemaphoreCount = 0;
    const Semaphore* pWaitSemaphores = nullptr;
    const PipelineStageFlags* pWaitDstStageMask = nullptr;
    uint32_t commandBufferCount = 0;
    const CommandBuffer* pCommandBuffers = nullptr;
    uint32_t signalSemaphoreCount = 0;
    const Semaphore* pSignalSemaphores = nullptr;
  };
  static_assert( sizeof( SubmitInfo ) == sizeof( VkSubmitInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( SubmitInfo, pNext ) == offsetof( VkSubmitInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubmitInfo, waitSemaphoreCount ) == offsetof( VkSubmitInfo, waitSemaphoreCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubmitInfo, pWaitSemaphores ) == offsetof( VkSubmitInfo, pWaitSemaphores ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubmitInfo, pWaitDstStageMask ) == offsetof( VkSubmitInfo, pWaitDstStageMask ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubmitInfo, commandBufferCount ) == offsetof( VkSubmitInfo, commandBufferCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubmitInfo, pCommandBuffers ) == offsetof( VkSubmitInfo, pCommandBuffers ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubmitInfo, signalSemaphoreCount ) == offsetof( VkSubmitInfo, signalSemaphoreCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( SubmitInfo, pSignalSemaphores ) == offsetof( VkSubmitInfo, pSignalSemaphores ), "struct member and wrapper member have different offset!" );

  class Queue
  {
  public:
    VULKAN_HPP_CONSTEXPR Queue()
      : m_queue(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Queue( std::nullptr_t )
      : m_queue(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Queue( VkQueue queue )
      : m_queue( queue )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Queue & operator=(VkQueue queue)
    {
      m_queue = queue;
      return *this; 
    }
#endif

    Queue & operator=( std::nullptr_t )
    {
      m_queue = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Queue const & rhs ) const
    {
      return m_queue == rhs.m_queue;
    }

    bool operator!=(Queue const & rhs ) const
    {
      return m_queue != rhs.m_queue;
    }

    bool operator<(Queue const & rhs ) const
    {
      return m_queue < rhs.m_queue;
    }

    template<typename Dispatch = DispatchLoaderStatic>
    Result submit( uint32_t submitCount, const SubmitInfo* pSubmits, Fence fence, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type submit( ArrayProxy<const SubmitInfo> submits, Fence fence, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result waitIdle(Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type waitIdle(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result bindSparse( uint32_t bindInfoCount, const BindSparseInfo* pBindInfo, Fence fence, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type bindSparse( ArrayProxy<const BindSparseInfo> bindInfo, Fence fence, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result presentKHR( const PresentInfoKHR* pPresentInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result presentKHR( const PresentInfoKHR & presentInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void beginDebugUtilsLabelEXT( const DebugUtilsLabelEXT* pLabelInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void beginDebugUtilsLabelEXT( const DebugUtilsLabelEXT & labelInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void endDebugUtilsLabelEXT(Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void insertDebugUtilsLabelEXT( const DebugUtilsLabelEXT* pLabelInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void insertDebugUtilsLabelEXT( const DebugUtilsLabelEXT & labelInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getCheckpointDataNV( uint32_t* pCheckpointDataCount, CheckpointDataNV* pCheckpointData, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<CheckpointDataNV>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<CheckpointDataNV,Allocator> getCheckpointDataNV(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkQueue() const
    {
      return m_queue;
    }

    explicit operator bool() const
    {
      return m_queue != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_queue == VK_NULL_HANDLE;
    }

  private:
    VkQueue m_queue;
  };

  static_assert( sizeof( Queue ) == sizeof( VkQueue ), "handle and wrapper have different size!" );

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Queue::submit( uint32_t submitCount, const SubmitInfo* pSubmits, Fence fence, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkQueueSubmit( m_queue, submitCount, reinterpret_cast<const VkSubmitInfo*>( pSubmits ), static_cast<VkFence>( fence ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Queue::submit( ArrayProxy<const SubmitInfo> submits, Fence fence, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkQueueSubmit( m_queue, submits.size() , reinterpret_cast<const VkSubmitInfo*>( submits.data() ), static_cast<VkFence>( fence ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Queue::submit" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Queue::waitIdle(Dispatch const &d) const
  {
    return static_cast<Result>( d.vkQueueWaitIdle( m_queue ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Queue::waitIdle(Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkQueueWaitIdle( m_queue ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Queue::waitIdle" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Queue::bindSparse( uint32_t bindInfoCount, const BindSparseInfo* pBindInfo, Fence fence, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkQueueBindSparse( m_queue, bindInfoCount, reinterpret_cast<const VkBindSparseInfo*>( pBindInfo ), static_cast<VkFence>( fence ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Queue::bindSparse( ArrayProxy<const BindSparseInfo> bindInfo, Fence fence, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkQueueBindSparse( m_queue, bindInfo.size() , reinterpret_cast<const VkBindSparseInfo*>( bindInfo.data() ), static_cast<VkFence>( fence ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Queue::bindSparse" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Queue::presentKHR( const PresentInfoKHR* pPresentInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkQueuePresentKHR( m_queue, reinterpret_cast<const VkPresentInfoKHR*>( pPresentInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Queue::presentKHR( const PresentInfoKHR & presentInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkQueuePresentKHR( m_queue, reinterpret_cast<const VkPresentInfoKHR*>( &presentInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Queue::presentKHR", { Result::eSuccess, Result::eSuboptimalKHR } );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Queue::beginDebugUtilsLabelEXT( const DebugUtilsLabelEXT* pLabelInfo, Dispatch const &d) const
  {
    d.vkQueueBeginDebugUtilsLabelEXT( m_queue, reinterpret_cast<const VkDebugUtilsLabelEXT*>( pLabelInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Queue::beginDebugUtilsLabelEXT( const DebugUtilsLabelEXT & labelInfo, Dispatch const &d ) const
  {
    d.vkQueueBeginDebugUtilsLabelEXT( m_queue, reinterpret_cast<const VkDebugUtilsLabelEXT*>( &labelInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Queue::endDebugUtilsLabelEXT(Dispatch const &d) const
  {
    d.vkQueueEndDebugUtilsLabelEXT( m_queue );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Queue::endDebugUtilsLabelEXT(Dispatch const &d ) const
  {
    d.vkQueueEndDebugUtilsLabelEXT( m_queue );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Queue::insertDebugUtilsLabelEXT( const DebugUtilsLabelEXT* pLabelInfo, Dispatch const &d) const
  {
    d.vkQueueInsertDebugUtilsLabelEXT( m_queue, reinterpret_cast<const VkDebugUtilsLabelEXT*>( pLabelInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Queue::insertDebugUtilsLabelEXT( const DebugUtilsLabelEXT & labelInfo, Dispatch const &d ) const
  {
    d.vkQueueInsertDebugUtilsLabelEXT( m_queue, reinterpret_cast<const VkDebugUtilsLabelEXT*>( &labelInfo ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Queue::getCheckpointDataNV( uint32_t* pCheckpointDataCount, CheckpointDataNV* pCheckpointData, Dispatch const &d) const
  {
    d.vkGetQueueCheckpointDataNV( m_queue, pCheckpointDataCount, reinterpret_cast<VkCheckpointDataNV*>( pCheckpointData ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<CheckpointDataNV,Allocator> Queue::getCheckpointDataNV(Dispatch const &d ) const
  {
    std::vector<CheckpointDataNV,Allocator> checkpointData;
    uint32_t checkpointDataCount;
    d.vkGetQueueCheckpointDataNV( m_queue, &checkpointDataCount, nullptr );
    checkpointData.resize( checkpointDataCount );
    d.vkGetQueueCheckpointDataNV( m_queue, &checkpointDataCount, reinterpret_cast<VkCheckpointDataNV*>( checkpointData.data() ) );
    return checkpointData;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifndef VULKAN_HPP_NO_SMART_HANDLE
  class Device;

  template <typename Dispatch> class UniqueHandleTraits<AccelerationStructureNVX,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueAccelerationStructureNVX = UniqueHandle<AccelerationStructureNVX,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<Buffer,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueBuffer = UniqueHandle<Buffer,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<BufferView,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueBufferView = UniqueHandle<BufferView,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<CommandBuffer,Dispatch> {public: using deleter = PoolFree<Device, CommandPool,Dispatch>; };
  using UniqueCommandBuffer = UniqueHandle<CommandBuffer,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<CommandPool,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueCommandPool = UniqueHandle<CommandPool,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<DescriptorPool,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueDescriptorPool = UniqueHandle<DescriptorPool,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<DescriptorSet,Dispatch> {public: using deleter = PoolFree<Device, DescriptorPool,Dispatch>; };
  using UniqueDescriptorSet = UniqueHandle<DescriptorSet,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<DescriptorSetLayout,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueDescriptorSetLayout = UniqueHandle<DescriptorSetLayout,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<DescriptorUpdateTemplate,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueDescriptorUpdateTemplate = UniqueHandle<DescriptorUpdateTemplate,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<DeviceMemory,Dispatch> {public: using deleter = ObjectFree<Device,Dispatch>; };
  using UniqueDeviceMemory = UniqueHandle<DeviceMemory,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<Event,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueEvent = UniqueHandle<Event,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<Fence,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueFence = UniqueHandle<Fence,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<Framebuffer,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueFramebuffer = UniqueHandle<Framebuffer,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<Image,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueImage = UniqueHandle<Image,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<ImageView,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueImageView = UniqueHandle<ImageView,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<IndirectCommandsLayoutNVX,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueIndirectCommandsLayoutNVX = UniqueHandle<IndirectCommandsLayoutNVX,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<ObjectTableNVX,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueObjectTableNVX = UniqueHandle<ObjectTableNVX,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<Pipeline,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniquePipeline = UniqueHandle<Pipeline,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<PipelineCache,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniquePipelineCache = UniqueHandle<PipelineCache,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<PipelineLayout,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniquePipelineLayout = UniqueHandle<PipelineLayout,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<QueryPool,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueQueryPool = UniqueHandle<QueryPool,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<RenderPass,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueRenderPass = UniqueHandle<RenderPass,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<Sampler,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueSampler = UniqueHandle<Sampler,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<SamplerYcbcrConversion,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueSamplerYcbcrConversion = UniqueHandle<SamplerYcbcrConversion,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<Semaphore,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueSemaphore = UniqueHandle<Semaphore,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<ShaderModule,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueShaderModule = UniqueHandle<ShaderModule,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<SwapchainKHR,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueSwapchainKHR = UniqueHandle<SwapchainKHR,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<ValidationCacheEXT,Dispatch> {public: using deleter = ObjectDestroy<Device,Dispatch>; };
  using UniqueValidationCacheEXT = UniqueHandle<ValidationCacheEXT,DispatchLoaderStatic>;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/

  class Device
  {
  public:
    VULKAN_HPP_CONSTEXPR Device()
      : m_device(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Device( std::nullptr_t )
      : m_device(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Device( VkDevice device )
      : m_device( device )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Device & operator=(VkDevice device)
    {
      m_device = device;
      return *this; 
    }
#endif

    Device & operator=( std::nullptr_t )
    {
      m_device = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Device const & rhs ) const
    {
      return m_device == rhs.m_device;
    }

    bool operator!=(Device const & rhs ) const
    {
      return m_device != rhs.m_device;
    }

    bool operator<(Device const & rhs ) const
    {
      return m_device < rhs.m_device;
    }

    template<typename Dispatch = DispatchLoaderStatic>
    PFN_vkVoidFunction getProcAddr( const char* pName, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PFN_vkVoidFunction getProcAddr( const std::string & name, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getQueue( uint32_t queueFamilyIndex, uint32_t queueIndex, Queue* pQueue, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Queue getQueue( uint32_t queueFamilyIndex, uint32_t queueIndex, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result waitIdle(Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type waitIdle(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result allocateMemory( const MemoryAllocateInfo* pAllocateInfo, const AllocationCallbacks* pAllocator, DeviceMemory* pMemory, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DeviceMemory>::type allocateMemory( const MemoryAllocateInfo & allocateInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<DeviceMemory,Dispatch>>::type allocateMemoryUnique( const MemoryAllocateInfo & allocateInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void freeMemory( DeviceMemory memory, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void freeMemory( DeviceMemory memory, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void free( DeviceMemory memory, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void free( DeviceMemory memory, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result mapMemory( DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags, void** ppData, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void*>::type mapMemory( DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags = MemoryMapFlags(), Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void unmapMemory( DeviceMemory memory, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    Result flushMappedMemoryRanges( uint32_t memoryRangeCount, const MappedMemoryRange* pMemoryRanges, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type flushMappedMemoryRanges( ArrayProxy<const MappedMemoryRange> memoryRanges, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result invalidateMappedMemoryRanges( uint32_t memoryRangeCount, const MappedMemoryRange* pMemoryRanges, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type invalidateMappedMemoryRanges( ArrayProxy<const MappedMemoryRange> memoryRanges, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getMemoryCommitment( DeviceMemory memory, DeviceSize* pCommittedMemoryInBytes, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    DeviceSize getMemoryCommitment( DeviceMemory memory, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getBufferMemoryRequirements( Buffer buffer, MemoryRequirements* pMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    MemoryRequirements getBufferMemoryRequirements( Buffer buffer, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result bindBufferMemory( Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset, Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type bindBufferMemory( Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getImageMemoryRequirements( Image image, MemoryRequirements* pMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    MemoryRequirements getImageMemoryRequirements( Image image, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result bindImageMemory( Image image, DeviceMemory memory, DeviceSize memoryOffset, Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type bindImageMemory( Image image, DeviceMemory memory, DeviceSize memoryOffset, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getImageSparseMemoryRequirements( Image image, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements* pSparseMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<SparseImageMemoryRequirements>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<SparseImageMemoryRequirements,Allocator> getImageSparseMemoryRequirements( Image image, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createFence( const FenceCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Fence* pFence, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Fence>::type createFence( const FenceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<Fence,Dispatch>>::type createFenceUnique( const FenceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyFence( Fence fence, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyFence( Fence fence, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Fence fence, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Fence fence, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result resetFences( uint32_t fenceCount, const Fence* pFences, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type resetFences( ArrayProxy<const Fence> fences, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getFenceStatus( Fence fence, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    Result waitForFences( uint32_t fenceCount, const Fence* pFences, Bool32 waitAll, uint64_t timeout, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result waitForFences( ArrayProxy<const Fence> fences, Bool32 waitAll, uint64_t timeout, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createSemaphore( const SemaphoreCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Semaphore* pSemaphore, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Semaphore>::type createSemaphore( const SemaphoreCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<Semaphore,Dispatch>>::type createSemaphoreUnique( const SemaphoreCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroySemaphore( Semaphore semaphore, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroySemaphore( Semaphore semaphore, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Semaphore semaphore, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Semaphore semaphore, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createEvent( const EventCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Event* pEvent, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Event>::type createEvent( const EventCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<Event,Dispatch>>::type createEventUnique( const EventCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyEvent( Event event, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyEvent( Event event, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Event event, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Event event, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getEventStatus( Event event, Dispatch const &d = Dispatch() ) const;

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result setEvent( Event event, Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type setEvent( Event event, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result resetEvent( Event event, Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type resetEvent( Event event, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createQueryPool( const QueryPoolCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, QueryPool* pQueryPool, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<QueryPool>::type createQueryPool( const QueryPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<QueryPool,Dispatch>>::type createQueryPoolUnique( const QueryPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyQueryPool( QueryPool queryPool, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyQueryPool( QueryPool queryPool, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( QueryPool queryPool, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( QueryPool queryPool, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getQueryPoolResults( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, DeviceSize stride, QueryResultFlags flags, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename T, typename Dispatch = DispatchLoaderStatic>
    Result getQueryPoolResults( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, ArrayProxy<T> data, DeviceSize stride, QueryResultFlags flags, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createBuffer( const BufferCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Buffer* pBuffer, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Buffer>::type createBuffer( const BufferCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<Buffer,Dispatch>>::type createBufferUnique( const BufferCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyBuffer( Buffer buffer, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyBuffer( Buffer buffer, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Buffer buffer, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Buffer buffer, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createBufferView( const BufferViewCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, BufferView* pView, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<BufferView>::type createBufferView( const BufferViewCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<BufferView,Dispatch>>::type createBufferViewUnique( const BufferViewCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyBufferView( BufferView bufferView, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyBufferView( BufferView bufferView, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( BufferView bufferView, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( BufferView bufferView, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createImage( const ImageCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Image* pImage, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Image>::type createImage( const ImageCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<Image,Dispatch>>::type createImageUnique( const ImageCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyImage( Image image, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyImage( Image image, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Image image, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Image image, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getImageSubresourceLayout( Image image, const ImageSubresource* pSubresource, SubresourceLayout* pLayout, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    SubresourceLayout getImageSubresourceLayout( Image image, const ImageSubresource & subresource, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createImageView( const ImageViewCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, ImageView* pView, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<ImageView>::type createImageView( const ImageViewCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<ImageView,Dispatch>>::type createImageViewUnique( const ImageViewCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyImageView( ImageView imageView, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyImageView( ImageView imageView, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( ImageView imageView, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( ImageView imageView, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createShaderModule( const ShaderModuleCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, ShaderModule* pShaderModule, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<ShaderModule>::type createShaderModule( const ShaderModuleCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<ShaderModule,Dispatch>>::type createShaderModuleUnique( const ShaderModuleCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyShaderModule( ShaderModule shaderModule, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyShaderModule( ShaderModule shaderModule, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( ShaderModule shaderModule, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( ShaderModule shaderModule, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createPipelineCache( const PipelineCacheCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, PipelineCache* pPipelineCache, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<PipelineCache>::type createPipelineCache( const PipelineCacheCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<PipelineCache,Dispatch>>::type createPipelineCacheUnique( const PipelineCacheCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyPipelineCache( PipelineCache pipelineCache, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyPipelineCache( PipelineCache pipelineCache, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( PipelineCache pipelineCache, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( PipelineCache pipelineCache, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getPipelineCacheData( PipelineCache pipelineCache, size_t* pDataSize, void* pData, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<uint8_t>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<uint8_t,Allocator>>::type getPipelineCacheData( PipelineCache pipelineCache, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result mergePipelineCaches( PipelineCache dstCache, uint32_t srcCacheCount, const PipelineCache* pSrcCaches, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type mergePipelineCaches( PipelineCache dstCache, ArrayProxy<const PipelineCache> srcCaches, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createGraphicsPipelines( PipelineCache pipelineCache, uint32_t createInfoCount, const GraphicsPipelineCreateInfo* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<Pipeline>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<Pipeline,Allocator>>::type createGraphicsPipelines( PipelineCache pipelineCache, ArrayProxy<const GraphicsPipelineCreateInfo> createInfos, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
    template <typename Allocator = std::allocator<Pipeline>, typename Dispatch = DispatchLoaderStatic> 
    ResultValueType<Pipeline>::type createGraphicsPipeline( PipelineCache pipelineCache, const GraphicsPipelineCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template <typename Allocator = std::allocator<UniquePipeline>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<UniqueHandle<Pipeline,Dispatch>,Allocator>>::type createGraphicsPipelinesUnique( PipelineCache pipelineCache, ArrayProxy<const GraphicsPipelineCreateInfo> createInfos, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
    template <typename Allocator = std::allocator<UniquePipeline>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<UniqueHandle<Pipeline,Dispatch>>::type createGraphicsPipelineUnique( PipelineCache pipelineCache, const GraphicsPipelineCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createComputePipelines( PipelineCache pipelineCache, uint32_t createInfoCount, const ComputePipelineCreateInfo* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<Pipeline>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<Pipeline,Allocator>>::type createComputePipelines( PipelineCache pipelineCache, ArrayProxy<const ComputePipelineCreateInfo> createInfos, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
    template <typename Allocator = std::allocator<Pipeline>, typename Dispatch = DispatchLoaderStatic> 
    ResultValueType<Pipeline>::type createComputePipeline( PipelineCache pipelineCache, const ComputePipelineCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template <typename Allocator = std::allocator<UniquePipeline>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<UniqueHandle<Pipeline,Dispatch>,Allocator>>::type createComputePipelinesUnique( PipelineCache pipelineCache, ArrayProxy<const ComputePipelineCreateInfo> createInfos, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
    template <typename Allocator = std::allocator<UniquePipeline>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<UniqueHandle<Pipeline,Dispatch>>::type createComputePipelineUnique( PipelineCache pipelineCache, const ComputePipelineCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyPipeline( Pipeline pipeline, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyPipeline( Pipeline pipeline, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Pipeline pipeline, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Pipeline pipeline, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createPipelineLayout( const PipelineLayoutCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, PipelineLayout* pPipelineLayout, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<PipelineLayout>::type createPipelineLayout( const PipelineLayoutCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<PipelineLayout,Dispatch>>::type createPipelineLayoutUnique( const PipelineLayoutCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyPipelineLayout( PipelineLayout pipelineLayout, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyPipelineLayout( PipelineLayout pipelineLayout, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( PipelineLayout pipelineLayout, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( PipelineLayout pipelineLayout, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createSampler( const SamplerCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Sampler* pSampler, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Sampler>::type createSampler( const SamplerCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<Sampler,Dispatch>>::type createSamplerUnique( const SamplerCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroySampler( Sampler sampler, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroySampler( Sampler sampler, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Sampler sampler, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Sampler sampler, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createDescriptorSetLayout( const DescriptorSetLayoutCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorSetLayout* pSetLayout, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DescriptorSetLayout>::type createDescriptorSetLayout( const DescriptorSetLayoutCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<DescriptorSetLayout,Dispatch>>::type createDescriptorSetLayoutUnique( const DescriptorSetLayoutCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDescriptorSetLayout( DescriptorSetLayout descriptorSetLayout, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDescriptorSetLayout( DescriptorSetLayout descriptorSetLayout, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DescriptorSetLayout descriptorSetLayout, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DescriptorSetLayout descriptorSetLayout, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createDescriptorPool( const DescriptorPoolCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorPool* pDescriptorPool, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DescriptorPool>::type createDescriptorPool( const DescriptorPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<DescriptorPool,Dispatch>>::type createDescriptorPoolUnique( const DescriptorPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDescriptorPool( DescriptorPool descriptorPool, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDescriptorPool( DescriptorPool descriptorPool, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DescriptorPool descriptorPool, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DescriptorPool descriptorPool, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result resetDescriptorPool( DescriptorPool descriptorPool, DescriptorPoolResetFlags flags = DescriptorPoolResetFlags(), Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type resetDescriptorPool( DescriptorPool descriptorPool, DescriptorPoolResetFlags flags = DescriptorPoolResetFlags(), Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result allocateDescriptorSets( const DescriptorSetAllocateInfo* pAllocateInfo, DescriptorSet* pDescriptorSets, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<DescriptorSet>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<DescriptorSet,Allocator>>::type allocateDescriptorSets( const DescriptorSetAllocateInfo & allocateInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template <typename Allocator = std::allocator<UniqueDescriptorSet>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<UniqueHandle<DescriptorSet,Dispatch>,Allocator>>::type allocateDescriptorSetsUnique( const DescriptorSetAllocateInfo & allocateInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result freeDescriptorSets( DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type freeDescriptorSets( DescriptorPool descriptorPool, ArrayProxy<const DescriptorSet> descriptorSets, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result free( DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type free( DescriptorPool descriptorPool, ArrayProxy<const DescriptorSet> descriptorSets, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void updateDescriptorSets( uint32_t descriptorWriteCount, const WriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const CopyDescriptorSet* pDescriptorCopies, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void updateDescriptorSets( ArrayProxy<const WriteDescriptorSet> descriptorWrites, ArrayProxy<const CopyDescriptorSet> descriptorCopies, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createFramebuffer( const FramebufferCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Framebuffer* pFramebuffer, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Framebuffer>::type createFramebuffer( const FramebufferCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<Framebuffer,Dispatch>>::type createFramebufferUnique( const FramebufferCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyFramebuffer( Framebuffer framebuffer, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyFramebuffer( Framebuffer framebuffer, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Framebuffer framebuffer, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Framebuffer framebuffer, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createRenderPass( const RenderPassCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, RenderPass* pRenderPass, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<RenderPass>::type createRenderPass( const RenderPassCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<RenderPass,Dispatch>>::type createRenderPassUnique( const RenderPassCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyRenderPass( RenderPass renderPass, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyRenderPass( RenderPass renderPass, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( RenderPass renderPass, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( RenderPass renderPass, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getRenderAreaGranularity( RenderPass renderPass, Extent2D* pGranularity, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Extent2D getRenderAreaGranularity( RenderPass renderPass, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createCommandPool( const CommandPoolCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, CommandPool* pCommandPool, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<CommandPool>::type createCommandPool( const CommandPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<CommandPool,Dispatch>>::type createCommandPoolUnique( const CommandPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyCommandPool( CommandPool commandPool, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyCommandPool( CommandPool commandPool, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( CommandPool commandPool, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( CommandPool commandPool, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result resetCommandPool( CommandPool commandPool, CommandPoolResetFlags flags, Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type resetCommandPool( CommandPool commandPool, CommandPoolResetFlags flags, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result allocateCommandBuffers( const CommandBufferAllocateInfo* pAllocateInfo, CommandBuffer* pCommandBuffers, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<CommandBuffer>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<CommandBuffer,Allocator>>::type allocateCommandBuffers( const CommandBufferAllocateInfo & allocateInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template <typename Allocator = std::allocator<UniqueCommandBuffer>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<UniqueHandle<CommandBuffer,Dispatch>,Allocator>>::type allocateCommandBuffersUnique( const CommandBufferAllocateInfo & allocateInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void freeCommandBuffers( CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void freeCommandBuffers( CommandPool commandPool, ArrayProxy<const CommandBuffer> commandBuffers, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void free( CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void free( CommandPool commandPool, ArrayProxy<const CommandBuffer> commandBuffers, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createSharedSwapchainsKHR( uint32_t swapchainCount, const SwapchainCreateInfoKHR* pCreateInfos, const AllocationCallbacks* pAllocator, SwapchainKHR* pSwapchains, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<SwapchainKHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<SwapchainKHR,Allocator>>::type createSharedSwapchainsKHR( ArrayProxy<const SwapchainCreateInfoKHR> createInfos, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
    template <typename Allocator = std::allocator<SwapchainKHR>, typename Dispatch = DispatchLoaderStatic> 
    ResultValueType<SwapchainKHR>::type createSharedSwapchainKHR( const SwapchainCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template <typename Allocator = std::allocator<UniqueSwapchainKHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<UniqueHandle<SwapchainKHR,Dispatch>,Allocator>>::type createSharedSwapchainsKHRUnique( ArrayProxy<const SwapchainCreateInfoKHR> createInfos, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
    template <typename Allocator = std::allocator<UniqueSwapchainKHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<UniqueHandle<SwapchainKHR,Dispatch>>::type createSharedSwapchainKHRUnique( const SwapchainCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createSwapchainKHR( const SwapchainCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SwapchainKHR* pSwapchain, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SwapchainKHR>::type createSwapchainKHR( const SwapchainCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SwapchainKHR,Dispatch>>::type createSwapchainKHRUnique( const SwapchainCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroySwapchainKHR( SwapchainKHR swapchain, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroySwapchainKHR( SwapchainKHR swapchain, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( SwapchainKHR swapchain, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( SwapchainKHR swapchain, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSwapchainImagesKHR( SwapchainKHR swapchain, uint32_t* pSwapchainImageCount, Image* pSwapchainImages, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<Image>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<Image,Allocator>>::type getSwapchainImagesKHR( SwapchainKHR swapchain, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result acquireNextImageKHR( SwapchainKHR swapchain, uint64_t timeout, Semaphore semaphore, Fence fence, uint32_t* pImageIndex, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValue<uint32_t> acquireNextImageKHR( SwapchainKHR swapchain, uint64_t timeout, Semaphore semaphore, Fence fence, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result debugMarkerSetObjectNameEXT( const DebugMarkerObjectNameInfoEXT* pNameInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type debugMarkerSetObjectNameEXT( const DebugMarkerObjectNameInfoEXT & nameInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result debugMarkerSetObjectTagEXT( const DebugMarkerObjectTagInfoEXT* pTagInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type debugMarkerSetObjectTagEXT( const DebugMarkerObjectTagInfoEXT & tagInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_WIN32_NV
    template<typename Dispatch = DispatchLoaderStatic>
    Result getMemoryWin32HandleNV( DeviceMemory memory, ExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<HANDLE>::type getMemoryWin32HandleNV( DeviceMemory memory, ExternalMemoryHandleTypeFlagsNV handleType, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_NV*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createIndirectCommandsLayoutNVX( const IndirectCommandsLayoutCreateInfoNVX* pCreateInfo, const AllocationCallbacks* pAllocator, IndirectCommandsLayoutNVX* pIndirectCommandsLayout, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<IndirectCommandsLayoutNVX>::type createIndirectCommandsLayoutNVX( const IndirectCommandsLayoutCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<IndirectCommandsLayoutNVX,Dispatch>>::type createIndirectCommandsLayoutNVXUnique( const IndirectCommandsLayoutCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyIndirectCommandsLayoutNVX( IndirectCommandsLayoutNVX indirectCommandsLayout, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyIndirectCommandsLayoutNVX( IndirectCommandsLayoutNVX indirectCommandsLayout, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( IndirectCommandsLayoutNVX indirectCommandsLayout, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( IndirectCommandsLayoutNVX indirectCommandsLayout, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createObjectTableNVX( const ObjectTableCreateInfoNVX* pCreateInfo, const AllocationCallbacks* pAllocator, ObjectTableNVX* pObjectTable, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<ObjectTableNVX>::type createObjectTableNVX( const ObjectTableCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<ObjectTableNVX,Dispatch>>::type createObjectTableNVXUnique( const ObjectTableCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyObjectTableNVX( ObjectTableNVX objectTable, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyObjectTableNVX( ObjectTableNVX objectTable, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( ObjectTableNVX objectTable, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( ObjectTableNVX objectTable, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result registerObjectsNVX( ObjectTableNVX objectTable, uint32_t objectCount, const ObjectTableEntryNVX* const* ppObjectTableEntries, const uint32_t* pObjectIndices, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type registerObjectsNVX( ObjectTableNVX objectTable, ArrayProxy<const ObjectTableEntryNVX* const> pObjectTableEntries, ArrayProxy<const uint32_t> objectIndices, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result unregisterObjectsNVX( ObjectTableNVX objectTable, uint32_t objectCount, const ObjectEntryTypeNVX* pObjectEntryTypes, const uint32_t* pObjectIndices, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type unregisterObjectsNVX( ObjectTableNVX objectTable, ArrayProxy<const ObjectEntryTypeNVX> objectEntryTypes, ArrayProxy<const uint32_t> objectIndices, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void trimCommandPool( CommandPool commandPool, CommandPoolTrimFlags flags = CommandPoolTrimFlags(), Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void trimCommandPoolKHR( CommandPool commandPool, CommandPoolTrimFlags flags = CommandPoolTrimFlags(), Dispatch const &d = Dispatch() ) const;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result getMemoryWin32HandleKHR( const MemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<HANDLE>::type getMemoryWin32HandleKHR( const MemoryGetWin32HandleInfoKHR & getWin32HandleInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result getMemoryWin32HandlePropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, MemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<MemoryWin32HandlePropertiesKHR>::type getMemoryWin32HandlePropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getMemoryFdKHR( const MemoryGetFdInfoKHR* pGetFdInfo, int* pFd, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<int>::type getMemoryFdKHR( const MemoryGetFdInfoKHR & getFdInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getMemoryFdPropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType, int fd, MemoryFdPropertiesKHR* pMemoryFdProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<MemoryFdPropertiesKHR>::type getMemoryFdPropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType, int fd, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result getSemaphoreWin32HandleKHR( const SemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<HANDLE>::type getSemaphoreWin32HandleKHR( const SemaphoreGetWin32HandleInfoKHR & getWin32HandleInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result importSemaphoreWin32HandleKHR( const ImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type importSemaphoreWin32HandleKHR( const ImportSemaphoreWin32HandleInfoKHR & importSemaphoreWin32HandleInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSemaphoreFdKHR( const SemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<int>::type getSemaphoreFdKHR( const SemaphoreGetFdInfoKHR & getFdInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result importSemaphoreFdKHR( const ImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type importSemaphoreFdKHR( const ImportSemaphoreFdInfoKHR & importSemaphoreFdInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result getFenceWin32HandleKHR( const FenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<HANDLE>::type getFenceWin32HandleKHR( const FenceGetWin32HandleInfoKHR & getWin32HandleInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result importFenceWin32HandleKHR( const ImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type importFenceWin32HandleKHR( const ImportFenceWin32HandleInfoKHR & importFenceWin32HandleInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getFenceFdKHR( const FenceGetFdInfoKHR* pGetFdInfo, int* pFd, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<int>::type getFenceFdKHR( const FenceGetFdInfoKHR & getFdInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result importFenceFdKHR( const ImportFenceFdInfoKHR* pImportFenceFdInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type importFenceFdKHR( const ImportFenceFdInfoKHR & importFenceFdInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result displayPowerControlEXT( DisplayKHR display, const DisplayPowerInfoEXT* pDisplayPowerInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type displayPowerControlEXT( DisplayKHR display, const DisplayPowerInfoEXT & displayPowerInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result registerEventEXT( const DeviceEventInfoEXT* pDeviceEventInfo, const AllocationCallbacks* pAllocator, Fence* pFence, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Fence>::type registerEventEXT( const DeviceEventInfoEXT & deviceEventInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result registerDisplayEventEXT( DisplayKHR display, const DisplayEventInfoEXT* pDisplayEventInfo, const AllocationCallbacks* pAllocator, Fence* pFence, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Fence>::type registerDisplayEventEXT( DisplayKHR display, const DisplayEventInfoEXT & displayEventInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSwapchainCounterEXT( SwapchainKHR swapchain, SurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<uint64_t>::type getSwapchainCounterEXT( SwapchainKHR swapchain, SurfaceCounterFlagBitsEXT counter, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getGroupPeerMemoryFeatures( uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, PeerMemoryFeatureFlags* pPeerMemoryFeatures, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PeerMemoryFeatureFlags getGroupPeerMemoryFeatures( uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getGroupPeerMemoryFeaturesKHR( uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, PeerMemoryFeatureFlags* pPeerMemoryFeatures, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PeerMemoryFeatureFlags getGroupPeerMemoryFeaturesKHR( uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result bindBufferMemory2( uint32_t bindInfoCount, const BindBufferMemoryInfo* pBindInfos, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type bindBufferMemory2( ArrayProxy<const BindBufferMemoryInfo> bindInfos, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result bindBufferMemory2KHR( uint32_t bindInfoCount, const BindBufferMemoryInfo* pBindInfos, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type bindBufferMemory2KHR( ArrayProxy<const BindBufferMemoryInfo> bindInfos, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result bindImageMemory2( uint32_t bindInfoCount, const BindImageMemoryInfo* pBindInfos, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type bindImageMemory2( ArrayProxy<const BindImageMemoryInfo> bindInfos, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result bindImageMemory2KHR( uint32_t bindInfoCount, const BindImageMemoryInfo* pBindInfos, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type bindImageMemory2KHR( ArrayProxy<const BindImageMemoryInfo> bindInfos, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getGroupPresentCapabilitiesKHR( DeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DeviceGroupPresentCapabilitiesKHR>::type getGroupPresentCapabilitiesKHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getGroupSurfacePresentModesKHR( SurfaceKHR surface, DeviceGroupPresentModeFlagsKHR* pModes, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DeviceGroupPresentModeFlagsKHR>::type getGroupSurfacePresentModesKHR( SurfaceKHR surface, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result acquireNextImage2KHR( const AcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValue<uint32_t> acquireNextImage2KHR( const AcquireNextImageInfoKHR & acquireInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createDescriptorUpdateTemplate( const DescriptorUpdateTemplateCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorUpdateTemplate* pDescriptorUpdateTemplate, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DescriptorUpdateTemplate>::type createDescriptorUpdateTemplate( const DescriptorUpdateTemplateCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<DescriptorUpdateTemplate,Dispatch>>::type createDescriptorUpdateTemplateUnique( const DescriptorUpdateTemplateCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createDescriptorUpdateTemplateKHR( const DescriptorUpdateTemplateCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorUpdateTemplate* pDescriptorUpdateTemplate, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DescriptorUpdateTemplate>::type createDescriptorUpdateTemplateKHR( const DescriptorUpdateTemplateCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<DescriptorUpdateTemplate,Dispatch>>::type createDescriptorUpdateTemplateKHRUnique( const DescriptorUpdateTemplateCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDescriptorUpdateTemplate( DescriptorUpdateTemplate descriptorUpdateTemplate, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDescriptorUpdateTemplate( DescriptorUpdateTemplate descriptorUpdateTemplate, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DescriptorUpdateTemplate descriptorUpdateTemplate, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DescriptorUpdateTemplate descriptorUpdateTemplate, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDescriptorUpdateTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDescriptorUpdateTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void updateDescriptorSetWithTemplate( DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void updateDescriptorSetWithTemplateKHR( DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    void setHdrMetadataEXT( uint32_t swapchainCount, const SwapchainKHR* pSwapchains, const HdrMetadataEXT* pMetadata, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void setHdrMetadataEXT( ArrayProxy<const SwapchainKHR> swapchains, ArrayProxy<const HdrMetadataEXT> metadata, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSwapchainStatusKHR( SwapchainKHR swapchain, Dispatch const &d = Dispatch() ) const;

    template<typename Dispatch = DispatchLoaderStatic>
    Result getRefreshCycleDurationGOOGLE( SwapchainKHR swapchain, RefreshCycleDurationGOOGLE* pDisplayTimingProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<RefreshCycleDurationGOOGLE>::type getRefreshCycleDurationGOOGLE( SwapchainKHR swapchain, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getPastPresentationTimingGOOGLE( SwapchainKHR swapchain, uint32_t* pPresentationTimingCount, PastPresentationTimingGOOGLE* pPresentationTimings, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<PastPresentationTimingGOOGLE>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<PastPresentationTimingGOOGLE,Allocator>>::type getPastPresentationTimingGOOGLE( SwapchainKHR swapchain, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getBufferMemoryRequirements2( const BufferMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    MemoryRequirements2 getBufferMemoryRequirements2( const BufferMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getBufferMemoryRequirements2( const BufferMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getBufferMemoryRequirements2KHR( const BufferMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    MemoryRequirements2 getBufferMemoryRequirements2KHR( const BufferMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getBufferMemoryRequirements2KHR( const BufferMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getImageMemoryRequirements2( const ImageMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    MemoryRequirements2 getImageMemoryRequirements2( const ImageMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getImageMemoryRequirements2( const ImageMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getImageMemoryRequirements2KHR( const ImageMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    MemoryRequirements2 getImageMemoryRequirements2KHR( const ImageMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getImageMemoryRequirements2KHR( const ImageMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getImageSparseMemoryRequirements2( const ImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<SparseImageMemoryRequirements2>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<SparseImageMemoryRequirements2,Allocator> getImageSparseMemoryRequirements2( const ImageSparseMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getImageSparseMemoryRequirements2KHR( const ImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<SparseImageMemoryRequirements2>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<SparseImageMemoryRequirements2,Allocator> getImageSparseMemoryRequirements2KHR( const ImageSparseMemoryRequirementsInfo2 & info, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createSamplerYcbcrConversion( const SamplerYcbcrConversionCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, SamplerYcbcrConversion* pYcbcrConversion, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SamplerYcbcrConversion>::type createSamplerYcbcrConversion( const SamplerYcbcrConversionCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SamplerYcbcrConversion,Dispatch>>::type createSamplerYcbcrConversionUnique( const SamplerYcbcrConversionCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createSamplerYcbcrConversionKHR( const SamplerYcbcrConversionCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, SamplerYcbcrConversion* pYcbcrConversion, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SamplerYcbcrConversion>::type createSamplerYcbcrConversionKHR( const SamplerYcbcrConversionCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SamplerYcbcrConversion,Dispatch>>::type createSamplerYcbcrConversionKHRUnique( const SamplerYcbcrConversionCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroySamplerYcbcrConversion( SamplerYcbcrConversion ycbcrConversion, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroySamplerYcbcrConversion( SamplerYcbcrConversion ycbcrConversion, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( SamplerYcbcrConversion ycbcrConversion, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( SamplerYcbcrConversion ycbcrConversion, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroySamplerYcbcrConversionKHR( SamplerYcbcrConversion ycbcrConversion, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroySamplerYcbcrConversionKHR( SamplerYcbcrConversion ycbcrConversion, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getQueue2( const DeviceQueueInfo2* pQueueInfo, Queue* pQueue, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Queue getQueue2( const DeviceQueueInfo2 & queueInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createValidationCacheEXT( const ValidationCacheCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, ValidationCacheEXT* pValidationCache, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<ValidationCacheEXT>::type createValidationCacheEXT( const ValidationCacheCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<ValidationCacheEXT,Dispatch>>::type createValidationCacheEXTUnique( const ValidationCacheCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyValidationCacheEXT( ValidationCacheEXT validationCache, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyValidationCacheEXT( ValidationCacheEXT validationCache, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( ValidationCacheEXT validationCache, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( ValidationCacheEXT validationCache, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getValidationCacheDataEXT( ValidationCacheEXT validationCache, size_t* pDataSize, void* pData, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<uint8_t>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<uint8_t,Allocator>>::type getValidationCacheDataEXT( ValidationCacheEXT validationCache, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result mergeValidationCachesEXT( ValidationCacheEXT dstCache, uint32_t srcCacheCount, const ValidationCacheEXT* pSrcCaches, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type mergeValidationCachesEXT( ValidationCacheEXT dstCache, ArrayProxy<const ValidationCacheEXT> srcCaches, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getDescriptorSetLayoutSupport( const DescriptorSetLayoutCreateInfo* pCreateInfo, DescriptorSetLayoutSupport* pSupport, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    DescriptorSetLayoutSupport getDescriptorSetLayoutSupport( const DescriptorSetLayoutCreateInfo & createInfo, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getDescriptorSetLayoutSupport( const DescriptorSetLayoutCreateInfo & createInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getDescriptorSetLayoutSupportKHR( const DescriptorSetLayoutCreateInfo* pCreateInfo, DescriptorSetLayoutSupport* pSupport, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    DescriptorSetLayoutSupport getDescriptorSetLayoutSupportKHR( const DescriptorSetLayoutCreateInfo & createInfo, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getDescriptorSetLayoutSupportKHR( const DescriptorSetLayoutCreateInfo & createInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getShaderInfoAMD( Pipeline pipeline, ShaderStageFlagBits shaderStage, ShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<uint8_t>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<uint8_t,Allocator>>::type getShaderInfoAMD( Pipeline pipeline, ShaderStageFlagBits shaderStage, ShaderInfoTypeAMD infoType, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result setDebugUtilsObjectNameEXT( const DebugUtilsObjectNameInfoEXT* pNameInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type setDebugUtilsObjectNameEXT( const DebugUtilsObjectNameInfoEXT & nameInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result setDebugUtilsObjectTagEXT( const DebugUtilsObjectTagInfoEXT* pTagInfo, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type setDebugUtilsObjectTagEXT( const DebugUtilsObjectTagInfoEXT & tagInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getMemoryHostPointerPropertiesEXT( ExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, MemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<MemoryHostPointerPropertiesEXT>::type getMemoryHostPointerPropertiesEXT( ExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createRenderPass2KHR( const RenderPassCreateInfo2KHR* pCreateInfo, const AllocationCallbacks* pAllocator, RenderPass* pRenderPass, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<RenderPass>::type createRenderPass2KHR( const RenderPassCreateInfo2KHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<RenderPass,Dispatch>>::type createRenderPass2KHRUnique( const RenderPassCreateInfo2KHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
    template<typename Dispatch = DispatchLoaderStatic>
    Result getAndroidHardwareBufferPropertiesANDROID( const struct AHardwareBuffer* buffer, AndroidHardwareBufferPropertiesANDROID* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<AndroidHardwareBufferPropertiesANDROID>::type getAndroidHardwareBufferPropertiesANDROID( const struct AHardwareBuffer & buffer, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<StructureChain<X, Y, Z...>>::type getAndroidHardwareBufferPropertiesANDROID( const struct AHardwareBuffer & buffer, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
    template<typename Dispatch = DispatchLoaderStatic>
    Result getMemoryAndroidHardwareBufferANDROID( const MemoryGetAndroidHardwareBufferInfoANDROID* pInfo, struct AHardwareBuffer** pBuffer, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<struct AHardwareBuffer*>::type getMemoryAndroidHardwareBufferANDROID( const MemoryGetAndroidHardwareBufferInfoANDROID & info, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result compileDeferredNVX( Pipeline pipeline, uint32_t shader, Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type compileDeferredNVX( Pipeline pipeline, uint32_t shader, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createAccelerationStructureNVX( const AccelerationStructureCreateInfoNVX* pCreateInfo, const AllocationCallbacks* pAllocator, AccelerationStructureNVX* pAccelerationStructure, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<AccelerationStructureNVX>::type createAccelerationStructureNVX( const AccelerationStructureCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<AccelerationStructureNVX,Dispatch>>::type createAccelerationStructureNVXUnique( const AccelerationStructureCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyAccelerationStructureNVX( AccelerationStructureNVX accelerationStructure, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyAccelerationStructureNVX( AccelerationStructureNVX accelerationStructure, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( AccelerationStructureNVX accelerationStructure, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( AccelerationStructureNVX accelerationStructure, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getAccelerationStructureMemoryRequirementsNVX( const AccelerationStructureMemoryRequirementsInfoNVX* pInfo, MemoryRequirements2KHR* pMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    MemoryRequirements2KHR getAccelerationStructureMemoryRequirementsNVX( const AccelerationStructureMemoryRequirementsInfoNVX & info, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getAccelerationStructureScratchMemoryRequirementsNVX( const AccelerationStructureMemoryRequirementsInfoNVX* pInfo, MemoryRequirements2KHR* pMemoryRequirements, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    MemoryRequirements2KHR getAccelerationStructureScratchMemoryRequirementsNVX( const AccelerationStructureMemoryRequirementsInfoNVX & info, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result bindAccelerationStructureMemoryNVX( uint32_t bindInfoCount, const BindAccelerationStructureMemoryInfoNVX* pBindInfos, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type bindAccelerationStructureMemoryNVX( ArrayProxy<const BindAccelerationStructureMemoryInfoNVX> bindInfos, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getRaytracingShaderHandlesNVX( Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename T, typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type getRaytracingShaderHandlesNVX( Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, ArrayProxy<T> data, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getAccelerationStructureHandleNVX( AccelerationStructureNVX accelerationStructure, size_t dataSize, void* pData, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename T, typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type getAccelerationStructureHandleNVX( AccelerationStructureNVX accelerationStructure, ArrayProxy<T> data, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createRaytracingPipelinesNVX( PipelineCache pipelineCache, uint32_t createInfoCount, const RaytracingPipelineCreateInfoNVX* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<Pipeline>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<Pipeline,Allocator>>::type createRaytracingPipelinesNVX( PipelineCache pipelineCache, ArrayProxy<const RaytracingPipelineCreateInfoNVX> createInfos, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
    template <typename Allocator = std::allocator<Pipeline>, typename Dispatch = DispatchLoaderStatic> 
    ResultValueType<Pipeline>::type createRaytracingPipelineNVX( PipelineCache pipelineCache, const RaytracingPipelineCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template <typename Allocator = std::allocator<UniquePipeline>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<UniqueHandle<Pipeline,Dispatch>,Allocator>>::type createRaytracingPipelinesNVXUnique( PipelineCache pipelineCache, ArrayProxy<const RaytracingPipelineCreateInfoNVX> createInfos, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
    template <typename Allocator = std::allocator<UniquePipeline>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<UniqueHandle<Pipeline,Dispatch>>::type createRaytracingPipelineNVXUnique( PipelineCache pipelineCache, const RaytracingPipelineCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDevice() const
    {
      return m_device;
    }

    explicit operator bool() const
    {
      return m_device != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_device == VK_NULL_HANDLE;
    }

  private:
    VkDevice m_device;
  };

  static_assert( sizeof( Device ) == sizeof( VkDevice ), "handle and wrapper have different size!" );

  template<typename Dispatch>
  VULKAN_HPP_INLINE PFN_vkVoidFunction Device::getProcAddr( const char* pName, Dispatch const &d) const
  {
    return d.vkGetDeviceProcAddr( m_device, pName );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PFN_vkVoidFunction Device::getProcAddr( const std::string & name, Dispatch const &d ) const
  {
    return d.vkGetDeviceProcAddr( m_device, name.c_str() );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDevice( m_device, reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDevice( m_device, reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getQueue( uint32_t queueFamilyIndex, uint32_t queueIndex, Queue* pQueue, Dispatch const &d) const
  {
    d.vkGetDeviceQueue( m_device, queueFamilyIndex, queueIndex, reinterpret_cast<VkQueue*>( pQueue ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Queue Device::getQueue( uint32_t queueFamilyIndex, uint32_t queueIndex, Dispatch const &d ) const
  {
    Queue queue;
    d.vkGetDeviceQueue( m_device, queueFamilyIndex, queueIndex, reinterpret_cast<VkQueue*>( &queue ) );
    return queue;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::waitIdle(Dispatch const &d) const
  {
    return static_cast<Result>( d.vkDeviceWaitIdle( m_device ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::waitIdle(Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkDeviceWaitIdle( m_device ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::waitIdle" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::allocateMemory( const MemoryAllocateInfo* pAllocateInfo, const AllocationCallbacks* pAllocator, DeviceMemory* pMemory, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkAllocateMemory( m_device, reinterpret_cast<const VkMemoryAllocateInfo*>( pAllocateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkDeviceMemory*>( pMemory ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DeviceMemory>::type Device::allocateMemory( const MemoryAllocateInfo & allocateInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DeviceMemory memory;
    Result result = static_cast<Result>( d.vkAllocateMemory( m_device, reinterpret_cast<const VkMemoryAllocateInfo*>( &allocateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDeviceMemory*>( &memory ) ) );
    return createResultValue( result, memory, VULKAN_HPP_NAMESPACE_STRING"::Device::allocateMemory" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<DeviceMemory,Dispatch>>::type Device::allocateMemoryUnique( const MemoryAllocateInfo & allocateInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DeviceMemory memory;
    Result result = static_cast<Result>( d.vkAllocateMemory( m_device, reinterpret_cast<const VkMemoryAllocateInfo*>( &allocateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDeviceMemory*>( &memory ) ) );

    ObjectFree<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<DeviceMemory,Dispatch>( result, memory, VULKAN_HPP_NAMESPACE_STRING"::Device::allocateMemoryUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::freeMemory( DeviceMemory memory, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkFreeMemory( m_device, static_cast<VkDeviceMemory>( memory ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::freeMemory( DeviceMemory memory, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkFreeMemory( m_device, static_cast<VkDeviceMemory>( memory ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::free( DeviceMemory memory, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkFreeMemory( m_device, static_cast<VkDeviceMemory>( memory ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::free( DeviceMemory memory, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkFreeMemory( m_device, static_cast<VkDeviceMemory>( memory ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::mapMemory( DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags, void** ppData, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkMapMemory( m_device, static_cast<VkDeviceMemory>( memory ), offset, size, static_cast<VkMemoryMapFlags>( flags ), ppData ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void*>::type Device::mapMemory( DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags, Dispatch const &d ) const
  {
    void* pData;
    Result result = static_cast<Result>( d.vkMapMemory( m_device, static_cast<VkDeviceMemory>( memory ), offset, size, static_cast<VkMemoryMapFlags>( flags ), &pData ) );
    return createResultValue( result, pData, VULKAN_HPP_NAMESPACE_STRING"::Device::mapMemory" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::unmapMemory( DeviceMemory memory, Dispatch const &d) const
  {
    d.vkUnmapMemory( m_device, static_cast<VkDeviceMemory>( memory ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::unmapMemory( DeviceMemory memory, Dispatch const &d ) const
  {
    d.vkUnmapMemory( m_device, static_cast<VkDeviceMemory>( memory ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::flushMappedMemoryRanges( uint32_t memoryRangeCount, const MappedMemoryRange* pMemoryRanges, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkFlushMappedMemoryRanges( m_device, memoryRangeCount, reinterpret_cast<const VkMappedMemoryRange*>( pMemoryRanges ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::flushMappedMemoryRanges( ArrayProxy<const MappedMemoryRange> memoryRanges, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkFlushMappedMemoryRanges( m_device, memoryRanges.size() , reinterpret_cast<const VkMappedMemoryRange*>( memoryRanges.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::flushMappedMemoryRanges" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::invalidateMappedMemoryRanges( uint32_t memoryRangeCount, const MappedMemoryRange* pMemoryRanges, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkInvalidateMappedMemoryRanges( m_device, memoryRangeCount, reinterpret_cast<const VkMappedMemoryRange*>( pMemoryRanges ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::invalidateMappedMemoryRanges( ArrayProxy<const MappedMemoryRange> memoryRanges, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkInvalidateMappedMemoryRanges( m_device, memoryRanges.size() , reinterpret_cast<const VkMappedMemoryRange*>( memoryRanges.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::invalidateMappedMemoryRanges" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getMemoryCommitment( DeviceMemory memory, DeviceSize* pCommittedMemoryInBytes, Dispatch const &d) const
  {
    d.vkGetDeviceMemoryCommitment( m_device, static_cast<VkDeviceMemory>( memory ), pCommittedMemoryInBytes );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE DeviceSize Device::getMemoryCommitment( DeviceMemory memory, Dispatch const &d ) const
  {
    DeviceSize committedMemoryInBytes;
    d.vkGetDeviceMemoryCommitment( m_device, static_cast<VkDeviceMemory>( memory ), &committedMemoryInBytes );
    return committedMemoryInBytes;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getBufferMemoryRequirements( Buffer buffer, MemoryRequirements* pMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetBufferMemoryRequirements( m_device, static_cast<VkBuffer>( buffer ), reinterpret_cast<VkMemoryRequirements*>( pMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE MemoryRequirements Device::getBufferMemoryRequirements( Buffer buffer, Dispatch const &d ) const
  {
    MemoryRequirements memoryRequirements;
    d.vkGetBufferMemoryRequirements( m_device, static_cast<VkBuffer>( buffer ), reinterpret_cast<VkMemoryRequirements*>( &memoryRequirements ) );
    return memoryRequirements;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::bindBufferMemory( Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkBindBufferMemory( m_device, static_cast<VkBuffer>( buffer ), static_cast<VkDeviceMemory>( memory ), memoryOffset ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::bindBufferMemory( Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkBindBufferMemory( m_device, static_cast<VkBuffer>( buffer ), static_cast<VkDeviceMemory>( memory ), memoryOffset ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::bindBufferMemory" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getImageMemoryRequirements( Image image, MemoryRequirements* pMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetImageMemoryRequirements( m_device, static_cast<VkImage>( image ), reinterpret_cast<VkMemoryRequirements*>( pMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE MemoryRequirements Device::getImageMemoryRequirements( Image image, Dispatch const &d ) const
  {
    MemoryRequirements memoryRequirements;
    d.vkGetImageMemoryRequirements( m_device, static_cast<VkImage>( image ), reinterpret_cast<VkMemoryRequirements*>( &memoryRequirements ) );
    return memoryRequirements;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::bindImageMemory( Image image, DeviceMemory memory, DeviceSize memoryOffset, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkBindImageMemory( m_device, static_cast<VkImage>( image ), static_cast<VkDeviceMemory>( memory ), memoryOffset ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::bindImageMemory( Image image, DeviceMemory memory, DeviceSize memoryOffset, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkBindImageMemory( m_device, static_cast<VkImage>( image ), static_cast<VkDeviceMemory>( memory ), memoryOffset ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::bindImageMemory" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getImageSparseMemoryRequirements( Image image, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements* pSparseMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetImageSparseMemoryRequirements( m_device, static_cast<VkImage>( image ), pSparseMemoryRequirementCount, reinterpret_cast<VkSparseImageMemoryRequirements*>( pSparseMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<SparseImageMemoryRequirements,Allocator> Device::getImageSparseMemoryRequirements( Image image, Dispatch const &d ) const
  {
    std::vector<SparseImageMemoryRequirements,Allocator> sparseMemoryRequirements;
    uint32_t sparseMemoryRequirementCount;
    d.vkGetImageSparseMemoryRequirements( m_device, static_cast<VkImage>( image ), &sparseMemoryRequirementCount, nullptr );
    sparseMemoryRequirements.resize( sparseMemoryRequirementCount );
    d.vkGetImageSparseMemoryRequirements( m_device, static_cast<VkImage>( image ), &sparseMemoryRequirementCount, reinterpret_cast<VkSparseImageMemoryRequirements*>( sparseMemoryRequirements.data() ) );
    return sparseMemoryRequirements;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createFence( const FenceCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Fence* pFence, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateFence( m_device, reinterpret_cast<const VkFenceCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkFence*>( pFence ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Fence>::type Device::createFence( const FenceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Fence fence;
    Result result = static_cast<Result>( d.vkCreateFence( m_device, reinterpret_cast<const VkFenceCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkFence*>( &fence ) ) );
    return createResultValue( result, fence, VULKAN_HPP_NAMESPACE_STRING"::Device::createFence" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Fence,Dispatch>>::type Device::createFenceUnique( const FenceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Fence fence;
    Result result = static_cast<Result>( d.vkCreateFence( m_device, reinterpret_cast<const VkFenceCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkFence*>( &fence ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Fence,Dispatch>( result, fence, VULKAN_HPP_NAMESPACE_STRING"::Device::createFenceUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyFence( Fence fence, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyFence( m_device, static_cast<VkFence>( fence ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyFence( Fence fence, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyFence( m_device, static_cast<VkFence>( fence ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Fence fence, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyFence( m_device, static_cast<VkFence>( fence ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Fence fence, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyFence( m_device, static_cast<VkFence>( fence ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::resetFences( uint32_t fenceCount, const Fence* pFences, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkResetFences( m_device, fenceCount, reinterpret_cast<const VkFence*>( pFences ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::resetFences( ArrayProxy<const Fence> fences, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkResetFences( m_device, fences.size() , reinterpret_cast<const VkFence*>( fences.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::resetFences" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getFenceStatus( Fence fence, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetFenceStatus( m_device, static_cast<VkFence>( fence ) ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getFenceStatus( Fence fence, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkGetFenceStatus( m_device, static_cast<VkFence>( fence ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::getFenceStatus", { Result::eSuccess, Result::eNotReady } );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::waitForFences( uint32_t fenceCount, const Fence* pFences, Bool32 waitAll, uint64_t timeout, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkWaitForFences( m_device, fenceCount, reinterpret_cast<const VkFence*>( pFences ), waitAll, timeout ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::waitForFences( ArrayProxy<const Fence> fences, Bool32 waitAll, uint64_t timeout, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkWaitForFences( m_device, fences.size() , reinterpret_cast<const VkFence*>( fences.data() ), waitAll, timeout ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::waitForFences", { Result::eSuccess, Result::eTimeout } );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createSemaphore( const SemaphoreCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Semaphore* pSemaphore, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateSemaphore( m_device, reinterpret_cast<const VkSemaphoreCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSemaphore*>( pSemaphore ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Semaphore>::type Device::createSemaphore( const SemaphoreCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Semaphore semaphore;
    Result result = static_cast<Result>( d.vkCreateSemaphore( m_device, reinterpret_cast<const VkSemaphoreCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSemaphore*>( &semaphore ) ) );
    return createResultValue( result, semaphore, VULKAN_HPP_NAMESPACE_STRING"::Device::createSemaphore" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Semaphore,Dispatch>>::type Device::createSemaphoreUnique( const SemaphoreCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Semaphore semaphore;
    Result result = static_cast<Result>( d.vkCreateSemaphore( m_device, reinterpret_cast<const VkSemaphoreCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSemaphore*>( &semaphore ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Semaphore,Dispatch>( result, semaphore, VULKAN_HPP_NAMESPACE_STRING"::Device::createSemaphoreUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySemaphore( Semaphore semaphore, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySemaphore( m_device, static_cast<VkSemaphore>( semaphore ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySemaphore( Semaphore semaphore, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySemaphore( m_device, static_cast<VkSemaphore>( semaphore ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Semaphore semaphore, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySemaphore( m_device, static_cast<VkSemaphore>( semaphore ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Semaphore semaphore, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySemaphore( m_device, static_cast<VkSemaphore>( semaphore ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createEvent( const EventCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Event* pEvent, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateEvent( m_device, reinterpret_cast<const VkEventCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkEvent*>( pEvent ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Event>::type Device::createEvent( const EventCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Event event;
    Result result = static_cast<Result>( d.vkCreateEvent( m_device, reinterpret_cast<const VkEventCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkEvent*>( &event ) ) );
    return createResultValue( result, event, VULKAN_HPP_NAMESPACE_STRING"::Device::createEvent" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Event,Dispatch>>::type Device::createEventUnique( const EventCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Event event;
    Result result = static_cast<Result>( d.vkCreateEvent( m_device, reinterpret_cast<const VkEventCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkEvent*>( &event ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Event,Dispatch>( result, event, VULKAN_HPP_NAMESPACE_STRING"::Device::createEventUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyEvent( Event event, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyEvent( m_device, static_cast<VkEvent>( event ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyEvent( Event event, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyEvent( m_device, static_cast<VkEvent>( event ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Event event, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyEvent( m_device, static_cast<VkEvent>( event ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Event event, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyEvent( m_device, static_cast<VkEvent>( event ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getEventStatus( Event event, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetEventStatus( m_device, static_cast<VkEvent>( event ) ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getEventStatus( Event event, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkGetEventStatus( m_device, static_cast<VkEvent>( event ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::getEventStatus", { Result::eEventSet, Result::eEventReset } );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::setEvent( Event event, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkSetEvent( m_device, static_cast<VkEvent>( event ) ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::setEvent( Event event, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkSetEvent( m_device, static_cast<VkEvent>( event ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::setEvent" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::resetEvent( Event event, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkResetEvent( m_device, static_cast<VkEvent>( event ) ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::resetEvent( Event event, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkResetEvent( m_device, static_cast<VkEvent>( event ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::resetEvent" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createQueryPool( const QueryPoolCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, QueryPool* pQueryPool, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateQueryPool( m_device, reinterpret_cast<const VkQueryPoolCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkQueryPool*>( pQueryPool ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<QueryPool>::type Device::createQueryPool( const QueryPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    QueryPool queryPool;
    Result result = static_cast<Result>( d.vkCreateQueryPool( m_device, reinterpret_cast<const VkQueryPoolCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkQueryPool*>( &queryPool ) ) );
    return createResultValue( result, queryPool, VULKAN_HPP_NAMESPACE_STRING"::Device::createQueryPool" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<QueryPool,Dispatch>>::type Device::createQueryPoolUnique( const QueryPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    QueryPool queryPool;
    Result result = static_cast<Result>( d.vkCreateQueryPool( m_device, reinterpret_cast<const VkQueryPoolCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkQueryPool*>( &queryPool ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<QueryPool,Dispatch>( result, queryPool, VULKAN_HPP_NAMESPACE_STRING"::Device::createQueryPoolUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyQueryPool( QueryPool queryPool, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyQueryPool( m_device, static_cast<VkQueryPool>( queryPool ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyQueryPool( QueryPool queryPool, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyQueryPool( m_device, static_cast<VkQueryPool>( queryPool ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( QueryPool queryPool, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyQueryPool( m_device, static_cast<VkQueryPool>( queryPool ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( QueryPool queryPool, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyQueryPool( m_device, static_cast<VkQueryPool>( queryPool ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getQueryPoolResults( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, DeviceSize stride, QueryResultFlags flags, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetQueryPoolResults( m_device, static_cast<VkQueryPool>( queryPool ), firstQuery, queryCount, dataSize, pData, stride, static_cast<VkQueryResultFlags>( flags ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename T, typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getQueryPoolResults( QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, ArrayProxy<T> data, DeviceSize stride, QueryResultFlags flags, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkGetQueryPoolResults( m_device, static_cast<VkQueryPool>( queryPool ), firstQuery, queryCount, data.size() * sizeof( T ) , reinterpret_cast<void*>( data.data() ), stride, static_cast<VkQueryResultFlags>( flags ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::getQueryPoolResults", { Result::eSuccess, Result::eNotReady } );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createBuffer( const BufferCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Buffer* pBuffer, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateBuffer( m_device, reinterpret_cast<const VkBufferCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkBuffer*>( pBuffer ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Buffer>::type Device::createBuffer( const BufferCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Buffer buffer;
    Result result = static_cast<Result>( d.vkCreateBuffer( m_device, reinterpret_cast<const VkBufferCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkBuffer*>( &buffer ) ) );
    return createResultValue( result, buffer, VULKAN_HPP_NAMESPACE_STRING"::Device::createBuffer" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Buffer,Dispatch>>::type Device::createBufferUnique( const BufferCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Buffer buffer;
    Result result = static_cast<Result>( d.vkCreateBuffer( m_device, reinterpret_cast<const VkBufferCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkBuffer*>( &buffer ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Buffer,Dispatch>( result, buffer, VULKAN_HPP_NAMESPACE_STRING"::Device::createBufferUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyBuffer( Buffer buffer, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyBuffer( m_device, static_cast<VkBuffer>( buffer ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyBuffer( Buffer buffer, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyBuffer( m_device, static_cast<VkBuffer>( buffer ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Buffer buffer, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyBuffer( m_device, static_cast<VkBuffer>( buffer ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Buffer buffer, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyBuffer( m_device, static_cast<VkBuffer>( buffer ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createBufferView( const BufferViewCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, BufferView* pView, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateBufferView( m_device, reinterpret_cast<const VkBufferViewCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkBufferView*>( pView ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<BufferView>::type Device::createBufferView( const BufferViewCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    BufferView view;
    Result result = static_cast<Result>( d.vkCreateBufferView( m_device, reinterpret_cast<const VkBufferViewCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkBufferView*>( &view ) ) );
    return createResultValue( result, view, VULKAN_HPP_NAMESPACE_STRING"::Device::createBufferView" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<BufferView,Dispatch>>::type Device::createBufferViewUnique( const BufferViewCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    BufferView view;
    Result result = static_cast<Result>( d.vkCreateBufferView( m_device, reinterpret_cast<const VkBufferViewCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkBufferView*>( &view ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<BufferView,Dispatch>( result, view, VULKAN_HPP_NAMESPACE_STRING"::Device::createBufferViewUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyBufferView( BufferView bufferView, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyBufferView( m_device, static_cast<VkBufferView>( bufferView ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyBufferView( BufferView bufferView, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyBufferView( m_device, static_cast<VkBufferView>( bufferView ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( BufferView bufferView, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyBufferView( m_device, static_cast<VkBufferView>( bufferView ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( BufferView bufferView, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyBufferView( m_device, static_cast<VkBufferView>( bufferView ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createImage( const ImageCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Image* pImage, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateImage( m_device, reinterpret_cast<const VkImageCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkImage*>( pImage ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Image>::type Device::createImage( const ImageCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Image image;
    Result result = static_cast<Result>( d.vkCreateImage( m_device, reinterpret_cast<const VkImageCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkImage*>( &image ) ) );
    return createResultValue( result, image, VULKAN_HPP_NAMESPACE_STRING"::Device::createImage" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Image,Dispatch>>::type Device::createImageUnique( const ImageCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Image image;
    Result result = static_cast<Result>( d.vkCreateImage( m_device, reinterpret_cast<const VkImageCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkImage*>( &image ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Image,Dispatch>( result, image, VULKAN_HPP_NAMESPACE_STRING"::Device::createImageUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyImage( Image image, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyImage( m_device, static_cast<VkImage>( image ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyImage( Image image, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyImage( m_device, static_cast<VkImage>( image ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Image image, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyImage( m_device, static_cast<VkImage>( image ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Image image, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyImage( m_device, static_cast<VkImage>( image ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getImageSubresourceLayout( Image image, const ImageSubresource* pSubresource, SubresourceLayout* pLayout, Dispatch const &d) const
  {
    d.vkGetImageSubresourceLayout( m_device, static_cast<VkImage>( image ), reinterpret_cast<const VkImageSubresource*>( pSubresource ), reinterpret_cast<VkSubresourceLayout*>( pLayout ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE SubresourceLayout Device::getImageSubresourceLayout( Image image, const ImageSubresource & subresource, Dispatch const &d ) const
  {
    SubresourceLayout layout;
    d.vkGetImageSubresourceLayout( m_device, static_cast<VkImage>( image ), reinterpret_cast<const VkImageSubresource*>( &subresource ), reinterpret_cast<VkSubresourceLayout*>( &layout ) );
    return layout;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createImageView( const ImageViewCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, ImageView* pView, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateImageView( m_device, reinterpret_cast<const VkImageViewCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkImageView*>( pView ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<ImageView>::type Device::createImageView( const ImageViewCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    ImageView view;
    Result result = static_cast<Result>( d.vkCreateImageView( m_device, reinterpret_cast<const VkImageViewCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkImageView*>( &view ) ) );
    return createResultValue( result, view, VULKAN_HPP_NAMESPACE_STRING"::Device::createImageView" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<ImageView,Dispatch>>::type Device::createImageViewUnique( const ImageViewCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    ImageView view;
    Result result = static_cast<Result>( d.vkCreateImageView( m_device, reinterpret_cast<const VkImageViewCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkImageView*>( &view ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<ImageView,Dispatch>( result, view, VULKAN_HPP_NAMESPACE_STRING"::Device::createImageViewUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyImageView( ImageView imageView, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyImageView( m_device, static_cast<VkImageView>( imageView ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyImageView( ImageView imageView, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyImageView( m_device, static_cast<VkImageView>( imageView ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( ImageView imageView, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyImageView( m_device, static_cast<VkImageView>( imageView ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( ImageView imageView, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyImageView( m_device, static_cast<VkImageView>( imageView ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createShaderModule( const ShaderModuleCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, ShaderModule* pShaderModule, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateShaderModule( m_device, reinterpret_cast<const VkShaderModuleCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkShaderModule*>( pShaderModule ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<ShaderModule>::type Device::createShaderModule( const ShaderModuleCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    ShaderModule shaderModule;
    Result result = static_cast<Result>( d.vkCreateShaderModule( m_device, reinterpret_cast<const VkShaderModuleCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkShaderModule*>( &shaderModule ) ) );
    return createResultValue( result, shaderModule, VULKAN_HPP_NAMESPACE_STRING"::Device::createShaderModule" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<ShaderModule,Dispatch>>::type Device::createShaderModuleUnique( const ShaderModuleCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    ShaderModule shaderModule;
    Result result = static_cast<Result>( d.vkCreateShaderModule( m_device, reinterpret_cast<const VkShaderModuleCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkShaderModule*>( &shaderModule ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<ShaderModule,Dispatch>( result, shaderModule, VULKAN_HPP_NAMESPACE_STRING"::Device::createShaderModuleUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyShaderModule( ShaderModule shaderModule, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyShaderModule( m_device, static_cast<VkShaderModule>( shaderModule ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyShaderModule( ShaderModule shaderModule, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyShaderModule( m_device, static_cast<VkShaderModule>( shaderModule ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( ShaderModule shaderModule, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyShaderModule( m_device, static_cast<VkShaderModule>( shaderModule ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( ShaderModule shaderModule, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyShaderModule( m_device, static_cast<VkShaderModule>( shaderModule ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createPipelineCache( const PipelineCacheCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, PipelineCache* pPipelineCache, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreatePipelineCache( m_device, reinterpret_cast<const VkPipelineCacheCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkPipelineCache*>( pPipelineCache ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<PipelineCache>::type Device::createPipelineCache( const PipelineCacheCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    PipelineCache pipelineCache;
    Result result = static_cast<Result>( d.vkCreatePipelineCache( m_device, reinterpret_cast<const VkPipelineCacheCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipelineCache*>( &pipelineCache ) ) );
    return createResultValue( result, pipelineCache, VULKAN_HPP_NAMESPACE_STRING"::Device::createPipelineCache" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<PipelineCache,Dispatch>>::type Device::createPipelineCacheUnique( const PipelineCacheCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    PipelineCache pipelineCache;
    Result result = static_cast<Result>( d.vkCreatePipelineCache( m_device, reinterpret_cast<const VkPipelineCacheCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipelineCache*>( &pipelineCache ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<PipelineCache,Dispatch>( result, pipelineCache, VULKAN_HPP_NAMESPACE_STRING"::Device::createPipelineCacheUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyPipelineCache( PipelineCache pipelineCache, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyPipelineCache( m_device, static_cast<VkPipelineCache>( pipelineCache ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyPipelineCache( PipelineCache pipelineCache, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyPipelineCache( m_device, static_cast<VkPipelineCache>( pipelineCache ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( PipelineCache pipelineCache, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyPipelineCache( m_device, static_cast<VkPipelineCache>( pipelineCache ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( PipelineCache pipelineCache, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyPipelineCache( m_device, static_cast<VkPipelineCache>( pipelineCache ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getPipelineCacheData( PipelineCache pipelineCache, size_t* pDataSize, void* pData, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPipelineCacheData( m_device, static_cast<VkPipelineCache>( pipelineCache ), pDataSize, pData ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<uint8_t,Allocator>>::type Device::getPipelineCacheData( PipelineCache pipelineCache, Dispatch const &d ) const
  {
    std::vector<uint8_t,Allocator> data;
    size_t dataSize;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPipelineCacheData( m_device, static_cast<VkPipelineCache>( pipelineCache ), &dataSize, nullptr ) );
      if ( ( result == Result::eSuccess ) && dataSize )
      {
        data.resize( dataSize );
        result = static_cast<Result>( d.vkGetPipelineCacheData( m_device, static_cast<VkPipelineCache>( pipelineCache ), &dataSize, reinterpret_cast<void*>( data.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( dataSize <= data.size() );
    data.resize( dataSize );
    return createResultValue( result, data, VULKAN_HPP_NAMESPACE_STRING"::Device::getPipelineCacheData" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::mergePipelineCaches( PipelineCache dstCache, uint32_t srcCacheCount, const PipelineCache* pSrcCaches, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkMergePipelineCaches( m_device, static_cast<VkPipelineCache>( dstCache ), srcCacheCount, reinterpret_cast<const VkPipelineCache*>( pSrcCaches ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::mergePipelineCaches( PipelineCache dstCache, ArrayProxy<const PipelineCache> srcCaches, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkMergePipelineCaches( m_device, static_cast<VkPipelineCache>( dstCache ), srcCaches.size() , reinterpret_cast<const VkPipelineCache*>( srcCaches.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::mergePipelineCaches" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createGraphicsPipelines( PipelineCache pipelineCache, uint32_t createInfoCount, const GraphicsPipelineCreateInfo* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateGraphicsPipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), createInfoCount, reinterpret_cast<const VkGraphicsPipelineCreateInfo*>( pCreateInfos ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkPipeline*>( pPipelines ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<Pipeline,Allocator>>::type Device::createGraphicsPipelines( PipelineCache pipelineCache, ArrayProxy<const GraphicsPipelineCreateInfo> createInfos, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    std::vector<Pipeline,Allocator> pipelines( createInfos.size() );
    Result result = static_cast<Result>( d.vkCreateGraphicsPipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), createInfos.size() , reinterpret_cast<const VkGraphicsPipelineCreateInfo*>( createInfos.data() ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( pipelines.data() ) ) );
    return createResultValue( result, pipelines, VULKAN_HPP_NAMESPACE_STRING"::Device::createGraphicsPipelines" );
  }
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE ResultValueType<Pipeline>::type Device::createGraphicsPipeline( PipelineCache pipelineCache, const GraphicsPipelineCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Pipeline pipeline;
    Result result = static_cast<Result>( d.vkCreateGraphicsPipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), 1 , reinterpret_cast<const VkGraphicsPipelineCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( &pipeline ) ) );
    return createResultValue( result, pipeline, VULKAN_HPP_NAMESPACE_STRING"::Device::createGraphicsPipeline" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<UniqueHandle<Pipeline,Dispatch>,Allocator>>::type Device::createGraphicsPipelinesUnique( PipelineCache pipelineCache, ArrayProxy<const GraphicsPipelineCreateInfo> createInfos, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    static_assert( sizeof( Pipeline ) <= sizeof( UniquePipeline ), "Pipeline is greater than UniquePipeline!" );
    std::vector<UniquePipeline, Allocator> pipelines;
    pipelines.reserve( createInfos.size() );
    Pipeline* buffer = reinterpret_cast<Pipeline*>( reinterpret_cast<char*>( pipelines.data() ) + createInfos.size() * ( sizeof( UniquePipeline ) - sizeof( Pipeline ) ) );
    Result result = static_cast<Result>(d.vkCreateGraphicsPipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), createInfos.size() , reinterpret_cast<const VkGraphicsPipelineCreateInfo*>( createInfos.data() ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( buffer ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    for ( size_t i=0 ; i<createInfos.size() ; i++ )
    {
      pipelines.push_back( UniquePipeline( buffer[i], deleter ) );
    }

    return createResultValue( result, pipelines, VULKAN_HPP_NAMESPACE_STRING "::Device::createGraphicsPipelinesUnique" );
  }
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Pipeline,Dispatch>>::type Device::createGraphicsPipelineUnique( PipelineCache pipelineCache, const GraphicsPipelineCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Pipeline pipeline;
    Result result = static_cast<Result>( d.vkCreateGraphicsPipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), 1 , reinterpret_cast<const VkGraphicsPipelineCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( &pipeline ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Pipeline,Dispatch>( result, pipeline, VULKAN_HPP_NAMESPACE_STRING"::Device::createGraphicsPipelineUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createComputePipelines( PipelineCache pipelineCache, uint32_t createInfoCount, const ComputePipelineCreateInfo* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateComputePipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), createInfoCount, reinterpret_cast<const VkComputePipelineCreateInfo*>( pCreateInfos ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkPipeline*>( pPipelines ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<Pipeline,Allocator>>::type Device::createComputePipelines( PipelineCache pipelineCache, ArrayProxy<const ComputePipelineCreateInfo> createInfos, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    std::vector<Pipeline,Allocator> pipelines( createInfos.size() );
    Result result = static_cast<Result>( d.vkCreateComputePipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), createInfos.size() , reinterpret_cast<const VkComputePipelineCreateInfo*>( createInfos.data() ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( pipelines.data() ) ) );
    return createResultValue( result, pipelines, VULKAN_HPP_NAMESPACE_STRING"::Device::createComputePipelines" );
  }
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE ResultValueType<Pipeline>::type Device::createComputePipeline( PipelineCache pipelineCache, const ComputePipelineCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Pipeline pipeline;
    Result result = static_cast<Result>( d.vkCreateComputePipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), 1 , reinterpret_cast<const VkComputePipelineCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( &pipeline ) ) );
    return createResultValue( result, pipeline, VULKAN_HPP_NAMESPACE_STRING"::Device::createComputePipeline" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<UniqueHandle<Pipeline,Dispatch>,Allocator>>::type Device::createComputePipelinesUnique( PipelineCache pipelineCache, ArrayProxy<const ComputePipelineCreateInfo> createInfos, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    static_assert( sizeof( Pipeline ) <= sizeof( UniquePipeline ), "Pipeline is greater than UniquePipeline!" );
    std::vector<UniquePipeline, Allocator> pipelines;
    pipelines.reserve( createInfos.size() );
    Pipeline* buffer = reinterpret_cast<Pipeline*>( reinterpret_cast<char*>( pipelines.data() ) + createInfos.size() * ( sizeof( UniquePipeline ) - sizeof( Pipeline ) ) );
    Result result = static_cast<Result>(d.vkCreateComputePipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), createInfos.size() , reinterpret_cast<const VkComputePipelineCreateInfo*>( createInfos.data() ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( buffer ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    for ( size_t i=0 ; i<createInfos.size() ; i++ )
    {
      pipelines.push_back( UniquePipeline( buffer[i], deleter ) );
    }

    return createResultValue( result, pipelines, VULKAN_HPP_NAMESPACE_STRING "::Device::createComputePipelinesUnique" );
  }
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Pipeline,Dispatch>>::type Device::createComputePipelineUnique( PipelineCache pipelineCache, const ComputePipelineCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Pipeline pipeline;
    Result result = static_cast<Result>( d.vkCreateComputePipelines( m_device, static_cast<VkPipelineCache>( pipelineCache ), 1 , reinterpret_cast<const VkComputePipelineCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( &pipeline ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Pipeline,Dispatch>( result, pipeline, VULKAN_HPP_NAMESPACE_STRING"::Device::createComputePipelineUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyPipeline( Pipeline pipeline, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyPipeline( m_device, static_cast<VkPipeline>( pipeline ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyPipeline( Pipeline pipeline, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyPipeline( m_device, static_cast<VkPipeline>( pipeline ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Pipeline pipeline, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyPipeline( m_device, static_cast<VkPipeline>( pipeline ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Pipeline pipeline, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyPipeline( m_device, static_cast<VkPipeline>( pipeline ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createPipelineLayout( const PipelineLayoutCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, PipelineLayout* pPipelineLayout, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreatePipelineLayout( m_device, reinterpret_cast<const VkPipelineLayoutCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkPipelineLayout*>( pPipelineLayout ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<PipelineLayout>::type Device::createPipelineLayout( const PipelineLayoutCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    PipelineLayout pipelineLayout;
    Result result = static_cast<Result>( d.vkCreatePipelineLayout( m_device, reinterpret_cast<const VkPipelineLayoutCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipelineLayout*>( &pipelineLayout ) ) );
    return createResultValue( result, pipelineLayout, VULKAN_HPP_NAMESPACE_STRING"::Device::createPipelineLayout" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<PipelineLayout,Dispatch>>::type Device::createPipelineLayoutUnique( const PipelineLayoutCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    PipelineLayout pipelineLayout;
    Result result = static_cast<Result>( d.vkCreatePipelineLayout( m_device, reinterpret_cast<const VkPipelineLayoutCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipelineLayout*>( &pipelineLayout ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<PipelineLayout,Dispatch>( result, pipelineLayout, VULKAN_HPP_NAMESPACE_STRING"::Device::createPipelineLayoutUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyPipelineLayout( PipelineLayout pipelineLayout, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyPipelineLayout( m_device, static_cast<VkPipelineLayout>( pipelineLayout ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyPipelineLayout( PipelineLayout pipelineLayout, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyPipelineLayout( m_device, static_cast<VkPipelineLayout>( pipelineLayout ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( PipelineLayout pipelineLayout, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyPipelineLayout( m_device, static_cast<VkPipelineLayout>( pipelineLayout ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( PipelineLayout pipelineLayout, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyPipelineLayout( m_device, static_cast<VkPipelineLayout>( pipelineLayout ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createSampler( const SamplerCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Sampler* pSampler, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateSampler( m_device, reinterpret_cast<const VkSamplerCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSampler*>( pSampler ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Sampler>::type Device::createSampler( const SamplerCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Sampler sampler;
    Result result = static_cast<Result>( d.vkCreateSampler( m_device, reinterpret_cast<const VkSamplerCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSampler*>( &sampler ) ) );
    return createResultValue( result, sampler, VULKAN_HPP_NAMESPACE_STRING"::Device::createSampler" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Sampler,Dispatch>>::type Device::createSamplerUnique( const SamplerCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Sampler sampler;
    Result result = static_cast<Result>( d.vkCreateSampler( m_device, reinterpret_cast<const VkSamplerCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSampler*>( &sampler ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Sampler,Dispatch>( result, sampler, VULKAN_HPP_NAMESPACE_STRING"::Device::createSamplerUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySampler( Sampler sampler, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySampler( m_device, static_cast<VkSampler>( sampler ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySampler( Sampler sampler, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySampler( m_device, static_cast<VkSampler>( sampler ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Sampler sampler, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySampler( m_device, static_cast<VkSampler>( sampler ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Sampler sampler, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySampler( m_device, static_cast<VkSampler>( sampler ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createDescriptorSetLayout( const DescriptorSetLayoutCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorSetLayout* pSetLayout, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateDescriptorSetLayout( m_device, reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkDescriptorSetLayout*>( pSetLayout ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DescriptorSetLayout>::type Device::createDescriptorSetLayout( const DescriptorSetLayoutCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DescriptorSetLayout setLayout;
    Result result = static_cast<Result>( d.vkCreateDescriptorSetLayout( m_device, reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDescriptorSetLayout*>( &setLayout ) ) );
    return createResultValue( result, setLayout, VULKAN_HPP_NAMESPACE_STRING"::Device::createDescriptorSetLayout" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<DescriptorSetLayout,Dispatch>>::type Device::createDescriptorSetLayoutUnique( const DescriptorSetLayoutCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DescriptorSetLayout setLayout;
    Result result = static_cast<Result>( d.vkCreateDescriptorSetLayout( m_device, reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDescriptorSetLayout*>( &setLayout ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<DescriptorSetLayout,Dispatch>( result, setLayout, VULKAN_HPP_NAMESPACE_STRING"::Device::createDescriptorSetLayoutUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyDescriptorSetLayout( DescriptorSetLayout descriptorSetLayout, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDescriptorSetLayout( m_device, static_cast<VkDescriptorSetLayout>( descriptorSetLayout ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyDescriptorSetLayout( DescriptorSetLayout descriptorSetLayout, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDescriptorSetLayout( m_device, static_cast<VkDescriptorSetLayout>( descriptorSetLayout ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( DescriptorSetLayout descriptorSetLayout, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDescriptorSetLayout( m_device, static_cast<VkDescriptorSetLayout>( descriptorSetLayout ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( DescriptorSetLayout descriptorSetLayout, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDescriptorSetLayout( m_device, static_cast<VkDescriptorSetLayout>( descriptorSetLayout ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createDescriptorPool( const DescriptorPoolCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorPool* pDescriptorPool, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateDescriptorPool( m_device, reinterpret_cast<const VkDescriptorPoolCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkDescriptorPool*>( pDescriptorPool ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DescriptorPool>::type Device::createDescriptorPool( const DescriptorPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DescriptorPool descriptorPool;
    Result result = static_cast<Result>( d.vkCreateDescriptorPool( m_device, reinterpret_cast<const VkDescriptorPoolCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDescriptorPool*>( &descriptorPool ) ) );
    return createResultValue( result, descriptorPool, VULKAN_HPP_NAMESPACE_STRING"::Device::createDescriptorPool" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<DescriptorPool,Dispatch>>::type Device::createDescriptorPoolUnique( const DescriptorPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DescriptorPool descriptorPool;
    Result result = static_cast<Result>( d.vkCreateDescriptorPool( m_device, reinterpret_cast<const VkDescriptorPoolCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDescriptorPool*>( &descriptorPool ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<DescriptorPool,Dispatch>( result, descriptorPool, VULKAN_HPP_NAMESPACE_STRING"::Device::createDescriptorPoolUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyDescriptorPool( DescriptorPool descriptorPool, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDescriptorPool( m_device, static_cast<VkDescriptorPool>( descriptorPool ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyDescriptorPool( DescriptorPool descriptorPool, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDescriptorPool( m_device, static_cast<VkDescriptorPool>( descriptorPool ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( DescriptorPool descriptorPool, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDescriptorPool( m_device, static_cast<VkDescriptorPool>( descriptorPool ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( DescriptorPool descriptorPool, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDescriptorPool( m_device, static_cast<VkDescriptorPool>( descriptorPool ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::resetDescriptorPool( DescriptorPool descriptorPool, DescriptorPoolResetFlags flags, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkResetDescriptorPool( m_device, static_cast<VkDescriptorPool>( descriptorPool ), static_cast<VkDescriptorPoolResetFlags>( flags ) ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::resetDescriptorPool( DescriptorPool descriptorPool, DescriptorPoolResetFlags flags, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkResetDescriptorPool( m_device, static_cast<VkDescriptorPool>( descriptorPool ), static_cast<VkDescriptorPoolResetFlags>( flags ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::resetDescriptorPool" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::allocateDescriptorSets( const DescriptorSetAllocateInfo* pAllocateInfo, DescriptorSet* pDescriptorSets, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkAllocateDescriptorSets( m_device, reinterpret_cast<const VkDescriptorSetAllocateInfo*>( pAllocateInfo ), reinterpret_cast<VkDescriptorSet*>( pDescriptorSets ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<DescriptorSet,Allocator>>::type Device::allocateDescriptorSets( const DescriptorSetAllocateInfo & allocateInfo, Dispatch const &d ) const
  {
    std::vector<DescriptorSet,Allocator> descriptorSets( allocateInfo.descriptorSetCount );
    Result result = static_cast<Result>( d.vkAllocateDescriptorSets( m_device, reinterpret_cast<const VkDescriptorSetAllocateInfo*>( &allocateInfo ), reinterpret_cast<VkDescriptorSet*>( descriptorSets.data() ) ) );
    return createResultValue( result, descriptorSets, VULKAN_HPP_NAMESPACE_STRING"::Device::allocateDescriptorSets" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<UniqueHandle<DescriptorSet,Dispatch>,Allocator>>::type Device::allocateDescriptorSetsUnique( const DescriptorSetAllocateInfo & allocateInfo, Dispatch const &d ) const
  {
    static_assert( sizeof( DescriptorSet ) <= sizeof( UniqueDescriptorSet ), "DescriptorSet is greater than UniqueDescriptorSet!" );
    std::vector<UniqueDescriptorSet, Allocator> descriptorSets;
    descriptorSets.reserve( allocateInfo.descriptorSetCount );
    DescriptorSet* buffer = reinterpret_cast<DescriptorSet*>( reinterpret_cast<char*>( descriptorSets.data() ) + allocateInfo.descriptorSetCount * ( sizeof( UniqueDescriptorSet ) - sizeof( DescriptorSet ) ) );
    Result result = static_cast<Result>(d.vkAllocateDescriptorSets( m_device, reinterpret_cast<const VkDescriptorSetAllocateInfo*>( &allocateInfo ), reinterpret_cast<VkDescriptorSet*>( buffer ) ) );

    PoolFree<Device,DescriptorPool,Dispatch> deleter( *this, allocateInfo.descriptorPool, d );
    for ( size_t i=0 ; i<allocateInfo.descriptorSetCount ; i++ )
    {
      descriptorSets.push_back( UniqueDescriptorSet( buffer[i], deleter ) );
    }

    return createResultValue( result, descriptorSets, VULKAN_HPP_NAMESPACE_STRING "::Device::allocateDescriptorSetsUnique" );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::freeDescriptorSets( DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkFreeDescriptorSets( m_device, static_cast<VkDescriptorPool>( descriptorPool ), descriptorSetCount, reinterpret_cast<const VkDescriptorSet*>( pDescriptorSets ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::freeDescriptorSets( DescriptorPool descriptorPool, ArrayProxy<const DescriptorSet> descriptorSets, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkFreeDescriptorSets( m_device, static_cast<VkDescriptorPool>( descriptorPool ), descriptorSets.size() , reinterpret_cast<const VkDescriptorSet*>( descriptorSets.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::freeDescriptorSets" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::free( DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkFreeDescriptorSets( m_device, static_cast<VkDescriptorPool>( descriptorPool ), descriptorSetCount, reinterpret_cast<const VkDescriptorSet*>( pDescriptorSets ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::free( DescriptorPool descriptorPool, ArrayProxy<const DescriptorSet> descriptorSets, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkFreeDescriptorSets( m_device, static_cast<VkDescriptorPool>( descriptorPool ), descriptorSets.size() , reinterpret_cast<const VkDescriptorSet*>( descriptorSets.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::free" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::updateDescriptorSets( uint32_t descriptorWriteCount, const WriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const CopyDescriptorSet* pDescriptorCopies, Dispatch const &d) const
  {
    d.vkUpdateDescriptorSets( m_device, descriptorWriteCount, reinterpret_cast<const VkWriteDescriptorSet*>( pDescriptorWrites ), descriptorCopyCount, reinterpret_cast<const VkCopyDescriptorSet*>( pDescriptorCopies ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::updateDescriptorSets( ArrayProxy<const WriteDescriptorSet> descriptorWrites, ArrayProxy<const CopyDescriptorSet> descriptorCopies, Dispatch const &d ) const
  {
    d.vkUpdateDescriptorSets( m_device, descriptorWrites.size() , reinterpret_cast<const VkWriteDescriptorSet*>( descriptorWrites.data() ), descriptorCopies.size() , reinterpret_cast<const VkCopyDescriptorSet*>( descriptorCopies.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createFramebuffer( const FramebufferCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Framebuffer* pFramebuffer, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateFramebuffer( m_device, reinterpret_cast<const VkFramebufferCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkFramebuffer*>( pFramebuffer ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Framebuffer>::type Device::createFramebuffer( const FramebufferCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Framebuffer framebuffer;
    Result result = static_cast<Result>( d.vkCreateFramebuffer( m_device, reinterpret_cast<const VkFramebufferCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkFramebuffer*>( &framebuffer ) ) );
    return createResultValue( result, framebuffer, VULKAN_HPP_NAMESPACE_STRING"::Device::createFramebuffer" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Framebuffer,Dispatch>>::type Device::createFramebufferUnique( const FramebufferCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Framebuffer framebuffer;
    Result result = static_cast<Result>( d.vkCreateFramebuffer( m_device, reinterpret_cast<const VkFramebufferCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkFramebuffer*>( &framebuffer ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Framebuffer,Dispatch>( result, framebuffer, VULKAN_HPP_NAMESPACE_STRING"::Device::createFramebufferUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyFramebuffer( Framebuffer framebuffer, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyFramebuffer( m_device, static_cast<VkFramebuffer>( framebuffer ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyFramebuffer( Framebuffer framebuffer, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyFramebuffer( m_device, static_cast<VkFramebuffer>( framebuffer ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Framebuffer framebuffer, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyFramebuffer( m_device, static_cast<VkFramebuffer>( framebuffer ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( Framebuffer framebuffer, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyFramebuffer( m_device, static_cast<VkFramebuffer>( framebuffer ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createRenderPass( const RenderPassCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, RenderPass* pRenderPass, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateRenderPass( m_device, reinterpret_cast<const VkRenderPassCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkRenderPass*>( pRenderPass ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<RenderPass>::type Device::createRenderPass( const RenderPassCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    RenderPass renderPass;
    Result result = static_cast<Result>( d.vkCreateRenderPass( m_device, reinterpret_cast<const VkRenderPassCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkRenderPass*>( &renderPass ) ) );
    return createResultValue( result, renderPass, VULKAN_HPP_NAMESPACE_STRING"::Device::createRenderPass" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<RenderPass,Dispatch>>::type Device::createRenderPassUnique( const RenderPassCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    RenderPass renderPass;
    Result result = static_cast<Result>( d.vkCreateRenderPass( m_device, reinterpret_cast<const VkRenderPassCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkRenderPass*>( &renderPass ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<RenderPass,Dispatch>( result, renderPass, VULKAN_HPP_NAMESPACE_STRING"::Device::createRenderPassUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyRenderPass( RenderPass renderPass, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyRenderPass( m_device, static_cast<VkRenderPass>( renderPass ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyRenderPass( RenderPass renderPass, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyRenderPass( m_device, static_cast<VkRenderPass>( renderPass ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( RenderPass renderPass, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyRenderPass( m_device, static_cast<VkRenderPass>( renderPass ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( RenderPass renderPass, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyRenderPass( m_device, static_cast<VkRenderPass>( renderPass ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getRenderAreaGranularity( RenderPass renderPass, Extent2D* pGranularity, Dispatch const &d) const
  {
    d.vkGetRenderAreaGranularity( m_device, static_cast<VkRenderPass>( renderPass ), reinterpret_cast<VkExtent2D*>( pGranularity ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Extent2D Device::getRenderAreaGranularity( RenderPass renderPass, Dispatch const &d ) const
  {
    Extent2D granularity;
    d.vkGetRenderAreaGranularity( m_device, static_cast<VkRenderPass>( renderPass ), reinterpret_cast<VkExtent2D*>( &granularity ) );
    return granularity;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createCommandPool( const CommandPoolCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, CommandPool* pCommandPool, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateCommandPool( m_device, reinterpret_cast<const VkCommandPoolCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkCommandPool*>( pCommandPool ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<CommandPool>::type Device::createCommandPool( const CommandPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    CommandPool commandPool;
    Result result = static_cast<Result>( d.vkCreateCommandPool( m_device, reinterpret_cast<const VkCommandPoolCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkCommandPool*>( &commandPool ) ) );
    return createResultValue( result, commandPool, VULKAN_HPP_NAMESPACE_STRING"::Device::createCommandPool" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<CommandPool,Dispatch>>::type Device::createCommandPoolUnique( const CommandPoolCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    CommandPool commandPool;
    Result result = static_cast<Result>( d.vkCreateCommandPool( m_device, reinterpret_cast<const VkCommandPoolCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkCommandPool*>( &commandPool ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<CommandPool,Dispatch>( result, commandPool, VULKAN_HPP_NAMESPACE_STRING"::Device::createCommandPoolUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyCommandPool( CommandPool commandPool, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyCommandPool( m_device, static_cast<VkCommandPool>( commandPool ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyCommandPool( CommandPool commandPool, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyCommandPool( m_device, static_cast<VkCommandPool>( commandPool ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( CommandPool commandPool, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyCommandPool( m_device, static_cast<VkCommandPool>( commandPool ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( CommandPool commandPool, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyCommandPool( m_device, static_cast<VkCommandPool>( commandPool ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::resetCommandPool( CommandPool commandPool, CommandPoolResetFlags flags, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkResetCommandPool( m_device, static_cast<VkCommandPool>( commandPool ), static_cast<VkCommandPoolResetFlags>( flags ) ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::resetCommandPool( CommandPool commandPool, CommandPoolResetFlags flags, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkResetCommandPool( m_device, static_cast<VkCommandPool>( commandPool ), static_cast<VkCommandPoolResetFlags>( flags ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::resetCommandPool" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::allocateCommandBuffers( const CommandBufferAllocateInfo* pAllocateInfo, CommandBuffer* pCommandBuffers, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkAllocateCommandBuffers( m_device, reinterpret_cast<const VkCommandBufferAllocateInfo*>( pAllocateInfo ), reinterpret_cast<VkCommandBuffer*>( pCommandBuffers ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<CommandBuffer,Allocator>>::type Device::allocateCommandBuffers( const CommandBufferAllocateInfo & allocateInfo, Dispatch const &d ) const
  {
    std::vector<CommandBuffer,Allocator> commandBuffers( allocateInfo.commandBufferCount );
    Result result = static_cast<Result>( d.vkAllocateCommandBuffers( m_device, reinterpret_cast<const VkCommandBufferAllocateInfo*>( &allocateInfo ), reinterpret_cast<VkCommandBuffer*>( commandBuffers.data() ) ) );
    return createResultValue( result, commandBuffers, VULKAN_HPP_NAMESPACE_STRING"::Device::allocateCommandBuffers" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<UniqueHandle<CommandBuffer,Dispatch>,Allocator>>::type Device::allocateCommandBuffersUnique( const CommandBufferAllocateInfo & allocateInfo, Dispatch const &d ) const
  {
    static_assert( sizeof( CommandBuffer ) <= sizeof( UniqueCommandBuffer ), "CommandBuffer is greater than UniqueCommandBuffer!" );
    std::vector<UniqueCommandBuffer, Allocator> commandBuffers;
    commandBuffers.reserve( allocateInfo.commandBufferCount );
    CommandBuffer* buffer = reinterpret_cast<CommandBuffer*>( reinterpret_cast<char*>( commandBuffers.data() ) + allocateInfo.commandBufferCount * ( sizeof( UniqueCommandBuffer ) - sizeof( CommandBuffer ) ) );
    Result result = static_cast<Result>(d.vkAllocateCommandBuffers( m_device, reinterpret_cast<const VkCommandBufferAllocateInfo*>( &allocateInfo ), reinterpret_cast<VkCommandBuffer*>( buffer ) ) );

    PoolFree<Device,CommandPool,Dispatch> deleter( *this, allocateInfo.commandPool, d );
    for ( size_t i=0 ; i<allocateInfo.commandBufferCount ; i++ )
    {
      commandBuffers.push_back( UniqueCommandBuffer( buffer[i], deleter ) );
    }

    return createResultValue( result, commandBuffers, VULKAN_HPP_NAMESPACE_STRING "::Device::allocateCommandBuffersUnique" );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::freeCommandBuffers( CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers, Dispatch const &d) const
  {
    d.vkFreeCommandBuffers( m_device, static_cast<VkCommandPool>( commandPool ), commandBufferCount, reinterpret_cast<const VkCommandBuffer*>( pCommandBuffers ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::freeCommandBuffers( CommandPool commandPool, ArrayProxy<const CommandBuffer> commandBuffers, Dispatch const &d ) const
  {
    d.vkFreeCommandBuffers( m_device, static_cast<VkCommandPool>( commandPool ), commandBuffers.size() , reinterpret_cast<const VkCommandBuffer*>( commandBuffers.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::free( CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers, Dispatch const &d) const
  {
    d.vkFreeCommandBuffers( m_device, static_cast<VkCommandPool>( commandPool ), commandBufferCount, reinterpret_cast<const VkCommandBuffer*>( pCommandBuffers ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::free( CommandPool commandPool, ArrayProxy<const CommandBuffer> commandBuffers, Dispatch const &d ) const
  {
    d.vkFreeCommandBuffers( m_device, static_cast<VkCommandPool>( commandPool ), commandBuffers.size() , reinterpret_cast<const VkCommandBuffer*>( commandBuffers.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createSharedSwapchainsKHR( uint32_t swapchainCount, const SwapchainCreateInfoKHR* pCreateInfos, const AllocationCallbacks* pAllocator, SwapchainKHR* pSwapchains, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateSharedSwapchainsKHR( m_device, swapchainCount, reinterpret_cast<const VkSwapchainCreateInfoKHR*>( pCreateInfos ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSwapchainKHR*>( pSwapchains ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<SwapchainKHR,Allocator>>::type Device::createSharedSwapchainsKHR( ArrayProxy<const SwapchainCreateInfoKHR> createInfos, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    std::vector<SwapchainKHR,Allocator> swapchains( createInfos.size() );
    Result result = static_cast<Result>( d.vkCreateSharedSwapchainsKHR( m_device, createInfos.size() , reinterpret_cast<const VkSwapchainCreateInfoKHR*>( createInfos.data() ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSwapchainKHR*>( swapchains.data() ) ) );
    return createResultValue( result, swapchains, VULKAN_HPP_NAMESPACE_STRING"::Device::createSharedSwapchainsKHR" );
  }
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE ResultValueType<SwapchainKHR>::type Device::createSharedSwapchainKHR( const SwapchainCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SwapchainKHR swapchain;
    Result result = static_cast<Result>( d.vkCreateSharedSwapchainsKHR( m_device, 1 , reinterpret_cast<const VkSwapchainCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSwapchainKHR*>( &swapchain ) ) );
    return createResultValue( result, swapchain, VULKAN_HPP_NAMESPACE_STRING"::Device::createSharedSwapchainKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<UniqueHandle<SwapchainKHR,Dispatch>,Allocator>>::type Device::createSharedSwapchainsKHRUnique( ArrayProxy<const SwapchainCreateInfoKHR> createInfos, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    static_assert( sizeof( SwapchainKHR ) <= sizeof( UniqueSwapchainKHR ), "SwapchainKHR is greater than UniqueSwapchainKHR!" );
    std::vector<UniqueSwapchainKHR, Allocator> swapchainKHRs;
    swapchainKHRs.reserve( createInfos.size() );
    SwapchainKHR* buffer = reinterpret_cast<SwapchainKHR*>( reinterpret_cast<char*>( swapchainKHRs.data() ) + createInfos.size() * ( sizeof( UniqueSwapchainKHR ) - sizeof( SwapchainKHR ) ) );
    Result result = static_cast<Result>(d.vkCreateSharedSwapchainsKHR( m_device, createInfos.size() , reinterpret_cast<const VkSwapchainCreateInfoKHR*>( createInfos.data() ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSwapchainKHR*>( buffer ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    for ( size_t i=0 ; i<createInfos.size() ; i++ )
    {
      swapchainKHRs.push_back( UniqueSwapchainKHR( buffer[i], deleter ) );
    }

    return createResultValue( result, swapchainKHRs, VULKAN_HPP_NAMESPACE_STRING "::Device::createSharedSwapchainsKHRUnique" );
  }
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SwapchainKHR,Dispatch>>::type Device::createSharedSwapchainKHRUnique( const SwapchainCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SwapchainKHR swapchain;
    Result result = static_cast<Result>( d.vkCreateSharedSwapchainsKHR( m_device, 1 , reinterpret_cast<const VkSwapchainCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSwapchainKHR*>( &swapchain ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SwapchainKHR,Dispatch>( result, swapchain, VULKAN_HPP_NAMESPACE_STRING"::Device::createSharedSwapchainKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createSwapchainKHR( const SwapchainCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SwapchainKHR* pSwapchain, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateSwapchainKHR( m_device, reinterpret_cast<const VkSwapchainCreateInfoKHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSwapchainKHR*>( pSwapchain ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SwapchainKHR>::type Device::createSwapchainKHR( const SwapchainCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SwapchainKHR swapchain;
    Result result = static_cast<Result>( d.vkCreateSwapchainKHR( m_device, reinterpret_cast<const VkSwapchainCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSwapchainKHR*>( &swapchain ) ) );
    return createResultValue( result, swapchain, VULKAN_HPP_NAMESPACE_STRING"::Device::createSwapchainKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SwapchainKHR,Dispatch>>::type Device::createSwapchainKHRUnique( const SwapchainCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SwapchainKHR swapchain;
    Result result = static_cast<Result>( d.vkCreateSwapchainKHR( m_device, reinterpret_cast<const VkSwapchainCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSwapchainKHR*>( &swapchain ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SwapchainKHR,Dispatch>( result, swapchain, VULKAN_HPP_NAMESPACE_STRING"::Device::createSwapchainKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySwapchainKHR( SwapchainKHR swapchain, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySwapchainKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySwapchainKHR( SwapchainKHR swapchain, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySwapchainKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( SwapchainKHR swapchain, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySwapchainKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( SwapchainKHR swapchain, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySwapchainKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getSwapchainImagesKHR( SwapchainKHR swapchain, uint32_t* pSwapchainImageCount, Image* pSwapchainImages, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetSwapchainImagesKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ), pSwapchainImageCount, reinterpret_cast<VkImage*>( pSwapchainImages ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<Image,Allocator>>::type Device::getSwapchainImagesKHR( SwapchainKHR swapchain, Dispatch const &d ) const
  {
    std::vector<Image,Allocator> swapchainImages;
    uint32_t swapchainImageCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetSwapchainImagesKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ), &swapchainImageCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && swapchainImageCount )
      {
        swapchainImages.resize( swapchainImageCount );
        result = static_cast<Result>( d.vkGetSwapchainImagesKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ), &swapchainImageCount, reinterpret_cast<VkImage*>( swapchainImages.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( swapchainImageCount <= swapchainImages.size() );
    swapchainImages.resize( swapchainImageCount );
    return createResultValue( result, swapchainImages, VULKAN_HPP_NAMESPACE_STRING"::Device::getSwapchainImagesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::acquireNextImageKHR( SwapchainKHR swapchain, uint64_t timeout, Semaphore semaphore, Fence fence, uint32_t* pImageIndex, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkAcquireNextImageKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ), timeout, static_cast<VkSemaphore>( semaphore ), static_cast<VkFence>( fence ), pImageIndex ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValue<uint32_t> Device::acquireNextImageKHR( SwapchainKHR swapchain, uint64_t timeout, Semaphore semaphore, Fence fence, Dispatch const &d ) const
  {
    uint32_t imageIndex;
    Result result = static_cast<Result>( d.vkAcquireNextImageKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ), timeout, static_cast<VkSemaphore>( semaphore ), static_cast<VkFence>( fence ), &imageIndex ) );
    return createResultValue( result, imageIndex, VULKAN_HPP_NAMESPACE_STRING"::Device::acquireNextImageKHR", { Result::eSuccess, Result::eTimeout, Result::eNotReady, Result::eSuboptimalKHR } );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::debugMarkerSetObjectNameEXT( const DebugMarkerObjectNameInfoEXT* pNameInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkDebugMarkerSetObjectNameEXT( m_device, reinterpret_cast<const VkDebugMarkerObjectNameInfoEXT*>( pNameInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::debugMarkerSetObjectNameEXT( const DebugMarkerObjectNameInfoEXT & nameInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkDebugMarkerSetObjectNameEXT( m_device, reinterpret_cast<const VkDebugMarkerObjectNameInfoEXT*>( &nameInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::debugMarkerSetObjectNameEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::debugMarkerSetObjectTagEXT( const DebugMarkerObjectTagInfoEXT* pTagInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkDebugMarkerSetObjectTagEXT( m_device, reinterpret_cast<const VkDebugMarkerObjectTagInfoEXT*>( pTagInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::debugMarkerSetObjectTagEXT( const DebugMarkerObjectTagInfoEXT & tagInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkDebugMarkerSetObjectTagEXT( m_device, reinterpret_cast<const VkDebugMarkerObjectTagInfoEXT*>( &tagInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::debugMarkerSetObjectTagEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_WIN32_NV
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getMemoryWin32HandleNV( DeviceMemory memory, ExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetMemoryWin32HandleNV( m_device, static_cast<VkDeviceMemory>( memory ), static_cast<VkExternalMemoryHandleTypeFlagsNV>( handleType ), pHandle ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<HANDLE>::type Device::getMemoryWin32HandleNV( DeviceMemory memory, ExternalMemoryHandleTypeFlagsNV handleType, Dispatch const &d ) const
  {
    HANDLE handle;
    Result result = static_cast<Result>( d.vkGetMemoryWin32HandleNV( m_device, static_cast<VkDeviceMemory>( memory ), static_cast<VkExternalMemoryHandleTypeFlagsNV>( handleType ), &handle ) );
    return createResultValue( result, handle, VULKAN_HPP_NAMESPACE_STRING"::Device::getMemoryWin32HandleNV" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_NV*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createIndirectCommandsLayoutNVX( const IndirectCommandsLayoutCreateInfoNVX* pCreateInfo, const AllocationCallbacks* pAllocator, IndirectCommandsLayoutNVX* pIndirectCommandsLayout, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateIndirectCommandsLayoutNVX( m_device, reinterpret_cast<const VkIndirectCommandsLayoutCreateInfoNVX*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkIndirectCommandsLayoutNVX*>( pIndirectCommandsLayout ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<IndirectCommandsLayoutNVX>::type Device::createIndirectCommandsLayoutNVX( const IndirectCommandsLayoutCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    IndirectCommandsLayoutNVX indirectCommandsLayout;
    Result result = static_cast<Result>( d.vkCreateIndirectCommandsLayoutNVX( m_device, reinterpret_cast<const VkIndirectCommandsLayoutCreateInfoNVX*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkIndirectCommandsLayoutNVX*>( &indirectCommandsLayout ) ) );
    return createResultValue( result, indirectCommandsLayout, VULKAN_HPP_NAMESPACE_STRING"::Device::createIndirectCommandsLayoutNVX" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<IndirectCommandsLayoutNVX,Dispatch>>::type Device::createIndirectCommandsLayoutNVXUnique( const IndirectCommandsLayoutCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    IndirectCommandsLayoutNVX indirectCommandsLayout;
    Result result = static_cast<Result>( d.vkCreateIndirectCommandsLayoutNVX( m_device, reinterpret_cast<const VkIndirectCommandsLayoutCreateInfoNVX*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkIndirectCommandsLayoutNVX*>( &indirectCommandsLayout ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<IndirectCommandsLayoutNVX,Dispatch>( result, indirectCommandsLayout, VULKAN_HPP_NAMESPACE_STRING"::Device::createIndirectCommandsLayoutNVXUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyIndirectCommandsLayoutNVX( IndirectCommandsLayoutNVX indirectCommandsLayout, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyIndirectCommandsLayoutNVX( m_device, static_cast<VkIndirectCommandsLayoutNVX>( indirectCommandsLayout ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyIndirectCommandsLayoutNVX( IndirectCommandsLayoutNVX indirectCommandsLayout, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyIndirectCommandsLayoutNVX( m_device, static_cast<VkIndirectCommandsLayoutNVX>( indirectCommandsLayout ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( IndirectCommandsLayoutNVX indirectCommandsLayout, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyIndirectCommandsLayoutNVX( m_device, static_cast<VkIndirectCommandsLayoutNVX>( indirectCommandsLayout ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( IndirectCommandsLayoutNVX indirectCommandsLayout, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyIndirectCommandsLayoutNVX( m_device, static_cast<VkIndirectCommandsLayoutNVX>( indirectCommandsLayout ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createObjectTableNVX( const ObjectTableCreateInfoNVX* pCreateInfo, const AllocationCallbacks* pAllocator, ObjectTableNVX* pObjectTable, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateObjectTableNVX( m_device, reinterpret_cast<const VkObjectTableCreateInfoNVX*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkObjectTableNVX*>( pObjectTable ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<ObjectTableNVX>::type Device::createObjectTableNVX( const ObjectTableCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    ObjectTableNVX objectTable;
    Result result = static_cast<Result>( d.vkCreateObjectTableNVX( m_device, reinterpret_cast<const VkObjectTableCreateInfoNVX*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkObjectTableNVX*>( &objectTable ) ) );
    return createResultValue( result, objectTable, VULKAN_HPP_NAMESPACE_STRING"::Device::createObjectTableNVX" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<ObjectTableNVX,Dispatch>>::type Device::createObjectTableNVXUnique( const ObjectTableCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    ObjectTableNVX objectTable;
    Result result = static_cast<Result>( d.vkCreateObjectTableNVX( m_device, reinterpret_cast<const VkObjectTableCreateInfoNVX*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkObjectTableNVX*>( &objectTable ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<ObjectTableNVX,Dispatch>( result, objectTable, VULKAN_HPP_NAMESPACE_STRING"::Device::createObjectTableNVXUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyObjectTableNVX( ObjectTableNVX objectTable, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyObjectTableNVX( m_device, static_cast<VkObjectTableNVX>( objectTable ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyObjectTableNVX( ObjectTableNVX objectTable, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyObjectTableNVX( m_device, static_cast<VkObjectTableNVX>( objectTable ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( ObjectTableNVX objectTable, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyObjectTableNVX( m_device, static_cast<VkObjectTableNVX>( objectTable ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( ObjectTableNVX objectTable, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyObjectTableNVX( m_device, static_cast<VkObjectTableNVX>( objectTable ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::registerObjectsNVX( ObjectTableNVX objectTable, uint32_t objectCount, const ObjectTableEntryNVX* const* ppObjectTableEntries, const uint32_t* pObjectIndices, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkRegisterObjectsNVX( m_device, static_cast<VkObjectTableNVX>( objectTable ), objectCount, reinterpret_cast<const VkObjectTableEntryNVX* const*>( ppObjectTableEntries ), pObjectIndices ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::registerObjectsNVX( ObjectTableNVX objectTable, ArrayProxy<const ObjectTableEntryNVX* const> pObjectTableEntries, ArrayProxy<const uint32_t> objectIndices, Dispatch const &d ) const
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( pObjectTableEntries.size() == objectIndices.size() );
#else
    if ( pObjectTableEntries.size() != objectIndices.size() )
    {
      throw LogicError( VULKAN_HPP_NAMESPACE_STRING "::Device::registerObjectsNVX: pObjectTableEntries.size() != objectIndices.size()" );
    }
#endif  // VULKAN_HPP_NO_EXCEPTIONS
    Result result = static_cast<Result>( d.vkRegisterObjectsNVX( m_device, static_cast<VkObjectTableNVX>( objectTable ), pObjectTableEntries.size() , reinterpret_cast<const VkObjectTableEntryNVX* const*>( pObjectTableEntries.data() ), objectIndices.data() ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::registerObjectsNVX" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::unregisterObjectsNVX( ObjectTableNVX objectTable, uint32_t objectCount, const ObjectEntryTypeNVX* pObjectEntryTypes, const uint32_t* pObjectIndices, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkUnregisterObjectsNVX( m_device, static_cast<VkObjectTableNVX>( objectTable ), objectCount, reinterpret_cast<const VkObjectEntryTypeNVX*>( pObjectEntryTypes ), pObjectIndices ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::unregisterObjectsNVX( ObjectTableNVX objectTable, ArrayProxy<const ObjectEntryTypeNVX> objectEntryTypes, ArrayProxy<const uint32_t> objectIndices, Dispatch const &d ) const
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( objectEntryTypes.size() == objectIndices.size() );
#else
    if ( objectEntryTypes.size() != objectIndices.size() )
    {
      throw LogicError( VULKAN_HPP_NAMESPACE_STRING "::Device::unregisterObjectsNVX: objectEntryTypes.size() != objectIndices.size()" );
    }
#endif  // VULKAN_HPP_NO_EXCEPTIONS
    Result result = static_cast<Result>( d.vkUnregisterObjectsNVX( m_device, static_cast<VkObjectTableNVX>( objectTable ), objectEntryTypes.size() , reinterpret_cast<const VkObjectEntryTypeNVX*>( objectEntryTypes.data() ), objectIndices.data() ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::unregisterObjectsNVX" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::trimCommandPool( CommandPool commandPool, CommandPoolTrimFlags flags, Dispatch const &d) const
  {
    d.vkTrimCommandPool( m_device, static_cast<VkCommandPool>( commandPool ), static_cast<VkCommandPoolTrimFlags>( flags ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::trimCommandPool( CommandPool commandPool, CommandPoolTrimFlags flags, Dispatch const &d ) const
  {
    d.vkTrimCommandPool( m_device, static_cast<VkCommandPool>( commandPool ), static_cast<VkCommandPoolTrimFlags>( flags ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::trimCommandPoolKHR( CommandPool commandPool, CommandPoolTrimFlags flags, Dispatch const &d) const
  {
    d.vkTrimCommandPoolKHR( m_device, static_cast<VkCommandPool>( commandPool ), static_cast<VkCommandPoolTrimFlags>( flags ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::trimCommandPoolKHR( CommandPool commandPool, CommandPoolTrimFlags flags, Dispatch const &d ) const
  {
    d.vkTrimCommandPoolKHR( m_device, static_cast<VkCommandPool>( commandPool ), static_cast<VkCommandPoolTrimFlags>( flags ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getMemoryWin32HandleKHR( const MemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetMemoryWin32HandleKHR( m_device, reinterpret_cast<const VkMemoryGetWin32HandleInfoKHR*>( pGetWin32HandleInfo ), pHandle ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<HANDLE>::type Device::getMemoryWin32HandleKHR( const MemoryGetWin32HandleInfoKHR & getWin32HandleInfo, Dispatch const &d ) const
  {
    HANDLE handle;
    Result result = static_cast<Result>( d.vkGetMemoryWin32HandleKHR( m_device, reinterpret_cast<const VkMemoryGetWin32HandleInfoKHR*>( &getWin32HandleInfo ), &handle ) );
    return createResultValue( result, handle, VULKAN_HPP_NAMESPACE_STRING"::Device::getMemoryWin32HandleKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getMemoryWin32HandlePropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, MemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetMemoryWin32HandlePropertiesKHR( m_device, static_cast<VkExternalMemoryHandleTypeFlagBits>( handleType ), handle, reinterpret_cast<VkMemoryWin32HandlePropertiesKHR*>( pMemoryWin32HandleProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<MemoryWin32HandlePropertiesKHR>::type Device::getMemoryWin32HandlePropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, Dispatch const &d ) const
  {
    MemoryWin32HandlePropertiesKHR memoryWin32HandleProperties;
    Result result = static_cast<Result>( d.vkGetMemoryWin32HandlePropertiesKHR( m_device, static_cast<VkExternalMemoryHandleTypeFlagBits>( handleType ), handle, reinterpret_cast<VkMemoryWin32HandlePropertiesKHR*>( &memoryWin32HandleProperties ) ) );
    return createResultValue( result, memoryWin32HandleProperties, VULKAN_HPP_NAMESPACE_STRING"::Device::getMemoryWin32HandlePropertiesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getMemoryFdKHR( const MemoryGetFdInfoKHR* pGetFdInfo, int* pFd, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetMemoryFdKHR( m_device, reinterpret_cast<const VkMemoryGetFdInfoKHR*>( pGetFdInfo ), pFd ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<int>::type Device::getMemoryFdKHR( const MemoryGetFdInfoKHR & getFdInfo, Dispatch const &d ) const
  {
    int fd;
    Result result = static_cast<Result>( d.vkGetMemoryFdKHR( m_device, reinterpret_cast<const VkMemoryGetFdInfoKHR*>( &getFdInfo ), &fd ) );
    return createResultValue( result, fd, VULKAN_HPP_NAMESPACE_STRING"::Device::getMemoryFdKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getMemoryFdPropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType, int fd, MemoryFdPropertiesKHR* pMemoryFdProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetMemoryFdPropertiesKHR( m_device, static_cast<VkExternalMemoryHandleTypeFlagBits>( handleType ), fd, reinterpret_cast<VkMemoryFdPropertiesKHR*>( pMemoryFdProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<MemoryFdPropertiesKHR>::type Device::getMemoryFdPropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType, int fd, Dispatch const &d ) const
  {
    MemoryFdPropertiesKHR memoryFdProperties;
    Result result = static_cast<Result>( d.vkGetMemoryFdPropertiesKHR( m_device, static_cast<VkExternalMemoryHandleTypeFlagBits>( handleType ), fd, reinterpret_cast<VkMemoryFdPropertiesKHR*>( &memoryFdProperties ) ) );
    return createResultValue( result, memoryFdProperties, VULKAN_HPP_NAMESPACE_STRING"::Device::getMemoryFdPropertiesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getSemaphoreWin32HandleKHR( const SemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetSemaphoreWin32HandleKHR( m_device, reinterpret_cast<const VkSemaphoreGetWin32HandleInfoKHR*>( pGetWin32HandleInfo ), pHandle ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<HANDLE>::type Device::getSemaphoreWin32HandleKHR( const SemaphoreGetWin32HandleInfoKHR & getWin32HandleInfo, Dispatch const &d ) const
  {
    HANDLE handle;
    Result result = static_cast<Result>( d.vkGetSemaphoreWin32HandleKHR( m_device, reinterpret_cast<const VkSemaphoreGetWin32HandleInfoKHR*>( &getWin32HandleInfo ), &handle ) );
    return createResultValue( result, handle, VULKAN_HPP_NAMESPACE_STRING"::Device::getSemaphoreWin32HandleKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::importSemaphoreWin32HandleKHR( const ImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkImportSemaphoreWin32HandleKHR( m_device, reinterpret_cast<const VkImportSemaphoreWin32HandleInfoKHR*>( pImportSemaphoreWin32HandleInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::importSemaphoreWin32HandleKHR( const ImportSemaphoreWin32HandleInfoKHR & importSemaphoreWin32HandleInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkImportSemaphoreWin32HandleKHR( m_device, reinterpret_cast<const VkImportSemaphoreWin32HandleInfoKHR*>( &importSemaphoreWin32HandleInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::importSemaphoreWin32HandleKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getSemaphoreFdKHR( const SemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetSemaphoreFdKHR( m_device, reinterpret_cast<const VkSemaphoreGetFdInfoKHR*>( pGetFdInfo ), pFd ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<int>::type Device::getSemaphoreFdKHR( const SemaphoreGetFdInfoKHR & getFdInfo, Dispatch const &d ) const
  {
    int fd;
    Result result = static_cast<Result>( d.vkGetSemaphoreFdKHR( m_device, reinterpret_cast<const VkSemaphoreGetFdInfoKHR*>( &getFdInfo ), &fd ) );
    return createResultValue( result, fd, VULKAN_HPP_NAMESPACE_STRING"::Device::getSemaphoreFdKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::importSemaphoreFdKHR( const ImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkImportSemaphoreFdKHR( m_device, reinterpret_cast<const VkImportSemaphoreFdInfoKHR*>( pImportSemaphoreFdInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::importSemaphoreFdKHR( const ImportSemaphoreFdInfoKHR & importSemaphoreFdInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkImportSemaphoreFdKHR( m_device, reinterpret_cast<const VkImportSemaphoreFdInfoKHR*>( &importSemaphoreFdInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::importSemaphoreFdKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getFenceWin32HandleKHR( const FenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetFenceWin32HandleKHR( m_device, reinterpret_cast<const VkFenceGetWin32HandleInfoKHR*>( pGetWin32HandleInfo ), pHandle ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<HANDLE>::type Device::getFenceWin32HandleKHR( const FenceGetWin32HandleInfoKHR & getWin32HandleInfo, Dispatch const &d ) const
  {
    HANDLE handle;
    Result result = static_cast<Result>( d.vkGetFenceWin32HandleKHR( m_device, reinterpret_cast<const VkFenceGetWin32HandleInfoKHR*>( &getWin32HandleInfo ), &handle ) );
    return createResultValue( result, handle, VULKAN_HPP_NAMESPACE_STRING"::Device::getFenceWin32HandleKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::importFenceWin32HandleKHR( const ImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkImportFenceWin32HandleKHR( m_device, reinterpret_cast<const VkImportFenceWin32HandleInfoKHR*>( pImportFenceWin32HandleInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::importFenceWin32HandleKHR( const ImportFenceWin32HandleInfoKHR & importFenceWin32HandleInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkImportFenceWin32HandleKHR( m_device, reinterpret_cast<const VkImportFenceWin32HandleInfoKHR*>( &importFenceWin32HandleInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::importFenceWin32HandleKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getFenceFdKHR( const FenceGetFdInfoKHR* pGetFdInfo, int* pFd, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetFenceFdKHR( m_device, reinterpret_cast<const VkFenceGetFdInfoKHR*>( pGetFdInfo ), pFd ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<int>::type Device::getFenceFdKHR( const FenceGetFdInfoKHR & getFdInfo, Dispatch const &d ) const
  {
    int fd;
    Result result = static_cast<Result>( d.vkGetFenceFdKHR( m_device, reinterpret_cast<const VkFenceGetFdInfoKHR*>( &getFdInfo ), &fd ) );
    return createResultValue( result, fd, VULKAN_HPP_NAMESPACE_STRING"::Device::getFenceFdKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::importFenceFdKHR( const ImportFenceFdInfoKHR* pImportFenceFdInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkImportFenceFdKHR( m_device, reinterpret_cast<const VkImportFenceFdInfoKHR*>( pImportFenceFdInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::importFenceFdKHR( const ImportFenceFdInfoKHR & importFenceFdInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkImportFenceFdKHR( m_device, reinterpret_cast<const VkImportFenceFdInfoKHR*>( &importFenceFdInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::importFenceFdKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::displayPowerControlEXT( DisplayKHR display, const DisplayPowerInfoEXT* pDisplayPowerInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkDisplayPowerControlEXT( m_device, static_cast<VkDisplayKHR>( display ), reinterpret_cast<const VkDisplayPowerInfoEXT*>( pDisplayPowerInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::displayPowerControlEXT( DisplayKHR display, const DisplayPowerInfoEXT & displayPowerInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkDisplayPowerControlEXT( m_device, static_cast<VkDisplayKHR>( display ), reinterpret_cast<const VkDisplayPowerInfoEXT*>( &displayPowerInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::displayPowerControlEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::registerEventEXT( const DeviceEventInfoEXT* pDeviceEventInfo, const AllocationCallbacks* pAllocator, Fence* pFence, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkRegisterDeviceEventEXT( m_device, reinterpret_cast<const VkDeviceEventInfoEXT*>( pDeviceEventInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkFence*>( pFence ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Fence>::type Device::registerEventEXT( const DeviceEventInfoEXT & deviceEventInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Fence fence;
    Result result = static_cast<Result>( d.vkRegisterDeviceEventEXT( m_device, reinterpret_cast<const VkDeviceEventInfoEXT*>( &deviceEventInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkFence*>( &fence ) ) );
    return createResultValue( result, fence, VULKAN_HPP_NAMESPACE_STRING"::Device::registerEventEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::registerDisplayEventEXT( DisplayKHR display, const DisplayEventInfoEXT* pDisplayEventInfo, const AllocationCallbacks* pAllocator, Fence* pFence, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkRegisterDisplayEventEXT( m_device, static_cast<VkDisplayKHR>( display ), reinterpret_cast<const VkDisplayEventInfoEXT*>( pDisplayEventInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkFence*>( pFence ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Fence>::type Device::registerDisplayEventEXT( DisplayKHR display, const DisplayEventInfoEXT & displayEventInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Fence fence;
    Result result = static_cast<Result>( d.vkRegisterDisplayEventEXT( m_device, static_cast<VkDisplayKHR>( display ), reinterpret_cast<const VkDisplayEventInfoEXT*>( &displayEventInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkFence*>( &fence ) ) );
    return createResultValue( result, fence, VULKAN_HPP_NAMESPACE_STRING"::Device::registerDisplayEventEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getSwapchainCounterEXT( SwapchainKHR swapchain, SurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetSwapchainCounterEXT( m_device, static_cast<VkSwapchainKHR>( swapchain ), static_cast<VkSurfaceCounterFlagBitsEXT>( counter ), pCounterValue ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<uint64_t>::type Device::getSwapchainCounterEXT( SwapchainKHR swapchain, SurfaceCounterFlagBitsEXT counter, Dispatch const &d ) const
  {
    uint64_t counterValue;
    Result result = static_cast<Result>( d.vkGetSwapchainCounterEXT( m_device, static_cast<VkSwapchainKHR>( swapchain ), static_cast<VkSurfaceCounterFlagBitsEXT>( counter ), &counterValue ) );
    return createResultValue( result, counterValue, VULKAN_HPP_NAMESPACE_STRING"::Device::getSwapchainCounterEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getGroupPeerMemoryFeatures( uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, PeerMemoryFeatureFlags* pPeerMemoryFeatures, Dispatch const &d) const
  {
    d.vkGetDeviceGroupPeerMemoryFeatures( m_device, heapIndex, localDeviceIndex, remoteDeviceIndex, reinterpret_cast<VkPeerMemoryFeatureFlags*>( pPeerMemoryFeatures ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PeerMemoryFeatureFlags Device::getGroupPeerMemoryFeatures( uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, Dispatch const &d ) const
  {
    PeerMemoryFeatureFlags peerMemoryFeatures;
    d.vkGetDeviceGroupPeerMemoryFeatures( m_device, heapIndex, localDeviceIndex, remoteDeviceIndex, reinterpret_cast<VkPeerMemoryFeatureFlags*>( &peerMemoryFeatures ) );
    return peerMemoryFeatures;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getGroupPeerMemoryFeaturesKHR( uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, PeerMemoryFeatureFlags* pPeerMemoryFeatures, Dispatch const &d) const
  {
    d.vkGetDeviceGroupPeerMemoryFeaturesKHR( m_device, heapIndex, localDeviceIndex, remoteDeviceIndex, reinterpret_cast<VkPeerMemoryFeatureFlags*>( pPeerMemoryFeatures ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PeerMemoryFeatureFlags Device::getGroupPeerMemoryFeaturesKHR( uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, Dispatch const &d ) const
  {
    PeerMemoryFeatureFlags peerMemoryFeatures;
    d.vkGetDeviceGroupPeerMemoryFeaturesKHR( m_device, heapIndex, localDeviceIndex, remoteDeviceIndex, reinterpret_cast<VkPeerMemoryFeatureFlags*>( &peerMemoryFeatures ) );
    return peerMemoryFeatures;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::bindBufferMemory2( uint32_t bindInfoCount, const BindBufferMemoryInfo* pBindInfos, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkBindBufferMemory2( m_device, bindInfoCount, reinterpret_cast<const VkBindBufferMemoryInfo*>( pBindInfos ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::bindBufferMemory2( ArrayProxy<const BindBufferMemoryInfo> bindInfos, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkBindBufferMemory2( m_device, bindInfos.size() , reinterpret_cast<const VkBindBufferMemoryInfo*>( bindInfos.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::bindBufferMemory2" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::bindBufferMemory2KHR( uint32_t bindInfoCount, const BindBufferMemoryInfo* pBindInfos, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkBindBufferMemory2KHR( m_device, bindInfoCount, reinterpret_cast<const VkBindBufferMemoryInfo*>( pBindInfos ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::bindBufferMemory2KHR( ArrayProxy<const BindBufferMemoryInfo> bindInfos, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkBindBufferMemory2KHR( m_device, bindInfos.size() , reinterpret_cast<const VkBindBufferMemoryInfo*>( bindInfos.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::bindBufferMemory2KHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::bindImageMemory2( uint32_t bindInfoCount, const BindImageMemoryInfo* pBindInfos, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkBindImageMemory2( m_device, bindInfoCount, reinterpret_cast<const VkBindImageMemoryInfo*>( pBindInfos ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::bindImageMemory2( ArrayProxy<const BindImageMemoryInfo> bindInfos, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkBindImageMemory2( m_device, bindInfos.size() , reinterpret_cast<const VkBindImageMemoryInfo*>( bindInfos.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::bindImageMemory2" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::bindImageMemory2KHR( uint32_t bindInfoCount, const BindImageMemoryInfo* pBindInfos, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkBindImageMemory2KHR( m_device, bindInfoCount, reinterpret_cast<const VkBindImageMemoryInfo*>( pBindInfos ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::bindImageMemory2KHR( ArrayProxy<const BindImageMemoryInfo> bindInfos, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkBindImageMemory2KHR( m_device, bindInfos.size() , reinterpret_cast<const VkBindImageMemoryInfo*>( bindInfos.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::bindImageMemory2KHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getGroupPresentCapabilitiesKHR( DeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetDeviceGroupPresentCapabilitiesKHR( m_device, reinterpret_cast<VkDeviceGroupPresentCapabilitiesKHR*>( pDeviceGroupPresentCapabilities ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DeviceGroupPresentCapabilitiesKHR>::type Device::getGroupPresentCapabilitiesKHR(Dispatch const &d ) const
  {
    DeviceGroupPresentCapabilitiesKHR deviceGroupPresentCapabilities;
    Result result = static_cast<Result>( d.vkGetDeviceGroupPresentCapabilitiesKHR( m_device, reinterpret_cast<VkDeviceGroupPresentCapabilitiesKHR*>( &deviceGroupPresentCapabilities ) ) );
    return createResultValue( result, deviceGroupPresentCapabilities, VULKAN_HPP_NAMESPACE_STRING"::Device::getGroupPresentCapabilitiesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getGroupSurfacePresentModesKHR( SurfaceKHR surface, DeviceGroupPresentModeFlagsKHR* pModes, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetDeviceGroupSurfacePresentModesKHR( m_device, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<VkDeviceGroupPresentModeFlagsKHR*>( pModes ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DeviceGroupPresentModeFlagsKHR>::type Device::getGroupSurfacePresentModesKHR( SurfaceKHR surface, Dispatch const &d ) const
  {
    DeviceGroupPresentModeFlagsKHR modes;
    Result result = static_cast<Result>( d.vkGetDeviceGroupSurfacePresentModesKHR( m_device, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<VkDeviceGroupPresentModeFlagsKHR*>( &modes ) ) );
    return createResultValue( result, modes, VULKAN_HPP_NAMESPACE_STRING"::Device::getGroupSurfacePresentModesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::acquireNextImage2KHR( const AcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkAcquireNextImage2KHR( m_device, reinterpret_cast<const VkAcquireNextImageInfoKHR*>( pAcquireInfo ), pImageIndex ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValue<uint32_t> Device::acquireNextImage2KHR( const AcquireNextImageInfoKHR & acquireInfo, Dispatch const &d ) const
  {
    uint32_t imageIndex;
    Result result = static_cast<Result>( d.vkAcquireNextImage2KHR( m_device, reinterpret_cast<const VkAcquireNextImageInfoKHR*>( &acquireInfo ), &imageIndex ) );
    return createResultValue( result, imageIndex, VULKAN_HPP_NAMESPACE_STRING"::Device::acquireNextImage2KHR", { Result::eSuccess, Result::eTimeout, Result::eNotReady, Result::eSuboptimalKHR } );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createDescriptorUpdateTemplate( const DescriptorUpdateTemplateCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorUpdateTemplate* pDescriptorUpdateTemplate, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateDescriptorUpdateTemplate( m_device, reinterpret_cast<const VkDescriptorUpdateTemplateCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkDescriptorUpdateTemplate*>( pDescriptorUpdateTemplate ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DescriptorUpdateTemplate>::type Device::createDescriptorUpdateTemplate( const DescriptorUpdateTemplateCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DescriptorUpdateTemplate descriptorUpdateTemplate;
    Result result = static_cast<Result>( d.vkCreateDescriptorUpdateTemplate( m_device, reinterpret_cast<const VkDescriptorUpdateTemplateCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDescriptorUpdateTemplate*>( &descriptorUpdateTemplate ) ) );
    return createResultValue( result, descriptorUpdateTemplate, VULKAN_HPP_NAMESPACE_STRING"::Device::createDescriptorUpdateTemplate" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<DescriptorUpdateTemplate,Dispatch>>::type Device::createDescriptorUpdateTemplateUnique( const DescriptorUpdateTemplateCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DescriptorUpdateTemplate descriptorUpdateTemplate;
    Result result = static_cast<Result>( d.vkCreateDescriptorUpdateTemplate( m_device, reinterpret_cast<const VkDescriptorUpdateTemplateCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDescriptorUpdateTemplate*>( &descriptorUpdateTemplate ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<DescriptorUpdateTemplate,Dispatch>( result, descriptorUpdateTemplate, VULKAN_HPP_NAMESPACE_STRING"::Device::createDescriptorUpdateTemplateUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createDescriptorUpdateTemplateKHR( const DescriptorUpdateTemplateCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, DescriptorUpdateTemplate* pDescriptorUpdateTemplate, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateDescriptorUpdateTemplateKHR( m_device, reinterpret_cast<const VkDescriptorUpdateTemplateCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkDescriptorUpdateTemplate*>( pDescriptorUpdateTemplate ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DescriptorUpdateTemplate>::type Device::createDescriptorUpdateTemplateKHR( const DescriptorUpdateTemplateCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DescriptorUpdateTemplate descriptorUpdateTemplate;
    Result result = static_cast<Result>( d.vkCreateDescriptorUpdateTemplateKHR( m_device, reinterpret_cast<const VkDescriptorUpdateTemplateCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDescriptorUpdateTemplate*>( &descriptorUpdateTemplate ) ) );
    return createResultValue( result, descriptorUpdateTemplate, VULKAN_HPP_NAMESPACE_STRING"::Device::createDescriptorUpdateTemplateKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<DescriptorUpdateTemplate,Dispatch>>::type Device::createDescriptorUpdateTemplateKHRUnique( const DescriptorUpdateTemplateCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DescriptorUpdateTemplate descriptorUpdateTemplate;
    Result result = static_cast<Result>( d.vkCreateDescriptorUpdateTemplateKHR( m_device, reinterpret_cast<const VkDescriptorUpdateTemplateCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDescriptorUpdateTemplate*>( &descriptorUpdateTemplate ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<DescriptorUpdateTemplate,Dispatch>( result, descriptorUpdateTemplate, VULKAN_HPP_NAMESPACE_STRING"::Device::createDescriptorUpdateTemplateKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyDescriptorUpdateTemplate( DescriptorUpdateTemplate descriptorUpdateTemplate, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDescriptorUpdateTemplate( m_device, static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyDescriptorUpdateTemplate( DescriptorUpdateTemplate descriptorUpdateTemplate, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDescriptorUpdateTemplate( m_device, static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( DescriptorUpdateTemplate descriptorUpdateTemplate, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDescriptorUpdateTemplate( m_device, static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( DescriptorUpdateTemplate descriptorUpdateTemplate, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDescriptorUpdateTemplate( m_device, static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyDescriptorUpdateTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDescriptorUpdateTemplateKHR( m_device, static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyDescriptorUpdateTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDescriptorUpdateTemplateKHR( m_device, static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::updateDescriptorSetWithTemplate( DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData, Dispatch const &d) const
  {
    d.vkUpdateDescriptorSetWithTemplate( m_device, static_cast<VkDescriptorSet>( descriptorSet ), static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), pData );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::updateDescriptorSetWithTemplate( DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData, Dispatch const &d ) const
  {
    d.vkUpdateDescriptorSetWithTemplate( m_device, static_cast<VkDescriptorSet>( descriptorSet ), static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), pData );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::updateDescriptorSetWithTemplateKHR( DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData, Dispatch const &d) const
  {
    d.vkUpdateDescriptorSetWithTemplateKHR( m_device, static_cast<VkDescriptorSet>( descriptorSet ), static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), pData );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::updateDescriptorSetWithTemplateKHR( DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData, Dispatch const &d ) const
  {
    d.vkUpdateDescriptorSetWithTemplateKHR( m_device, static_cast<VkDescriptorSet>( descriptorSet ), static_cast<VkDescriptorUpdateTemplate>( descriptorUpdateTemplate ), pData );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::setHdrMetadataEXT( uint32_t swapchainCount, const SwapchainKHR* pSwapchains, const HdrMetadataEXT* pMetadata, Dispatch const &d) const
  {
    d.vkSetHdrMetadataEXT( m_device, swapchainCount, reinterpret_cast<const VkSwapchainKHR*>( pSwapchains ), reinterpret_cast<const VkHdrMetadataEXT*>( pMetadata ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::setHdrMetadataEXT( ArrayProxy<const SwapchainKHR> swapchains, ArrayProxy<const HdrMetadataEXT> metadata, Dispatch const &d ) const
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( swapchains.size() == metadata.size() );
#else
    if ( swapchains.size() != metadata.size() )
    {
      throw LogicError( VULKAN_HPP_NAMESPACE_STRING "::Device::setHdrMetadataEXT: swapchains.size() != metadata.size()" );
    }
#endif  // VULKAN_HPP_NO_EXCEPTIONS
    d.vkSetHdrMetadataEXT( m_device, swapchains.size() , reinterpret_cast<const VkSwapchainKHR*>( swapchains.data() ), reinterpret_cast<const VkHdrMetadataEXT*>( metadata.data() ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getSwapchainStatusKHR( SwapchainKHR swapchain, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetSwapchainStatusKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ) ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getSwapchainStatusKHR( SwapchainKHR swapchain, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkGetSwapchainStatusKHR( m_device, static_cast<VkSwapchainKHR>( swapchain ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::getSwapchainStatusKHR", { Result::eSuccess, Result::eSuboptimalKHR } );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getRefreshCycleDurationGOOGLE( SwapchainKHR swapchain, RefreshCycleDurationGOOGLE* pDisplayTimingProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetRefreshCycleDurationGOOGLE( m_device, static_cast<VkSwapchainKHR>( swapchain ), reinterpret_cast<VkRefreshCycleDurationGOOGLE*>( pDisplayTimingProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<RefreshCycleDurationGOOGLE>::type Device::getRefreshCycleDurationGOOGLE( SwapchainKHR swapchain, Dispatch const &d ) const
  {
    RefreshCycleDurationGOOGLE displayTimingProperties;
    Result result = static_cast<Result>( d.vkGetRefreshCycleDurationGOOGLE( m_device, static_cast<VkSwapchainKHR>( swapchain ), reinterpret_cast<VkRefreshCycleDurationGOOGLE*>( &displayTimingProperties ) ) );
    return createResultValue( result, displayTimingProperties, VULKAN_HPP_NAMESPACE_STRING"::Device::getRefreshCycleDurationGOOGLE" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getPastPresentationTimingGOOGLE( SwapchainKHR swapchain, uint32_t* pPresentationTimingCount, PastPresentationTimingGOOGLE* pPresentationTimings, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPastPresentationTimingGOOGLE( m_device, static_cast<VkSwapchainKHR>( swapchain ), pPresentationTimingCount, reinterpret_cast<VkPastPresentationTimingGOOGLE*>( pPresentationTimings ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<PastPresentationTimingGOOGLE,Allocator>>::type Device::getPastPresentationTimingGOOGLE( SwapchainKHR swapchain, Dispatch const &d ) const
  {
    std::vector<PastPresentationTimingGOOGLE,Allocator> presentationTimings;
    uint32_t presentationTimingCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPastPresentationTimingGOOGLE( m_device, static_cast<VkSwapchainKHR>( swapchain ), &presentationTimingCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && presentationTimingCount )
      {
        presentationTimings.resize( presentationTimingCount );
        result = static_cast<Result>( d.vkGetPastPresentationTimingGOOGLE( m_device, static_cast<VkSwapchainKHR>( swapchain ), &presentationTimingCount, reinterpret_cast<VkPastPresentationTimingGOOGLE*>( presentationTimings.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( presentationTimingCount <= presentationTimings.size() );
    presentationTimings.resize( presentationTimingCount );
    return createResultValue( result, presentationTimings, VULKAN_HPP_NAMESPACE_STRING"::Device::getPastPresentationTimingGOOGLE" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getBufferMemoryRequirements2( const BufferMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetBufferMemoryRequirements2( m_device, reinterpret_cast<const VkBufferMemoryRequirementsInfo2*>( pInfo ), reinterpret_cast<VkMemoryRequirements2*>( pMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE MemoryRequirements2 Device::getBufferMemoryRequirements2( const BufferMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    MemoryRequirements2 memoryRequirements;
    d.vkGetBufferMemoryRequirements2( m_device, reinterpret_cast<const VkBufferMemoryRequirementsInfo2*>( &info ), reinterpret_cast<VkMemoryRequirements2*>( &memoryRequirements ) );
    return memoryRequirements;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> Device::getBufferMemoryRequirements2( const BufferMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    MemoryRequirements2& memoryRequirements = structureChain.template get<MemoryRequirements2>();
    d.vkGetBufferMemoryRequirements2( m_device, reinterpret_cast<const VkBufferMemoryRequirementsInfo2*>( &info ), reinterpret_cast<VkMemoryRequirements2*>( &memoryRequirements ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getBufferMemoryRequirements2KHR( const BufferMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetBufferMemoryRequirements2KHR( m_device, reinterpret_cast<const VkBufferMemoryRequirementsInfo2*>( pInfo ), reinterpret_cast<VkMemoryRequirements2*>( pMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE MemoryRequirements2 Device::getBufferMemoryRequirements2KHR( const BufferMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    MemoryRequirements2 memoryRequirements;
    d.vkGetBufferMemoryRequirements2KHR( m_device, reinterpret_cast<const VkBufferMemoryRequirementsInfo2*>( &info ), reinterpret_cast<VkMemoryRequirements2*>( &memoryRequirements ) );
    return memoryRequirements;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> Device::getBufferMemoryRequirements2KHR( const BufferMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    MemoryRequirements2& memoryRequirements = structureChain.template get<MemoryRequirements2>();
    d.vkGetBufferMemoryRequirements2KHR( m_device, reinterpret_cast<const VkBufferMemoryRequirementsInfo2*>( &info ), reinterpret_cast<VkMemoryRequirements2*>( &memoryRequirements ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getImageMemoryRequirements2( const ImageMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetImageMemoryRequirements2( m_device, reinterpret_cast<const VkImageMemoryRequirementsInfo2*>( pInfo ), reinterpret_cast<VkMemoryRequirements2*>( pMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE MemoryRequirements2 Device::getImageMemoryRequirements2( const ImageMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    MemoryRequirements2 memoryRequirements;
    d.vkGetImageMemoryRequirements2( m_device, reinterpret_cast<const VkImageMemoryRequirementsInfo2*>( &info ), reinterpret_cast<VkMemoryRequirements2*>( &memoryRequirements ) );
    return memoryRequirements;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> Device::getImageMemoryRequirements2( const ImageMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    MemoryRequirements2& memoryRequirements = structureChain.template get<MemoryRequirements2>();
    d.vkGetImageMemoryRequirements2( m_device, reinterpret_cast<const VkImageMemoryRequirementsInfo2*>( &info ), reinterpret_cast<VkMemoryRequirements2*>( &memoryRequirements ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getImageMemoryRequirements2KHR( const ImageMemoryRequirementsInfo2* pInfo, MemoryRequirements2* pMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetImageMemoryRequirements2KHR( m_device, reinterpret_cast<const VkImageMemoryRequirementsInfo2*>( pInfo ), reinterpret_cast<VkMemoryRequirements2*>( pMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE MemoryRequirements2 Device::getImageMemoryRequirements2KHR( const ImageMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    MemoryRequirements2 memoryRequirements;
    d.vkGetImageMemoryRequirements2KHR( m_device, reinterpret_cast<const VkImageMemoryRequirementsInfo2*>( &info ), reinterpret_cast<VkMemoryRequirements2*>( &memoryRequirements ) );
    return memoryRequirements;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> Device::getImageMemoryRequirements2KHR( const ImageMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    MemoryRequirements2& memoryRequirements = structureChain.template get<MemoryRequirements2>();
    d.vkGetImageMemoryRequirements2KHR( m_device, reinterpret_cast<const VkImageMemoryRequirementsInfo2*>( &info ), reinterpret_cast<VkMemoryRequirements2*>( &memoryRequirements ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getImageSparseMemoryRequirements2( const ImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetImageSparseMemoryRequirements2( m_device, reinterpret_cast<const VkImageSparseMemoryRequirementsInfo2*>( pInfo ), pSparseMemoryRequirementCount, reinterpret_cast<VkSparseImageMemoryRequirements2*>( pSparseMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<SparseImageMemoryRequirements2,Allocator> Device::getImageSparseMemoryRequirements2( const ImageSparseMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    std::vector<SparseImageMemoryRequirements2,Allocator> sparseMemoryRequirements;
    uint32_t sparseMemoryRequirementCount;
    d.vkGetImageSparseMemoryRequirements2( m_device, reinterpret_cast<const VkImageSparseMemoryRequirementsInfo2*>( &info ), &sparseMemoryRequirementCount, nullptr );
    sparseMemoryRequirements.resize( sparseMemoryRequirementCount );
    d.vkGetImageSparseMemoryRequirements2( m_device, reinterpret_cast<const VkImageSparseMemoryRequirementsInfo2*>( &info ), &sparseMemoryRequirementCount, reinterpret_cast<VkSparseImageMemoryRequirements2*>( sparseMemoryRequirements.data() ) );
    return sparseMemoryRequirements;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getImageSparseMemoryRequirements2KHR( const ImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetImageSparseMemoryRequirements2KHR( m_device, reinterpret_cast<const VkImageSparseMemoryRequirementsInfo2*>( pInfo ), pSparseMemoryRequirementCount, reinterpret_cast<VkSparseImageMemoryRequirements2*>( pSparseMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<SparseImageMemoryRequirements2,Allocator> Device::getImageSparseMemoryRequirements2KHR( const ImageSparseMemoryRequirementsInfo2 & info, Dispatch const &d ) const
  {
    std::vector<SparseImageMemoryRequirements2,Allocator> sparseMemoryRequirements;
    uint32_t sparseMemoryRequirementCount;
    d.vkGetImageSparseMemoryRequirements2KHR( m_device, reinterpret_cast<const VkImageSparseMemoryRequirementsInfo2*>( &info ), &sparseMemoryRequirementCount, nullptr );
    sparseMemoryRequirements.resize( sparseMemoryRequirementCount );
    d.vkGetImageSparseMemoryRequirements2KHR( m_device, reinterpret_cast<const VkImageSparseMemoryRequirementsInfo2*>( &info ), &sparseMemoryRequirementCount, reinterpret_cast<VkSparseImageMemoryRequirements2*>( sparseMemoryRequirements.data() ) );
    return sparseMemoryRequirements;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createSamplerYcbcrConversion( const SamplerYcbcrConversionCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, SamplerYcbcrConversion* pYcbcrConversion, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateSamplerYcbcrConversion( m_device, reinterpret_cast<const VkSamplerYcbcrConversionCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSamplerYcbcrConversion*>( pYcbcrConversion ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SamplerYcbcrConversion>::type Device::createSamplerYcbcrConversion( const SamplerYcbcrConversionCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SamplerYcbcrConversion ycbcrConversion;
    Result result = static_cast<Result>( d.vkCreateSamplerYcbcrConversion( m_device, reinterpret_cast<const VkSamplerYcbcrConversionCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSamplerYcbcrConversion*>( &ycbcrConversion ) ) );
    return createResultValue( result, ycbcrConversion, VULKAN_HPP_NAMESPACE_STRING"::Device::createSamplerYcbcrConversion" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SamplerYcbcrConversion,Dispatch>>::type Device::createSamplerYcbcrConversionUnique( const SamplerYcbcrConversionCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SamplerYcbcrConversion ycbcrConversion;
    Result result = static_cast<Result>( d.vkCreateSamplerYcbcrConversion( m_device, reinterpret_cast<const VkSamplerYcbcrConversionCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSamplerYcbcrConversion*>( &ycbcrConversion ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SamplerYcbcrConversion,Dispatch>( result, ycbcrConversion, VULKAN_HPP_NAMESPACE_STRING"::Device::createSamplerYcbcrConversionUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createSamplerYcbcrConversionKHR( const SamplerYcbcrConversionCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, SamplerYcbcrConversion* pYcbcrConversion, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateSamplerYcbcrConversionKHR( m_device, reinterpret_cast<const VkSamplerYcbcrConversionCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSamplerYcbcrConversion*>( pYcbcrConversion ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SamplerYcbcrConversion>::type Device::createSamplerYcbcrConversionKHR( const SamplerYcbcrConversionCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SamplerYcbcrConversion ycbcrConversion;
    Result result = static_cast<Result>( d.vkCreateSamplerYcbcrConversionKHR( m_device, reinterpret_cast<const VkSamplerYcbcrConversionCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSamplerYcbcrConversion*>( &ycbcrConversion ) ) );
    return createResultValue( result, ycbcrConversion, VULKAN_HPP_NAMESPACE_STRING"::Device::createSamplerYcbcrConversionKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SamplerYcbcrConversion,Dispatch>>::type Device::createSamplerYcbcrConversionKHRUnique( const SamplerYcbcrConversionCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SamplerYcbcrConversion ycbcrConversion;
    Result result = static_cast<Result>( d.vkCreateSamplerYcbcrConversionKHR( m_device, reinterpret_cast<const VkSamplerYcbcrConversionCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSamplerYcbcrConversion*>( &ycbcrConversion ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SamplerYcbcrConversion,Dispatch>( result, ycbcrConversion, VULKAN_HPP_NAMESPACE_STRING"::Device::createSamplerYcbcrConversionKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySamplerYcbcrConversion( SamplerYcbcrConversion ycbcrConversion, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySamplerYcbcrConversion( m_device, static_cast<VkSamplerYcbcrConversion>( ycbcrConversion ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySamplerYcbcrConversion( SamplerYcbcrConversion ycbcrConversion, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySamplerYcbcrConversion( m_device, static_cast<VkSamplerYcbcrConversion>( ycbcrConversion ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( SamplerYcbcrConversion ycbcrConversion, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySamplerYcbcrConversion( m_device, static_cast<VkSamplerYcbcrConversion>( ycbcrConversion ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( SamplerYcbcrConversion ycbcrConversion, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySamplerYcbcrConversion( m_device, static_cast<VkSamplerYcbcrConversion>( ycbcrConversion ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySamplerYcbcrConversionKHR( SamplerYcbcrConversion ycbcrConversion, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySamplerYcbcrConversionKHR( m_device, static_cast<VkSamplerYcbcrConversion>( ycbcrConversion ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroySamplerYcbcrConversionKHR( SamplerYcbcrConversion ycbcrConversion, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySamplerYcbcrConversionKHR( m_device, static_cast<VkSamplerYcbcrConversion>( ycbcrConversion ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getQueue2( const DeviceQueueInfo2* pQueueInfo, Queue* pQueue, Dispatch const &d) const
  {
    d.vkGetDeviceQueue2( m_device, reinterpret_cast<const VkDeviceQueueInfo2*>( pQueueInfo ), reinterpret_cast<VkQueue*>( pQueue ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Queue Device::getQueue2( const DeviceQueueInfo2 & queueInfo, Dispatch const &d ) const
  {
    Queue queue;
    d.vkGetDeviceQueue2( m_device, reinterpret_cast<const VkDeviceQueueInfo2*>( &queueInfo ), reinterpret_cast<VkQueue*>( &queue ) );
    return queue;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createValidationCacheEXT( const ValidationCacheCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, ValidationCacheEXT* pValidationCache, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateValidationCacheEXT( m_device, reinterpret_cast<const VkValidationCacheCreateInfoEXT*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkValidationCacheEXT*>( pValidationCache ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<ValidationCacheEXT>::type Device::createValidationCacheEXT( const ValidationCacheCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    ValidationCacheEXT validationCache;
    Result result = static_cast<Result>( d.vkCreateValidationCacheEXT( m_device, reinterpret_cast<const VkValidationCacheCreateInfoEXT*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkValidationCacheEXT*>( &validationCache ) ) );
    return createResultValue( result, validationCache, VULKAN_HPP_NAMESPACE_STRING"::Device::createValidationCacheEXT" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<ValidationCacheEXT,Dispatch>>::type Device::createValidationCacheEXTUnique( const ValidationCacheCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    ValidationCacheEXT validationCache;
    Result result = static_cast<Result>( d.vkCreateValidationCacheEXT( m_device, reinterpret_cast<const VkValidationCacheCreateInfoEXT*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkValidationCacheEXT*>( &validationCache ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<ValidationCacheEXT,Dispatch>( result, validationCache, VULKAN_HPP_NAMESPACE_STRING"::Device::createValidationCacheEXTUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyValidationCacheEXT( ValidationCacheEXT validationCache, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyValidationCacheEXT( m_device, static_cast<VkValidationCacheEXT>( validationCache ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyValidationCacheEXT( ValidationCacheEXT validationCache, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyValidationCacheEXT( m_device, static_cast<VkValidationCacheEXT>( validationCache ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( ValidationCacheEXT validationCache, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyValidationCacheEXT( m_device, static_cast<VkValidationCacheEXT>( validationCache ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( ValidationCacheEXT validationCache, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyValidationCacheEXT( m_device, static_cast<VkValidationCacheEXT>( validationCache ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getValidationCacheDataEXT( ValidationCacheEXT validationCache, size_t* pDataSize, void* pData, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetValidationCacheDataEXT( m_device, static_cast<VkValidationCacheEXT>( validationCache ), pDataSize, pData ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<uint8_t,Allocator>>::type Device::getValidationCacheDataEXT( ValidationCacheEXT validationCache, Dispatch const &d ) const
  {
    std::vector<uint8_t,Allocator> data;
    size_t dataSize;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetValidationCacheDataEXT( m_device, static_cast<VkValidationCacheEXT>( validationCache ), &dataSize, nullptr ) );
      if ( ( result == Result::eSuccess ) && dataSize )
      {
        data.resize( dataSize );
        result = static_cast<Result>( d.vkGetValidationCacheDataEXT( m_device, static_cast<VkValidationCacheEXT>( validationCache ), &dataSize, reinterpret_cast<void*>( data.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( dataSize <= data.size() );
    data.resize( dataSize );
    return createResultValue( result, data, VULKAN_HPP_NAMESPACE_STRING"::Device::getValidationCacheDataEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::mergeValidationCachesEXT( ValidationCacheEXT dstCache, uint32_t srcCacheCount, const ValidationCacheEXT* pSrcCaches, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkMergeValidationCachesEXT( m_device, static_cast<VkValidationCacheEXT>( dstCache ), srcCacheCount, reinterpret_cast<const VkValidationCacheEXT*>( pSrcCaches ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::mergeValidationCachesEXT( ValidationCacheEXT dstCache, ArrayProxy<const ValidationCacheEXT> srcCaches, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkMergeValidationCachesEXT( m_device, static_cast<VkValidationCacheEXT>( dstCache ), srcCaches.size() , reinterpret_cast<const VkValidationCacheEXT*>( srcCaches.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::mergeValidationCachesEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getDescriptorSetLayoutSupport( const DescriptorSetLayoutCreateInfo* pCreateInfo, DescriptorSetLayoutSupport* pSupport, Dispatch const &d) const
  {
    d.vkGetDescriptorSetLayoutSupport( m_device, reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>( pCreateInfo ), reinterpret_cast<VkDescriptorSetLayoutSupport*>( pSupport ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE DescriptorSetLayoutSupport Device::getDescriptorSetLayoutSupport( const DescriptorSetLayoutCreateInfo & createInfo, Dispatch const &d ) const
  {
    DescriptorSetLayoutSupport support;
    d.vkGetDescriptorSetLayoutSupport( m_device, reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>( &createInfo ), reinterpret_cast<VkDescriptorSetLayoutSupport*>( &support ) );
    return support;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> Device::getDescriptorSetLayoutSupport( const DescriptorSetLayoutCreateInfo & createInfo, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    DescriptorSetLayoutSupport& support = structureChain.template get<DescriptorSetLayoutSupport>();
    d.vkGetDescriptorSetLayoutSupport( m_device, reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>( &createInfo ), reinterpret_cast<VkDescriptorSetLayoutSupport*>( &support ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getDescriptorSetLayoutSupportKHR( const DescriptorSetLayoutCreateInfo* pCreateInfo, DescriptorSetLayoutSupport* pSupport, Dispatch const &d) const
  {
    d.vkGetDescriptorSetLayoutSupportKHR( m_device, reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>( pCreateInfo ), reinterpret_cast<VkDescriptorSetLayoutSupport*>( pSupport ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE DescriptorSetLayoutSupport Device::getDescriptorSetLayoutSupportKHR( const DescriptorSetLayoutCreateInfo & createInfo, Dispatch const &d ) const
  {
    DescriptorSetLayoutSupport support;
    d.vkGetDescriptorSetLayoutSupportKHR( m_device, reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>( &createInfo ), reinterpret_cast<VkDescriptorSetLayoutSupport*>( &support ) );
    return support;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> Device::getDescriptorSetLayoutSupportKHR( const DescriptorSetLayoutCreateInfo & createInfo, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    DescriptorSetLayoutSupport& support = structureChain.template get<DescriptorSetLayoutSupport>();
    d.vkGetDescriptorSetLayoutSupportKHR( m_device, reinterpret_cast<const VkDescriptorSetLayoutCreateInfo*>( &createInfo ), reinterpret_cast<VkDescriptorSetLayoutSupport*>( &support ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getShaderInfoAMD( Pipeline pipeline, ShaderStageFlagBits shaderStage, ShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetShaderInfoAMD( m_device, static_cast<VkPipeline>( pipeline ), static_cast<VkShaderStageFlagBits>( shaderStage ), static_cast<VkShaderInfoTypeAMD>( infoType ), pInfoSize, pInfo ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<uint8_t,Allocator>>::type Device::getShaderInfoAMD( Pipeline pipeline, ShaderStageFlagBits shaderStage, ShaderInfoTypeAMD infoType, Dispatch const &d ) const
  {
    std::vector<uint8_t,Allocator> info;
    size_t infoSize;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetShaderInfoAMD( m_device, static_cast<VkPipeline>( pipeline ), static_cast<VkShaderStageFlagBits>( shaderStage ), static_cast<VkShaderInfoTypeAMD>( infoType ), &infoSize, nullptr ) );
      if ( ( result == Result::eSuccess ) && infoSize )
      {
        info.resize( infoSize );
        result = static_cast<Result>( d.vkGetShaderInfoAMD( m_device, static_cast<VkPipeline>( pipeline ), static_cast<VkShaderStageFlagBits>( shaderStage ), static_cast<VkShaderInfoTypeAMD>( infoType ), &infoSize, reinterpret_cast<void*>( info.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( infoSize <= info.size() );
    info.resize( infoSize );
    return createResultValue( result, info, VULKAN_HPP_NAMESPACE_STRING"::Device::getShaderInfoAMD" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::setDebugUtilsObjectNameEXT( const DebugUtilsObjectNameInfoEXT* pNameInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkSetDebugUtilsObjectNameEXT( m_device, reinterpret_cast<const VkDebugUtilsObjectNameInfoEXT*>( pNameInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::setDebugUtilsObjectNameEXT( const DebugUtilsObjectNameInfoEXT & nameInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkSetDebugUtilsObjectNameEXT( m_device, reinterpret_cast<const VkDebugUtilsObjectNameInfoEXT*>( &nameInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::setDebugUtilsObjectNameEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::setDebugUtilsObjectTagEXT( const DebugUtilsObjectTagInfoEXT* pTagInfo, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkSetDebugUtilsObjectTagEXT( m_device, reinterpret_cast<const VkDebugUtilsObjectTagInfoEXT*>( pTagInfo ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::setDebugUtilsObjectTagEXT( const DebugUtilsObjectTagInfoEXT & tagInfo, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkSetDebugUtilsObjectTagEXT( m_device, reinterpret_cast<const VkDebugUtilsObjectTagInfoEXT*>( &tagInfo ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::setDebugUtilsObjectTagEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getMemoryHostPointerPropertiesEXT( ExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, MemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetMemoryHostPointerPropertiesEXT( m_device, static_cast<VkExternalMemoryHandleTypeFlagBits>( handleType ), pHostPointer, reinterpret_cast<VkMemoryHostPointerPropertiesEXT*>( pMemoryHostPointerProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<MemoryHostPointerPropertiesEXT>::type Device::getMemoryHostPointerPropertiesEXT( ExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, Dispatch const &d ) const
  {
    MemoryHostPointerPropertiesEXT memoryHostPointerProperties;
    Result result = static_cast<Result>( d.vkGetMemoryHostPointerPropertiesEXT( m_device, static_cast<VkExternalMemoryHandleTypeFlagBits>( handleType ), pHostPointer, reinterpret_cast<VkMemoryHostPointerPropertiesEXT*>( &memoryHostPointerProperties ) ) );
    return createResultValue( result, memoryHostPointerProperties, VULKAN_HPP_NAMESPACE_STRING"::Device::getMemoryHostPointerPropertiesEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createRenderPass2KHR( const RenderPassCreateInfo2KHR* pCreateInfo, const AllocationCallbacks* pAllocator, RenderPass* pRenderPass, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateRenderPass2KHR( m_device, reinterpret_cast<const VkRenderPassCreateInfo2KHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkRenderPass*>( pRenderPass ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<RenderPass>::type Device::createRenderPass2KHR( const RenderPassCreateInfo2KHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    RenderPass renderPass;
    Result result = static_cast<Result>( d.vkCreateRenderPass2KHR( m_device, reinterpret_cast<const VkRenderPassCreateInfo2KHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkRenderPass*>( &renderPass ) ) );
    return createResultValue( result, renderPass, VULKAN_HPP_NAMESPACE_STRING"::Device::createRenderPass2KHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<RenderPass,Dispatch>>::type Device::createRenderPass2KHRUnique( const RenderPassCreateInfo2KHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    RenderPass renderPass;
    Result result = static_cast<Result>( d.vkCreateRenderPass2KHR( m_device, reinterpret_cast<const VkRenderPassCreateInfo2KHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkRenderPass*>( &renderPass ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<RenderPass,Dispatch>( result, renderPass, VULKAN_HPP_NAMESPACE_STRING"::Device::createRenderPass2KHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getAndroidHardwareBufferPropertiesANDROID( const struct AHardwareBuffer* buffer, AndroidHardwareBufferPropertiesANDROID* pProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetAndroidHardwareBufferPropertiesANDROID( m_device, buffer, reinterpret_cast<VkAndroidHardwareBufferPropertiesANDROID*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<AndroidHardwareBufferPropertiesANDROID>::type Device::getAndroidHardwareBufferPropertiesANDROID( const struct AHardwareBuffer & buffer, Dispatch const &d ) const
  {
    AndroidHardwareBufferPropertiesANDROID properties;
    Result result = static_cast<Result>( d.vkGetAndroidHardwareBufferPropertiesANDROID( m_device, buffer, reinterpret_cast<VkAndroidHardwareBufferPropertiesANDROID*>( &properties ) ) );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::Device::getAndroidHardwareBufferPropertiesANDROID" );
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<StructureChain<X, Y, Z...>>::type Device::getAndroidHardwareBufferPropertiesANDROID( const struct AHardwareBuffer & buffer, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    AndroidHardwareBufferPropertiesANDROID& properties = structureChain.template get<AndroidHardwareBufferPropertiesANDROID>();
    Result result = static_cast<Result>( d.vkGetAndroidHardwareBufferPropertiesANDROID( m_device, buffer, reinterpret_cast<VkAndroidHardwareBufferPropertiesANDROID*>( &properties ) ) );
    return createResultValue( result, structureChain, VULKAN_HPP_NAMESPACE_STRING"::Device::getAndroidHardwareBufferPropertiesANDROID" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getMemoryAndroidHardwareBufferANDROID( const MemoryGetAndroidHardwareBufferInfoANDROID* pInfo, struct AHardwareBuffer** pBuffer, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetMemoryAndroidHardwareBufferANDROID( m_device, reinterpret_cast<const VkMemoryGetAndroidHardwareBufferInfoANDROID*>( pInfo ), pBuffer ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<struct AHardwareBuffer*>::type Device::getMemoryAndroidHardwareBufferANDROID( const MemoryGetAndroidHardwareBufferInfoANDROID & info, Dispatch const &d ) const
  {
    struct AHardwareBuffer* buffer;
    Result result = static_cast<Result>( d.vkGetMemoryAndroidHardwareBufferANDROID( m_device, reinterpret_cast<const VkMemoryGetAndroidHardwareBufferInfoANDROID*>( &info ), &buffer ) );
    return createResultValue( result, buffer, VULKAN_HPP_NAMESPACE_STRING"::Device::getMemoryAndroidHardwareBufferANDROID" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::compileDeferredNVX( Pipeline pipeline, uint32_t shader, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCompileDeferredNVX( m_device, static_cast<VkPipeline>( pipeline ), shader ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::compileDeferredNVX( Pipeline pipeline, uint32_t shader, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkCompileDeferredNVX( m_device, static_cast<VkPipeline>( pipeline ), shader ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::compileDeferredNVX" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createAccelerationStructureNVX( const AccelerationStructureCreateInfoNVX* pCreateInfo, const AllocationCallbacks* pAllocator, AccelerationStructureNVX* pAccelerationStructure, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateAccelerationStructureNVX( m_device, reinterpret_cast<const VkAccelerationStructureCreateInfoNVX*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkAccelerationStructureNVX*>( pAccelerationStructure ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<AccelerationStructureNVX>::type Device::createAccelerationStructureNVX( const AccelerationStructureCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    AccelerationStructureNVX accelerationStructure;
    Result result = static_cast<Result>( d.vkCreateAccelerationStructureNVX( m_device, reinterpret_cast<const VkAccelerationStructureCreateInfoNVX*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkAccelerationStructureNVX*>( &accelerationStructure ) ) );
    return createResultValue( result, accelerationStructure, VULKAN_HPP_NAMESPACE_STRING"::Device::createAccelerationStructureNVX" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<AccelerationStructureNVX,Dispatch>>::type Device::createAccelerationStructureNVXUnique( const AccelerationStructureCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    AccelerationStructureNVX accelerationStructure;
    Result result = static_cast<Result>( d.vkCreateAccelerationStructureNVX( m_device, reinterpret_cast<const VkAccelerationStructureCreateInfoNVX*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkAccelerationStructureNVX*>( &accelerationStructure ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<AccelerationStructureNVX,Dispatch>( result, accelerationStructure, VULKAN_HPP_NAMESPACE_STRING"::Device::createAccelerationStructureNVXUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyAccelerationStructureNVX( AccelerationStructureNVX accelerationStructure, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyAccelerationStructureNVX( m_device, static_cast<VkAccelerationStructureNVX>( accelerationStructure ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroyAccelerationStructureNVX( AccelerationStructureNVX accelerationStructure, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyAccelerationStructureNVX( m_device, static_cast<VkAccelerationStructureNVX>( accelerationStructure ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( AccelerationStructureNVX accelerationStructure, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyAccelerationStructureNVX( m_device, static_cast<VkAccelerationStructureNVX>( accelerationStructure ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::destroy( AccelerationStructureNVX accelerationStructure, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyAccelerationStructureNVX( m_device, static_cast<VkAccelerationStructureNVX>( accelerationStructure ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getAccelerationStructureMemoryRequirementsNVX( const AccelerationStructureMemoryRequirementsInfoNVX* pInfo, MemoryRequirements2KHR* pMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetAccelerationStructureMemoryRequirementsNVX( m_device, reinterpret_cast<const VkAccelerationStructureMemoryRequirementsInfoNVX*>( pInfo ), reinterpret_cast<VkMemoryRequirements2KHR*>( pMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE MemoryRequirements2KHR Device::getAccelerationStructureMemoryRequirementsNVX( const AccelerationStructureMemoryRequirementsInfoNVX & info, Dispatch const &d ) const
  {
    MemoryRequirements2KHR memoryRequirements;
    d.vkGetAccelerationStructureMemoryRequirementsNVX( m_device, reinterpret_cast<const VkAccelerationStructureMemoryRequirementsInfoNVX*>( &info ), reinterpret_cast<VkMemoryRequirements2KHR*>( &memoryRequirements ) );
    return memoryRequirements;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Device::getAccelerationStructureScratchMemoryRequirementsNVX( const AccelerationStructureMemoryRequirementsInfoNVX* pInfo, MemoryRequirements2KHR* pMemoryRequirements, Dispatch const &d) const
  {
    d.vkGetAccelerationStructureScratchMemoryRequirementsNVX( m_device, reinterpret_cast<const VkAccelerationStructureMemoryRequirementsInfoNVX*>( pInfo ), reinterpret_cast<VkMemoryRequirements2KHR*>( pMemoryRequirements ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE MemoryRequirements2KHR Device::getAccelerationStructureScratchMemoryRequirementsNVX( const AccelerationStructureMemoryRequirementsInfoNVX & info, Dispatch const &d ) const
  {
    MemoryRequirements2KHR memoryRequirements;
    d.vkGetAccelerationStructureScratchMemoryRequirementsNVX( m_device, reinterpret_cast<const VkAccelerationStructureMemoryRequirementsInfoNVX*>( &info ), reinterpret_cast<VkMemoryRequirements2KHR*>( &memoryRequirements ) );
    return memoryRequirements;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::bindAccelerationStructureMemoryNVX( uint32_t bindInfoCount, const BindAccelerationStructureMemoryInfoNVX* pBindInfos, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkBindAccelerationStructureMemoryNVX( m_device, bindInfoCount, reinterpret_cast<const VkBindAccelerationStructureMemoryInfoNVX*>( pBindInfos ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::bindAccelerationStructureMemoryNVX( ArrayProxy<const BindAccelerationStructureMemoryInfoNVX> bindInfos, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkBindAccelerationStructureMemoryNVX( m_device, bindInfos.size() , reinterpret_cast<const VkBindAccelerationStructureMemoryInfoNVX*>( bindInfos.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::bindAccelerationStructureMemoryNVX" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getRaytracingShaderHandlesNVX( Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetRaytracingShaderHandlesNVX( m_device, static_cast<VkPipeline>( pipeline ), firstGroup, groupCount, dataSize, pData ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename T, typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::getRaytracingShaderHandlesNVX( Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, ArrayProxy<T> data, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkGetRaytracingShaderHandlesNVX( m_device, static_cast<VkPipeline>( pipeline ), firstGroup, groupCount, data.size() * sizeof( T ) , reinterpret_cast<void*>( data.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::getRaytracingShaderHandlesNVX" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::getAccelerationStructureHandleNVX( AccelerationStructureNVX accelerationStructure, size_t dataSize, void* pData, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetAccelerationStructureHandleNVX( m_device, static_cast<VkAccelerationStructureNVX>( accelerationStructure ), dataSize, pData ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename T, typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type Device::getAccelerationStructureHandleNVX( AccelerationStructureNVX accelerationStructure, ArrayProxy<T> data, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkGetAccelerationStructureHandleNVX( m_device, static_cast<VkAccelerationStructureNVX>( accelerationStructure ), data.size() * sizeof( T ) , reinterpret_cast<void*>( data.data() ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::Device::getAccelerationStructureHandleNVX" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Device::createRaytracingPipelinesNVX( PipelineCache pipelineCache, uint32_t createInfoCount, const RaytracingPipelineCreateInfoNVX* pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline* pPipelines, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateRaytracingPipelinesNVX( m_device, static_cast<VkPipelineCache>( pipelineCache ), createInfoCount, reinterpret_cast<const VkRaytracingPipelineCreateInfoNVX*>( pCreateInfos ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkPipeline*>( pPipelines ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<Pipeline,Allocator>>::type Device::createRaytracingPipelinesNVX( PipelineCache pipelineCache, ArrayProxy<const RaytracingPipelineCreateInfoNVX> createInfos, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    std::vector<Pipeline,Allocator> pipelines( createInfos.size() );
    Result result = static_cast<Result>( d.vkCreateRaytracingPipelinesNVX( m_device, static_cast<VkPipelineCache>( pipelineCache ), createInfos.size() , reinterpret_cast<const VkRaytracingPipelineCreateInfoNVX*>( createInfos.data() ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( pipelines.data() ) ) );
    return createResultValue( result, pipelines, VULKAN_HPP_NAMESPACE_STRING"::Device::createRaytracingPipelinesNVX" );
  }
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE ResultValueType<Pipeline>::type Device::createRaytracingPipelineNVX( PipelineCache pipelineCache, const RaytracingPipelineCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Pipeline pipeline;
    Result result = static_cast<Result>( d.vkCreateRaytracingPipelinesNVX( m_device, static_cast<VkPipelineCache>( pipelineCache ), 1 , reinterpret_cast<const VkRaytracingPipelineCreateInfoNVX*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( &pipeline ) ) );
    return createResultValue( result, pipeline, VULKAN_HPP_NAMESPACE_STRING"::Device::createRaytracingPipelineNVX" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<UniqueHandle<Pipeline,Dispatch>,Allocator>>::type Device::createRaytracingPipelinesNVXUnique( PipelineCache pipelineCache, ArrayProxy<const RaytracingPipelineCreateInfoNVX> createInfos, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    static_assert( sizeof( Pipeline ) <= sizeof( UniquePipeline ), "Pipeline is greater than UniquePipeline!" );
    std::vector<UniquePipeline, Allocator> pipelines;
    pipelines.reserve( createInfos.size() );
    Pipeline* buffer = reinterpret_cast<Pipeline*>( reinterpret_cast<char*>( pipelines.data() ) + createInfos.size() * ( sizeof( UniquePipeline ) - sizeof( Pipeline ) ) );
    Result result = static_cast<Result>(d.vkCreateRaytracingPipelinesNVX( m_device, static_cast<VkPipelineCache>( pipelineCache ), createInfos.size() , reinterpret_cast<const VkRaytracingPipelineCreateInfoNVX*>( createInfos.data() ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( buffer ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    for ( size_t i=0 ; i<createInfos.size() ; i++ )
    {
      pipelines.push_back( UniquePipeline( buffer[i], deleter ) );
    }

    return createResultValue( result, pipelines, VULKAN_HPP_NAMESPACE_STRING "::Device::createRaytracingPipelinesNVXUnique" );
  }
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Pipeline,Dispatch>>::type Device::createRaytracingPipelineNVXUnique( PipelineCache pipelineCache, const RaytracingPipelineCreateInfoNVX & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Pipeline pipeline;
    Result result = static_cast<Result>( d.vkCreateRaytracingPipelinesNVX( m_device, static_cast<VkPipelineCache>( pipelineCache ), 1 , reinterpret_cast<const VkRaytracingPipelineCreateInfoNVX*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkPipeline*>( &pipeline ) ) );

    ObjectDestroy<Device,Dispatch> deleter( *this, allocator, d );
    return createResultValue<Pipeline,Dispatch>( result, pipeline, VULKAN_HPP_NAMESPACE_STRING"::Device::createRaytracingPipelineNVXUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifndef VULKAN_HPP_NO_SMART_HANDLE

  template <typename Dispatch> class UniqueHandleTraits<Device,Dispatch> {public: using deleter = ObjectDestroy<NoParent,Dispatch>; };
  using UniqueDevice = UniqueHandle<Device,DispatchLoaderStatic>;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/

  class PhysicalDevice
  {
  public:
    VULKAN_HPP_CONSTEXPR PhysicalDevice()
      : m_physicalDevice(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevice( std::nullptr_t )
      : m_physicalDevice(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT PhysicalDevice( VkPhysicalDevice physicalDevice )
      : m_physicalDevice( physicalDevice )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    PhysicalDevice & operator=(VkPhysicalDevice physicalDevice)
    {
      m_physicalDevice = physicalDevice;
      return *this; 
    }
#endif

    PhysicalDevice & operator=( std::nullptr_t )
    {
      m_physicalDevice = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( PhysicalDevice const & rhs ) const
    {
      return m_physicalDevice == rhs.m_physicalDevice;
    }

    bool operator!=(PhysicalDevice const & rhs ) const
    {
      return m_physicalDevice != rhs.m_physicalDevice;
    }

    bool operator<(PhysicalDevice const & rhs ) const
    {
      return m_physicalDevice < rhs.m_physicalDevice;
    }

    template<typename Dispatch = DispatchLoaderStatic>
    void getProperties( PhysicalDeviceProperties* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PhysicalDeviceProperties getProperties(Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getProperties(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getQueueFamilyProperties( uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties* pQueueFamilyProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<QueueFamilyProperties>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<QueueFamilyProperties,Allocator> getQueueFamilyProperties(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getMemoryProperties( PhysicalDeviceMemoryProperties* pMemoryProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PhysicalDeviceMemoryProperties getMemoryProperties(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getFeatures( PhysicalDeviceFeatures* pFeatures, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PhysicalDeviceFeatures getFeatures(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getFormatProperties( Format format, FormatProperties* pFormatProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    FormatProperties getFormatProperties( Format format, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getImageFormatProperties( Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, ImageFormatProperties* pImageFormatProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<ImageFormatProperties>::type getImageFormatProperties( Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createDevice( const DeviceCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Device* pDevice, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Device>::type createDevice( const DeviceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<Device,Dispatch>>::type createDeviceUnique( const DeviceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result enumerateDeviceLayerProperties( uint32_t* pPropertyCount, LayerProperties* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<LayerProperties>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<LayerProperties,Allocator>>::type enumerateDeviceLayerProperties(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result enumerateDeviceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, ExtensionProperties* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<ExtensionProperties>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<ExtensionProperties,Allocator>>::type enumerateDeviceExtensionProperties( Optional<const std::string> layerName = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getSparseImageFormatProperties( Format format, ImageType type, SampleCountFlagBits samples, ImageUsageFlags usage, ImageTiling tiling, uint32_t* pPropertyCount, SparseImageFormatProperties* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<SparseImageFormatProperties>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<SparseImageFormatProperties,Allocator> getSparseImageFormatProperties( Format format, ImageType type, SampleCountFlagBits samples, ImageUsageFlags usage, ImageTiling tiling, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getDisplayPropertiesKHR( uint32_t* pPropertyCount, DisplayPropertiesKHR* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<DisplayPropertiesKHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<DisplayPropertiesKHR,Allocator>>::type getDisplayPropertiesKHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getDisplayPlanePropertiesKHR( uint32_t* pPropertyCount, DisplayPlanePropertiesKHR* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<DisplayPlanePropertiesKHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<DisplayPlanePropertiesKHR,Allocator>>::type getDisplayPlanePropertiesKHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getDisplayPlaneSupportedDisplaysKHR( uint32_t planeIndex, uint32_t* pDisplayCount, DisplayKHR* pDisplays, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<DisplayKHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<DisplayKHR,Allocator>>::type getDisplayPlaneSupportedDisplaysKHR( uint32_t planeIndex, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getDisplayModePropertiesKHR( DisplayKHR display, uint32_t* pPropertyCount, DisplayModePropertiesKHR* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<DisplayModePropertiesKHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<DisplayModePropertiesKHR,Allocator>>::type getDisplayModePropertiesKHR( DisplayKHR display, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createDisplayModeKHR( DisplayKHR display, const DisplayModeCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, DisplayModeKHR* pMode, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DisplayModeKHR>::type createDisplayModeKHR( DisplayKHR display, const DisplayModeCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getDisplayPlaneCapabilitiesKHR( DisplayModeKHR mode, uint32_t planeIndex, DisplayPlaneCapabilitiesKHR* pCapabilities, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DisplayPlaneCapabilitiesKHR>::type getDisplayPlaneCapabilitiesKHR( DisplayModeKHR mode, uint32_t planeIndex, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_MIR_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Bool32 getMirPresentationSupportKHR( uint32_t queueFamilyIndex, MirConnection* connection, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Bool32 getMirPresentationSupportKHR( uint32_t queueFamilyIndex, MirConnection & connection, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_MIR_KHR*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSurfaceSupportKHR( uint32_t queueFamilyIndex, SurfaceKHR surface, Bool32* pSupported, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Bool32>::type getSurfaceSupportKHR( uint32_t queueFamilyIndex, SurfaceKHR surface, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSurfaceCapabilitiesKHR( SurfaceKHR surface, SurfaceCapabilitiesKHR* pSurfaceCapabilities, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceCapabilitiesKHR>::type getSurfaceCapabilitiesKHR( SurfaceKHR surface, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSurfaceFormatsKHR( SurfaceKHR surface, uint32_t* pSurfaceFormatCount, SurfaceFormatKHR* pSurfaceFormats, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<SurfaceFormatKHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<SurfaceFormatKHR,Allocator>>::type getSurfaceFormatsKHR( SurfaceKHR surface, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSurfacePresentModesKHR( SurfaceKHR surface, uint32_t* pPresentModeCount, PresentModeKHR* pPresentModes, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<PresentModeKHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<PresentModeKHR,Allocator>>::type getSurfacePresentModesKHR( SurfaceKHR surface, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Bool32 getWaylandPresentationSupportKHR( uint32_t queueFamilyIndex, struct wl_display* display, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Bool32 getWaylandPresentationSupportKHR( uint32_t queueFamilyIndex, struct wl_display & display, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Bool32 getWin32PresentationSupportKHR( uint32_t queueFamilyIndex, Dispatch const &d = Dispatch() ) const;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_XLIB_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Bool32 getXlibPresentationSupportKHR( uint32_t queueFamilyIndex, Display* dpy, VisualID visualID, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Bool32 getXlibPresentationSupportKHR( uint32_t queueFamilyIndex, Display & dpy, VisualID visualID, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#ifdef VK_USE_PLATFORM_XCB_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Bool32 getXcbPresentationSupportKHR( uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Bool32 getXcbPresentationSupportKHR( uint32_t queueFamilyIndex, xcb_connection_t & connection, xcb_visualid_t visual_id, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XCB_KHR*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getExternalImageFormatPropertiesNV( Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, ExternalMemoryHandleTypeFlagsNV externalHandleType, ExternalImageFormatPropertiesNV* pExternalImageFormatProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<ExternalImageFormatPropertiesNV>::type getExternalImageFormatPropertiesNV( Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, ExternalMemoryHandleTypeFlagsNV externalHandleType, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getGeneratedCommandsPropertiesNVX( DeviceGeneratedCommandsFeaturesNVX* pFeatures, DeviceGeneratedCommandsLimitsNVX* pLimits, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    DeviceGeneratedCommandsLimitsNVX getGeneratedCommandsPropertiesNVX( DeviceGeneratedCommandsFeaturesNVX & features, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getFeatures2( PhysicalDeviceFeatures2* pFeatures, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PhysicalDeviceFeatures2 getFeatures2(Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getFeatures2(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getFeatures2KHR( PhysicalDeviceFeatures2* pFeatures, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PhysicalDeviceFeatures2 getFeatures2KHR(Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getFeatures2KHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getProperties2( PhysicalDeviceProperties2* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PhysicalDeviceProperties2 getProperties2(Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getProperties2(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getProperties2KHR( PhysicalDeviceProperties2* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PhysicalDeviceProperties2 getProperties2KHR(Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    StructureChain<X, Y, Z...> getProperties2KHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getFormatProperties2( Format format, FormatProperties2* pFormatProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    FormatProperties2 getFormatProperties2( Format format, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getFormatProperties2KHR( Format format, FormatProperties2* pFormatProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    FormatProperties2 getFormatProperties2KHR( Format format, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getImageFormatProperties2( const PhysicalDeviceImageFormatInfo2* pImageFormatInfo, ImageFormatProperties2* pImageFormatProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<ImageFormatProperties2>::type getImageFormatProperties2( const PhysicalDeviceImageFormatInfo2 & imageFormatInfo, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<StructureChain<X, Y, Z...>>::type getImageFormatProperties2( const PhysicalDeviceImageFormatInfo2 & imageFormatInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getImageFormatProperties2KHR( const PhysicalDeviceImageFormatInfo2* pImageFormatInfo, ImageFormatProperties2* pImageFormatProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<ImageFormatProperties2>::type getImageFormatProperties2KHR( const PhysicalDeviceImageFormatInfo2 & imageFormatInfo, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<StructureChain<X, Y, Z...>>::type getImageFormatProperties2KHR( const PhysicalDeviceImageFormatInfo2 & imageFormatInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getQueueFamilyProperties2( uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<QueueFamilyProperties2>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<QueueFamilyProperties2,Allocator> getQueueFamilyProperties2(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getQueueFamilyProperties2KHR( uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<QueueFamilyProperties2>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<QueueFamilyProperties2,Allocator> getQueueFamilyProperties2KHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getMemoryProperties2( PhysicalDeviceMemoryProperties2* pMemoryProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PhysicalDeviceMemoryProperties2 getMemoryProperties2(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getMemoryProperties2KHR( PhysicalDeviceMemoryProperties2* pMemoryProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PhysicalDeviceMemoryProperties2 getMemoryProperties2KHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getSparseImageFormatProperties2( const PhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, SparseImageFormatProperties2* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<SparseImageFormatProperties2>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<SparseImageFormatProperties2,Allocator> getSparseImageFormatProperties2( const PhysicalDeviceSparseImageFormatInfo2 & formatInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getSparseImageFormatProperties2KHR( const PhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, SparseImageFormatProperties2* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<SparseImageFormatProperties2>, typename Dispatch = DispatchLoaderStatic> 
    std::vector<SparseImageFormatProperties2,Allocator> getSparseImageFormatProperties2KHR( const PhysicalDeviceSparseImageFormatInfo2 & formatInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getExternalBufferProperties( const PhysicalDeviceExternalBufferInfo* pExternalBufferInfo, ExternalBufferProperties* pExternalBufferProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ExternalBufferProperties getExternalBufferProperties( const PhysicalDeviceExternalBufferInfo & externalBufferInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getExternalBufferPropertiesKHR( const PhysicalDeviceExternalBufferInfo* pExternalBufferInfo, ExternalBufferProperties* pExternalBufferProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ExternalBufferProperties getExternalBufferPropertiesKHR( const PhysicalDeviceExternalBufferInfo & externalBufferInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getExternalSemaphoreProperties( const PhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, ExternalSemaphoreProperties* pExternalSemaphoreProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ExternalSemaphoreProperties getExternalSemaphoreProperties( const PhysicalDeviceExternalSemaphoreInfo & externalSemaphoreInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getExternalSemaphorePropertiesKHR( const PhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, ExternalSemaphoreProperties* pExternalSemaphoreProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ExternalSemaphoreProperties getExternalSemaphorePropertiesKHR( const PhysicalDeviceExternalSemaphoreInfo & externalSemaphoreInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getExternalFenceProperties( const PhysicalDeviceExternalFenceInfo* pExternalFenceInfo, ExternalFenceProperties* pExternalFenceProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ExternalFenceProperties getExternalFenceProperties( const PhysicalDeviceExternalFenceInfo & externalFenceInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getExternalFencePropertiesKHR( const PhysicalDeviceExternalFenceInfo* pExternalFenceInfo, ExternalFenceProperties* pExternalFenceProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ExternalFenceProperties getExternalFencePropertiesKHR( const PhysicalDeviceExternalFenceInfo & externalFenceInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    Result releaseDisplayEXT( DisplayKHR display, Dispatch const &d = Dispatch() ) const;
#else
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<void>::type releaseDisplayEXT( DisplayKHR display, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
    template<typename Dispatch = DispatchLoaderStatic>
    Result acquireXlibDisplayEXT( Display* dpy, DisplayKHR display, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<Display>::type acquireXlibDisplayEXT( DisplayKHR display, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
    template<typename Dispatch = DispatchLoaderStatic>
    Result getRandROutputDisplayEXT( Display* dpy, RROutput rrOutput, DisplayKHR* pDisplay, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DisplayKHR>::type getRandROutputDisplayEXT( Display & dpy, RROutput rrOutput, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSurfaceCapabilities2EXT( SurfaceKHR surface, SurfaceCapabilities2EXT* pSurfaceCapabilities, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceCapabilities2EXT>::type getSurfaceCapabilities2EXT( SurfaceKHR surface, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getPresentRectanglesKHR( SurfaceKHR surface, uint32_t* pRectCount, Rect2D* pRects, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<Rect2D>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<Rect2D,Allocator>>::type getPresentRectanglesKHR( SurfaceKHR surface, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void getMultisamplePropertiesEXT( SampleCountFlagBits samples, MultisamplePropertiesEXT* pMultisampleProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    MultisamplePropertiesEXT getMultisamplePropertiesEXT( SampleCountFlagBits samples, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSurfaceCapabilities2KHR( const PhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, SurfaceCapabilities2KHR* pSurfaceCapabilities, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceCapabilities2KHR>::type getSurfaceCapabilities2KHR( const PhysicalDeviceSurfaceInfo2KHR & surfaceInfo, Dispatch const &d = Dispatch() ) const;
    template <typename X, typename Y, typename ...Z, typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<StructureChain<X, Y, Z...>>::type getSurfaceCapabilities2KHR( const PhysicalDeviceSurfaceInfo2KHR & surfaceInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getSurfaceFormats2KHR( const PhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, SurfaceFormat2KHR* pSurfaceFormats, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<SurfaceFormat2KHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<SurfaceFormat2KHR,Allocator>>::type getSurfaceFormats2KHR( const PhysicalDeviceSurfaceInfo2KHR & surfaceInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getDisplayProperties2KHR( uint32_t* pPropertyCount, DisplayProperties2KHR* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<DisplayProperties2KHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<DisplayProperties2KHR,Allocator>>::type getDisplayProperties2KHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getDisplayPlaneProperties2KHR( uint32_t* pPropertyCount, DisplayPlaneProperties2KHR* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<DisplayPlaneProperties2KHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<DisplayPlaneProperties2KHR,Allocator>>::type getDisplayPlaneProperties2KHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getDisplayModeProperties2KHR( DisplayKHR display, uint32_t* pPropertyCount, DisplayModeProperties2KHR* pProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<DisplayModeProperties2KHR>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<DisplayModeProperties2KHR,Allocator>>::type getDisplayModeProperties2KHR( DisplayKHR display, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result getDisplayPlaneCapabilities2KHR( const DisplayPlaneInfo2KHR* pDisplayPlaneInfo, DisplayPlaneCapabilities2KHR* pCapabilities, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DisplayPlaneCapabilities2KHR>::type getDisplayPlaneCapabilities2KHR( const DisplayPlaneInfo2KHR & displayPlaneInfo, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPhysicalDevice() const
    {
      return m_physicalDevice;
    }

    explicit operator bool() const
    {
      return m_physicalDevice != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_physicalDevice == VK_NULL_HANDLE;
    }

  private:
    VkPhysicalDevice m_physicalDevice;
  };

  static_assert( sizeof( PhysicalDevice ) == sizeof( VkPhysicalDevice ), "handle and wrapper have different size!" );

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getProperties( PhysicalDeviceProperties* pProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceProperties( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceProperties*>( pProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PhysicalDeviceProperties PhysicalDevice::getProperties(Dispatch const &d ) const
  {
    PhysicalDeviceProperties properties;
    d.vkGetPhysicalDeviceProperties( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceProperties*>( &properties ) );
    return properties;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> PhysicalDevice::getProperties(Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    PhysicalDeviceProperties& properties = structureChain.template get<PhysicalDeviceProperties>();
    d.vkGetPhysicalDeviceProperties( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceProperties*>( &properties ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getQueueFamilyProperties( uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties* pQueueFamilyProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceQueueFamilyProperties( m_physicalDevice, pQueueFamilyPropertyCount, reinterpret_cast<VkQueueFamilyProperties*>( pQueueFamilyProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<QueueFamilyProperties,Allocator> PhysicalDevice::getQueueFamilyProperties(Dispatch const &d ) const
  {
    std::vector<QueueFamilyProperties,Allocator> queueFamilyProperties;
    uint32_t queueFamilyPropertyCount;
    d.vkGetPhysicalDeviceQueueFamilyProperties( m_physicalDevice, &queueFamilyPropertyCount, nullptr );
    queueFamilyProperties.resize( queueFamilyPropertyCount );
    d.vkGetPhysicalDeviceQueueFamilyProperties( m_physicalDevice, &queueFamilyPropertyCount, reinterpret_cast<VkQueueFamilyProperties*>( queueFamilyProperties.data() ) );
    return queueFamilyProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getMemoryProperties( PhysicalDeviceMemoryProperties* pMemoryProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceMemoryProperties( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceMemoryProperties*>( pMemoryProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PhysicalDeviceMemoryProperties PhysicalDevice::getMemoryProperties(Dispatch const &d ) const
  {
    PhysicalDeviceMemoryProperties memoryProperties;
    d.vkGetPhysicalDeviceMemoryProperties( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceMemoryProperties*>( &memoryProperties ) );
    return memoryProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getFeatures( PhysicalDeviceFeatures* pFeatures, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceFeatures( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceFeatures*>( pFeatures ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PhysicalDeviceFeatures PhysicalDevice::getFeatures(Dispatch const &d ) const
  {
    PhysicalDeviceFeatures features;
    d.vkGetPhysicalDeviceFeatures( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceFeatures*>( &features ) );
    return features;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getFormatProperties( Format format, FormatProperties* pFormatProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceFormatProperties( m_physicalDevice, static_cast<VkFormat>( format ), reinterpret_cast<VkFormatProperties*>( pFormatProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE FormatProperties PhysicalDevice::getFormatProperties( Format format, Dispatch const &d ) const
  {
    FormatProperties formatProperties;
    d.vkGetPhysicalDeviceFormatProperties( m_physicalDevice, static_cast<VkFormat>( format ), reinterpret_cast<VkFormatProperties*>( &formatProperties ) );
    return formatProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getImageFormatProperties( Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, ImageFormatProperties* pImageFormatProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceImageFormatProperties( m_physicalDevice, static_cast<VkFormat>( format ), static_cast<VkImageType>( type ), static_cast<VkImageTiling>( tiling ), static_cast<VkImageUsageFlags>( usage ), static_cast<VkImageCreateFlags>( flags ), reinterpret_cast<VkImageFormatProperties*>( pImageFormatProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<ImageFormatProperties>::type PhysicalDevice::getImageFormatProperties( Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, Dispatch const &d ) const
  {
    ImageFormatProperties imageFormatProperties;
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceImageFormatProperties( m_physicalDevice, static_cast<VkFormat>( format ), static_cast<VkImageType>( type ), static_cast<VkImageTiling>( tiling ), static_cast<VkImageUsageFlags>( usage ), static_cast<VkImageCreateFlags>( flags ), reinterpret_cast<VkImageFormatProperties*>( &imageFormatProperties ) ) );
    return createResultValue( result, imageFormatProperties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getImageFormatProperties" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::createDevice( const DeviceCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Device* pDevice, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateDevice( m_physicalDevice, reinterpret_cast<const VkDeviceCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkDevice*>( pDevice ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Device>::type PhysicalDevice::createDevice( const DeviceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Device device;
    Result result = static_cast<Result>( d.vkCreateDevice( m_physicalDevice, reinterpret_cast<const VkDeviceCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDevice*>( &device ) ) );
    return createResultValue( result, device, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::createDevice" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Device,Dispatch>>::type PhysicalDevice::createDeviceUnique( const DeviceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    Device device;
    Result result = static_cast<Result>( d.vkCreateDevice( m_physicalDevice, reinterpret_cast<const VkDeviceCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDevice*>( &device ) ) );

    ObjectDestroy<NoParent,Dispatch> deleter( allocator, d );
    return createResultValue<Device,Dispatch>( result, device, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::createDeviceUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::enumerateDeviceLayerProperties( uint32_t* pPropertyCount, LayerProperties* pProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkEnumerateDeviceLayerProperties( m_physicalDevice, pPropertyCount, reinterpret_cast<VkLayerProperties*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<LayerProperties,Allocator>>::type PhysicalDevice::enumerateDeviceLayerProperties(Dispatch const &d ) const
  {
    std::vector<LayerProperties,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkEnumerateDeviceLayerProperties( m_physicalDevice, &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkEnumerateDeviceLayerProperties( m_physicalDevice, &propertyCount, reinterpret_cast<VkLayerProperties*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::enumerateDeviceLayerProperties" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::enumerateDeviceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, ExtensionProperties* pProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkEnumerateDeviceExtensionProperties( m_physicalDevice, pLayerName, pPropertyCount, reinterpret_cast<VkExtensionProperties*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<ExtensionProperties,Allocator>>::type PhysicalDevice::enumerateDeviceExtensionProperties( Optional<const std::string> layerName, Dispatch const &d ) const
  {
    std::vector<ExtensionProperties,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkEnumerateDeviceExtensionProperties( m_physicalDevice, layerName ? layerName->c_str() : nullptr, &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkEnumerateDeviceExtensionProperties( m_physicalDevice, layerName ? layerName->c_str() : nullptr, &propertyCount, reinterpret_cast<VkExtensionProperties*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::enumerateDeviceExtensionProperties" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getSparseImageFormatProperties( Format format, ImageType type, SampleCountFlagBits samples, ImageUsageFlags usage, ImageTiling tiling, uint32_t* pPropertyCount, SparseImageFormatProperties* pProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceSparseImageFormatProperties( m_physicalDevice, static_cast<VkFormat>( format ), static_cast<VkImageType>( type ), static_cast<VkSampleCountFlagBits>( samples ), static_cast<VkImageUsageFlags>( usage ), static_cast<VkImageTiling>( tiling ), pPropertyCount, reinterpret_cast<VkSparseImageFormatProperties*>( pProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<SparseImageFormatProperties,Allocator> PhysicalDevice::getSparseImageFormatProperties( Format format, ImageType type, SampleCountFlagBits samples, ImageUsageFlags usage, ImageTiling tiling, Dispatch const &d ) const
  {
    std::vector<SparseImageFormatProperties,Allocator> properties;
    uint32_t propertyCount;
    d.vkGetPhysicalDeviceSparseImageFormatProperties( m_physicalDevice, static_cast<VkFormat>( format ), static_cast<VkImageType>( type ), static_cast<VkSampleCountFlagBits>( samples ), static_cast<VkImageUsageFlags>( usage ), static_cast<VkImageTiling>( tiling ), &propertyCount, nullptr );
    properties.resize( propertyCount );
    d.vkGetPhysicalDeviceSparseImageFormatProperties( m_physicalDevice, static_cast<VkFormat>( format ), static_cast<VkImageType>( type ), static_cast<VkSampleCountFlagBits>( samples ), static_cast<VkImageUsageFlags>( usage ), static_cast<VkImageTiling>( tiling ), &propertyCount, reinterpret_cast<VkSparseImageFormatProperties*>( properties.data() ) );
    return properties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getDisplayPropertiesKHR( uint32_t* pPropertyCount, DisplayPropertiesKHR* pProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceDisplayPropertiesKHR( m_physicalDevice, pPropertyCount, reinterpret_cast<VkDisplayPropertiesKHR*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<DisplayPropertiesKHR,Allocator>>::type PhysicalDevice::getDisplayPropertiesKHR(Dispatch const &d ) const
  {
    std::vector<DisplayPropertiesKHR,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPhysicalDeviceDisplayPropertiesKHR( m_physicalDevice, &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkGetPhysicalDeviceDisplayPropertiesKHR( m_physicalDevice, &propertyCount, reinterpret_cast<VkDisplayPropertiesKHR*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getDisplayPropertiesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getDisplayPlanePropertiesKHR( uint32_t* pPropertyCount, DisplayPlanePropertiesKHR* pProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceDisplayPlanePropertiesKHR( m_physicalDevice, pPropertyCount, reinterpret_cast<VkDisplayPlanePropertiesKHR*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<DisplayPlanePropertiesKHR,Allocator>>::type PhysicalDevice::getDisplayPlanePropertiesKHR(Dispatch const &d ) const
  {
    std::vector<DisplayPlanePropertiesKHR,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPhysicalDeviceDisplayPlanePropertiesKHR( m_physicalDevice, &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkGetPhysicalDeviceDisplayPlanePropertiesKHR( m_physicalDevice, &propertyCount, reinterpret_cast<VkDisplayPlanePropertiesKHR*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getDisplayPlanePropertiesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getDisplayPlaneSupportedDisplaysKHR( uint32_t planeIndex, uint32_t* pDisplayCount, DisplayKHR* pDisplays, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetDisplayPlaneSupportedDisplaysKHR( m_physicalDevice, planeIndex, pDisplayCount, reinterpret_cast<VkDisplayKHR*>( pDisplays ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<DisplayKHR,Allocator>>::type PhysicalDevice::getDisplayPlaneSupportedDisplaysKHR( uint32_t planeIndex, Dispatch const &d ) const
  {
    std::vector<DisplayKHR,Allocator> displays;
    uint32_t displayCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetDisplayPlaneSupportedDisplaysKHR( m_physicalDevice, planeIndex, &displayCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && displayCount )
      {
        displays.resize( displayCount );
        result = static_cast<Result>( d.vkGetDisplayPlaneSupportedDisplaysKHR( m_physicalDevice, planeIndex, &displayCount, reinterpret_cast<VkDisplayKHR*>( displays.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( displayCount <= displays.size() );
    displays.resize( displayCount );
    return createResultValue( result, displays, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getDisplayPlaneSupportedDisplaysKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getDisplayModePropertiesKHR( DisplayKHR display, uint32_t* pPropertyCount, DisplayModePropertiesKHR* pProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetDisplayModePropertiesKHR( m_physicalDevice, static_cast<VkDisplayKHR>( display ), pPropertyCount, reinterpret_cast<VkDisplayModePropertiesKHR*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<DisplayModePropertiesKHR,Allocator>>::type PhysicalDevice::getDisplayModePropertiesKHR( DisplayKHR display, Dispatch const &d ) const
  {
    std::vector<DisplayModePropertiesKHR,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetDisplayModePropertiesKHR( m_physicalDevice, static_cast<VkDisplayKHR>( display ), &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkGetDisplayModePropertiesKHR( m_physicalDevice, static_cast<VkDisplayKHR>( display ), &propertyCount, reinterpret_cast<VkDisplayModePropertiesKHR*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getDisplayModePropertiesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::createDisplayModeKHR( DisplayKHR display, const DisplayModeCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, DisplayModeKHR* pMode, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateDisplayModeKHR( m_physicalDevice, static_cast<VkDisplayKHR>( display ), reinterpret_cast<const VkDisplayModeCreateInfoKHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkDisplayModeKHR*>( pMode ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DisplayModeKHR>::type PhysicalDevice::createDisplayModeKHR( DisplayKHR display, const DisplayModeCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DisplayModeKHR mode;
    Result result = static_cast<Result>( d.vkCreateDisplayModeKHR( m_physicalDevice, static_cast<VkDisplayKHR>( display ), reinterpret_cast<const VkDisplayModeCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDisplayModeKHR*>( &mode ) ) );
    return createResultValue( result, mode, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::createDisplayModeKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getDisplayPlaneCapabilitiesKHR( DisplayModeKHR mode, uint32_t planeIndex, DisplayPlaneCapabilitiesKHR* pCapabilities, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetDisplayPlaneCapabilitiesKHR( m_physicalDevice, static_cast<VkDisplayModeKHR>( mode ), planeIndex, reinterpret_cast<VkDisplayPlaneCapabilitiesKHR*>( pCapabilities ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DisplayPlaneCapabilitiesKHR>::type PhysicalDevice::getDisplayPlaneCapabilitiesKHR( DisplayModeKHR mode, uint32_t planeIndex, Dispatch const &d ) const
  {
    DisplayPlaneCapabilitiesKHR capabilities;
    Result result = static_cast<Result>( d.vkGetDisplayPlaneCapabilitiesKHR( m_physicalDevice, static_cast<VkDisplayModeKHR>( mode ), planeIndex, reinterpret_cast<VkDisplayPlaneCapabilitiesKHR*>( &capabilities ) ) );
    return createResultValue( result, capabilities, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getDisplayPlaneCapabilitiesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_MIR_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getMirPresentationSupportKHR( uint32_t queueFamilyIndex, MirConnection* connection, Dispatch const &d) const
  {
    return d.vkGetPhysicalDeviceMirPresentationSupportKHR( m_physicalDevice, queueFamilyIndex, connection );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getMirPresentationSupportKHR( uint32_t queueFamilyIndex, MirConnection & connection, Dispatch const &d ) const
  {
    return d.vkGetPhysicalDeviceMirPresentationSupportKHR( m_physicalDevice, queueFamilyIndex, &connection );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_MIR_KHR*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getSurfaceSupportKHR( uint32_t queueFamilyIndex, SurfaceKHR surface, Bool32* pSupported, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceSurfaceSupportKHR( m_physicalDevice, queueFamilyIndex, static_cast<VkSurfaceKHR>( surface ), pSupported ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Bool32>::type PhysicalDevice::getSurfaceSupportKHR( uint32_t queueFamilyIndex, SurfaceKHR surface, Dispatch const &d ) const
  {
    Bool32 supported;
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceSurfaceSupportKHR( m_physicalDevice, queueFamilyIndex, static_cast<VkSurfaceKHR>( surface ), &supported ) );
    return createResultValue( result, supported, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getSurfaceSupportKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getSurfaceCapabilitiesKHR( SurfaceKHR surface, SurfaceCapabilitiesKHR* pSurfaceCapabilities, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceSurfaceCapabilitiesKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<VkSurfaceCapabilitiesKHR*>( pSurfaceCapabilities ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceCapabilitiesKHR>::type PhysicalDevice::getSurfaceCapabilitiesKHR( SurfaceKHR surface, Dispatch const &d ) const
  {
    SurfaceCapabilitiesKHR surfaceCapabilities;
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceSurfaceCapabilitiesKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<VkSurfaceCapabilitiesKHR*>( &surfaceCapabilities ) ) );
    return createResultValue( result, surfaceCapabilities, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getSurfaceCapabilitiesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getSurfaceFormatsKHR( SurfaceKHR surface, uint32_t* pSurfaceFormatCount, SurfaceFormatKHR* pSurfaceFormats, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceSurfaceFormatsKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), pSurfaceFormatCount, reinterpret_cast<VkSurfaceFormatKHR*>( pSurfaceFormats ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<SurfaceFormatKHR,Allocator>>::type PhysicalDevice::getSurfaceFormatsKHR( SurfaceKHR surface, Dispatch const &d ) const
  {
    std::vector<SurfaceFormatKHR,Allocator> surfaceFormats;
    uint32_t surfaceFormatCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPhysicalDeviceSurfaceFormatsKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), &surfaceFormatCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && surfaceFormatCount )
      {
        surfaceFormats.resize( surfaceFormatCount );
        result = static_cast<Result>( d.vkGetPhysicalDeviceSurfaceFormatsKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), &surfaceFormatCount, reinterpret_cast<VkSurfaceFormatKHR*>( surfaceFormats.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( surfaceFormatCount <= surfaceFormats.size() );
    surfaceFormats.resize( surfaceFormatCount );
    return createResultValue( result, surfaceFormats, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getSurfaceFormatsKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getSurfacePresentModesKHR( SurfaceKHR surface, uint32_t* pPresentModeCount, PresentModeKHR* pPresentModes, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceSurfacePresentModesKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), pPresentModeCount, reinterpret_cast<VkPresentModeKHR*>( pPresentModes ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<PresentModeKHR,Allocator>>::type PhysicalDevice::getSurfacePresentModesKHR( SurfaceKHR surface, Dispatch const &d ) const
  {
    std::vector<PresentModeKHR,Allocator> presentModes;
    uint32_t presentModeCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPhysicalDeviceSurfacePresentModesKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), &presentModeCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && presentModeCount )
      {
        presentModes.resize( presentModeCount );
        result = static_cast<Result>( d.vkGetPhysicalDeviceSurfacePresentModesKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), &presentModeCount, reinterpret_cast<VkPresentModeKHR*>( presentModes.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( presentModeCount <= presentModes.size() );
    presentModes.resize( presentModeCount );
    return createResultValue( result, presentModes, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getSurfacePresentModesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getWaylandPresentationSupportKHR( uint32_t queueFamilyIndex, struct wl_display* display, Dispatch const &d) const
  {
    return d.vkGetPhysicalDeviceWaylandPresentationSupportKHR( m_physicalDevice, queueFamilyIndex, display );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getWaylandPresentationSupportKHR( uint32_t queueFamilyIndex, struct wl_display & display, Dispatch const &d ) const
  {
    return d.vkGetPhysicalDeviceWaylandPresentationSupportKHR( m_physicalDevice, queueFamilyIndex, &display );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getWin32PresentationSupportKHR( uint32_t queueFamilyIndex, Dispatch const &d) const
  {
    return d.vkGetPhysicalDeviceWin32PresentationSupportKHR( m_physicalDevice, queueFamilyIndex );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getWin32PresentationSupportKHR( uint32_t queueFamilyIndex, Dispatch const &d ) const
  {
    return d.vkGetPhysicalDeviceWin32PresentationSupportKHR( m_physicalDevice, queueFamilyIndex );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_XLIB_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getXlibPresentationSupportKHR( uint32_t queueFamilyIndex, Display* dpy, VisualID visualID, Dispatch const &d) const
  {
    return d.vkGetPhysicalDeviceXlibPresentationSupportKHR( m_physicalDevice, queueFamilyIndex, dpy, visualID );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getXlibPresentationSupportKHR( uint32_t queueFamilyIndex, Display & dpy, VisualID visualID, Dispatch const &d ) const
  {
    return d.vkGetPhysicalDeviceXlibPresentationSupportKHR( m_physicalDevice, queueFamilyIndex, &dpy, visualID );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#ifdef VK_USE_PLATFORM_XCB_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getXcbPresentationSupportKHR( uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id, Dispatch const &d) const
  {
    return d.vkGetPhysicalDeviceXcbPresentationSupportKHR( m_physicalDevice, queueFamilyIndex, connection, visual_id );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Bool32 PhysicalDevice::getXcbPresentationSupportKHR( uint32_t queueFamilyIndex, xcb_connection_t & connection, xcb_visualid_t visual_id, Dispatch const &d ) const
  {
    return d.vkGetPhysicalDeviceXcbPresentationSupportKHR( m_physicalDevice, queueFamilyIndex, &connection, visual_id );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XCB_KHR*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getExternalImageFormatPropertiesNV( Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, ExternalMemoryHandleTypeFlagsNV externalHandleType, ExternalImageFormatPropertiesNV* pExternalImageFormatProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceExternalImageFormatPropertiesNV( m_physicalDevice, static_cast<VkFormat>( format ), static_cast<VkImageType>( type ), static_cast<VkImageTiling>( tiling ), static_cast<VkImageUsageFlags>( usage ), static_cast<VkImageCreateFlags>( flags ), static_cast<VkExternalMemoryHandleTypeFlagsNV>( externalHandleType ), reinterpret_cast<VkExternalImageFormatPropertiesNV*>( pExternalImageFormatProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<ExternalImageFormatPropertiesNV>::type PhysicalDevice::getExternalImageFormatPropertiesNV( Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, ExternalMemoryHandleTypeFlagsNV externalHandleType, Dispatch const &d ) const
  {
    ExternalImageFormatPropertiesNV externalImageFormatProperties;
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceExternalImageFormatPropertiesNV( m_physicalDevice, static_cast<VkFormat>( format ), static_cast<VkImageType>( type ), static_cast<VkImageTiling>( tiling ), static_cast<VkImageUsageFlags>( usage ), static_cast<VkImageCreateFlags>( flags ), static_cast<VkExternalMemoryHandleTypeFlagsNV>( externalHandleType ), reinterpret_cast<VkExternalImageFormatPropertiesNV*>( &externalImageFormatProperties ) ) );
    return createResultValue( result, externalImageFormatProperties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getExternalImageFormatPropertiesNV" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getGeneratedCommandsPropertiesNVX( DeviceGeneratedCommandsFeaturesNVX* pFeatures, DeviceGeneratedCommandsLimitsNVX* pLimits, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX( m_physicalDevice, reinterpret_cast<VkDeviceGeneratedCommandsFeaturesNVX*>( pFeatures ), reinterpret_cast<VkDeviceGeneratedCommandsLimitsNVX*>( pLimits ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE DeviceGeneratedCommandsLimitsNVX PhysicalDevice::getGeneratedCommandsPropertiesNVX( DeviceGeneratedCommandsFeaturesNVX & features, Dispatch const &d ) const
  {
    DeviceGeneratedCommandsLimitsNVX limits;
    d.vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX( m_physicalDevice, reinterpret_cast<VkDeviceGeneratedCommandsFeaturesNVX*>( &features ), reinterpret_cast<VkDeviceGeneratedCommandsLimitsNVX*>( &limits ) );
    return limits;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getFeatures2( PhysicalDeviceFeatures2* pFeatures, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceFeatures2( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceFeatures2*>( pFeatures ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PhysicalDeviceFeatures2 PhysicalDevice::getFeatures2(Dispatch const &d ) const
  {
    PhysicalDeviceFeatures2 features;
    d.vkGetPhysicalDeviceFeatures2( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceFeatures2*>( &features ) );
    return features;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> PhysicalDevice::getFeatures2(Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    PhysicalDeviceFeatures2& features = structureChain.template get<PhysicalDeviceFeatures2>();
    d.vkGetPhysicalDeviceFeatures2( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceFeatures2*>( &features ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getFeatures2KHR( PhysicalDeviceFeatures2* pFeatures, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceFeatures2KHR( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceFeatures2*>( pFeatures ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PhysicalDeviceFeatures2 PhysicalDevice::getFeatures2KHR(Dispatch const &d ) const
  {
    PhysicalDeviceFeatures2 features;
    d.vkGetPhysicalDeviceFeatures2KHR( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceFeatures2*>( &features ) );
    return features;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> PhysicalDevice::getFeatures2KHR(Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    PhysicalDeviceFeatures2& features = structureChain.template get<PhysicalDeviceFeatures2>();
    d.vkGetPhysicalDeviceFeatures2KHR( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceFeatures2*>( &features ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getProperties2( PhysicalDeviceProperties2* pProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceProperties2( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceProperties2*>( pProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PhysicalDeviceProperties2 PhysicalDevice::getProperties2(Dispatch const &d ) const
  {
    PhysicalDeviceProperties2 properties;
    d.vkGetPhysicalDeviceProperties2( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceProperties2*>( &properties ) );
    return properties;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> PhysicalDevice::getProperties2(Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    PhysicalDeviceProperties2& properties = structureChain.template get<PhysicalDeviceProperties2>();
    d.vkGetPhysicalDeviceProperties2( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceProperties2*>( &properties ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getProperties2KHR( PhysicalDeviceProperties2* pProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceProperties2KHR( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceProperties2*>( pProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PhysicalDeviceProperties2 PhysicalDevice::getProperties2KHR(Dispatch const &d ) const
  {
    PhysicalDeviceProperties2 properties;
    d.vkGetPhysicalDeviceProperties2KHR( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceProperties2*>( &properties ) );
    return properties;
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE StructureChain<X, Y, Z...> PhysicalDevice::getProperties2KHR(Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    PhysicalDeviceProperties2& properties = structureChain.template get<PhysicalDeviceProperties2>();
    d.vkGetPhysicalDeviceProperties2KHR( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceProperties2*>( &properties ) );
    return structureChain;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getFormatProperties2( Format format, FormatProperties2* pFormatProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceFormatProperties2( m_physicalDevice, static_cast<VkFormat>( format ), reinterpret_cast<VkFormatProperties2*>( pFormatProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE FormatProperties2 PhysicalDevice::getFormatProperties2( Format format, Dispatch const &d ) const
  {
    FormatProperties2 formatProperties;
    d.vkGetPhysicalDeviceFormatProperties2( m_physicalDevice, static_cast<VkFormat>( format ), reinterpret_cast<VkFormatProperties2*>( &formatProperties ) );
    return formatProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getFormatProperties2KHR( Format format, FormatProperties2* pFormatProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceFormatProperties2KHR( m_physicalDevice, static_cast<VkFormat>( format ), reinterpret_cast<VkFormatProperties2*>( pFormatProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE FormatProperties2 PhysicalDevice::getFormatProperties2KHR( Format format, Dispatch const &d ) const
  {
    FormatProperties2 formatProperties;
    d.vkGetPhysicalDeviceFormatProperties2KHR( m_physicalDevice, static_cast<VkFormat>( format ), reinterpret_cast<VkFormatProperties2*>( &formatProperties ) );
    return formatProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getImageFormatProperties2( const PhysicalDeviceImageFormatInfo2* pImageFormatInfo, ImageFormatProperties2* pImageFormatProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceImageFormatProperties2( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceImageFormatInfo2*>( pImageFormatInfo ), reinterpret_cast<VkImageFormatProperties2*>( pImageFormatProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<ImageFormatProperties2>::type PhysicalDevice::getImageFormatProperties2( const PhysicalDeviceImageFormatInfo2 & imageFormatInfo, Dispatch const &d ) const
  {
    ImageFormatProperties2 imageFormatProperties;
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceImageFormatProperties2( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceImageFormatInfo2*>( &imageFormatInfo ), reinterpret_cast<VkImageFormatProperties2*>( &imageFormatProperties ) ) );
    return createResultValue( result, imageFormatProperties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getImageFormatProperties2" );
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<StructureChain<X, Y, Z...>>::type PhysicalDevice::getImageFormatProperties2( const PhysicalDeviceImageFormatInfo2 & imageFormatInfo, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    ImageFormatProperties2& imageFormatProperties = structureChain.template get<ImageFormatProperties2>();
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceImageFormatProperties2( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceImageFormatInfo2*>( &imageFormatInfo ), reinterpret_cast<VkImageFormatProperties2*>( &imageFormatProperties ) ) );
    return createResultValue( result, structureChain, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getImageFormatProperties2" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getImageFormatProperties2KHR( const PhysicalDeviceImageFormatInfo2* pImageFormatInfo, ImageFormatProperties2* pImageFormatProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceImageFormatProperties2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceImageFormatInfo2*>( pImageFormatInfo ), reinterpret_cast<VkImageFormatProperties2*>( pImageFormatProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<ImageFormatProperties2>::type PhysicalDevice::getImageFormatProperties2KHR( const PhysicalDeviceImageFormatInfo2 & imageFormatInfo, Dispatch const &d ) const
  {
    ImageFormatProperties2 imageFormatProperties;
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceImageFormatProperties2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceImageFormatInfo2*>( &imageFormatInfo ), reinterpret_cast<VkImageFormatProperties2*>( &imageFormatProperties ) ) );
    return createResultValue( result, imageFormatProperties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getImageFormatProperties2KHR" );
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<StructureChain<X, Y, Z...>>::type PhysicalDevice::getImageFormatProperties2KHR( const PhysicalDeviceImageFormatInfo2 & imageFormatInfo, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    ImageFormatProperties2& imageFormatProperties = structureChain.template get<ImageFormatProperties2>();
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceImageFormatProperties2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceImageFormatInfo2*>( &imageFormatInfo ), reinterpret_cast<VkImageFormatProperties2*>( &imageFormatProperties ) ) );
    return createResultValue( result, structureChain, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getImageFormatProperties2KHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getQueueFamilyProperties2( uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceQueueFamilyProperties2( m_physicalDevice, pQueueFamilyPropertyCount, reinterpret_cast<VkQueueFamilyProperties2*>( pQueueFamilyProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<QueueFamilyProperties2,Allocator> PhysicalDevice::getQueueFamilyProperties2(Dispatch const &d ) const
  {
    std::vector<QueueFamilyProperties2,Allocator> queueFamilyProperties;
    uint32_t queueFamilyPropertyCount;
    d.vkGetPhysicalDeviceQueueFamilyProperties2( m_physicalDevice, &queueFamilyPropertyCount, nullptr );
    queueFamilyProperties.resize( queueFamilyPropertyCount );
    d.vkGetPhysicalDeviceQueueFamilyProperties2( m_physicalDevice, &queueFamilyPropertyCount, reinterpret_cast<VkQueueFamilyProperties2*>( queueFamilyProperties.data() ) );
    return queueFamilyProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getQueueFamilyProperties2KHR( uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceQueueFamilyProperties2KHR( m_physicalDevice, pQueueFamilyPropertyCount, reinterpret_cast<VkQueueFamilyProperties2*>( pQueueFamilyProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<QueueFamilyProperties2,Allocator> PhysicalDevice::getQueueFamilyProperties2KHR(Dispatch const &d ) const
  {
    std::vector<QueueFamilyProperties2,Allocator> queueFamilyProperties;
    uint32_t queueFamilyPropertyCount;
    d.vkGetPhysicalDeviceQueueFamilyProperties2KHR( m_physicalDevice, &queueFamilyPropertyCount, nullptr );
    queueFamilyProperties.resize( queueFamilyPropertyCount );
    d.vkGetPhysicalDeviceQueueFamilyProperties2KHR( m_physicalDevice, &queueFamilyPropertyCount, reinterpret_cast<VkQueueFamilyProperties2*>( queueFamilyProperties.data() ) );
    return queueFamilyProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getMemoryProperties2( PhysicalDeviceMemoryProperties2* pMemoryProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceMemoryProperties2( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceMemoryProperties2*>( pMemoryProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PhysicalDeviceMemoryProperties2 PhysicalDevice::getMemoryProperties2(Dispatch const &d ) const
  {
    PhysicalDeviceMemoryProperties2 memoryProperties;
    d.vkGetPhysicalDeviceMemoryProperties2( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceMemoryProperties2*>( &memoryProperties ) );
    return memoryProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getMemoryProperties2KHR( PhysicalDeviceMemoryProperties2* pMemoryProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceMemoryProperties2KHR( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceMemoryProperties2*>( pMemoryProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PhysicalDeviceMemoryProperties2 PhysicalDevice::getMemoryProperties2KHR(Dispatch const &d ) const
  {
    PhysicalDeviceMemoryProperties2 memoryProperties;
    d.vkGetPhysicalDeviceMemoryProperties2KHR( m_physicalDevice, reinterpret_cast<VkPhysicalDeviceMemoryProperties2*>( &memoryProperties ) );
    return memoryProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getSparseImageFormatProperties2( const PhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, SparseImageFormatProperties2* pProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceSparseImageFormatProperties2( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>( pFormatInfo ), pPropertyCount, reinterpret_cast<VkSparseImageFormatProperties2*>( pProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<SparseImageFormatProperties2,Allocator> PhysicalDevice::getSparseImageFormatProperties2( const PhysicalDeviceSparseImageFormatInfo2 & formatInfo, Dispatch const &d ) const
  {
    std::vector<SparseImageFormatProperties2,Allocator> properties;
    uint32_t propertyCount;
    d.vkGetPhysicalDeviceSparseImageFormatProperties2( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>( &formatInfo ), &propertyCount, nullptr );
    properties.resize( propertyCount );
    d.vkGetPhysicalDeviceSparseImageFormatProperties2( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>( &formatInfo ), &propertyCount, reinterpret_cast<VkSparseImageFormatProperties2*>( properties.data() ) );
    return properties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getSparseImageFormatProperties2KHR( const PhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, SparseImageFormatProperties2* pProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceSparseImageFormatProperties2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>( pFormatInfo ), pPropertyCount, reinterpret_cast<VkSparseImageFormatProperties2*>( pProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE std::vector<SparseImageFormatProperties2,Allocator> PhysicalDevice::getSparseImageFormatProperties2KHR( const PhysicalDeviceSparseImageFormatInfo2 & formatInfo, Dispatch const &d ) const
  {
    std::vector<SparseImageFormatProperties2,Allocator> properties;
    uint32_t propertyCount;
    d.vkGetPhysicalDeviceSparseImageFormatProperties2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>( &formatInfo ), &propertyCount, nullptr );
    properties.resize( propertyCount );
    d.vkGetPhysicalDeviceSparseImageFormatProperties2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>( &formatInfo ), &propertyCount, reinterpret_cast<VkSparseImageFormatProperties2*>( properties.data() ) );
    return properties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getExternalBufferProperties( const PhysicalDeviceExternalBufferInfo* pExternalBufferInfo, ExternalBufferProperties* pExternalBufferProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceExternalBufferProperties( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalBufferInfo*>( pExternalBufferInfo ), reinterpret_cast<VkExternalBufferProperties*>( pExternalBufferProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ExternalBufferProperties PhysicalDevice::getExternalBufferProperties( const PhysicalDeviceExternalBufferInfo & externalBufferInfo, Dispatch const &d ) const
  {
    ExternalBufferProperties externalBufferProperties;
    d.vkGetPhysicalDeviceExternalBufferProperties( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalBufferInfo*>( &externalBufferInfo ), reinterpret_cast<VkExternalBufferProperties*>( &externalBufferProperties ) );
    return externalBufferProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getExternalBufferPropertiesKHR( const PhysicalDeviceExternalBufferInfo* pExternalBufferInfo, ExternalBufferProperties* pExternalBufferProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceExternalBufferPropertiesKHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalBufferInfo*>( pExternalBufferInfo ), reinterpret_cast<VkExternalBufferProperties*>( pExternalBufferProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ExternalBufferProperties PhysicalDevice::getExternalBufferPropertiesKHR( const PhysicalDeviceExternalBufferInfo & externalBufferInfo, Dispatch const &d ) const
  {
    ExternalBufferProperties externalBufferProperties;
    d.vkGetPhysicalDeviceExternalBufferPropertiesKHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalBufferInfo*>( &externalBufferInfo ), reinterpret_cast<VkExternalBufferProperties*>( &externalBufferProperties ) );
    return externalBufferProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getExternalSemaphoreProperties( const PhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, ExternalSemaphoreProperties* pExternalSemaphoreProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceExternalSemaphoreProperties( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalSemaphoreInfo*>( pExternalSemaphoreInfo ), reinterpret_cast<VkExternalSemaphoreProperties*>( pExternalSemaphoreProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ExternalSemaphoreProperties PhysicalDevice::getExternalSemaphoreProperties( const PhysicalDeviceExternalSemaphoreInfo & externalSemaphoreInfo, Dispatch const &d ) const
  {
    ExternalSemaphoreProperties externalSemaphoreProperties;
    d.vkGetPhysicalDeviceExternalSemaphoreProperties( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalSemaphoreInfo*>( &externalSemaphoreInfo ), reinterpret_cast<VkExternalSemaphoreProperties*>( &externalSemaphoreProperties ) );
    return externalSemaphoreProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getExternalSemaphorePropertiesKHR( const PhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, ExternalSemaphoreProperties* pExternalSemaphoreProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceExternalSemaphorePropertiesKHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalSemaphoreInfo*>( pExternalSemaphoreInfo ), reinterpret_cast<VkExternalSemaphoreProperties*>( pExternalSemaphoreProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ExternalSemaphoreProperties PhysicalDevice::getExternalSemaphorePropertiesKHR( const PhysicalDeviceExternalSemaphoreInfo & externalSemaphoreInfo, Dispatch const &d ) const
  {
    ExternalSemaphoreProperties externalSemaphoreProperties;
    d.vkGetPhysicalDeviceExternalSemaphorePropertiesKHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalSemaphoreInfo*>( &externalSemaphoreInfo ), reinterpret_cast<VkExternalSemaphoreProperties*>( &externalSemaphoreProperties ) );
    return externalSemaphoreProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getExternalFenceProperties( const PhysicalDeviceExternalFenceInfo* pExternalFenceInfo, ExternalFenceProperties* pExternalFenceProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceExternalFenceProperties( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalFenceInfo*>( pExternalFenceInfo ), reinterpret_cast<VkExternalFenceProperties*>( pExternalFenceProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ExternalFenceProperties PhysicalDevice::getExternalFenceProperties( const PhysicalDeviceExternalFenceInfo & externalFenceInfo, Dispatch const &d ) const
  {
    ExternalFenceProperties externalFenceProperties;
    d.vkGetPhysicalDeviceExternalFenceProperties( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalFenceInfo*>( &externalFenceInfo ), reinterpret_cast<VkExternalFenceProperties*>( &externalFenceProperties ) );
    return externalFenceProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getExternalFencePropertiesKHR( const PhysicalDeviceExternalFenceInfo* pExternalFenceInfo, ExternalFenceProperties* pExternalFenceProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceExternalFencePropertiesKHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalFenceInfo*>( pExternalFenceInfo ), reinterpret_cast<VkExternalFenceProperties*>( pExternalFenceProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ExternalFenceProperties PhysicalDevice::getExternalFencePropertiesKHR( const PhysicalDeviceExternalFenceInfo & externalFenceInfo, Dispatch const &d ) const
  {
    ExternalFenceProperties externalFenceProperties;
    d.vkGetPhysicalDeviceExternalFencePropertiesKHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceExternalFenceInfo*>( &externalFenceInfo ), reinterpret_cast<VkExternalFenceProperties*>( &externalFenceProperties ) );
    return externalFenceProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::releaseDisplayEXT( DisplayKHR display, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkReleaseDisplayEXT( m_physicalDevice, static_cast<VkDisplayKHR>( display ) ) );
  }
#else
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<void>::type PhysicalDevice::releaseDisplayEXT( DisplayKHR display, Dispatch const &d ) const
  {
    Result result = static_cast<Result>( d.vkReleaseDisplayEXT( m_physicalDevice, static_cast<VkDisplayKHR>( display ) ) );
    return createResultValue( result, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::releaseDisplayEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::acquireXlibDisplayEXT( Display* dpy, DisplayKHR display, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkAcquireXlibDisplayEXT( m_physicalDevice, dpy, static_cast<VkDisplayKHR>( display ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Display>::type PhysicalDevice::acquireXlibDisplayEXT( DisplayKHR display, Dispatch const &d ) const
  {
    Display dpy;
    Result result = static_cast<Result>( d.vkAcquireXlibDisplayEXT( m_physicalDevice, &dpy, static_cast<VkDisplayKHR>( display ) ) );
    return createResultValue( result, dpy, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::acquireXlibDisplayEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getRandROutputDisplayEXT( Display* dpy, RROutput rrOutput, DisplayKHR* pDisplay, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetRandROutputDisplayEXT( m_physicalDevice, dpy, rrOutput, reinterpret_cast<VkDisplayKHR*>( pDisplay ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DisplayKHR>::type PhysicalDevice::getRandROutputDisplayEXT( Display & dpy, RROutput rrOutput, Dispatch const &d ) const
  {
    DisplayKHR display;
    Result result = static_cast<Result>( d.vkGetRandROutputDisplayEXT( m_physicalDevice, &dpy, rrOutput, reinterpret_cast<VkDisplayKHR*>( &display ) ) );
    return createResultValue( result, display, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getRandROutputDisplayEXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getSurfaceCapabilities2EXT( SurfaceKHR surface, SurfaceCapabilities2EXT* pSurfaceCapabilities, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceSurfaceCapabilities2EXT( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<VkSurfaceCapabilities2EXT*>( pSurfaceCapabilities ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceCapabilities2EXT>::type PhysicalDevice::getSurfaceCapabilities2EXT( SurfaceKHR surface, Dispatch const &d ) const
  {
    SurfaceCapabilities2EXT surfaceCapabilities;
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceSurfaceCapabilities2EXT( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<VkSurfaceCapabilities2EXT*>( &surfaceCapabilities ) ) );
    return createResultValue( result, surfaceCapabilities, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getSurfaceCapabilities2EXT" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getPresentRectanglesKHR( SurfaceKHR surface, uint32_t* pRectCount, Rect2D* pRects, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDevicePresentRectanglesKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), pRectCount, reinterpret_cast<VkRect2D*>( pRects ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<Rect2D,Allocator>>::type PhysicalDevice::getPresentRectanglesKHR( SurfaceKHR surface, Dispatch const &d ) const
  {
    std::vector<Rect2D,Allocator> rects;
    uint32_t rectCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPhysicalDevicePresentRectanglesKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), &rectCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && rectCount )
      {
        rects.resize( rectCount );
        result = static_cast<Result>( d.vkGetPhysicalDevicePresentRectanglesKHR( m_physicalDevice, static_cast<VkSurfaceKHR>( surface ), &rectCount, reinterpret_cast<VkRect2D*>( rects.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( rectCount <= rects.size() );
    rects.resize( rectCount );
    return createResultValue( result, rects, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getPresentRectanglesKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void PhysicalDevice::getMultisamplePropertiesEXT( SampleCountFlagBits samples, MultisamplePropertiesEXT* pMultisampleProperties, Dispatch const &d) const
  {
    d.vkGetPhysicalDeviceMultisamplePropertiesEXT( m_physicalDevice, static_cast<VkSampleCountFlagBits>( samples ), reinterpret_cast<VkMultisamplePropertiesEXT*>( pMultisampleProperties ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE MultisamplePropertiesEXT PhysicalDevice::getMultisamplePropertiesEXT( SampleCountFlagBits samples, Dispatch const &d ) const
  {
    MultisamplePropertiesEXT multisampleProperties;
    d.vkGetPhysicalDeviceMultisamplePropertiesEXT( m_physicalDevice, static_cast<VkSampleCountFlagBits>( samples ), reinterpret_cast<VkMultisamplePropertiesEXT*>( &multisampleProperties ) );
    return multisampleProperties;
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getSurfaceCapabilities2KHR( const PhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, SurfaceCapabilities2KHR* pSurfaceCapabilities, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceSurfaceCapabilities2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>( pSurfaceInfo ), reinterpret_cast<VkSurfaceCapabilities2KHR*>( pSurfaceCapabilities ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceCapabilities2KHR>::type PhysicalDevice::getSurfaceCapabilities2KHR( const PhysicalDeviceSurfaceInfo2KHR & surfaceInfo, Dispatch const &d ) const
  {
    SurfaceCapabilities2KHR surfaceCapabilities;
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceSurfaceCapabilities2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>( &surfaceInfo ), reinterpret_cast<VkSurfaceCapabilities2KHR*>( &surfaceCapabilities ) ) );
    return createResultValue( result, surfaceCapabilities, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getSurfaceCapabilities2KHR" );
  }
  template <typename X, typename Y, typename ...Z, typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<StructureChain<X, Y, Z...>>::type PhysicalDevice::getSurfaceCapabilities2KHR( const PhysicalDeviceSurfaceInfo2KHR & surfaceInfo, Dispatch const &d ) const
  {
    StructureChain<X, Y, Z...> structureChain;
    SurfaceCapabilities2KHR& surfaceCapabilities = structureChain.template get<SurfaceCapabilities2KHR>();
    Result result = static_cast<Result>( d.vkGetPhysicalDeviceSurfaceCapabilities2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>( &surfaceInfo ), reinterpret_cast<VkSurfaceCapabilities2KHR*>( &surfaceCapabilities ) ) );
    return createResultValue( result, structureChain, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getSurfaceCapabilities2KHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getSurfaceFormats2KHR( const PhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, SurfaceFormat2KHR* pSurfaceFormats, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceSurfaceFormats2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>( pSurfaceInfo ), pSurfaceFormatCount, reinterpret_cast<VkSurfaceFormat2KHR*>( pSurfaceFormats ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<SurfaceFormat2KHR,Allocator>>::type PhysicalDevice::getSurfaceFormats2KHR( const PhysicalDeviceSurfaceInfo2KHR & surfaceInfo, Dispatch const &d ) const
  {
    std::vector<SurfaceFormat2KHR,Allocator> surfaceFormats;
    uint32_t surfaceFormatCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPhysicalDeviceSurfaceFormats2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>( &surfaceInfo ), &surfaceFormatCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && surfaceFormatCount )
      {
        surfaceFormats.resize( surfaceFormatCount );
        result = static_cast<Result>( d.vkGetPhysicalDeviceSurfaceFormats2KHR( m_physicalDevice, reinterpret_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>( &surfaceInfo ), &surfaceFormatCount, reinterpret_cast<VkSurfaceFormat2KHR*>( surfaceFormats.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( surfaceFormatCount <= surfaceFormats.size() );
    surfaceFormats.resize( surfaceFormatCount );
    return createResultValue( result, surfaceFormats, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getSurfaceFormats2KHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getDisplayProperties2KHR( uint32_t* pPropertyCount, DisplayProperties2KHR* pProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceDisplayProperties2KHR( m_physicalDevice, pPropertyCount, reinterpret_cast<VkDisplayProperties2KHR*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<DisplayProperties2KHR,Allocator>>::type PhysicalDevice::getDisplayProperties2KHR(Dispatch const &d ) const
  {
    std::vector<DisplayProperties2KHR,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPhysicalDeviceDisplayProperties2KHR( m_physicalDevice, &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkGetPhysicalDeviceDisplayProperties2KHR( m_physicalDevice, &propertyCount, reinterpret_cast<VkDisplayProperties2KHR*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getDisplayProperties2KHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getDisplayPlaneProperties2KHR( uint32_t* pPropertyCount, DisplayPlaneProperties2KHR* pProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetPhysicalDeviceDisplayPlaneProperties2KHR( m_physicalDevice, pPropertyCount, reinterpret_cast<VkDisplayPlaneProperties2KHR*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<DisplayPlaneProperties2KHR,Allocator>>::type PhysicalDevice::getDisplayPlaneProperties2KHR(Dispatch const &d ) const
  {
    std::vector<DisplayPlaneProperties2KHR,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetPhysicalDeviceDisplayPlaneProperties2KHR( m_physicalDevice, &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkGetPhysicalDeviceDisplayPlaneProperties2KHR( m_physicalDevice, &propertyCount, reinterpret_cast<VkDisplayPlaneProperties2KHR*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getDisplayPlaneProperties2KHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getDisplayModeProperties2KHR( DisplayKHR display, uint32_t* pPropertyCount, DisplayModeProperties2KHR* pProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetDisplayModeProperties2KHR( m_physicalDevice, static_cast<VkDisplayKHR>( display ), pPropertyCount, reinterpret_cast<VkDisplayModeProperties2KHR*>( pProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<DisplayModeProperties2KHR,Allocator>>::type PhysicalDevice::getDisplayModeProperties2KHR( DisplayKHR display, Dispatch const &d ) const
  {
    std::vector<DisplayModeProperties2KHR,Allocator> properties;
    uint32_t propertyCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkGetDisplayModeProperties2KHR( m_physicalDevice, static_cast<VkDisplayKHR>( display ), &propertyCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && propertyCount )
      {
        properties.resize( propertyCount );
        result = static_cast<Result>( d.vkGetDisplayModeProperties2KHR( m_physicalDevice, static_cast<VkDisplayKHR>( display ), &propertyCount, reinterpret_cast<VkDisplayModeProperties2KHR*>( properties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( propertyCount <= properties.size() );
    properties.resize( propertyCount );
    return createResultValue( result, properties, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getDisplayModeProperties2KHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result PhysicalDevice::getDisplayPlaneCapabilities2KHR( const DisplayPlaneInfo2KHR* pDisplayPlaneInfo, DisplayPlaneCapabilities2KHR* pCapabilities, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkGetDisplayPlaneCapabilities2KHR( m_physicalDevice, reinterpret_cast<const VkDisplayPlaneInfo2KHR*>( pDisplayPlaneInfo ), reinterpret_cast<VkDisplayPlaneCapabilities2KHR*>( pCapabilities ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DisplayPlaneCapabilities2KHR>::type PhysicalDevice::getDisplayPlaneCapabilities2KHR( const DisplayPlaneInfo2KHR & displayPlaneInfo, Dispatch const &d ) const
  {
    DisplayPlaneCapabilities2KHR capabilities;
    Result result = static_cast<Result>( d.vkGetDisplayPlaneCapabilities2KHR( m_physicalDevice, reinterpret_cast<const VkDisplayPlaneInfo2KHR*>( &displayPlaneInfo ), reinterpret_cast<VkDisplayPlaneCapabilities2KHR*>( &capabilities ) ) );
    return createResultValue( result, capabilities, VULKAN_HPP_NAMESPACE_STRING"::PhysicalDevice::getDisplayPlaneCapabilities2KHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  struct CmdProcessCommandsInfoNVX
  {
    operator VkCmdProcessCommandsInfoNVX const&() const
    {
      return *reinterpret_cast<const VkCmdProcessCommandsInfoNVX*>(this);
    }

    operator VkCmdProcessCommandsInfoNVX &()
    {
      return *reinterpret_cast<VkCmdProcessCommandsInfoNVX*>(this);
    }

    bool operator==( CmdProcessCommandsInfoNVX const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( objectTable == rhs.objectTable )
          && ( indirectCommandsLayout == rhs.indirectCommandsLayout )
          && ( indirectCommandsTokenCount == rhs.indirectCommandsTokenCount )
          && ( pIndirectCommandsTokens == rhs.pIndirectCommandsTokens )
          && ( maxSequencesCount == rhs.maxSequencesCount )
          && ( targetCommandBuffer == rhs.targetCommandBuffer )
          && ( sequencesCountBuffer == rhs.sequencesCountBuffer )
          && ( sequencesCountOffset == rhs.sequencesCountOffset )
          && ( sequencesIndexBuffer == rhs.sequencesIndexBuffer )
          && ( sequencesIndexOffset == rhs.sequencesIndexOffset );
    }

    bool operator!=( CmdProcessCommandsInfoNVX const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eCmdProcessCommandsInfoNVX;
    const void* pNext = nullptr;
    ObjectTableNVX objectTable = ObjectTableNVX();
    IndirectCommandsLayoutNVX indirectCommandsLayout = IndirectCommandsLayoutNVX();
    uint32_t indirectCommandsTokenCount = 0;
    const IndirectCommandsTokenNVX* pIndirectCommandsTokens = nullptr;
    uint32_t maxSequencesCount = 0;
    CommandBuffer targetCommandBuffer = CommandBuffer();
    Buffer sequencesCountBuffer = Buffer();
    DeviceSize sequencesCountOffset = 0;
    Buffer sequencesIndexBuffer = Buffer();
    DeviceSize sequencesIndexOffset = 0;
  };
  static_assert( sizeof( CmdProcessCommandsInfoNVX ) == sizeof( VkCmdProcessCommandsInfoNVX ), "struct and wrapper have different size!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, pNext ) == offsetof( VkCmdProcessCommandsInfoNVX, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, objectTable ) == offsetof( VkCmdProcessCommandsInfoNVX, objectTable ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, indirectCommandsLayout ) == offsetof( VkCmdProcessCommandsInfoNVX, indirectCommandsLayout ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, indirectCommandsTokenCount ) == offsetof( VkCmdProcessCommandsInfoNVX, indirectCommandsTokenCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, pIndirectCommandsTokens ) == offsetof( VkCmdProcessCommandsInfoNVX, pIndirectCommandsTokens ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, maxSequencesCount ) == offsetof( VkCmdProcessCommandsInfoNVX, maxSequencesCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, targetCommandBuffer ) == offsetof( VkCmdProcessCommandsInfoNVX, targetCommandBuffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, sequencesCountBuffer ) == offsetof( VkCmdProcessCommandsInfoNVX, sequencesCountBuffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, sequencesCountOffset ) == offsetof( VkCmdProcessCommandsInfoNVX, sequencesCountOffset ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, sequencesIndexBuffer ) == offsetof( VkCmdProcessCommandsInfoNVX, sequencesIndexBuffer ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( CmdProcessCommandsInfoNVX, sequencesIndexOffset ) == offsetof( VkCmdProcessCommandsInfoNVX, sequencesIndexOffset ), "struct member and wrapper member have different offset!" );

  struct PhysicalDeviceGroupProperties
  {
    operator VkPhysicalDeviceGroupProperties const&() const
    {
      return *reinterpret_cast<const VkPhysicalDeviceGroupProperties*>(this);
    }

    operator VkPhysicalDeviceGroupProperties &()
    {
      return *reinterpret_cast<VkPhysicalDeviceGroupProperties*>(this);
    }

    bool operator==( PhysicalDeviceGroupProperties const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( physicalDeviceCount == rhs.physicalDeviceCount )
          && ( physicalDevices == rhs.physicalDevices )
          && ( subsetAllocation == rhs.subsetAllocation );
    }

    bool operator!=( PhysicalDeviceGroupProperties const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::ePhysicalDeviceGroupProperties;
    void* pNext = nullptr;
    uint32_t physicalDeviceCount = 0;
    std::array<PhysicalDevice, VK_MAX_DEVICE_GROUP_SIZE> physicalDevices = { { PhysicalDevice() } };
    Bool32 subsetAllocation = 0;
  };
  static_assert( sizeof( PhysicalDeviceGroupProperties ) == sizeof( VkPhysicalDeviceGroupProperties ), "struct and wrapper have different size!" );
  static_assert( offsetof( PhysicalDeviceGroupProperties, pNext ) == offsetof( VkPhysicalDeviceGroupProperties, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceGroupProperties, physicalDeviceCount ) == offsetof( VkPhysicalDeviceGroupProperties, physicalDeviceCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceGroupProperties, physicalDevices ) == offsetof( VkPhysicalDeviceGroupProperties, physicalDevices ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( PhysicalDeviceGroupProperties, subsetAllocation ) == offsetof( VkPhysicalDeviceGroupProperties, subsetAllocation ), "struct member and wrapper member have different offset!" );

  using PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;

#ifndef VULKAN_HPP_NO_SMART_HANDLE
  class Instance;

  template <typename Dispatch> class UniqueHandleTraits<DebugReportCallbackEXT,Dispatch> {public: using deleter = ObjectDestroy<Instance,Dispatch>; };
  using UniqueDebugReportCallbackEXT = UniqueHandle<DebugReportCallbackEXT,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<DebugUtilsMessengerEXT,Dispatch> {public: using deleter = ObjectDestroy<Instance,Dispatch>; };
  using UniqueDebugUtilsMessengerEXT = UniqueHandle<DebugUtilsMessengerEXT,DispatchLoaderStatic>;
  template <typename Dispatch> class UniqueHandleTraits<SurfaceKHR,Dispatch> {public: using deleter = ObjectDestroy<Instance,Dispatch>; };
  using UniqueSurfaceKHR = UniqueHandle<SurfaceKHR,DispatchLoaderStatic>;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/

  class Instance
  {
  public:
    VULKAN_HPP_CONSTEXPR Instance()
      : m_instance(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_CONSTEXPR Instance( std::nullptr_t )
      : m_instance(VK_NULL_HANDLE)
    {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Instance( VkInstance instance )
      : m_instance( instance )
    {}

#if defined(VULKAN_HPP_TYPESAFE_CONVERSION)
    Instance & operator=(VkInstance instance)
    {
      m_instance = instance;
      return *this; 
    }
#endif

    Instance & operator=( std::nullptr_t )
    {
      m_instance = VK_NULL_HANDLE;
      return *this;
    }

    bool operator==( Instance const & rhs ) const
    {
      return m_instance == rhs.m_instance;
    }

    bool operator!=(Instance const & rhs ) const
    {
      return m_instance != rhs.m_instance;
    }

    bool operator<(Instance const & rhs ) const
    {
      return m_instance < rhs.m_instance;
    }

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result enumeratePhysicalDevices( uint32_t* pPhysicalDeviceCount, PhysicalDevice* pPhysicalDevices, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<PhysicalDevice>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<PhysicalDevice,Allocator>>::type enumeratePhysicalDevices(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    PFN_vkVoidFunction getProcAddr( const char* pName, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    PFN_vkVoidFunction getProcAddr( const std::string & name, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result createAndroidSurfaceKHR( const AndroidSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createAndroidSurfaceKHR( const AndroidSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createAndroidSurfaceKHRUnique( const AndroidSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createDisplayPlaneSurfaceKHR( const DisplaySurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createDisplayPlaneSurfaceKHR( const DisplaySurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createDisplayPlaneSurfaceKHRUnique( const DisplaySurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_MIR_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result createMirSurfaceKHR( const MirSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createMirSurfaceKHR( const MirSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createMirSurfaceKHRUnique( const MirSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_MIR_KHR*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroySurfaceKHR( SurfaceKHR surface, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroySurfaceKHR( SurfaceKHR surface, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( SurfaceKHR surface, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( SurfaceKHR surface, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_VI_NN
    template<typename Dispatch = DispatchLoaderStatic>
    Result createViSurfaceNN( const ViSurfaceCreateInfoNN* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createViSurfaceNN( const ViSurfaceCreateInfoNN & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createViSurfaceNNUnique( const ViSurfaceCreateInfoNN & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_VI_NN*/

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result createWaylandSurfaceKHR( const WaylandSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createWaylandSurfaceKHR( const WaylandSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createWaylandSurfaceKHRUnique( const WaylandSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result createWin32SurfaceKHR( const Win32SurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createWin32SurfaceKHR( const Win32SurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createWin32SurfaceKHRUnique( const Win32SurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_XLIB_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result createXlibSurfaceKHR( const XlibSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createXlibSurfaceKHR( const XlibSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createXlibSurfaceKHRUnique( const XlibSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#ifdef VK_USE_PLATFORM_XCB_KHR
    template<typename Dispatch = DispatchLoaderStatic>
    Result createXcbSurfaceKHR( const XcbSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createXcbSurfaceKHR( const XcbSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createXcbSurfaceKHRUnique( const XcbSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XCB_KHR*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createDebugReportCallbackEXT( const DebugReportCallbackCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, DebugReportCallbackEXT* pCallback, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DebugReportCallbackEXT>::type createDebugReportCallbackEXT( const DebugReportCallbackCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<DebugReportCallbackEXT,Dispatch>>::type createDebugReportCallbackEXTUnique( const DebugReportCallbackCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDebugReportCallbackEXT( DebugReportCallbackEXT callback, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDebugReportCallbackEXT( DebugReportCallbackEXT callback, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DebugReportCallbackEXT callback, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DebugReportCallbackEXT callback, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void debugReportMessageEXT( DebugReportFlagsEXT flags, DebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void debugReportMessageEXT( DebugReportFlagsEXT flags, DebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const std::string & layerPrefix, const std::string & message, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result enumeratePhysicalDeviceGroups( uint32_t* pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<PhysicalDeviceGroupProperties>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<PhysicalDeviceGroupProperties,Allocator>>::type enumeratePhysicalDeviceGroups(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result enumeratePhysicalDeviceGroupsKHR( uint32_t* pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template <typename Allocator = std::allocator<PhysicalDeviceGroupProperties>, typename Dispatch = DispatchLoaderStatic> 
    typename ResultValueType<std::vector<PhysicalDeviceGroupProperties,Allocator>>::type enumeratePhysicalDeviceGroupsKHR(Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_IOS_MVK
    template<typename Dispatch = DispatchLoaderStatic>
    Result createIOSSurfaceMVK( const IOSSurfaceCreateInfoMVK* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createIOSSurfaceMVK( const IOSSurfaceCreateInfoMVK & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createIOSSurfaceMVKUnique( const IOSSurfaceCreateInfoMVK & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_IOS_MVK*/

#ifdef VK_USE_PLATFORM_MACOS_MVK
    template<typename Dispatch = DispatchLoaderStatic>
    Result createMacOSSurfaceMVK( const MacOSSurfaceCreateInfoMVK* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<SurfaceKHR>::type createMacOSSurfaceMVK( const MacOSSurfaceCreateInfoMVK & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type createMacOSSurfaceMVKUnique( const MacOSSurfaceCreateInfoMVK & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_MACOS_MVK*/

    template<typename Dispatch = DispatchLoaderStatic>
    Result createDebugUtilsMessengerEXT( const DebugUtilsMessengerCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, DebugUtilsMessengerEXT* pMessenger, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    ResultValueType<DebugUtilsMessengerEXT>::type createDebugUtilsMessengerEXT( const DebugUtilsMessengerCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_NO_SMART_HANDLE
    template<typename Dispatch = DispatchLoaderStatic>
    typename ResultValueType<UniqueHandle<DebugUtilsMessengerEXT,Dispatch>>::type createDebugUtilsMessengerEXTUnique( const DebugUtilsMessengerCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDebugUtilsMessengerEXT( DebugUtilsMessengerEXT messenger, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroyDebugUtilsMessengerEXT( DebugUtilsMessengerEXT messenger, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DebugUtilsMessengerEXT messenger, const AllocationCallbacks* pAllocator, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void destroy( DebugUtilsMessengerEXT messenger, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    template<typename Dispatch = DispatchLoaderStatic>
    void submitDebugUtilsMessageEXT( DebugUtilsMessageSeverityFlagBitsEXT messageSeverity, DebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT* pCallbackData, Dispatch const &d = Dispatch() ) const;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    template<typename Dispatch = DispatchLoaderStatic>
    void submitDebugUtilsMessageEXT( DebugUtilsMessageSeverityFlagBitsEXT messageSeverity, DebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT & callbackData, Dispatch const &d = Dispatch() ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/



    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkInstance() const
    {
      return m_instance;
    }

    explicit operator bool() const
    {
      return m_instance != VK_NULL_HANDLE;
    }

    bool operator!() const
    {
      return m_instance == VK_NULL_HANDLE;
    }

  private:
    VkInstance m_instance;
  };

  static_assert( sizeof( Instance ) == sizeof( VkInstance ), "handle and wrapper have different size!" );

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroy( const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyInstance( m_instance, reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroy( Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyInstance( m_instance, reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::enumeratePhysicalDevices( uint32_t* pPhysicalDeviceCount, PhysicalDevice* pPhysicalDevices, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkEnumeratePhysicalDevices( m_instance, pPhysicalDeviceCount, reinterpret_cast<VkPhysicalDevice*>( pPhysicalDevices ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<PhysicalDevice,Allocator>>::type Instance::enumeratePhysicalDevices(Dispatch const &d ) const
  {
    std::vector<PhysicalDevice,Allocator> physicalDevices;
    uint32_t physicalDeviceCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkEnumeratePhysicalDevices( m_instance, &physicalDeviceCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && physicalDeviceCount )
      {
        physicalDevices.resize( physicalDeviceCount );
        result = static_cast<Result>( d.vkEnumeratePhysicalDevices( m_instance, &physicalDeviceCount, reinterpret_cast<VkPhysicalDevice*>( physicalDevices.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( physicalDeviceCount <= physicalDevices.size() );
    physicalDevices.resize( physicalDeviceCount );
    return createResultValue( result, physicalDevices, VULKAN_HPP_NAMESPACE_STRING"::Instance::enumeratePhysicalDevices" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE PFN_vkVoidFunction Instance::getProcAddr( const char* pName, Dispatch const &d) const
  {
    return d.vkGetInstanceProcAddr( m_instance, pName );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE PFN_vkVoidFunction Instance::getProcAddr( const std::string & name, Dispatch const &d ) const
  {
    return d.vkGetInstanceProcAddr( m_instance, name.c_str() );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createAndroidSurfaceKHR( const AndroidSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateAndroidSurfaceKHR( m_instance, reinterpret_cast<const VkAndroidSurfaceCreateInfoKHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createAndroidSurfaceKHR( const AndroidSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateAndroidSurfaceKHR( m_instance, reinterpret_cast<const VkAndroidSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createAndroidSurfaceKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createAndroidSurfaceKHRUnique( const AndroidSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateAndroidSurfaceKHR( m_instance, reinterpret_cast<const VkAndroidSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createAndroidSurfaceKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createDisplayPlaneSurfaceKHR( const DisplaySurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateDisplayPlaneSurfaceKHR( m_instance, reinterpret_cast<const VkDisplaySurfaceCreateInfoKHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createDisplayPlaneSurfaceKHR( const DisplaySurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateDisplayPlaneSurfaceKHR( m_instance, reinterpret_cast<const VkDisplaySurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createDisplayPlaneSurfaceKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createDisplayPlaneSurfaceKHRUnique( const DisplaySurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateDisplayPlaneSurfaceKHR( m_instance, reinterpret_cast<const VkDisplaySurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createDisplayPlaneSurfaceKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_MIR_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createMirSurfaceKHR( const MirSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateMirSurfaceKHR( m_instance, reinterpret_cast<const VkMirSurfaceCreateInfoKHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createMirSurfaceKHR( const MirSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateMirSurfaceKHR( m_instance, reinterpret_cast<const VkMirSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createMirSurfaceKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createMirSurfaceKHRUnique( const MirSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateMirSurfaceKHR( m_instance, reinterpret_cast<const VkMirSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createMirSurfaceKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_MIR_KHR*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroySurfaceKHR( SurfaceKHR surface, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySurfaceKHR( m_instance, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroySurfaceKHR( SurfaceKHR surface, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySurfaceKHR( m_instance, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroy( SurfaceKHR surface, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroySurfaceKHR( m_instance, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroy( SurfaceKHR surface, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroySurfaceKHR( m_instance, static_cast<VkSurfaceKHR>( surface ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_VI_NN
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createViSurfaceNN( const ViSurfaceCreateInfoNN* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateViSurfaceNN( m_instance, reinterpret_cast<const VkViSurfaceCreateInfoNN*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createViSurfaceNN( const ViSurfaceCreateInfoNN & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateViSurfaceNN( m_instance, reinterpret_cast<const VkViSurfaceCreateInfoNN*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createViSurfaceNN" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createViSurfaceNNUnique( const ViSurfaceCreateInfoNN & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateViSurfaceNN( m_instance, reinterpret_cast<const VkViSurfaceCreateInfoNN*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createViSurfaceNNUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_VI_NN*/

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createWaylandSurfaceKHR( const WaylandSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateWaylandSurfaceKHR( m_instance, reinterpret_cast<const VkWaylandSurfaceCreateInfoKHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createWaylandSurfaceKHR( const WaylandSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateWaylandSurfaceKHR( m_instance, reinterpret_cast<const VkWaylandSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createWaylandSurfaceKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createWaylandSurfaceKHRUnique( const WaylandSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateWaylandSurfaceKHR( m_instance, reinterpret_cast<const VkWaylandSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createWaylandSurfaceKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createWin32SurfaceKHR( const Win32SurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateWin32SurfaceKHR( m_instance, reinterpret_cast<const VkWin32SurfaceCreateInfoKHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createWin32SurfaceKHR( const Win32SurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateWin32SurfaceKHR( m_instance, reinterpret_cast<const VkWin32SurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createWin32SurfaceKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createWin32SurfaceKHRUnique( const Win32SurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateWin32SurfaceKHR( m_instance, reinterpret_cast<const VkWin32SurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createWin32SurfaceKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_XLIB_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createXlibSurfaceKHR( const XlibSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateXlibSurfaceKHR( m_instance, reinterpret_cast<const VkXlibSurfaceCreateInfoKHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createXlibSurfaceKHR( const XlibSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateXlibSurfaceKHR( m_instance, reinterpret_cast<const VkXlibSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createXlibSurfaceKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createXlibSurfaceKHRUnique( const XlibSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateXlibSurfaceKHR( m_instance, reinterpret_cast<const VkXlibSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createXlibSurfaceKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#ifdef VK_USE_PLATFORM_XCB_KHR
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createXcbSurfaceKHR( const XcbSurfaceCreateInfoKHR* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateXcbSurfaceKHR( m_instance, reinterpret_cast<const VkXcbSurfaceCreateInfoKHR*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createXcbSurfaceKHR( const XcbSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateXcbSurfaceKHR( m_instance, reinterpret_cast<const VkXcbSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createXcbSurfaceKHR" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createXcbSurfaceKHRUnique( const XcbSurfaceCreateInfoKHR & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateXcbSurfaceKHR( m_instance, reinterpret_cast<const VkXcbSurfaceCreateInfoKHR*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createXcbSurfaceKHRUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_XCB_KHR*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createDebugReportCallbackEXT( const DebugReportCallbackCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, DebugReportCallbackEXT* pCallback, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateDebugReportCallbackEXT( m_instance, reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkDebugReportCallbackEXT*>( pCallback ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DebugReportCallbackEXT>::type Instance::createDebugReportCallbackEXT( const DebugReportCallbackCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DebugReportCallbackEXT callback;
    Result result = static_cast<Result>( d.vkCreateDebugReportCallbackEXT( m_instance, reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDebugReportCallbackEXT*>( &callback ) ) );
    return createResultValue( result, callback, VULKAN_HPP_NAMESPACE_STRING"::Instance::createDebugReportCallbackEXT" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<DebugReportCallbackEXT,Dispatch>>::type Instance::createDebugReportCallbackEXTUnique( const DebugReportCallbackCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DebugReportCallbackEXT callback;
    Result result = static_cast<Result>( d.vkCreateDebugReportCallbackEXT( m_instance, reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDebugReportCallbackEXT*>( &callback ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<DebugReportCallbackEXT,Dispatch>( result, callback, VULKAN_HPP_NAMESPACE_STRING"::Instance::createDebugReportCallbackEXTUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroyDebugReportCallbackEXT( DebugReportCallbackEXT callback, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDebugReportCallbackEXT( m_instance, static_cast<VkDebugReportCallbackEXT>( callback ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroyDebugReportCallbackEXT( DebugReportCallbackEXT callback, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDebugReportCallbackEXT( m_instance, static_cast<VkDebugReportCallbackEXT>( callback ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroy( DebugReportCallbackEXT callback, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDebugReportCallbackEXT( m_instance, static_cast<VkDebugReportCallbackEXT>( callback ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroy( DebugReportCallbackEXT callback, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDebugReportCallbackEXT( m_instance, static_cast<VkDebugReportCallbackEXT>( callback ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::debugReportMessageEXT( DebugReportFlagsEXT flags, DebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage, Dispatch const &d) const
  {
    d.vkDebugReportMessageEXT( m_instance, static_cast<VkDebugReportFlagsEXT>( flags ), static_cast<VkDebugReportObjectTypeEXT>( objectType ), object, location, messageCode, pLayerPrefix, pMessage );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::debugReportMessageEXT( DebugReportFlagsEXT flags, DebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const std::string & layerPrefix, const std::string & message, Dispatch const &d ) const
  {
#ifdef VULKAN_HPP_NO_EXCEPTIONS
    VULKAN_HPP_ASSERT( layerPrefix.size() == message.size() );
#else
    if ( layerPrefix.size() != message.size() )
    {
      throw LogicError( VULKAN_HPP_NAMESPACE_STRING "::Instance::debugReportMessageEXT: layerPrefix.size() != message.size()" );
    }
#endif  // VULKAN_HPP_NO_EXCEPTIONS
    d.vkDebugReportMessageEXT( m_instance, static_cast<VkDebugReportFlagsEXT>( flags ), static_cast<VkDebugReportObjectTypeEXT>( objectType ), object, location, messageCode, layerPrefix.c_str(), message.c_str() );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::enumeratePhysicalDeviceGroups( uint32_t* pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkEnumeratePhysicalDeviceGroups( m_instance, pPhysicalDeviceGroupCount, reinterpret_cast<VkPhysicalDeviceGroupProperties*>( pPhysicalDeviceGroupProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<PhysicalDeviceGroupProperties,Allocator>>::type Instance::enumeratePhysicalDeviceGroups(Dispatch const &d ) const
  {
    std::vector<PhysicalDeviceGroupProperties,Allocator> physicalDeviceGroupProperties;
    uint32_t physicalDeviceGroupCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkEnumeratePhysicalDeviceGroups( m_instance, &physicalDeviceGroupCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && physicalDeviceGroupCount )
      {
        physicalDeviceGroupProperties.resize( physicalDeviceGroupCount );
        result = static_cast<Result>( d.vkEnumeratePhysicalDeviceGroups( m_instance, &physicalDeviceGroupCount, reinterpret_cast<VkPhysicalDeviceGroupProperties*>( physicalDeviceGroupProperties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( physicalDeviceGroupCount <= physicalDeviceGroupProperties.size() );
    physicalDeviceGroupProperties.resize( physicalDeviceGroupCount );
    return createResultValue( result, physicalDeviceGroupProperties, VULKAN_HPP_NAMESPACE_STRING"::Instance::enumeratePhysicalDeviceGroups" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::enumeratePhysicalDeviceGroupsKHR( uint32_t* pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkEnumeratePhysicalDeviceGroupsKHR( m_instance, pPhysicalDeviceGroupCount, reinterpret_cast<VkPhysicalDeviceGroupProperties*>( pPhysicalDeviceGroupProperties ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template <typename Allocator, typename Dispatch> 
  VULKAN_HPP_INLINE typename ResultValueType<std::vector<PhysicalDeviceGroupProperties,Allocator>>::type Instance::enumeratePhysicalDeviceGroupsKHR(Dispatch const &d ) const
  {
    std::vector<PhysicalDeviceGroupProperties,Allocator> physicalDeviceGroupProperties;
    uint32_t physicalDeviceGroupCount;
    Result result;
    do
    {
      result = static_cast<Result>( d.vkEnumeratePhysicalDeviceGroupsKHR( m_instance, &physicalDeviceGroupCount, nullptr ) );
      if ( ( result == Result::eSuccess ) && physicalDeviceGroupCount )
      {
        physicalDeviceGroupProperties.resize( physicalDeviceGroupCount );
        result = static_cast<Result>( d.vkEnumeratePhysicalDeviceGroupsKHR( m_instance, &physicalDeviceGroupCount, reinterpret_cast<VkPhysicalDeviceGroupProperties*>( physicalDeviceGroupProperties.data() ) ) );
      }
    } while ( result == Result::eIncomplete );
    VULKAN_HPP_ASSERT( physicalDeviceGroupCount <= physicalDeviceGroupProperties.size() );
    physicalDeviceGroupProperties.resize( physicalDeviceGroupCount );
    return createResultValue( result, physicalDeviceGroupProperties, VULKAN_HPP_NAMESPACE_STRING"::Instance::enumeratePhysicalDeviceGroupsKHR" );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VK_USE_PLATFORM_IOS_MVK
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createIOSSurfaceMVK( const IOSSurfaceCreateInfoMVK* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateIOSSurfaceMVK( m_instance, reinterpret_cast<const VkIOSSurfaceCreateInfoMVK*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createIOSSurfaceMVK( const IOSSurfaceCreateInfoMVK & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateIOSSurfaceMVK( m_instance, reinterpret_cast<const VkIOSSurfaceCreateInfoMVK*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createIOSSurfaceMVK" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createIOSSurfaceMVKUnique( const IOSSurfaceCreateInfoMVK & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateIOSSurfaceMVK( m_instance, reinterpret_cast<const VkIOSSurfaceCreateInfoMVK*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createIOSSurfaceMVKUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_IOS_MVK*/

#ifdef VK_USE_PLATFORM_MACOS_MVK
  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createMacOSSurfaceMVK( const MacOSSurfaceCreateInfoMVK* pCreateInfo, const AllocationCallbacks* pAllocator, SurfaceKHR* pSurface, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateMacOSSurfaceMVK( m_instance, reinterpret_cast<const VkMacOSSurfaceCreateInfoMVK*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkSurfaceKHR*>( pSurface ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<SurfaceKHR>::type Instance::createMacOSSurfaceMVK( const MacOSSurfaceCreateInfoMVK & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateMacOSSurfaceMVK( m_instance, reinterpret_cast<const VkMacOSSurfaceCreateInfoMVK*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );
    return createResultValue( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createMacOSSurfaceMVK" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<SurfaceKHR,Dispatch>>::type Instance::createMacOSSurfaceMVKUnique( const MacOSSurfaceCreateInfoMVK & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    SurfaceKHR surface;
    Result result = static_cast<Result>( d.vkCreateMacOSSurfaceMVK( m_instance, reinterpret_cast<const VkMacOSSurfaceCreateInfoMVK*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkSurfaceKHR*>( &surface ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<SurfaceKHR,Dispatch>( result, surface, VULKAN_HPP_NAMESPACE_STRING"::Instance::createMacOSSurfaceMVKUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif /*VK_USE_PLATFORM_MACOS_MVK*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result Instance::createDebugUtilsMessengerEXT( const DebugUtilsMessengerCreateInfoEXT* pCreateInfo, const AllocationCallbacks* pAllocator, DebugUtilsMessengerEXT* pMessenger, Dispatch const &d) const
  {
    return static_cast<Result>( d.vkCreateDebugUtilsMessengerEXT( m_instance, reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkDebugUtilsMessengerEXT*>( pMessenger ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<DebugUtilsMessengerEXT>::type Instance::createDebugUtilsMessengerEXT( const DebugUtilsMessengerCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DebugUtilsMessengerEXT messenger;
    Result result = static_cast<Result>( d.vkCreateDebugUtilsMessengerEXT( m_instance, reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDebugUtilsMessengerEXT*>( &messenger ) ) );
    return createResultValue( result, messenger, VULKAN_HPP_NAMESPACE_STRING"::Instance::createDebugUtilsMessengerEXT" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<DebugUtilsMessengerEXT,Dispatch>>::type Instance::createDebugUtilsMessengerEXTUnique( const DebugUtilsMessengerCreateInfoEXT & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    DebugUtilsMessengerEXT messenger;
    Result result = static_cast<Result>( d.vkCreateDebugUtilsMessengerEXT( m_instance, reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkDebugUtilsMessengerEXT*>( &messenger ) ) );

    ObjectDestroy<Instance,Dispatch> deleter( *this, allocator, d );
    return createResultValue<DebugUtilsMessengerEXT,Dispatch>( result, messenger, VULKAN_HPP_NAMESPACE_STRING"::Instance::createDebugUtilsMessengerEXTUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroyDebugUtilsMessengerEXT( DebugUtilsMessengerEXT messenger, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDebugUtilsMessengerEXT( m_instance, static_cast<VkDebugUtilsMessengerEXT>( messenger ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroyDebugUtilsMessengerEXT( DebugUtilsMessengerEXT messenger, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDebugUtilsMessengerEXT( m_instance, static_cast<VkDebugUtilsMessengerEXT>( messenger ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroy( DebugUtilsMessengerEXT messenger, const AllocationCallbacks* pAllocator, Dispatch const &d) const
  {
    d.vkDestroyDebugUtilsMessengerEXT( m_instance, static_cast<VkDebugUtilsMessengerEXT>( messenger ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::destroy( DebugUtilsMessengerEXT messenger, Optional<const AllocationCallbacks> allocator, Dispatch const &d ) const
  {
    d.vkDestroyDebugUtilsMessengerEXT( m_instance, static_cast<VkDebugUtilsMessengerEXT>( messenger ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::submitDebugUtilsMessageEXT( DebugUtilsMessageSeverityFlagBitsEXT messageSeverity, DebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT* pCallbackData, Dispatch const &d) const
  {
    d.vkSubmitDebugUtilsMessageEXT( m_instance, static_cast<VkDebugUtilsMessageSeverityFlagBitsEXT>( messageSeverity ), static_cast<VkDebugUtilsMessageTypeFlagsEXT>( messageTypes ), reinterpret_cast<const VkDebugUtilsMessengerCallbackDataEXT*>( pCallbackData ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE void Instance::submitDebugUtilsMessageEXT( DebugUtilsMessageSeverityFlagBitsEXT messageSeverity, DebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT & callbackData, Dispatch const &d ) const
  {
    d.vkSubmitDebugUtilsMessageEXT( m_instance, static_cast<VkDebugUtilsMessageSeverityFlagBitsEXT>( messageSeverity ), static_cast<VkDebugUtilsMessageTypeFlagsEXT>( messageTypes ), reinterpret_cast<const VkDebugUtilsMessengerCallbackDataEXT*>( &callbackData ) );
  }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  struct DeviceGroupDeviceCreateInfo
  {
    operator VkDeviceGroupDeviceCreateInfo const&() const
    {
      return *reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(this);
    }

    operator VkDeviceGroupDeviceCreateInfo &()
    {
      return *reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(this);
    }

    bool operator==( DeviceGroupDeviceCreateInfo const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext )
          && ( physicalDeviceCount == rhs.physicalDeviceCount )
          && ( pPhysicalDevices == rhs.pPhysicalDevices );
    }

    bool operator!=( DeviceGroupDeviceCreateInfo const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType = StructureType::eDeviceGroupDeviceCreateInfo;
    const void* pNext = nullptr;
    uint32_t physicalDeviceCount = 0;
    const PhysicalDevice* pPhysicalDevices = nullptr;
  };
  static_assert( sizeof( DeviceGroupDeviceCreateInfo ) == sizeof( VkDeviceGroupDeviceCreateInfo ), "struct and wrapper have different size!" );
  static_assert( offsetof( DeviceGroupDeviceCreateInfo, pNext ) == offsetof( VkDeviceGroupDeviceCreateInfo, pNext ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupDeviceCreateInfo, physicalDeviceCount ) == offsetof( VkDeviceGroupDeviceCreateInfo, physicalDeviceCount ), "struct member and wrapper member have different offset!" );
  static_assert( offsetof( DeviceGroupDeviceCreateInfo, pPhysicalDevices ) == offsetof( VkDeviceGroupDeviceCreateInfo, pPhysicalDevices ), "struct member and wrapper member have different offset!" );

  using DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;

#ifndef VULKAN_HPP_NO_SMART_HANDLE

  template <typename Dispatch> class UniqueHandleTraits<Instance,Dispatch> {public: using deleter = ObjectDestroy<NoParent,Dispatch>; };
  using UniqueInstance = UniqueHandle<Instance,DispatchLoaderStatic>;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/

  template<typename Dispatch = DispatchLoaderStatic>
  Result createInstance( const InstanceCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Instance* pInstance, Dispatch const &d = Dispatch() );
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch = DispatchLoaderStatic>
  ResultValueType<Instance>::type createInstance( const InstanceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() );
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch = DispatchLoaderStatic>
  typename ResultValueType<UniqueHandle<Instance,Dispatch>>::type createInstanceUnique( const InstanceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator = nullptr, Dispatch const &d = Dispatch() );
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

  template<typename Dispatch>
  VULKAN_HPP_INLINE Result createInstance( const InstanceCreateInfo* pCreateInfo, const AllocationCallbacks* pAllocator, Instance* pInstance, Dispatch const &d)
  {
    return static_cast<Result>( d.vkCreateInstance( reinterpret_cast<const VkInstanceCreateInfo*>( pCreateInfo ), reinterpret_cast<const VkAllocationCallbacks*>( pAllocator ), reinterpret_cast<VkInstance*>( pInstance ) ) );
  }
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  template<typename Dispatch>
  VULKAN_HPP_INLINE ResultValueType<Instance>::type createInstance( const InstanceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d )
  {
    Instance instance;
    Result result = static_cast<Result>( d.vkCreateInstance( reinterpret_cast<const VkInstanceCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkInstance*>( &instance ) ) );
    return createResultValue( result, instance, VULKAN_HPP_NAMESPACE_STRING"::createInstance" );
  }
#ifndef VULKAN_HPP_NO_SMART_HANDLE
  template<typename Dispatch>
  VULKAN_HPP_INLINE typename ResultValueType<UniqueHandle<Instance,Dispatch>>::type createInstanceUnique( const InstanceCreateInfo & createInfo, Optional<const AllocationCallbacks> allocator, Dispatch const &d )
  {
    Instance instance;
    Result result = static_cast<Result>( d.vkCreateInstance( reinterpret_cast<const VkInstanceCreateInfo*>( &createInfo ), reinterpret_cast<const VkAllocationCallbacks*>( static_cast<const AllocationCallbacks*>( allocator ) ), reinterpret_cast<VkInstance*>( &instance ) ) );

    ObjectDestroy<NoParent,Dispatch> deleter( allocator, d );
    return createResultValue<Instance,Dispatch>( result, instance, VULKAN_HPP_NAMESPACE_STRING"::createInstanceUnique", deleter );
  }
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/


  struct BaseOutStructure
  {
    operator VkBaseOutStructure const&() const
    {
      return *reinterpret_cast<const VkBaseOutStructure*>(this);
    }

    operator VkBaseOutStructure &()
    {
      return *reinterpret_cast<VkBaseOutStructure*>(this);
    }

    bool operator==( BaseOutStructure const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext );
    }

    bool operator!=( BaseOutStructure const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType;
    struct BaseOutStructure* pNext = nullptr;
  };
  static_assert( sizeof( BaseOutStructure ) == sizeof( VkBaseOutStructure ), "struct and wrapper have different size!" );
  static_assert( offsetof( BaseOutStructure, pNext ) == offsetof( VkBaseOutStructure, pNext ), "struct member and wrapper member have different offset!" );

  struct BaseInStructure
  {
    operator VkBaseInStructure const&() const
    {
      return *reinterpret_cast<const VkBaseInStructure*>(this);
    }

    operator VkBaseInStructure &()
    {
      return *reinterpret_cast<VkBaseInStructure*>(this);
    }

    bool operator==( BaseInStructure const& rhs ) const
    {
      return ( sType == rhs.sType )
          && ( pNext == rhs.pNext );
    }

    bool operator!=( BaseInStructure const& rhs ) const
    {
      return !operator==( rhs );
    }

    StructureType sType;
    const struct BaseInStructure* pNext = nullptr;
  };
  static_assert( sizeof( BaseInStructure ) == sizeof( VkBaseInStructure ), "struct and wrapper have different size!" );
  static_assert( offsetof( BaseInStructure, pNext ) == offsetof( VkBaseInStructure, pNext ), "struct member and wrapper member have different offset!" );

  template <> struct isStructureChainValid<PresentInfoKHR, DisplayPresentInfoKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageCreateInfo, DedicatedAllocationImageCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<BufferCreateInfo, DedicatedAllocationBufferCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<MemoryAllocateInfo, DedicatedAllocationMemoryAllocateInfoNV>{ enum { value = true }; };
#ifdef VK_USE_PLATFORM_WIN32_NV
  template <> struct isStructureChainValid<MemoryAllocateInfo, ExportMemoryWin32HandleInfoNV>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_WIN32_NV*/
#ifdef VK_USE_PLATFORM_WIN32_NV
  template <> struct isStructureChainValid<SubmitInfo, Win32KeyedMutexAcquireReleaseInfoNV>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_WIN32_NV*/
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceFeatures2>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDevicePushDescriptorPropertiesKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<PresentInfoKHR, PresentRegionsKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceVariablePointerFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceVariablePointerFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceIDProperties>{ enum { value = true }; };
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> struct isStructureChainValid<MemoryAllocateInfo, ExportMemoryWin32HandleInfoKHR>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> struct isStructureChainValid<SubmitInfo, Win32KeyedMutexAcquireReleaseInfoKHR>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> struct isStructureChainValid<SemaphoreCreateInfo, ExportSemaphoreWin32HandleInfoKHR>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> struct isStructureChainValid<SubmitInfo, D3D12FenceSubmitInfoKHR>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> struct isStructureChainValid<FenceCreateInfo, ExportFenceWin32HandleInfoKHR>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceMultiviewFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceMultiviewFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceMultiviewProperties>{ enum { value = true }; };
  template <> struct isStructureChainValid<RenderPassCreateInfo, RenderPassMultiviewCreateInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<BindBufferMemoryInfo, BindBufferMemoryDeviceGroupInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<BindImageMemoryInfo, BindImageMemoryDeviceGroupInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<RenderPassBeginInfo, DeviceGroupRenderPassBeginInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<CommandBufferBeginInfo, DeviceGroupCommandBufferBeginInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<SubmitInfo, DeviceGroupSubmitInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<BindSparseInfo, DeviceGroupBindSparseInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageCreateInfo, ImageSwapchainCreateInfoKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<BindImageMemoryInfo, BindImageMemorySwapchainInfoKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<PresentInfoKHR, PresentTimesInfoGOOGLE>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineViewportStateCreateInfo, PipelineViewportWScalingStateCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceDiscardRectanglePropertiesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDevice16BitStorageFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDevice16BitStorageFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<MemoryRequirements2, MemoryDedicatedRequirements>{ enum { value = true }; };
  template <> struct isStructureChainValid<MemoryAllocateInfo, MemoryDedicatedAllocateInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<SamplerCreateInfo, SamplerYcbcrConversionInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageViewCreateInfo, SamplerYcbcrConversionInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceSamplerYcbcrConversionFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceSamplerYcbcrConversionFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageFormatProperties2, SamplerYcbcrConversionImageFormatProperties>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageFormatProperties2, TextureLODGatherFormatPropertiesAMD>{ enum { value = true }; };
  template <> struct isStructureChainValid<SubmitInfo, ProtectedSubmitInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceProtectedMemoryFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceProtectedMemoryFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceProtectedMemoryProperties>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineMultisampleStateCreateInfo, PipelineCoverageToColorStateCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceSamplerFilterMinmaxPropertiesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceBlendOperationAdvancedFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceBlendOperationAdvancedFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceBlendOperationAdvancedPropertiesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceInlineUniformBlockFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceInlineUniformBlockFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceInlineUniformBlockPropertiesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<WriteDescriptorSet, WriteDescriptorSetInlineUniformBlockEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DescriptorPoolCreateInfo, DescriptorPoolInlineUniformBlockCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageCreateInfo, ImageFormatListCreateInfoKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<ShaderModuleCreateInfo, ShaderModuleValidationCacheCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceMaintenance3Properties>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceShaderDrawParameterFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceShaderDrawParameterFeatures>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceExternalMemoryHostPropertiesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceConservativeRasterizationPropertiesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceShaderCorePropertiesAMD>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceDescriptorIndexingFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceDescriptorIndexingFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceDescriptorIndexingPropertiesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DescriptorSetAllocateInfo, DescriptorSetVariableDescriptorCountAllocateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DescriptorSetLayoutSupport, DescriptorSetVariableDescriptorCountLayoutSupportEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineVertexInputStateCreateInfo, PipelineVertexInputDivisorStateCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceVertexAttributeDivisorPropertiesEXT>{ enum { value = true }; };
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  template <> struct isStructureChainValid<MemoryAllocateInfo, ImportAndroidHardwareBufferInfoANDROID>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  template <> struct isStructureChainValid<ImageFormatProperties2, AndroidHardwareBufferUsageANDROID>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
  template <> struct isStructureChainValid<CommandBufferInheritanceInfo, CommandBufferInheritanceConditionalRenderingInfoEXT>{ enum { value = true }; };
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  template <> struct isStructureChainValid<ImageCreateInfo, ExternalFormatANDROID>{ enum { value = true }; };
  template <> struct isStructureChainValid<SamplerYcbcrConversionCreateInfo, ExternalFormatANDROID>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDevice8BitStorageFeaturesKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDevice8BitStorageFeaturesKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceConditionalRenderingFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceConditionalRenderingFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceVulkanMemoryModelFeaturesKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceVulkanMemoryModelFeaturesKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceVertexAttributeDivisorFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceVertexAttributeDivisorFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageViewCreateInfo, ImageViewASTCDecodeModeEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceASTCDecodeFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceASTCDecodeFeaturesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceRepresentativeFragmentTestFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceRepresentativeFragmentTestFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<GraphicsPipelineCreateInfo, PipelineRepresentativeFragmentTestStateCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceExclusiveScissorFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceExclusiveScissorFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineViewportStateCreateInfo, PipelineViewportExclusiveScissorStateCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceCornerSampledImageFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceCornerSampledImageFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceComputeShaderDerivativesFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceComputeShaderDerivativesFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceFragmentShaderBarycentricFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceFragmentShaderBarycentricFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceShaderImageFootprintFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceShaderImageFootprintFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceShadingRateImageFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceShadingRateImageFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties, PhysicalDeviceShadingRateImagePropertiesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceFeatures2, PhysicalDeviceMeshShaderFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, PhysicalDeviceMeshShaderFeaturesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceMeshShaderPropertiesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<WriteDescriptorSet, DescriptorAccelerationStructureInfoNVX>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceRaytracingPropertiesNVX>{ enum { value = true }; };
  template <> struct isStructureChainValid<SurfaceCapabilities2KHR, SharedPresentSurfaceCapabilitiesKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageViewCreateInfo, ImageViewUsageCreateInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<RenderPassCreateInfo, RenderPassInputAttachmentAspectCreateInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<BindImageMemoryInfo, BindImagePlaneMemoryInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageMemoryRequirementsInfo2, ImagePlaneMemoryRequirementsInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<QueueFamilyProperties2, QueueFamilyCheckpointPropertiesNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageMemoryBarrier, SampleLocationsInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<RenderPassBeginInfo, RenderPassSampleLocationsBeginInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineMultisampleStateCreateInfo, PipelineSampleLocationsStateCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceSampleLocationsPropertiesEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<InstanceCreateInfo, DebugReportCallbackCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineRasterizationStateCreateInfo, PipelineRasterizationStateRasterizationOrderAMD>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageCreateInfo, ExternalMemoryImageCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<MemoryAllocateInfo, ExportMemoryAllocateInfoNV>{ enum { value = true }; };
#ifdef VK_USE_PLATFORM_WIN32_NV
  template <> struct isStructureChainValid<MemoryAllocateInfo, ImportMemoryWin32HandleInfoNV>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_WIN32_NV*/
  template <> struct isStructureChainValid<InstanceCreateInfo, ValidationFlagsEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDeviceSubgroupProperties>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceImageFormatInfo2, PhysicalDeviceExternalImageFormatInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageCreateInfo, ExternalMemoryImageCreateInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<BufferCreateInfo, ExternalMemoryBufferCreateInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<MemoryAllocateInfo, ExportMemoryAllocateInfo>{ enum { value = true }; };
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> struct isStructureChainValid<MemoryAllocateInfo, ImportMemoryWin32HandleInfoKHR>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
  template <> struct isStructureChainValid<MemoryAllocateInfo, ImportMemoryFdInfoKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<MemoryAllocateInfo, ImportMemoryHostPointerInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<ImageFormatProperties2, ExternalImageFormatProperties>{ enum { value = true }; };
  template <> struct isStructureChainValid<SemaphoreCreateInfo, ExportSemaphoreCreateInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<FenceCreateInfo, ExportFenceCreateInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<SwapchainCreateInfoKHR, SwapchainCounterCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<MemoryAllocateInfo, MemoryAllocateFlagsInfo>{ enum { value = true }; };
  template <> struct isStructureChainValid<PresentInfoKHR, DeviceGroupPresentInfoKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<SwapchainCreateInfoKHR, DeviceGroupSwapchainCreateInfoKHR>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineViewportStateCreateInfo, PipelineViewportSwizzleStateCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<GraphicsPipelineCreateInfo, PipelineDiscardRectangleStateCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PhysicalDeviceProperties2, PhysicalDevicePointClippingProperties>{ enum { value = true }; };
  template <> struct isStructureChainValid<SamplerCreateInfo, SamplerReductionModeCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineTessellationStateCreateInfo, PipelineTessellationDomainOriginStateCreateInfo>{ enum { value = true }; };
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
  template <> struct isStructureChainValid<AndroidHardwareBufferPropertiesANDROID, AndroidHardwareBufferFormatPropertiesANDROID>{ enum { value = true }; };
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
  template <> struct isStructureChainValid<PipelineColorBlendStateCreateInfo, PipelineColorBlendAdvancedStateCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineMultisampleStateCreateInfo, PipelineCoverageModulationStateCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceQueueCreateInfo, DeviceQueueGlobalPriorityCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<InstanceCreateInfo, DebugUtilsMessengerCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineRasterizationStateCreateInfo, PipelineRasterizationConservativeStateCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<DescriptorSetLayoutCreateInfo, DescriptorSetLayoutBindingFlagsCreateInfoEXT>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineViewportStateCreateInfo, PipelineViewportShadingRateImageStateCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<PipelineViewportStateCreateInfo, PipelineViewportCoarseSampleOrderStateCreateInfoNV>{ enum { value = true }; };
  template <> struct isStructureChainValid<DeviceCreateInfo, DeviceGroupDeviceCreateInfo>{ enum { value = true }; };
  VULKAN_HPP_INLINE std::string to_string(FramebufferCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(FramebufferCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(QueryPoolCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(QueryPoolCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(RenderPassCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(RenderPassCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(SamplerCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(SamplerCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineLayoutCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineLayoutCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineCacheCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineCacheCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineDepthStencilStateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineDepthStencilStateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineDynamicStateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineDynamicStateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineColorBlendStateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineColorBlendStateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineMultisampleStateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineMultisampleStateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineRasterizationStateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineRasterizationStateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineViewportStateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineViewportStateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineTessellationStateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineTessellationStateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineInputAssemblyStateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineInputAssemblyStateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineVertexInputStateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineVertexInputStateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineShaderStageCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineShaderStageCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(BufferViewCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(BufferViewCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(InstanceCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(InstanceCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(DeviceCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(DeviceCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(ImageViewCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(ImageViewCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(SemaphoreCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(SemaphoreCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(ShaderModuleCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(ShaderModuleCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(EventCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(EventCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(MemoryMapFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(MemoryMapFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorPoolResetFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorPoolResetFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorUpdateTemplateCreateFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorUpdateTemplateCreateFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(DisplayModeCreateFlagBitsKHR)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(DisplayModeCreateFlagsKHR)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(DisplaySurfaceCreateFlagBitsKHR)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(DisplaySurfaceCreateFlagsKHR)
  {
    return "{}";
  }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  VULKAN_HPP_INLINE std::string to_string(AndroidSurfaceCreateFlagBitsKHR)
  {
    return "(void)";
  }
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  VULKAN_HPP_INLINE std::string to_string(AndroidSurfaceCreateFlagsKHR)
  {
    return "{}";
  }
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#ifdef VK_USE_PLATFORM_MIR_KHR
  VULKAN_HPP_INLINE std::string to_string(MirSurfaceCreateFlagBitsKHR)
  {
    return "(void)";
  }
#endif /*VK_USE_PLATFORM_MIR_KHR*/

#ifdef VK_USE_PLATFORM_MIR_KHR
  VULKAN_HPP_INLINE std::string to_string(MirSurfaceCreateFlagsKHR)
  {
    return "{}";
  }
#endif /*VK_USE_PLATFORM_MIR_KHR*/

#ifdef VK_USE_PLATFORM_VI_NN
  VULKAN_HPP_INLINE std::string to_string(ViSurfaceCreateFlagBitsNN)
  {
    return "(void)";
  }
#endif /*VK_USE_PLATFORM_VI_NN*/

#ifdef VK_USE_PLATFORM_VI_NN
  VULKAN_HPP_INLINE std::string to_string(ViSurfaceCreateFlagsNN)
  {
    return "{}";
  }
#endif /*VK_USE_PLATFORM_VI_NN*/

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  VULKAN_HPP_INLINE std::string to_string(WaylandSurfaceCreateFlagBitsKHR)
  {
    return "(void)";
  }
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  VULKAN_HPP_INLINE std::string to_string(WaylandSurfaceCreateFlagsKHR)
  {
    return "{}";
  }
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  VULKAN_HPP_INLINE std::string to_string(Win32SurfaceCreateFlagBitsKHR)
  {
    return "(void)";
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_WIN32_KHR
  VULKAN_HPP_INLINE std::string to_string(Win32SurfaceCreateFlagsKHR)
  {
    return "{}";
  }
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#ifdef VK_USE_PLATFORM_XLIB_KHR
  VULKAN_HPP_INLINE std::string to_string(XlibSurfaceCreateFlagBitsKHR)
  {
    return "(void)";
  }
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#ifdef VK_USE_PLATFORM_XLIB_KHR
  VULKAN_HPP_INLINE std::string to_string(XlibSurfaceCreateFlagsKHR)
  {
    return "{}";
  }
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#ifdef VK_USE_PLATFORM_XCB_KHR
  VULKAN_HPP_INLINE std::string to_string(XcbSurfaceCreateFlagBitsKHR)
  {
    return "(void)";
  }
#endif /*VK_USE_PLATFORM_XCB_KHR*/

#ifdef VK_USE_PLATFORM_XCB_KHR
  VULKAN_HPP_INLINE std::string to_string(XcbSurfaceCreateFlagsKHR)
  {
    return "{}";
  }
#endif /*VK_USE_PLATFORM_XCB_KHR*/

#ifdef VK_USE_PLATFORM_IOS_MVK
  VULKAN_HPP_INLINE std::string to_string(IOSSurfaceCreateFlagBitsMVK)
  {
    return "(void)";
  }
#endif /*VK_USE_PLATFORM_IOS_MVK*/

#ifdef VK_USE_PLATFORM_IOS_MVK
  VULKAN_HPP_INLINE std::string to_string(IOSSurfaceCreateFlagsMVK)
  {
    return "{}";
  }
#endif /*VK_USE_PLATFORM_IOS_MVK*/

#ifdef VK_USE_PLATFORM_MACOS_MVK
  VULKAN_HPP_INLINE std::string to_string(MacOSSurfaceCreateFlagBitsMVK)
  {
    return "(void)";
  }
#endif /*VK_USE_PLATFORM_MACOS_MVK*/

#ifdef VK_USE_PLATFORM_MACOS_MVK
  VULKAN_HPP_INLINE std::string to_string(MacOSSurfaceCreateFlagsMVK)
  {
    return "{}";
  }
#endif /*VK_USE_PLATFORM_MACOS_MVK*/

  VULKAN_HPP_INLINE std::string to_string(CommandPoolTrimFlagBits)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(CommandPoolTrimFlags)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineViewportSwizzleStateCreateFlagBitsNV)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineViewportSwizzleStateCreateFlagsNV)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineDiscardRectangleStateCreateFlagBitsEXT)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineDiscardRectangleStateCreateFlagsEXT)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineCoverageToColorStateCreateFlagBitsNV)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineCoverageToColorStateCreateFlagsNV)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineCoverageModulationStateCreateFlagBitsNV)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineCoverageModulationStateCreateFlagsNV)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(ValidationCacheCreateFlagBitsEXT)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(ValidationCacheCreateFlagsEXT)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(DebugUtilsMessengerCreateFlagBitsEXT)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(DebugUtilsMessengerCreateFlagsEXT)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(DebugUtilsMessengerCallbackDataFlagBitsEXT)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(DebugUtilsMessengerCallbackDataFlagsEXT)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineRasterizationConservativeStateCreateFlagBitsEXT)
  {
    return "(void)";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineRasterizationConservativeStateCreateFlagsEXT)
  {
    return "{}";
  }

  VULKAN_HPP_INLINE std::string to_string(ImageLayout value)
  {
    switch (value)
    {
    case ImageLayout::eUndefined: return "Undefined";
    case ImageLayout::eGeneral: return "General";
    case ImageLayout::eColorAttachmentOptimal: return "ColorAttachmentOptimal";
    case ImageLayout::eDepthStencilAttachmentOptimal: return "DepthStencilAttachmentOptimal";
    case ImageLayout::eDepthStencilReadOnlyOptimal: return "DepthStencilReadOnlyOptimal";
    case ImageLayout::eShaderReadOnlyOptimal: return "ShaderReadOnlyOptimal";
    case ImageLayout::eTransferSrcOptimal: return "TransferSrcOptimal";
    case ImageLayout::eTransferDstOptimal: return "TransferDstOptimal";
    case ImageLayout::ePreinitialized: return "Preinitialized";
    case ImageLayout::eDepthReadOnlyStencilAttachmentOptimal: return "DepthReadOnlyStencilAttachmentOptimal";
    case ImageLayout::eDepthAttachmentStencilReadOnlyOptimal: return "DepthAttachmentStencilReadOnlyOptimal";
    case ImageLayout::ePresentSrcKHR: return "PresentSrcKHR";
    case ImageLayout::eSharedPresentKHR: return "SharedPresentKHR";
    case ImageLayout::eShadingRateOptimalNV: return "ShadingRateOptimalNV";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(AttachmentLoadOp value)
  {
    switch (value)
    {
    case AttachmentLoadOp::eLoad: return "Load";
    case AttachmentLoadOp::eClear: return "Clear";
    case AttachmentLoadOp::eDontCare: return "DontCare";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(AttachmentStoreOp value)
  {
    switch (value)
    {
    case AttachmentStoreOp::eStore: return "Store";
    case AttachmentStoreOp::eDontCare: return "DontCare";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ImageType value)
  {
    switch (value)
    {
    case ImageType::e1D: return "1D";
    case ImageType::e2D: return "2D";
    case ImageType::e3D: return "3D";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ImageTiling value)
  {
    switch (value)
    {
    case ImageTiling::eOptimal: return "Optimal";
    case ImageTiling::eLinear: return "Linear";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ImageViewType value)
  {
    switch (value)
    {
    case ImageViewType::e1D: return "1D";
    case ImageViewType::e2D: return "2D";
    case ImageViewType::e3D: return "3D";
    case ImageViewType::eCube: return "Cube";
    case ImageViewType::e1DArray: return "1DArray";
    case ImageViewType::e2DArray: return "2DArray";
    case ImageViewType::eCubeArray: return "CubeArray";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CommandBufferLevel value)
  {
    switch (value)
    {
    case CommandBufferLevel::ePrimary: return "Primary";
    case CommandBufferLevel::eSecondary: return "Secondary";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ComponentSwizzle value)
  {
    switch (value)
    {
    case ComponentSwizzle::eIdentity: return "Identity";
    case ComponentSwizzle::eZero: return "Zero";
    case ComponentSwizzle::eOne: return "One";
    case ComponentSwizzle::eR: return "R";
    case ComponentSwizzle::eG: return "G";
    case ComponentSwizzle::eB: return "B";
    case ComponentSwizzle::eA: return "A";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorType value)
  {
    switch (value)
    {
    case DescriptorType::eSampler: return "Sampler";
    case DescriptorType::eCombinedImageSampler: return "CombinedImageSampler";
    case DescriptorType::eSampledImage: return "SampledImage";
    case DescriptorType::eStorageImage: return "StorageImage";
    case DescriptorType::eUniformTexelBuffer: return "UniformTexelBuffer";
    case DescriptorType::eStorageTexelBuffer: return "StorageTexelBuffer";
    case DescriptorType::eUniformBuffer: return "UniformBuffer";
    case DescriptorType::eStorageBuffer: return "StorageBuffer";
    case DescriptorType::eUniformBufferDynamic: return "UniformBufferDynamic";
    case DescriptorType::eStorageBufferDynamic: return "StorageBufferDynamic";
    case DescriptorType::eInputAttachment: return "InputAttachment";
    case DescriptorType::eInlineUniformBlockEXT: return "InlineUniformBlockEXT";
    case DescriptorType::eAccelerationStructureNVX: return "AccelerationStructureNVX";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(QueryType value)
  {
    switch (value)
    {
    case QueryType::eOcclusion: return "Occlusion";
    case QueryType::ePipelineStatistics: return "PipelineStatistics";
    case QueryType::eTimestamp: return "Timestamp";
    case QueryType::eCompactedSizeNVX: return "CompactedSizeNVX";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(BorderColor value)
  {
    switch (value)
    {
    case BorderColor::eFloatTransparentBlack: return "FloatTransparentBlack";
    case BorderColor::eIntTransparentBlack: return "IntTransparentBlack";
    case BorderColor::eFloatOpaqueBlack: return "FloatOpaqueBlack";
    case BorderColor::eIntOpaqueBlack: return "IntOpaqueBlack";
    case BorderColor::eFloatOpaqueWhite: return "FloatOpaqueWhite";
    case BorderColor::eIntOpaqueWhite: return "IntOpaqueWhite";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineBindPoint value)
  {
    switch (value)
    {
    case PipelineBindPoint::eGraphics: return "Graphics";
    case PipelineBindPoint::eCompute: return "Compute";
    case PipelineBindPoint::eRaytracingNVX: return "RaytracingNVX";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineCacheHeaderVersion value)
  {
    switch (value)
    {
    case PipelineCacheHeaderVersion::eOne: return "One";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(PrimitiveTopology value)
  {
    switch (value)
    {
    case PrimitiveTopology::ePointList: return "PointList";
    case PrimitiveTopology::eLineList: return "LineList";
    case PrimitiveTopology::eLineStrip: return "LineStrip";
    case PrimitiveTopology::eTriangleList: return "TriangleList";
    case PrimitiveTopology::eTriangleStrip: return "TriangleStrip";
    case PrimitiveTopology::eTriangleFan: return "TriangleFan";
    case PrimitiveTopology::eLineListWithAdjacency: return "LineListWithAdjacency";
    case PrimitiveTopology::eLineStripWithAdjacency: return "LineStripWithAdjacency";
    case PrimitiveTopology::eTriangleListWithAdjacency: return "TriangleListWithAdjacency";
    case PrimitiveTopology::eTriangleStripWithAdjacency: return "TriangleStripWithAdjacency";
    case PrimitiveTopology::ePatchList: return "PatchList";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SharingMode value)
  {
    switch (value)
    {
    case SharingMode::eExclusive: return "Exclusive";
    case SharingMode::eConcurrent: return "Concurrent";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(IndexType value)
  {
    switch (value)
    {
    case IndexType::eUint16: return "Uint16";
    case IndexType::eUint32: return "Uint32";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(Filter value)
  {
    switch (value)
    {
    case Filter::eNearest: return "Nearest";
    case Filter::eLinear: return "Linear";
    case Filter::eCubicIMG: return "CubicIMG";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SamplerMipmapMode value)
  {
    switch (value)
    {
    case SamplerMipmapMode::eNearest: return "Nearest";
    case SamplerMipmapMode::eLinear: return "Linear";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SamplerAddressMode value)
  {
    switch (value)
    {
    case SamplerAddressMode::eRepeat: return "Repeat";
    case SamplerAddressMode::eMirroredRepeat: return "MirroredRepeat";
    case SamplerAddressMode::eClampToEdge: return "ClampToEdge";
    case SamplerAddressMode::eClampToBorder: return "ClampToBorder";
    case SamplerAddressMode::eMirrorClampToEdge: return "MirrorClampToEdge";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CompareOp value)
  {
    switch (value)
    {
    case CompareOp::eNever: return "Never";
    case CompareOp::eLess: return "Less";
    case CompareOp::eEqual: return "Equal";
    case CompareOp::eLessOrEqual: return "LessOrEqual";
    case CompareOp::eGreater: return "Greater";
    case CompareOp::eNotEqual: return "NotEqual";
    case CompareOp::eGreaterOrEqual: return "GreaterOrEqual";
    case CompareOp::eAlways: return "Always";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(PolygonMode value)
  {
    switch (value)
    {
    case PolygonMode::eFill: return "Fill";
    case PolygonMode::eLine: return "Line";
    case PolygonMode::ePoint: return "Point";
    case PolygonMode::eFillRectangleNV: return "FillRectangleNV";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CullModeFlagBits value)
  {
    switch (value)
    {
    case CullModeFlagBits::eNone: return "None";
    case CullModeFlagBits::eFront: return "Front";
    case CullModeFlagBits::eBack: return "Back";
    case CullModeFlagBits::eFrontAndBack: return "FrontAndBack";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CullModeFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & CullModeFlagBits::eNone) result += "None | ";
    if (value & CullModeFlagBits::eFront) result += "Front | ";
    if (value & CullModeFlagBits::eBack) result += "Back | ";
    if (value & CullModeFlagBits::eFrontAndBack) result += "FrontAndBack | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(FrontFace value)
  {
    switch (value)
    {
    case FrontFace::eCounterClockwise: return "CounterClockwise";
    case FrontFace::eClockwise: return "Clockwise";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(BlendFactor value)
  {
    switch (value)
    {
    case BlendFactor::eZero: return "Zero";
    case BlendFactor::eOne: return "One";
    case BlendFactor::eSrcColor: return "SrcColor";
    case BlendFactor::eOneMinusSrcColor: return "OneMinusSrcColor";
    case BlendFactor::eDstColor: return "DstColor";
    case BlendFactor::eOneMinusDstColor: return "OneMinusDstColor";
    case BlendFactor::eSrcAlpha: return "SrcAlpha";
    case BlendFactor::eOneMinusSrcAlpha: return "OneMinusSrcAlpha";
    case BlendFactor::eDstAlpha: return "DstAlpha";
    case BlendFactor::eOneMinusDstAlpha: return "OneMinusDstAlpha";
    case BlendFactor::eConstantColor: return "ConstantColor";
    case BlendFactor::eOneMinusConstantColor: return "OneMinusConstantColor";
    case BlendFactor::eConstantAlpha: return "ConstantAlpha";
    case BlendFactor::eOneMinusConstantAlpha: return "OneMinusConstantAlpha";
    case BlendFactor::eSrcAlphaSaturate: return "SrcAlphaSaturate";
    case BlendFactor::eSrc1Color: return "Src1Color";
    case BlendFactor::eOneMinusSrc1Color: return "OneMinusSrc1Color";
    case BlendFactor::eSrc1Alpha: return "Src1Alpha";
    case BlendFactor::eOneMinusSrc1Alpha: return "OneMinusSrc1Alpha";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(BlendOp value)
  {
    switch (value)
    {
    case BlendOp::eAdd: return "Add";
    case BlendOp::eSubtract: return "Subtract";
    case BlendOp::eReverseSubtract: return "ReverseSubtract";
    case BlendOp::eMin: return "Min";
    case BlendOp::eMax: return "Max";
    case BlendOp::eZeroEXT: return "ZeroEXT";
    case BlendOp::eSrcEXT: return "SrcEXT";
    case BlendOp::eDstEXT: return "DstEXT";
    case BlendOp::eSrcOverEXT: return "SrcOverEXT";
    case BlendOp::eDstOverEXT: return "DstOverEXT";
    case BlendOp::eSrcInEXT: return "SrcInEXT";
    case BlendOp::eDstInEXT: return "DstInEXT";
    case BlendOp::eSrcOutEXT: return "SrcOutEXT";
    case BlendOp::eDstOutEXT: return "DstOutEXT";
    case BlendOp::eSrcAtopEXT: return "SrcAtopEXT";
    case BlendOp::eDstAtopEXT: return "DstAtopEXT";
    case BlendOp::eXorEXT: return "XorEXT";
    case BlendOp::eMultiplyEXT: return "MultiplyEXT";
    case BlendOp::eScreenEXT: return "ScreenEXT";
    case BlendOp::eOverlayEXT: return "OverlayEXT";
    case BlendOp::eDarkenEXT: return "DarkenEXT";
    case BlendOp::eLightenEXT: return "LightenEXT";
    case BlendOp::eColordodgeEXT: return "ColordodgeEXT";
    case BlendOp::eColorburnEXT: return "ColorburnEXT";
    case BlendOp::eHardlightEXT: return "HardlightEXT";
    case BlendOp::eSoftlightEXT: return "SoftlightEXT";
    case BlendOp::eDifferenceEXT: return "DifferenceEXT";
    case BlendOp::eExclusionEXT: return "ExclusionEXT";
    case BlendOp::eInvertEXT: return "InvertEXT";
    case BlendOp::eInvertRgbEXT: return "InvertRgbEXT";
    case BlendOp::eLineardodgeEXT: return "LineardodgeEXT";
    case BlendOp::eLinearburnEXT: return "LinearburnEXT";
    case BlendOp::eVividlightEXT: return "VividlightEXT";
    case BlendOp::eLinearlightEXT: return "LinearlightEXT";
    case BlendOp::ePinlightEXT: return "PinlightEXT";
    case BlendOp::eHardmixEXT: return "HardmixEXT";
    case BlendOp::eHslHueEXT: return "HslHueEXT";
    case BlendOp::eHslSaturationEXT: return "HslSaturationEXT";
    case BlendOp::eHslColorEXT: return "HslColorEXT";
    case BlendOp::eHslLuminosityEXT: return "HslLuminosityEXT";
    case BlendOp::ePlusEXT: return "PlusEXT";
    case BlendOp::ePlusClampedEXT: return "PlusClampedEXT";
    case BlendOp::ePlusClampedAlphaEXT: return "PlusClampedAlphaEXT";
    case BlendOp::ePlusDarkerEXT: return "PlusDarkerEXT";
    case BlendOp::eMinusEXT: return "MinusEXT";
    case BlendOp::eMinusClampedEXT: return "MinusClampedEXT";
    case BlendOp::eContrastEXT: return "ContrastEXT";
    case BlendOp::eInvertOvgEXT: return "InvertOvgEXT";
    case BlendOp::eRedEXT: return "RedEXT";
    case BlendOp::eGreenEXT: return "GreenEXT";
    case BlendOp::eBlueEXT: return "BlueEXT";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(StencilOp value)
  {
    switch (value)
    {
    case StencilOp::eKeep: return "Keep";
    case StencilOp::eZero: return "Zero";
    case StencilOp::eReplace: return "Replace";
    case StencilOp::eIncrementAndClamp: return "IncrementAndClamp";
    case StencilOp::eDecrementAndClamp: return "DecrementAndClamp";
    case StencilOp::eInvert: return "Invert";
    case StencilOp::eIncrementAndWrap: return "IncrementAndWrap";
    case StencilOp::eDecrementAndWrap: return "DecrementAndWrap";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(LogicOp value)
  {
    switch (value)
    {
    case LogicOp::eClear: return "Clear";
    case LogicOp::eAnd: return "And";
    case LogicOp::eAndReverse: return "AndReverse";
    case LogicOp::eCopy: return "Copy";
    case LogicOp::eAndInverted: return "AndInverted";
    case LogicOp::eNoOp: return "NoOp";
    case LogicOp::eXor: return "Xor";
    case LogicOp::eOr: return "Or";
    case LogicOp::eNor: return "Nor";
    case LogicOp::eEquivalent: return "Equivalent";
    case LogicOp::eInvert: return "Invert";
    case LogicOp::eOrReverse: return "OrReverse";
    case LogicOp::eCopyInverted: return "CopyInverted";
    case LogicOp::eOrInverted: return "OrInverted";
    case LogicOp::eNand: return "Nand";
    case LogicOp::eSet: return "Set";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(InternalAllocationType value)
  {
    switch (value)
    {
    case InternalAllocationType::eExecutable: return "Executable";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SystemAllocationScope value)
  {
    switch (value)
    {
    case SystemAllocationScope::eCommand: return "Command";
    case SystemAllocationScope::eObject: return "Object";
    case SystemAllocationScope::eCache: return "Cache";
    case SystemAllocationScope::eDevice: return "Device";
    case SystemAllocationScope::eInstance: return "Instance";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(PhysicalDeviceType value)
  {
    switch (value)
    {
    case PhysicalDeviceType::eOther: return "Other";
    case PhysicalDeviceType::eIntegratedGpu: return "IntegratedGpu";
    case PhysicalDeviceType::eDiscreteGpu: return "DiscreteGpu";
    case PhysicalDeviceType::eVirtualGpu: return "VirtualGpu";
    case PhysicalDeviceType::eCpu: return "Cpu";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(VertexInputRate value)
  {
    switch (value)
    {
    case VertexInputRate::eVertex: return "Vertex";
    case VertexInputRate::eInstance: return "Instance";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(Format value)
  {
    switch (value)
    {
    case Format::eUndefined: return "Undefined";
    case Format::eR4G4UnormPack8: return "R4G4UnormPack8";
    case Format::eR4G4B4A4UnormPack16: return "R4G4B4A4UnormPack16";
    case Format::eB4G4R4A4UnormPack16: return "B4G4R4A4UnormPack16";
    case Format::eR5G6B5UnormPack16: return "R5G6B5UnormPack16";
    case Format::eB5G6R5UnormPack16: return "B5G6R5UnormPack16";
    case Format::eR5G5B5A1UnormPack16: return "R5G5B5A1UnormPack16";
    case Format::eB5G5R5A1UnormPack16: return "B5G5R5A1UnormPack16";
    case Format::eA1R5G5B5UnormPack16: return "A1R5G5B5UnormPack16";
    case Format::eR8Unorm: return "R8Unorm";
    case Format::eR8Snorm: return "R8Snorm";
    case Format::eR8Uscaled: return "R8Uscaled";
    case Format::eR8Sscaled: return "R8Sscaled";
    case Format::eR8Uint: return "R8Uint";
    case Format::eR8Sint: return "R8Sint";
    case Format::eR8Srgb: return "R8Srgb";
    case Format::eR8G8Unorm: return "R8G8Unorm";
    case Format::eR8G8Snorm: return "R8G8Snorm";
    case Format::eR8G8Uscaled: return "R8G8Uscaled";
    case Format::eR8G8Sscaled: return "R8G8Sscaled";
    case Format::eR8G8Uint: return "R8G8Uint";
    case Format::eR8G8Sint: return "R8G8Sint";
    case Format::eR8G8Srgb: return "R8G8Srgb";
    case Format::eR8G8B8Unorm: return "R8G8B8Unorm";
    case Format::eR8G8B8Snorm: return "R8G8B8Snorm";
    case Format::eR8G8B8Uscaled: return "R8G8B8Uscaled";
    case Format::eR8G8B8Sscaled: return "R8G8B8Sscaled";
    case Format::eR8G8B8Uint: return "R8G8B8Uint";
    case Format::eR8G8B8Sint: return "R8G8B8Sint";
    case Format::eR8G8B8Srgb: return "R8G8B8Srgb";
    case Format::eB8G8R8Unorm: return "B8G8R8Unorm";
    case Format::eB8G8R8Snorm: return "B8G8R8Snorm";
    case Format::eB8G8R8Uscaled: return "B8G8R8Uscaled";
    case Format::eB8G8R8Sscaled: return "B8G8R8Sscaled";
    case Format::eB8G8R8Uint: return "B8G8R8Uint";
    case Format::eB8G8R8Sint: return "B8G8R8Sint";
    case Format::eB8G8R8Srgb: return "B8G8R8Srgb";
    case Format::eR8G8B8A8Unorm: return "R8G8B8A8Unorm";
    case Format::eR8G8B8A8Snorm: return "R8G8B8A8Snorm";
    case Format::eR8G8B8A8Uscaled: return "R8G8B8A8Uscaled";
    case Format::eR8G8B8A8Sscaled: return "R8G8B8A8Sscaled";
    case Format::eR8G8B8A8Uint: return "R8G8B8A8Uint";
    case Format::eR8G8B8A8Sint: return "R8G8B8A8Sint";
    case Format::eR8G8B8A8Srgb: return "R8G8B8A8Srgb";
    case Format::eB8G8R8A8Unorm: return "B8G8R8A8Unorm";
    case Format::eB8G8R8A8Snorm: return "B8G8R8A8Snorm";
    case Format::eB8G8R8A8Uscaled: return "B8G8R8A8Uscaled";
    case Format::eB8G8R8A8Sscaled: return "B8G8R8A8Sscaled";
    case Format::eB8G8R8A8Uint: return "B8G8R8A8Uint";
    case Format::eB8G8R8A8Sint: return "B8G8R8A8Sint";
    case Format::eB8G8R8A8Srgb: return "B8G8R8A8Srgb";
    case Format::eA8B8G8R8UnormPack32: return "A8B8G8R8UnormPack32";
    case Format::eA8B8G8R8SnormPack32: return "A8B8G8R8SnormPack32";
    case Format::eA8B8G8R8UscaledPack32: return "A8B8G8R8UscaledPack32";
    case Format::eA8B8G8R8SscaledPack32: return "A8B8G8R8SscaledPack32";
    case Format::eA8B8G8R8UintPack32: return "A8B8G8R8UintPack32";
    case Format::eA8B8G8R8SintPack32: return "A8B8G8R8SintPack32";
    case Format::eA8B8G8R8SrgbPack32: return "A8B8G8R8SrgbPack32";
    case Format::eA2R10G10B10UnormPack32: return "A2R10G10B10UnormPack32";
    case Format::eA2R10G10B10SnormPack32: return "A2R10G10B10SnormPack32";
    case Format::eA2R10G10B10UscaledPack32: return "A2R10G10B10UscaledPack32";
    case Format::eA2R10G10B10SscaledPack32: return "A2R10G10B10SscaledPack32";
    case Format::eA2R10G10B10UintPack32: return "A2R10G10B10UintPack32";
    case Format::eA2R10G10B10SintPack32: return "A2R10G10B10SintPack32";
    case Format::eA2B10G10R10UnormPack32: return "A2B10G10R10UnormPack32";
    case Format::eA2B10G10R10SnormPack32: return "A2B10G10R10SnormPack32";
    case Format::eA2B10G10R10UscaledPack32: return "A2B10G10R10UscaledPack32";
    case Format::eA2B10G10R10SscaledPack32: return "A2B10G10R10SscaledPack32";
    case Format::eA2B10G10R10UintPack32: return "A2B10G10R10UintPack32";
    case Format::eA2B10G10R10SintPack32: return "A2B10G10R10SintPack32";
    case Format::eR16Unorm: return "R16Unorm";
    case Format::eR16Snorm: return "R16Snorm";
    case Format::eR16Uscaled: return "R16Uscaled";
    case Format::eR16Sscaled: return "R16Sscaled";
    case Format::eR16Uint: return "R16Uint";
    case Format::eR16Sint: return "R16Sint";
    case Format::eR16Sfloat: return "R16Sfloat";
    case Format::eR16G16Unorm: return "R16G16Unorm";
    case Format::eR16G16Snorm: return "R16G16Snorm";
    case Format::eR16G16Uscaled: return "R16G16Uscaled";
    case Format::eR16G16Sscaled: return "R16G16Sscaled";
    case Format::eR16G16Uint: return "R16G16Uint";
    case Format::eR16G16Sint: return "R16G16Sint";
    case Format::eR16G16Sfloat: return "R16G16Sfloat";
    case Format::eR16G16B16Unorm: return "R16G16B16Unorm";
    case Format::eR16G16B16Snorm: return "R16G16B16Snorm";
    case Format::eR16G16B16Uscaled: return "R16G16B16Uscaled";
    case Format::eR16G16B16Sscaled: return "R16G16B16Sscaled";
    case Format::eR16G16B16Uint: return "R16G16B16Uint";
    case Format::eR16G16B16Sint: return "R16G16B16Sint";
    case Format::eR16G16B16Sfloat: return "R16G16B16Sfloat";
    case Format::eR16G16B16A16Unorm: return "R16G16B16A16Unorm";
    case Format::eR16G16B16A16Snorm: return "R16G16B16A16Snorm";
    case Format::eR16G16B16A16Uscaled: return "R16G16B16A16Uscaled";
    case Format::eR16G16B16A16Sscaled: return "R16G16B16A16Sscaled";
    case Format::eR16G16B16A16Uint: return "R16G16B16A16Uint";
    case Format::eR16G16B16A16Sint: return "R16G16B16A16Sint";
    case Format::eR16G16B16A16Sfloat: return "R16G16B16A16Sfloat";
    case Format::eR32Uint: return "R32Uint";
    case Format::eR32Sint: return "R32Sint";
    case Format::eR32Sfloat: return "R32Sfloat";
    case Format::eR32G32Uint: return "R32G32Uint";
    case Format::eR32G32Sint: return "R32G32Sint";
    case Format::eR32G32Sfloat: return "R32G32Sfloat";
    case Format::eR32G32B32Uint: return "R32G32B32Uint";
    case Format::eR32G32B32Sint: return "R32G32B32Sint";
    case Format::eR32G32B32Sfloat: return "R32G32B32Sfloat";
    case Format::eR32G32B32A32Uint: return "R32G32B32A32Uint";
    case Format::eR32G32B32A32Sint: return "R32G32B32A32Sint";
    case Format::eR32G32B32A32Sfloat: return "R32G32B32A32Sfloat";
    case Format::eR64Uint: return "R64Uint";
    case Format::eR64Sint: return "R64Sint";
    case Format::eR64Sfloat: return "R64Sfloat";
    case Format::eR64G64Uint: return "R64G64Uint";
    case Format::eR64G64Sint: return "R64G64Sint";
    case Format::eR64G64Sfloat: return "R64G64Sfloat";
    case Format::eR64G64B64Uint: return "R64G64B64Uint";
    case Format::eR64G64B64Sint: return "R64G64B64Sint";
    case Format::eR64G64B64Sfloat: return "R64G64B64Sfloat";
    case Format::eR64G64B64A64Uint: return "R64G64B64A64Uint";
    case Format::eR64G64B64A64Sint: return "R64G64B64A64Sint";
    case Format::eR64G64B64A64Sfloat: return "R64G64B64A64Sfloat";
    case Format::eB10G11R11UfloatPack32: return "B10G11R11UfloatPack32";
    case Format::eE5B9G9R9UfloatPack32: return "E5B9G9R9UfloatPack32";
    case Format::eD16Unorm: return "D16Unorm";
    case Format::eX8D24UnormPack32: return "X8D24UnormPack32";
    case Format::eD32Sfloat: return "D32Sfloat";
    case Format::eS8Uint: return "S8Uint";
    case Format::eD16UnormS8Uint: return "D16UnormS8Uint";
    case Format::eD24UnormS8Uint: return "D24UnormS8Uint";
    case Format::eD32SfloatS8Uint: return "D32SfloatS8Uint";
    case Format::eBc1RgbUnormBlock: return "Bc1RgbUnormBlock";
    case Format::eBc1RgbSrgbBlock: return "Bc1RgbSrgbBlock";
    case Format::eBc1RgbaUnormBlock: return "Bc1RgbaUnormBlock";
    case Format::eBc1RgbaSrgbBlock: return "Bc1RgbaSrgbBlock";
    case Format::eBc2UnormBlock: return "Bc2UnormBlock";
    case Format::eBc2SrgbBlock: return "Bc2SrgbBlock";
    case Format::eBc3UnormBlock: return "Bc3UnormBlock";
    case Format::eBc3SrgbBlock: return "Bc3SrgbBlock";
    case Format::eBc4UnormBlock: return "Bc4UnormBlock";
    case Format::eBc4SnormBlock: return "Bc4SnormBlock";
    case Format::eBc5UnormBlock: return "Bc5UnormBlock";
    case Format::eBc5SnormBlock: return "Bc5SnormBlock";
    case Format::eBc6HUfloatBlock: return "Bc6HUfloatBlock";
    case Format::eBc6HSfloatBlock: return "Bc6HSfloatBlock";
    case Format::eBc7UnormBlock: return "Bc7UnormBlock";
    case Format::eBc7SrgbBlock: return "Bc7SrgbBlock";
    case Format::eEtc2R8G8B8UnormBlock: return "Etc2R8G8B8UnormBlock";
    case Format::eEtc2R8G8B8SrgbBlock: return "Etc2R8G8B8SrgbBlock";
    case Format::eEtc2R8G8B8A1UnormBlock: return "Etc2R8G8B8A1UnormBlock";
    case Format::eEtc2R8G8B8A1SrgbBlock: return "Etc2R8G8B8A1SrgbBlock";
    case Format::eEtc2R8G8B8A8UnormBlock: return "Etc2R8G8B8A8UnormBlock";
    case Format::eEtc2R8G8B8A8SrgbBlock: return "Etc2R8G8B8A8SrgbBlock";
    case Format::eEacR11UnormBlock: return "EacR11UnormBlock";
    case Format::eEacR11SnormBlock: return "EacR11SnormBlock";
    case Format::eEacR11G11UnormBlock: return "EacR11G11UnormBlock";
    case Format::eEacR11G11SnormBlock: return "EacR11G11SnormBlock";
    case Format::eAstc4x4UnormBlock: return "Astc4x4UnormBlock";
    case Format::eAstc4x4SrgbBlock: return "Astc4x4SrgbBlock";
    case Format::eAstc5x4UnormBlock: return "Astc5x4UnormBlock";
    case Format::eAstc5x4SrgbBlock: return "Astc5x4SrgbBlock";
    case Format::eAstc5x5UnormBlock: return "Astc5x5UnormBlock";
    case Format::eAstc5x5SrgbBlock: return "Astc5x5SrgbBlock";
    case Format::eAstc6x5UnormBlock: return "Astc6x5UnormBlock";
    case Format::eAstc6x5SrgbBlock: return "Astc6x5SrgbBlock";
    case Format::eAstc6x6UnormBlock: return "Astc6x6UnormBlock";
    case Format::eAstc6x6SrgbBlock: return "Astc6x6SrgbBlock";
    case Format::eAstc8x5UnormBlock: return "Astc8x5UnormBlock";
    case Format::eAstc8x5SrgbBlock: return "Astc8x5SrgbBlock";
    case Format::eAstc8x6UnormBlock: return "Astc8x6UnormBlock";
    case Format::eAstc8x6SrgbBlock: return "Astc8x6SrgbBlock";
    case Format::eAstc8x8UnormBlock: return "Astc8x8UnormBlock";
    case Format::eAstc8x8SrgbBlock: return "Astc8x8SrgbBlock";
    case Format::eAstc10x5UnormBlock: return "Astc10x5UnormBlock";
    case Format::eAstc10x5SrgbBlock: return "Astc10x5SrgbBlock";
    case Format::eAstc10x6UnormBlock: return "Astc10x6UnormBlock";
    case Format::eAstc10x6SrgbBlock: return "Astc10x6SrgbBlock";
    case Format::eAstc10x8UnormBlock: return "Astc10x8UnormBlock";
    case Format::eAstc10x8SrgbBlock: return "Astc10x8SrgbBlock";
    case Format::eAstc10x10UnormBlock: return "Astc10x10UnormBlock";
    case Format::eAstc10x10SrgbBlock: return "Astc10x10SrgbBlock";
    case Format::eAstc12x10UnormBlock: return "Astc12x10UnormBlock";
    case Format::eAstc12x10SrgbBlock: return "Astc12x10SrgbBlock";
    case Format::eAstc12x12UnormBlock: return "Astc12x12UnormBlock";
    case Format::eAstc12x12SrgbBlock: return "Astc12x12SrgbBlock";
    case Format::eG8B8G8R8422Unorm: return "G8B8G8R8422Unorm";
    case Format::eB8G8R8G8422Unorm: return "B8G8R8G8422Unorm";
    case Format::eG8B8R83Plane420Unorm: return "G8B8R83Plane420Unorm";
    case Format::eG8B8R82Plane420Unorm: return "G8B8R82Plane420Unorm";
    case Format::eG8B8R83Plane422Unorm: return "G8B8R83Plane422Unorm";
    case Format::eG8B8R82Plane422Unorm: return "G8B8R82Plane422Unorm";
    case Format::eG8B8R83Plane444Unorm: return "G8B8R83Plane444Unorm";
    case Format::eR10X6UnormPack16: return "R10X6UnormPack16";
    case Format::eR10X6G10X6Unorm2Pack16: return "R10X6G10X6Unorm2Pack16";
    case Format::eR10X6G10X6B10X6A10X6Unorm4Pack16: return "R10X6G10X6B10X6A10X6Unorm4Pack16";
    case Format::eG10X6B10X6G10X6R10X6422Unorm4Pack16: return "G10X6B10X6G10X6R10X6422Unorm4Pack16";
    case Format::eB10X6G10X6R10X6G10X6422Unorm4Pack16: return "B10X6G10X6R10X6G10X6422Unorm4Pack16";
    case Format::eG10X6B10X6R10X63Plane420Unorm3Pack16: return "G10X6B10X6R10X63Plane420Unorm3Pack16";
    case Format::eG10X6B10X6R10X62Plane420Unorm3Pack16: return "G10X6B10X6R10X62Plane420Unorm3Pack16";
    case Format::eG10X6B10X6R10X63Plane422Unorm3Pack16: return "G10X6B10X6R10X63Plane422Unorm3Pack16";
    case Format::eG10X6B10X6R10X62Plane422Unorm3Pack16: return "G10X6B10X6R10X62Plane422Unorm3Pack16";
    case Format::eG10X6B10X6R10X63Plane444Unorm3Pack16: return "G10X6B10X6R10X63Plane444Unorm3Pack16";
    case Format::eR12X4UnormPack16: return "R12X4UnormPack16";
    case Format::eR12X4G12X4Unorm2Pack16: return "R12X4G12X4Unorm2Pack16";
    case Format::eR12X4G12X4B12X4A12X4Unorm4Pack16: return "R12X4G12X4B12X4A12X4Unorm4Pack16";
    case Format::eG12X4B12X4G12X4R12X4422Unorm4Pack16: return "G12X4B12X4G12X4R12X4422Unorm4Pack16";
    case Format::eB12X4G12X4R12X4G12X4422Unorm4Pack16: return "B12X4G12X4R12X4G12X4422Unorm4Pack16";
    case Format::eG12X4B12X4R12X43Plane420Unorm3Pack16: return "G12X4B12X4R12X43Plane420Unorm3Pack16";
    case Format::eG12X4B12X4R12X42Plane420Unorm3Pack16: return "G12X4B12X4R12X42Plane420Unorm3Pack16";
    case Format::eG12X4B12X4R12X43Plane422Unorm3Pack16: return "G12X4B12X4R12X43Plane422Unorm3Pack16";
    case Format::eG12X4B12X4R12X42Plane422Unorm3Pack16: return "G12X4B12X4R12X42Plane422Unorm3Pack16";
    case Format::eG12X4B12X4R12X43Plane444Unorm3Pack16: return "G12X4B12X4R12X43Plane444Unorm3Pack16";
    case Format::eG16B16G16R16422Unorm: return "G16B16G16R16422Unorm";
    case Format::eB16G16R16G16422Unorm: return "B16G16R16G16422Unorm";
    case Format::eG16B16R163Plane420Unorm: return "G16B16R163Plane420Unorm";
    case Format::eG16B16R162Plane420Unorm: return "G16B16R162Plane420Unorm";
    case Format::eG16B16R163Plane422Unorm: return "G16B16R163Plane422Unorm";
    case Format::eG16B16R162Plane422Unorm: return "G16B16R162Plane422Unorm";
    case Format::eG16B16R163Plane444Unorm: return "G16B16R163Plane444Unorm";
    case Format::ePvrtc12BppUnormBlockIMG: return "Pvrtc12BppUnormBlockIMG";
    case Format::ePvrtc14BppUnormBlockIMG: return "Pvrtc14BppUnormBlockIMG";
    case Format::ePvrtc22BppUnormBlockIMG: return "Pvrtc22BppUnormBlockIMG";
    case Format::ePvrtc24BppUnormBlockIMG: return "Pvrtc24BppUnormBlockIMG";
    case Format::ePvrtc12BppSrgbBlockIMG: return "Pvrtc12BppSrgbBlockIMG";
    case Format::ePvrtc14BppSrgbBlockIMG: return "Pvrtc14BppSrgbBlockIMG";
    case Format::ePvrtc22BppSrgbBlockIMG: return "Pvrtc22BppSrgbBlockIMG";
    case Format::ePvrtc24BppSrgbBlockIMG: return "Pvrtc24BppSrgbBlockIMG";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(StructureType value)
  {
    switch (value)
    {
    case StructureType::eApplicationInfo: return "ApplicationInfo";
    case StructureType::eInstanceCreateInfo: return "InstanceCreateInfo";
    case StructureType::eDeviceQueueCreateInfo: return "DeviceQueueCreateInfo";
    case StructureType::eDeviceCreateInfo: return "DeviceCreateInfo";
    case StructureType::eSubmitInfo: return "SubmitInfo";
    case StructureType::eMemoryAllocateInfo: return "MemoryAllocateInfo";
    case StructureType::eMappedMemoryRange: return "MappedMemoryRange";
    case StructureType::eBindSparseInfo: return "BindSparseInfo";
    case StructureType::eFenceCreateInfo: return "FenceCreateInfo";
    case StructureType::eSemaphoreCreateInfo: return "SemaphoreCreateInfo";
    case StructureType::eEventCreateInfo: return "EventCreateInfo";
    case StructureType::eQueryPoolCreateInfo: return "QueryPoolCreateInfo";
    case StructureType::eBufferCreateInfo: return "BufferCreateInfo";
    case StructureType::eBufferViewCreateInfo: return "BufferViewCreateInfo";
    case StructureType::eImageCreateInfo: return "ImageCreateInfo";
    case StructureType::eImageViewCreateInfo: return "ImageViewCreateInfo";
    case StructureType::eShaderModuleCreateInfo: return "ShaderModuleCreateInfo";
    case StructureType::ePipelineCacheCreateInfo: return "PipelineCacheCreateInfo";
    case StructureType::ePipelineShaderStageCreateInfo: return "PipelineShaderStageCreateInfo";
    case StructureType::ePipelineVertexInputStateCreateInfo: return "PipelineVertexInputStateCreateInfo";
    case StructureType::ePipelineInputAssemblyStateCreateInfo: return "PipelineInputAssemblyStateCreateInfo";
    case StructureType::ePipelineTessellationStateCreateInfo: return "PipelineTessellationStateCreateInfo";
    case StructureType::ePipelineViewportStateCreateInfo: return "PipelineViewportStateCreateInfo";
    case StructureType::ePipelineRasterizationStateCreateInfo: return "PipelineRasterizationStateCreateInfo";
    case StructureType::ePipelineMultisampleStateCreateInfo: return "PipelineMultisampleStateCreateInfo";
    case StructureType::ePipelineDepthStencilStateCreateInfo: return "PipelineDepthStencilStateCreateInfo";
    case StructureType::ePipelineColorBlendStateCreateInfo: return "PipelineColorBlendStateCreateInfo";
    case StructureType::ePipelineDynamicStateCreateInfo: return "PipelineDynamicStateCreateInfo";
    case StructureType::eGraphicsPipelineCreateInfo: return "GraphicsPipelineCreateInfo";
    case StructureType::eComputePipelineCreateInfo: return "ComputePipelineCreateInfo";
    case StructureType::ePipelineLayoutCreateInfo: return "PipelineLayoutCreateInfo";
    case StructureType::eSamplerCreateInfo: return "SamplerCreateInfo";
    case StructureType::eDescriptorSetLayoutCreateInfo: return "DescriptorSetLayoutCreateInfo";
    case StructureType::eDescriptorPoolCreateInfo: return "DescriptorPoolCreateInfo";
    case StructureType::eDescriptorSetAllocateInfo: return "DescriptorSetAllocateInfo";
    case StructureType::eWriteDescriptorSet: return "WriteDescriptorSet";
    case StructureType::eCopyDescriptorSet: return "CopyDescriptorSet";
    case StructureType::eFramebufferCreateInfo: return "FramebufferCreateInfo";
    case StructureType::eRenderPassCreateInfo: return "RenderPassCreateInfo";
    case StructureType::eCommandPoolCreateInfo: return "CommandPoolCreateInfo";
    case StructureType::eCommandBufferAllocateInfo: return "CommandBufferAllocateInfo";
    case StructureType::eCommandBufferInheritanceInfo: return "CommandBufferInheritanceInfo";
    case StructureType::eCommandBufferBeginInfo: return "CommandBufferBeginInfo";
    case StructureType::eRenderPassBeginInfo: return "RenderPassBeginInfo";
    case StructureType::eBufferMemoryBarrier: return "BufferMemoryBarrier";
    case StructureType::eImageMemoryBarrier: return "ImageMemoryBarrier";
    case StructureType::eMemoryBarrier: return "MemoryBarrier";
    case StructureType::eLoaderInstanceCreateInfo: return "LoaderInstanceCreateInfo";
    case StructureType::eLoaderDeviceCreateInfo: return "LoaderDeviceCreateInfo";
    case StructureType::ePhysicalDeviceSubgroupProperties: return "PhysicalDeviceSubgroupProperties";
    case StructureType::eBindBufferMemoryInfo: return "BindBufferMemoryInfo";
    case StructureType::eBindImageMemoryInfo: return "BindImageMemoryInfo";
    case StructureType::ePhysicalDevice16BitStorageFeatures: return "PhysicalDevice16BitStorageFeatures";
    case StructureType::eMemoryDedicatedRequirements: return "MemoryDedicatedRequirements";
    case StructureType::eMemoryDedicatedAllocateInfo: return "MemoryDedicatedAllocateInfo";
    case StructureType::eMemoryAllocateFlagsInfo: return "MemoryAllocateFlagsInfo";
    case StructureType::eDeviceGroupRenderPassBeginInfo: return "DeviceGroupRenderPassBeginInfo";
    case StructureType::eDeviceGroupCommandBufferBeginInfo: return "DeviceGroupCommandBufferBeginInfo";
    case StructureType::eDeviceGroupSubmitInfo: return "DeviceGroupSubmitInfo";
    case StructureType::eDeviceGroupBindSparseInfo: return "DeviceGroupBindSparseInfo";
    case StructureType::eBindBufferMemoryDeviceGroupInfo: return "BindBufferMemoryDeviceGroupInfo";
    case StructureType::eBindImageMemoryDeviceGroupInfo: return "BindImageMemoryDeviceGroupInfo";
    case StructureType::ePhysicalDeviceGroupProperties: return "PhysicalDeviceGroupProperties";
    case StructureType::eDeviceGroupDeviceCreateInfo: return "DeviceGroupDeviceCreateInfo";
    case StructureType::eBufferMemoryRequirementsInfo2: return "BufferMemoryRequirementsInfo2";
    case StructureType::eImageMemoryRequirementsInfo2: return "ImageMemoryRequirementsInfo2";
    case StructureType::eImageSparseMemoryRequirementsInfo2: return "ImageSparseMemoryRequirementsInfo2";
    case StructureType::eMemoryRequirements2: return "MemoryRequirements2";
    case StructureType::eSparseImageMemoryRequirements2: return "SparseImageMemoryRequirements2";
    case StructureType::ePhysicalDeviceFeatures2: return "PhysicalDeviceFeatures2";
    case StructureType::ePhysicalDeviceProperties2: return "PhysicalDeviceProperties2";
    case StructureType::eFormatProperties2: return "FormatProperties2";
    case StructureType::eImageFormatProperties2: return "ImageFormatProperties2";
    case StructureType::ePhysicalDeviceImageFormatInfo2: return "PhysicalDeviceImageFormatInfo2";
    case StructureType::eQueueFamilyProperties2: return "QueueFamilyProperties2";
    case StructureType::ePhysicalDeviceMemoryProperties2: return "PhysicalDeviceMemoryProperties2";
    case StructureType::eSparseImageFormatProperties2: return "SparseImageFormatProperties2";
    case StructureType::ePhysicalDeviceSparseImageFormatInfo2: return "PhysicalDeviceSparseImageFormatInfo2";
    case StructureType::ePhysicalDevicePointClippingProperties: return "PhysicalDevicePointClippingProperties";
    case StructureType::eRenderPassInputAttachmentAspectCreateInfo: return "RenderPassInputAttachmentAspectCreateInfo";
    case StructureType::eImageViewUsageCreateInfo: return "ImageViewUsageCreateInfo";
    case StructureType::ePipelineTessellationDomainOriginStateCreateInfo: return "PipelineTessellationDomainOriginStateCreateInfo";
    case StructureType::eRenderPassMultiviewCreateInfo: return "RenderPassMultiviewCreateInfo";
    case StructureType::ePhysicalDeviceMultiviewFeatures: return "PhysicalDeviceMultiviewFeatures";
    case StructureType::ePhysicalDeviceMultiviewProperties: return "PhysicalDeviceMultiviewProperties";
    case StructureType::ePhysicalDeviceVariablePointerFeatures: return "PhysicalDeviceVariablePointerFeatures";
    case StructureType::eProtectedSubmitInfo: return "ProtectedSubmitInfo";
    case StructureType::ePhysicalDeviceProtectedMemoryFeatures: return "PhysicalDeviceProtectedMemoryFeatures";
    case StructureType::ePhysicalDeviceProtectedMemoryProperties: return "PhysicalDeviceProtectedMemoryProperties";
    case StructureType::eDeviceQueueInfo2: return "DeviceQueueInfo2";
    case StructureType::eSamplerYcbcrConversionCreateInfo: return "SamplerYcbcrConversionCreateInfo";
    case StructureType::eSamplerYcbcrConversionInfo: return "SamplerYcbcrConversionInfo";
    case StructureType::eBindImagePlaneMemoryInfo: return "BindImagePlaneMemoryInfo";
    case StructureType::eImagePlaneMemoryRequirementsInfo: return "ImagePlaneMemoryRequirementsInfo";
    case StructureType::ePhysicalDeviceSamplerYcbcrConversionFeatures: return "PhysicalDeviceSamplerYcbcrConversionFeatures";
    case StructureType::eSamplerYcbcrConversionImageFormatProperties: return "SamplerYcbcrConversionImageFormatProperties";
    case StructureType::eDescriptorUpdateTemplateCreateInfo: return "DescriptorUpdateTemplateCreateInfo";
    case StructureType::ePhysicalDeviceExternalImageFormatInfo: return "PhysicalDeviceExternalImageFormatInfo";
    case StructureType::eExternalImageFormatProperties: return "ExternalImageFormatProperties";
    case StructureType::ePhysicalDeviceExternalBufferInfo: return "PhysicalDeviceExternalBufferInfo";
    case StructureType::eExternalBufferProperties: return "ExternalBufferProperties";
    case StructureType::ePhysicalDeviceIdProperties: return "PhysicalDeviceIdProperties";
    case StructureType::eExternalMemoryBufferCreateInfo: return "ExternalMemoryBufferCreateInfo";
    case StructureType::eExternalMemoryImageCreateInfo: return "ExternalMemoryImageCreateInfo";
    case StructureType::eExportMemoryAllocateInfo: return "ExportMemoryAllocateInfo";
    case StructureType::ePhysicalDeviceExternalFenceInfo: return "PhysicalDeviceExternalFenceInfo";
    case StructureType::eExternalFenceProperties: return "ExternalFenceProperties";
    case StructureType::eExportFenceCreateInfo: return "ExportFenceCreateInfo";
    case StructureType::eExportSemaphoreCreateInfo: return "ExportSemaphoreCreateInfo";
    case StructureType::ePhysicalDeviceExternalSemaphoreInfo: return "PhysicalDeviceExternalSemaphoreInfo";
    case StructureType::eExternalSemaphoreProperties: return "ExternalSemaphoreProperties";
    case StructureType::ePhysicalDeviceMaintenance3Properties: return "PhysicalDeviceMaintenance3Properties";
    case StructureType::eDescriptorSetLayoutSupport: return "DescriptorSetLayoutSupport";
    case StructureType::ePhysicalDeviceShaderDrawParameterFeatures: return "PhysicalDeviceShaderDrawParameterFeatures";
    case StructureType::eSwapchainCreateInfoKHR: return "SwapchainCreateInfoKHR";
    case StructureType::ePresentInfoKHR: return "PresentInfoKHR";
    case StructureType::eDeviceGroupPresentCapabilitiesKHR: return "DeviceGroupPresentCapabilitiesKHR";
    case StructureType::eImageSwapchainCreateInfoKHR: return "ImageSwapchainCreateInfoKHR";
    case StructureType::eBindImageMemorySwapchainInfoKHR: return "BindImageMemorySwapchainInfoKHR";
    case StructureType::eAcquireNextImageInfoKHR: return "AcquireNextImageInfoKHR";
    case StructureType::eDeviceGroupPresentInfoKHR: return "DeviceGroupPresentInfoKHR";
    case StructureType::eDeviceGroupSwapchainCreateInfoKHR: return "DeviceGroupSwapchainCreateInfoKHR";
    case StructureType::eDisplayModeCreateInfoKHR: return "DisplayModeCreateInfoKHR";
    case StructureType::eDisplaySurfaceCreateInfoKHR: return "DisplaySurfaceCreateInfoKHR";
    case StructureType::eDisplayPresentInfoKHR: return "DisplayPresentInfoKHR";
    case StructureType::eXlibSurfaceCreateInfoKHR: return "XlibSurfaceCreateInfoKHR";
    case StructureType::eXcbSurfaceCreateInfoKHR: return "XcbSurfaceCreateInfoKHR";
    case StructureType::eWaylandSurfaceCreateInfoKHR: return "WaylandSurfaceCreateInfoKHR";
    case StructureType::eMirSurfaceCreateInfoKHR: return "MirSurfaceCreateInfoKHR";
    case StructureType::eAndroidSurfaceCreateInfoKHR: return "AndroidSurfaceCreateInfoKHR";
    case StructureType::eWin32SurfaceCreateInfoKHR: return "Win32SurfaceCreateInfoKHR";
    case StructureType::eDebugReportCallbackCreateInfoEXT: return "DebugReportCallbackCreateInfoEXT";
    case StructureType::ePipelineRasterizationStateRasterizationOrderAMD: return "PipelineRasterizationStateRasterizationOrderAMD";
    case StructureType::eDebugMarkerObjectNameInfoEXT: return "DebugMarkerObjectNameInfoEXT";
    case StructureType::eDebugMarkerObjectTagInfoEXT: return "DebugMarkerObjectTagInfoEXT";
    case StructureType::eDebugMarkerMarkerInfoEXT: return "DebugMarkerMarkerInfoEXT";
    case StructureType::eDedicatedAllocationImageCreateInfoNV: return "DedicatedAllocationImageCreateInfoNV";
    case StructureType::eDedicatedAllocationBufferCreateInfoNV: return "DedicatedAllocationBufferCreateInfoNV";
    case StructureType::eDedicatedAllocationMemoryAllocateInfoNV: return "DedicatedAllocationMemoryAllocateInfoNV";
    case StructureType::eTextureLodGatherFormatPropertiesAMD: return "TextureLodGatherFormatPropertiesAMD";
    case StructureType::ePhysicalDeviceCornerSampledImageFeaturesNV: return "PhysicalDeviceCornerSampledImageFeaturesNV";
    case StructureType::eExternalMemoryImageCreateInfoNV: return "ExternalMemoryImageCreateInfoNV";
    case StructureType::eExportMemoryAllocateInfoNV: return "ExportMemoryAllocateInfoNV";
    case StructureType::eImportMemoryWin32HandleInfoNV: return "ImportMemoryWin32HandleInfoNV";
    case StructureType::eExportMemoryWin32HandleInfoNV: return "ExportMemoryWin32HandleInfoNV";
    case StructureType::eWin32KeyedMutexAcquireReleaseInfoNV: return "Win32KeyedMutexAcquireReleaseInfoNV";
    case StructureType::eValidationFlagsEXT: return "ValidationFlagsEXT";
    case StructureType::eViSurfaceCreateInfoNN: return "ViSurfaceCreateInfoNN";
    case StructureType::eImageViewAstcDecodeModeEXT: return "ImageViewAstcDecodeModeEXT";
    case StructureType::ePhysicalDeviceAstcDecodeFeaturesEXT: return "PhysicalDeviceAstcDecodeFeaturesEXT";
    case StructureType::eImportMemoryWin32HandleInfoKHR: return "ImportMemoryWin32HandleInfoKHR";
    case StructureType::eExportMemoryWin32HandleInfoKHR: return "ExportMemoryWin32HandleInfoKHR";
    case StructureType::eMemoryWin32HandlePropertiesKHR: return "MemoryWin32HandlePropertiesKHR";
    case StructureType::eMemoryGetWin32HandleInfoKHR: return "MemoryGetWin32HandleInfoKHR";
    case StructureType::eImportMemoryFdInfoKHR: return "ImportMemoryFdInfoKHR";
    case StructureType::eMemoryFdPropertiesKHR: return "MemoryFdPropertiesKHR";
    case StructureType::eMemoryGetFdInfoKHR: return "MemoryGetFdInfoKHR";
    case StructureType::eWin32KeyedMutexAcquireReleaseInfoKHR: return "Win32KeyedMutexAcquireReleaseInfoKHR";
    case StructureType::eImportSemaphoreWin32HandleInfoKHR: return "ImportSemaphoreWin32HandleInfoKHR";
    case StructureType::eExportSemaphoreWin32HandleInfoKHR: return "ExportSemaphoreWin32HandleInfoKHR";
    case StructureType::eD3D12FenceSubmitInfoKHR: return "D3D12FenceSubmitInfoKHR";
    case StructureType::eSemaphoreGetWin32HandleInfoKHR: return "SemaphoreGetWin32HandleInfoKHR";
    case StructureType::eImportSemaphoreFdInfoKHR: return "ImportSemaphoreFdInfoKHR";
    case StructureType::eSemaphoreGetFdInfoKHR: return "SemaphoreGetFdInfoKHR";
    case StructureType::ePhysicalDevicePushDescriptorPropertiesKHR: return "PhysicalDevicePushDescriptorPropertiesKHR";
    case StructureType::eCommandBufferInheritanceConditionalRenderingInfoEXT: return "CommandBufferInheritanceConditionalRenderingInfoEXT";
    case StructureType::ePhysicalDeviceConditionalRenderingFeaturesEXT: return "PhysicalDeviceConditionalRenderingFeaturesEXT";
    case StructureType::eConditionalRenderingBeginInfoEXT: return "ConditionalRenderingBeginInfoEXT";
    case StructureType::ePresentRegionsKHR: return "PresentRegionsKHR";
    case StructureType::eObjectTableCreateInfoNVX: return "ObjectTableCreateInfoNVX";
    case StructureType::eIndirectCommandsLayoutCreateInfoNVX: return "IndirectCommandsLayoutCreateInfoNVX";
    case StructureType::eCmdProcessCommandsInfoNVX: return "CmdProcessCommandsInfoNVX";
    case StructureType::eCmdReserveSpaceForCommandsInfoNVX: return "CmdReserveSpaceForCommandsInfoNVX";
    case StructureType::eDeviceGeneratedCommandsLimitsNVX: return "DeviceGeneratedCommandsLimitsNVX";
    case StructureType::eDeviceGeneratedCommandsFeaturesNVX: return "DeviceGeneratedCommandsFeaturesNVX";
    case StructureType::ePipelineViewportWScalingStateCreateInfoNV: return "PipelineViewportWScalingStateCreateInfoNV";
    case StructureType::eSurfaceCapabilities2EXT: return "SurfaceCapabilities2EXT";
    case StructureType::eDisplayPowerInfoEXT: return "DisplayPowerInfoEXT";
    case StructureType::eDeviceEventInfoEXT: return "DeviceEventInfoEXT";
    case StructureType::eDisplayEventInfoEXT: return "DisplayEventInfoEXT";
    case StructureType::eSwapchainCounterCreateInfoEXT: return "SwapchainCounterCreateInfoEXT";
    case StructureType::ePresentTimesInfoGOOGLE: return "PresentTimesInfoGOOGLE";
    case StructureType::ePhysicalDeviceMultiviewPerViewAttributesPropertiesNVX: return "PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX";
    case StructureType::ePipelineViewportSwizzleStateCreateInfoNV: return "PipelineViewportSwizzleStateCreateInfoNV";
    case StructureType::ePhysicalDeviceDiscardRectanglePropertiesEXT: return "PhysicalDeviceDiscardRectanglePropertiesEXT";
    case StructureType::ePipelineDiscardRectangleStateCreateInfoEXT: return "PipelineDiscardRectangleStateCreateInfoEXT";
    case StructureType::ePhysicalDeviceConservativeRasterizationPropertiesEXT: return "PhysicalDeviceConservativeRasterizationPropertiesEXT";
    case StructureType::ePipelineRasterizationConservativeStateCreateInfoEXT: return "PipelineRasterizationConservativeStateCreateInfoEXT";
    case StructureType::eHdrMetadataEXT: return "HdrMetadataEXT";
    case StructureType::eAttachmentDescription2KHR: return "AttachmentDescription2KHR";
    case StructureType::eAttachmentReference2KHR: return "AttachmentReference2KHR";
    case StructureType::eSubpassDescription2KHR: return "SubpassDescription2KHR";
    case StructureType::eSubpassDependency2KHR: return "SubpassDependency2KHR";
    case StructureType::eRenderPassCreateInfo2KHR: return "RenderPassCreateInfo2KHR";
    case StructureType::eSubpassBeginInfoKHR: return "SubpassBeginInfoKHR";
    case StructureType::eSubpassEndInfoKHR: return "SubpassEndInfoKHR";
    case StructureType::eSharedPresentSurfaceCapabilitiesKHR: return "SharedPresentSurfaceCapabilitiesKHR";
    case StructureType::eImportFenceWin32HandleInfoKHR: return "ImportFenceWin32HandleInfoKHR";
    case StructureType::eExportFenceWin32HandleInfoKHR: return "ExportFenceWin32HandleInfoKHR";
    case StructureType::eFenceGetWin32HandleInfoKHR: return "FenceGetWin32HandleInfoKHR";
    case StructureType::eImportFenceFdInfoKHR: return "ImportFenceFdInfoKHR";
    case StructureType::eFenceGetFdInfoKHR: return "FenceGetFdInfoKHR";
    case StructureType::ePhysicalDeviceSurfaceInfo2KHR: return "PhysicalDeviceSurfaceInfo2KHR";
    case StructureType::eSurfaceCapabilities2KHR: return "SurfaceCapabilities2KHR";
    case StructureType::eSurfaceFormat2KHR: return "SurfaceFormat2KHR";
    case StructureType::eDisplayProperties2KHR: return "DisplayProperties2KHR";
    case StructureType::eDisplayPlaneProperties2KHR: return "DisplayPlaneProperties2KHR";
    case StructureType::eDisplayModeProperties2KHR: return "DisplayModeProperties2KHR";
    case StructureType::eDisplayPlaneInfo2KHR: return "DisplayPlaneInfo2KHR";
    case StructureType::eDisplayPlaneCapabilities2KHR: return "DisplayPlaneCapabilities2KHR";
    case StructureType::eIosSurfaceCreateInfoMVK: return "IosSurfaceCreateInfoMVK";
    case StructureType::eMacosSurfaceCreateInfoMVK: return "MacosSurfaceCreateInfoMVK";
    case StructureType::eDebugUtilsObjectNameInfoEXT: return "DebugUtilsObjectNameInfoEXT";
    case StructureType::eDebugUtilsObjectTagInfoEXT: return "DebugUtilsObjectTagInfoEXT";
    case StructureType::eDebugUtilsLabelEXT: return "DebugUtilsLabelEXT";
    case StructureType::eDebugUtilsMessengerCallbackDataEXT: return "DebugUtilsMessengerCallbackDataEXT";
    case StructureType::eDebugUtilsMessengerCreateInfoEXT: return "DebugUtilsMessengerCreateInfoEXT";
    case StructureType::eAndroidHardwareBufferUsageANDROID: return "AndroidHardwareBufferUsageANDROID";
    case StructureType::eAndroidHardwareBufferPropertiesANDROID: return "AndroidHardwareBufferPropertiesANDROID";
    case StructureType::eAndroidHardwareBufferFormatPropertiesANDROID: return "AndroidHardwareBufferFormatPropertiesANDROID";
    case StructureType::eImportAndroidHardwareBufferInfoANDROID: return "ImportAndroidHardwareBufferInfoANDROID";
    case StructureType::eMemoryGetAndroidHardwareBufferInfoANDROID: return "MemoryGetAndroidHardwareBufferInfoANDROID";
    case StructureType::eExternalFormatANDROID: return "ExternalFormatANDROID";
    case StructureType::ePhysicalDeviceSamplerFilterMinmaxPropertiesEXT: return "PhysicalDeviceSamplerFilterMinmaxPropertiesEXT";
    case StructureType::eSamplerReductionModeCreateInfoEXT: return "SamplerReductionModeCreateInfoEXT";
    case StructureType::ePhysicalDeviceInlineUniformBlockFeaturesEXT: return "PhysicalDeviceInlineUniformBlockFeaturesEXT";
    case StructureType::ePhysicalDeviceInlineUniformBlockPropertiesEXT: return "PhysicalDeviceInlineUniformBlockPropertiesEXT";
    case StructureType::eWriteDescriptorSetInlineUniformBlockEXT: return "WriteDescriptorSetInlineUniformBlockEXT";
    case StructureType::eDescriptorPoolInlineUniformBlockCreateInfoEXT: return "DescriptorPoolInlineUniformBlockCreateInfoEXT";
    case StructureType::eSampleLocationsInfoEXT: return "SampleLocationsInfoEXT";
    case StructureType::eRenderPassSampleLocationsBeginInfoEXT: return "RenderPassSampleLocationsBeginInfoEXT";
    case StructureType::ePipelineSampleLocationsStateCreateInfoEXT: return "PipelineSampleLocationsStateCreateInfoEXT";
    case StructureType::ePhysicalDeviceSampleLocationsPropertiesEXT: return "PhysicalDeviceSampleLocationsPropertiesEXT";
    case StructureType::eMultisamplePropertiesEXT: return "MultisamplePropertiesEXT";
    case StructureType::eImageFormatListCreateInfoKHR: return "ImageFormatListCreateInfoKHR";
    case StructureType::ePhysicalDeviceBlendOperationAdvancedFeaturesEXT: return "PhysicalDeviceBlendOperationAdvancedFeaturesEXT";
    case StructureType::ePhysicalDeviceBlendOperationAdvancedPropertiesEXT: return "PhysicalDeviceBlendOperationAdvancedPropertiesEXT";
    case StructureType::ePipelineColorBlendAdvancedStateCreateInfoEXT: return "PipelineColorBlendAdvancedStateCreateInfoEXT";
    case StructureType::ePipelineCoverageToColorStateCreateInfoNV: return "PipelineCoverageToColorStateCreateInfoNV";
    case StructureType::ePipelineCoverageModulationStateCreateInfoNV: return "PipelineCoverageModulationStateCreateInfoNV";
    case StructureType::eValidationCacheCreateInfoEXT: return "ValidationCacheCreateInfoEXT";
    case StructureType::eShaderModuleValidationCacheCreateInfoEXT: return "ShaderModuleValidationCacheCreateInfoEXT";
    case StructureType::eDescriptorSetLayoutBindingFlagsCreateInfoEXT: return "DescriptorSetLayoutBindingFlagsCreateInfoEXT";
    case StructureType::ePhysicalDeviceDescriptorIndexingFeaturesEXT: return "PhysicalDeviceDescriptorIndexingFeaturesEXT";
    case StructureType::ePhysicalDeviceDescriptorIndexingPropertiesEXT: return "PhysicalDeviceDescriptorIndexingPropertiesEXT";
    case StructureType::eDescriptorSetVariableDescriptorCountAllocateInfoEXT: return "DescriptorSetVariableDescriptorCountAllocateInfoEXT";
    case StructureType::eDescriptorSetVariableDescriptorCountLayoutSupportEXT: return "DescriptorSetVariableDescriptorCountLayoutSupportEXT";
    case StructureType::ePipelineViewportShadingRateImageStateCreateInfoNV: return "PipelineViewportShadingRateImageStateCreateInfoNV";
    case StructureType::ePhysicalDeviceShadingRateImageFeaturesNV: return "PhysicalDeviceShadingRateImageFeaturesNV";
    case StructureType::ePhysicalDeviceShadingRateImagePropertiesNV: return "PhysicalDeviceShadingRateImagePropertiesNV";
    case StructureType::ePipelineViewportCoarseSampleOrderStateCreateInfoNV: return "PipelineViewportCoarseSampleOrderStateCreateInfoNV";
    case StructureType::eRaytracingPipelineCreateInfoNVX: return "RaytracingPipelineCreateInfoNVX";
    case StructureType::eAccelerationStructureCreateInfoNVX: return "AccelerationStructureCreateInfoNVX";
    case StructureType::eGeometryInstanceNVX: return "GeometryInstanceNVX";
    case StructureType::eGeometryNVX: return "GeometryNVX";
    case StructureType::eGeometryTrianglesNVX: return "GeometryTrianglesNVX";
    case StructureType::eGeometryAabbNVX: return "GeometryAabbNVX";
    case StructureType::eBindAccelerationStructureMemoryInfoNVX: return "BindAccelerationStructureMemoryInfoNVX";
    case StructureType::eDescriptorAccelerationStructureInfoNVX: return "DescriptorAccelerationStructureInfoNVX";
    case StructureType::eAccelerationStructureMemoryRequirementsInfoNVX: return "AccelerationStructureMemoryRequirementsInfoNVX";
    case StructureType::ePhysicalDeviceRaytracingPropertiesNVX: return "PhysicalDeviceRaytracingPropertiesNVX";
    case StructureType::eHitShaderModuleCreateInfoNVX: return "HitShaderModuleCreateInfoNVX";
    case StructureType::ePhysicalDeviceRepresentativeFragmentTestFeaturesNV: return "PhysicalDeviceRepresentativeFragmentTestFeaturesNV";
    case StructureType::ePipelineRepresentativeFragmentTestStateCreateInfoNV: return "PipelineRepresentativeFragmentTestStateCreateInfoNV";
    case StructureType::eDeviceQueueGlobalPriorityCreateInfoEXT: return "DeviceQueueGlobalPriorityCreateInfoEXT";
    case StructureType::ePhysicalDevice8BitStorageFeaturesKHR: return "PhysicalDevice8BitStorageFeaturesKHR";
    case StructureType::eImportMemoryHostPointerInfoEXT: return "ImportMemoryHostPointerInfoEXT";
    case StructureType::eMemoryHostPointerPropertiesEXT: return "MemoryHostPointerPropertiesEXT";
    case StructureType::ePhysicalDeviceExternalMemoryHostPropertiesEXT: return "PhysicalDeviceExternalMemoryHostPropertiesEXT";
    case StructureType::ePhysicalDeviceShaderCorePropertiesAMD: return "PhysicalDeviceShaderCorePropertiesAMD";
    case StructureType::ePhysicalDeviceVertexAttributeDivisorPropertiesEXT: return "PhysicalDeviceVertexAttributeDivisorPropertiesEXT";
    case StructureType::ePipelineVertexInputDivisorStateCreateInfoEXT: return "PipelineVertexInputDivisorStateCreateInfoEXT";
    case StructureType::ePhysicalDeviceVertexAttributeDivisorFeaturesEXT: return "PhysicalDeviceVertexAttributeDivisorFeaturesEXT";
    case StructureType::ePhysicalDeviceComputeShaderDerivativesFeaturesNV: return "PhysicalDeviceComputeShaderDerivativesFeaturesNV";
    case StructureType::ePhysicalDeviceMeshShaderFeaturesNV: return "PhysicalDeviceMeshShaderFeaturesNV";
    case StructureType::ePhysicalDeviceMeshShaderPropertiesNV: return "PhysicalDeviceMeshShaderPropertiesNV";
    case StructureType::ePhysicalDeviceFragmentShaderBarycentricFeaturesNV: return "PhysicalDeviceFragmentShaderBarycentricFeaturesNV";
    case StructureType::ePhysicalDeviceShaderImageFootprintFeaturesNV: return "PhysicalDeviceShaderImageFootprintFeaturesNV";
    case StructureType::ePipelineViewportExclusiveScissorStateCreateInfoNV: return "PipelineViewportExclusiveScissorStateCreateInfoNV";
    case StructureType::ePhysicalDeviceExclusiveScissorFeaturesNV: return "PhysicalDeviceExclusiveScissorFeaturesNV";
    case StructureType::eCheckpointDataNV: return "CheckpointDataNV";
    case StructureType::eQueueFamilyCheckpointPropertiesNV: return "QueueFamilyCheckpointPropertiesNV";
    case StructureType::ePhysicalDeviceVulkanMemoryModelFeaturesKHR: return "PhysicalDeviceVulkanMemoryModelFeaturesKHR";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SubpassContents value)
  {
    switch (value)
    {
    case SubpassContents::eInline: return "Inline";
    case SubpassContents::eSecondaryCommandBuffers: return "SecondaryCommandBuffers";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DynamicState value)
  {
    switch (value)
    {
    case DynamicState::eViewport: return "Viewport";
    case DynamicState::eScissor: return "Scissor";
    case DynamicState::eLineWidth: return "LineWidth";
    case DynamicState::eDepthBias: return "DepthBias";
    case DynamicState::eBlendConstants: return "BlendConstants";
    case DynamicState::eDepthBounds: return "DepthBounds";
    case DynamicState::eStencilCompareMask: return "StencilCompareMask";
    case DynamicState::eStencilWriteMask: return "StencilWriteMask";
    case DynamicState::eStencilReference: return "StencilReference";
    case DynamicState::eViewportWScalingNV: return "ViewportWScalingNV";
    case DynamicState::eDiscardRectangleEXT: return "DiscardRectangleEXT";
    case DynamicState::eSampleLocationsEXT: return "SampleLocationsEXT";
    case DynamicState::eViewportShadingRatePaletteNV: return "ViewportShadingRatePaletteNV";
    case DynamicState::eViewportCoarseSampleOrderNV: return "ViewportCoarseSampleOrderNV";
    case DynamicState::eExclusiveScissorNV: return "ExclusiveScissorNV";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorUpdateTemplateType value)
  {
    switch (value)
    {
    case DescriptorUpdateTemplateType::eDescriptorSet: return "DescriptorSet";
    case DescriptorUpdateTemplateType::ePushDescriptorsKHR: return "PushDescriptorsKHR";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ObjectType value)
  {
    switch (value)
    {
    case ObjectType::eUnknown: return "Unknown";
    case ObjectType::eInstance: return "Instance";
    case ObjectType::ePhysicalDevice: return "PhysicalDevice";
    case ObjectType::eDevice: return "Device";
    case ObjectType::eQueue: return "Queue";
    case ObjectType::eSemaphore: return "Semaphore";
    case ObjectType::eCommandBuffer: return "CommandBuffer";
    case ObjectType::eFence: return "Fence";
    case ObjectType::eDeviceMemory: return "DeviceMemory";
    case ObjectType::eBuffer: return "Buffer";
    case ObjectType::eImage: return "Image";
    case ObjectType::eEvent: return "Event";
    case ObjectType::eQueryPool: return "QueryPool";
    case ObjectType::eBufferView: return "BufferView";
    case ObjectType::eImageView: return "ImageView";
    case ObjectType::eShaderModule: return "ShaderModule";
    case ObjectType::ePipelineCache: return "PipelineCache";
    case ObjectType::ePipelineLayout: return "PipelineLayout";
    case ObjectType::eRenderPass: return "RenderPass";
    case ObjectType::ePipeline: return "Pipeline";
    case ObjectType::eDescriptorSetLayout: return "DescriptorSetLayout";
    case ObjectType::eSampler: return "Sampler";
    case ObjectType::eDescriptorPool: return "DescriptorPool";
    case ObjectType::eDescriptorSet: return "DescriptorSet";
    case ObjectType::eFramebuffer: return "Framebuffer";
    case ObjectType::eCommandPool: return "CommandPool";
    case ObjectType::eSamplerYcbcrConversion: return "SamplerYcbcrConversion";
    case ObjectType::eDescriptorUpdateTemplate: return "DescriptorUpdateTemplate";
    case ObjectType::eSurfaceKHR: return "SurfaceKHR";
    case ObjectType::eSwapchainKHR: return "SwapchainKHR";
    case ObjectType::eDisplayKHR: return "DisplayKHR";
    case ObjectType::eDisplayModeKHR: return "DisplayModeKHR";
    case ObjectType::eDebugReportCallbackEXT: return "DebugReportCallbackEXT";
    case ObjectType::eObjectTableNVX: return "ObjectTableNVX";
    case ObjectType::eIndirectCommandsLayoutNVX: return "IndirectCommandsLayoutNVX";
    case ObjectType::eDebugUtilsMessengerEXT: return "DebugUtilsMessengerEXT";
    case ObjectType::eValidationCacheEXT: return "ValidationCacheEXT";
    case ObjectType::eAccelerationStructureNVX: return "AccelerationStructureNVX";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(QueueFlagBits value)
  {
    switch (value)
    {
    case QueueFlagBits::eGraphics: return "Graphics";
    case QueueFlagBits::eCompute: return "Compute";
    case QueueFlagBits::eTransfer: return "Transfer";
    case QueueFlagBits::eSparseBinding: return "SparseBinding";
    case QueueFlagBits::eProtected: return "Protected";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(QueueFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & QueueFlagBits::eGraphics) result += "Graphics | ";
    if (value & QueueFlagBits::eCompute) result += "Compute | ";
    if (value & QueueFlagBits::eTransfer) result += "Transfer | ";
    if (value & QueueFlagBits::eSparseBinding) result += "SparseBinding | ";
    if (value & QueueFlagBits::eProtected) result += "Protected | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(DeviceQueueCreateFlagBits value)
  {
    switch (value)
    {
    case DeviceQueueCreateFlagBits::eProtected: return "Protected";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DeviceQueueCreateFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DeviceQueueCreateFlagBits::eProtected) result += "Protected | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(MemoryPropertyFlagBits value)
  {
    switch (value)
    {
    case MemoryPropertyFlagBits::eDeviceLocal: return "DeviceLocal";
    case MemoryPropertyFlagBits::eHostVisible: return "HostVisible";
    case MemoryPropertyFlagBits::eHostCoherent: return "HostCoherent";
    case MemoryPropertyFlagBits::eHostCached: return "HostCached";
    case MemoryPropertyFlagBits::eLazilyAllocated: return "LazilyAllocated";
    case MemoryPropertyFlagBits::eProtected: return "Protected";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(MemoryPropertyFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & MemoryPropertyFlagBits::eDeviceLocal) result += "DeviceLocal | ";
    if (value & MemoryPropertyFlagBits::eHostVisible) result += "HostVisible | ";
    if (value & MemoryPropertyFlagBits::eHostCoherent) result += "HostCoherent | ";
    if (value & MemoryPropertyFlagBits::eHostCached) result += "HostCached | ";
    if (value & MemoryPropertyFlagBits::eLazilyAllocated) result += "LazilyAllocated | ";
    if (value & MemoryPropertyFlagBits::eProtected) result += "Protected | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(MemoryHeapFlagBits value)
  {
    switch (value)
    {
    case MemoryHeapFlagBits::eDeviceLocal: return "DeviceLocal";
    case MemoryHeapFlagBits::eMultiInstance: return "MultiInstance";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(MemoryHeapFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & MemoryHeapFlagBits::eDeviceLocal) result += "DeviceLocal | ";
    if (value & MemoryHeapFlagBits::eMultiInstance) result += "MultiInstance | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(AccessFlagBits value)
  {
    switch (value)
    {
    case AccessFlagBits::eIndirectCommandRead: return "IndirectCommandRead";
    case AccessFlagBits::eIndexRead: return "IndexRead";
    case AccessFlagBits::eVertexAttributeRead: return "VertexAttributeRead";
    case AccessFlagBits::eUniformRead: return "UniformRead";
    case AccessFlagBits::eInputAttachmentRead: return "InputAttachmentRead";
    case AccessFlagBits::eShaderRead: return "ShaderRead";
    case AccessFlagBits::eShaderWrite: return "ShaderWrite";
    case AccessFlagBits::eColorAttachmentRead: return "ColorAttachmentRead";
    case AccessFlagBits::eColorAttachmentWrite: return "ColorAttachmentWrite";
    case AccessFlagBits::eDepthStencilAttachmentRead: return "DepthStencilAttachmentRead";
    case AccessFlagBits::eDepthStencilAttachmentWrite: return "DepthStencilAttachmentWrite";
    case AccessFlagBits::eTransferRead: return "TransferRead";
    case AccessFlagBits::eTransferWrite: return "TransferWrite";
    case AccessFlagBits::eHostRead: return "HostRead";
    case AccessFlagBits::eHostWrite: return "HostWrite";
    case AccessFlagBits::eMemoryRead: return "MemoryRead";
    case AccessFlagBits::eMemoryWrite: return "MemoryWrite";
    case AccessFlagBits::eConditionalRenderingReadEXT: return "ConditionalRenderingReadEXT";
    case AccessFlagBits::eCommandProcessReadNVX: return "CommandProcessReadNVX";
    case AccessFlagBits::eCommandProcessWriteNVX: return "CommandProcessWriteNVX";
    case AccessFlagBits::eColorAttachmentReadNoncoherentEXT: return "ColorAttachmentReadNoncoherentEXT";
    case AccessFlagBits::eShadingRateImageReadNV: return "ShadingRateImageReadNV";
    case AccessFlagBits::eAccelerationStructureReadNVX: return "AccelerationStructureReadNVX";
    case AccessFlagBits::eAccelerationStructureWriteNVX: return "AccelerationStructureWriteNVX";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(AccessFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & AccessFlagBits::eIndirectCommandRead) result += "IndirectCommandRead | ";
    if (value & AccessFlagBits::eIndexRead) result += "IndexRead | ";
    if (value & AccessFlagBits::eVertexAttributeRead) result += "VertexAttributeRead | ";
    if (value & AccessFlagBits::eUniformRead) result += "UniformRead | ";
    if (value & AccessFlagBits::eInputAttachmentRead) result += "InputAttachmentRead | ";
    if (value & AccessFlagBits::eShaderRead) result += "ShaderRead | ";
    if (value & AccessFlagBits::eShaderWrite) result += "ShaderWrite | ";
    if (value & AccessFlagBits::eColorAttachmentRead) result += "ColorAttachmentRead | ";
    if (value & AccessFlagBits::eColorAttachmentWrite) result += "ColorAttachmentWrite | ";
    if (value & AccessFlagBits::eDepthStencilAttachmentRead) result += "DepthStencilAttachmentRead | ";
    if (value & AccessFlagBits::eDepthStencilAttachmentWrite) result += "DepthStencilAttachmentWrite | ";
    if (value & AccessFlagBits::eTransferRead) result += "TransferRead | ";
    if (value & AccessFlagBits::eTransferWrite) result += "TransferWrite | ";
    if (value & AccessFlagBits::eHostRead) result += "HostRead | ";
    if (value & AccessFlagBits::eHostWrite) result += "HostWrite | ";
    if (value & AccessFlagBits::eMemoryRead) result += "MemoryRead | ";
    if (value & AccessFlagBits::eMemoryWrite) result += "MemoryWrite | ";
    if (value & AccessFlagBits::eConditionalRenderingReadEXT) result += "ConditionalRenderingReadEXT | ";
    if (value & AccessFlagBits::eCommandProcessReadNVX) result += "CommandProcessReadNVX | ";
    if (value & AccessFlagBits::eCommandProcessWriteNVX) result += "CommandProcessWriteNVX | ";
    if (value & AccessFlagBits::eColorAttachmentReadNoncoherentEXT) result += "ColorAttachmentReadNoncoherentEXT | ";
    if (value & AccessFlagBits::eShadingRateImageReadNV) result += "ShadingRateImageReadNV | ";
    if (value & AccessFlagBits::eAccelerationStructureReadNVX) result += "AccelerationStructureReadNVX | ";
    if (value & AccessFlagBits::eAccelerationStructureWriteNVX) result += "AccelerationStructureWriteNVX | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(BufferUsageFlagBits value)
  {
    switch (value)
    {
    case BufferUsageFlagBits::eTransferSrc: return "TransferSrc";
    case BufferUsageFlagBits::eTransferDst: return "TransferDst";
    case BufferUsageFlagBits::eUniformTexelBuffer: return "UniformTexelBuffer";
    case BufferUsageFlagBits::eStorageTexelBuffer: return "StorageTexelBuffer";
    case BufferUsageFlagBits::eUniformBuffer: return "UniformBuffer";
    case BufferUsageFlagBits::eStorageBuffer: return "StorageBuffer";
    case BufferUsageFlagBits::eIndexBuffer: return "IndexBuffer";
    case BufferUsageFlagBits::eVertexBuffer: return "VertexBuffer";
    case BufferUsageFlagBits::eIndirectBuffer: return "IndirectBuffer";
    case BufferUsageFlagBits::eConditionalRenderingEXT: return "ConditionalRenderingEXT";
    case BufferUsageFlagBits::eRaytracingNVX: return "RaytracingNVX";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(BufferUsageFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & BufferUsageFlagBits::eTransferSrc) result += "TransferSrc | ";
    if (value & BufferUsageFlagBits::eTransferDst) result += "TransferDst | ";
    if (value & BufferUsageFlagBits::eUniformTexelBuffer) result += "UniformTexelBuffer | ";
    if (value & BufferUsageFlagBits::eStorageTexelBuffer) result += "StorageTexelBuffer | ";
    if (value & BufferUsageFlagBits::eUniformBuffer) result += "UniformBuffer | ";
    if (value & BufferUsageFlagBits::eStorageBuffer) result += "StorageBuffer | ";
    if (value & BufferUsageFlagBits::eIndexBuffer) result += "IndexBuffer | ";
    if (value & BufferUsageFlagBits::eVertexBuffer) result += "VertexBuffer | ";
    if (value & BufferUsageFlagBits::eIndirectBuffer) result += "IndirectBuffer | ";
    if (value & BufferUsageFlagBits::eConditionalRenderingEXT) result += "ConditionalRenderingEXT | ";
    if (value & BufferUsageFlagBits::eRaytracingNVX) result += "RaytracingNVX | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(BufferCreateFlagBits value)
  {
    switch (value)
    {
    case BufferCreateFlagBits::eSparseBinding: return "SparseBinding";
    case BufferCreateFlagBits::eSparseResidency: return "SparseResidency";
    case BufferCreateFlagBits::eSparseAliased: return "SparseAliased";
    case BufferCreateFlagBits::eProtected: return "Protected";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(BufferCreateFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & BufferCreateFlagBits::eSparseBinding) result += "SparseBinding | ";
    if (value & BufferCreateFlagBits::eSparseResidency) result += "SparseResidency | ";
    if (value & BufferCreateFlagBits::eSparseAliased) result += "SparseAliased | ";
    if (value & BufferCreateFlagBits::eProtected) result += "Protected | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ShaderStageFlagBits value)
  {
    switch (value)
    {
    case ShaderStageFlagBits::eVertex: return "Vertex";
    case ShaderStageFlagBits::eTessellationControl: return "TessellationControl";
    case ShaderStageFlagBits::eTessellationEvaluation: return "TessellationEvaluation";
    case ShaderStageFlagBits::eGeometry: return "Geometry";
    case ShaderStageFlagBits::eFragment: return "Fragment";
    case ShaderStageFlagBits::eCompute: return "Compute";
    case ShaderStageFlagBits::eAllGraphics: return "AllGraphics";
    case ShaderStageFlagBits::eAll: return "All";
    case ShaderStageFlagBits::eRaygenNVX: return "RaygenNVX";
    case ShaderStageFlagBits::eAnyHitNVX: return "AnyHitNVX";
    case ShaderStageFlagBits::eClosestHitNVX: return "ClosestHitNVX";
    case ShaderStageFlagBits::eMissNVX: return "MissNVX";
    case ShaderStageFlagBits::eIntersectionNVX: return "IntersectionNVX";
    case ShaderStageFlagBits::eCallableNVX: return "CallableNVX";
    case ShaderStageFlagBits::eTaskNV: return "TaskNV";
    case ShaderStageFlagBits::eMeshNV: return "MeshNV";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ShaderStageFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ShaderStageFlagBits::eVertex) result += "Vertex | ";
    if (value & ShaderStageFlagBits::eTessellationControl) result += "TessellationControl | ";
    if (value & ShaderStageFlagBits::eTessellationEvaluation) result += "TessellationEvaluation | ";
    if (value & ShaderStageFlagBits::eGeometry) result += "Geometry | ";
    if (value & ShaderStageFlagBits::eFragment) result += "Fragment | ";
    if (value & ShaderStageFlagBits::eCompute) result += "Compute | ";
    if (value & ShaderStageFlagBits::eAllGraphics) result += "AllGraphics | ";
    if (value & ShaderStageFlagBits::eAll) result += "All | ";
    if (value & ShaderStageFlagBits::eRaygenNVX) result += "RaygenNVX | ";
    if (value & ShaderStageFlagBits::eAnyHitNVX) result += "AnyHitNVX | ";
    if (value & ShaderStageFlagBits::eClosestHitNVX) result += "ClosestHitNVX | ";
    if (value & ShaderStageFlagBits::eMissNVX) result += "MissNVX | ";
    if (value & ShaderStageFlagBits::eIntersectionNVX) result += "IntersectionNVX | ";
    if (value & ShaderStageFlagBits::eCallableNVX) result += "CallableNVX | ";
    if (value & ShaderStageFlagBits::eTaskNV) result += "TaskNV | ";
    if (value & ShaderStageFlagBits::eMeshNV) result += "MeshNV | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ImageUsageFlagBits value)
  {
    switch (value)
    {
    case ImageUsageFlagBits::eTransferSrc: return "TransferSrc";
    case ImageUsageFlagBits::eTransferDst: return "TransferDst";
    case ImageUsageFlagBits::eSampled: return "Sampled";
    case ImageUsageFlagBits::eStorage: return "Storage";
    case ImageUsageFlagBits::eColorAttachment: return "ColorAttachment";
    case ImageUsageFlagBits::eDepthStencilAttachment: return "DepthStencilAttachment";
    case ImageUsageFlagBits::eTransientAttachment: return "TransientAttachment";
    case ImageUsageFlagBits::eInputAttachment: return "InputAttachment";
    case ImageUsageFlagBits::eShadingRateImageNV: return "ShadingRateImageNV";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ImageUsageFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ImageUsageFlagBits::eTransferSrc) result += "TransferSrc | ";
    if (value & ImageUsageFlagBits::eTransferDst) result += "TransferDst | ";
    if (value & ImageUsageFlagBits::eSampled) result += "Sampled | ";
    if (value & ImageUsageFlagBits::eStorage) result += "Storage | ";
    if (value & ImageUsageFlagBits::eColorAttachment) result += "ColorAttachment | ";
    if (value & ImageUsageFlagBits::eDepthStencilAttachment) result += "DepthStencilAttachment | ";
    if (value & ImageUsageFlagBits::eTransientAttachment) result += "TransientAttachment | ";
    if (value & ImageUsageFlagBits::eInputAttachment) result += "InputAttachment | ";
    if (value & ImageUsageFlagBits::eShadingRateImageNV) result += "ShadingRateImageNV | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ImageCreateFlagBits value)
  {
    switch (value)
    {
    case ImageCreateFlagBits::eSparseBinding: return "SparseBinding";
    case ImageCreateFlagBits::eSparseResidency: return "SparseResidency";
    case ImageCreateFlagBits::eSparseAliased: return "SparseAliased";
    case ImageCreateFlagBits::eMutableFormat: return "MutableFormat";
    case ImageCreateFlagBits::eCubeCompatible: return "CubeCompatible";
    case ImageCreateFlagBits::eAlias: return "Alias";
    case ImageCreateFlagBits::eSplitInstanceBindRegions: return "SplitInstanceBindRegions";
    case ImageCreateFlagBits::e2DArrayCompatible: return "2DArrayCompatible";
    case ImageCreateFlagBits::eBlockTexelViewCompatible: return "BlockTexelViewCompatible";
    case ImageCreateFlagBits::eExtendedUsage: return "ExtendedUsage";
    case ImageCreateFlagBits::eProtected: return "Protected";
    case ImageCreateFlagBits::eDisjoint: return "Disjoint";
    case ImageCreateFlagBits::eCornerSampledNV: return "CornerSampledNV";
    case ImageCreateFlagBits::eSampleLocationsCompatibleDepthEXT: return "SampleLocationsCompatibleDepthEXT";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ImageCreateFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ImageCreateFlagBits::eSparseBinding) result += "SparseBinding | ";
    if (value & ImageCreateFlagBits::eSparseResidency) result += "SparseResidency | ";
    if (value & ImageCreateFlagBits::eSparseAliased) result += "SparseAliased | ";
    if (value & ImageCreateFlagBits::eMutableFormat) result += "MutableFormat | ";
    if (value & ImageCreateFlagBits::eCubeCompatible) result += "CubeCompatible | ";
    if (value & ImageCreateFlagBits::eAlias) result += "Alias | ";
    if (value & ImageCreateFlagBits::eSplitInstanceBindRegions) result += "SplitInstanceBindRegions | ";
    if (value & ImageCreateFlagBits::e2DArrayCompatible) result += "2DArrayCompatible | ";
    if (value & ImageCreateFlagBits::eBlockTexelViewCompatible) result += "BlockTexelViewCompatible | ";
    if (value & ImageCreateFlagBits::eExtendedUsage) result += "ExtendedUsage | ";
    if (value & ImageCreateFlagBits::eProtected) result += "Protected | ";
    if (value & ImageCreateFlagBits::eDisjoint) result += "Disjoint | ";
    if (value & ImageCreateFlagBits::eCornerSampledNV) result += "CornerSampledNV | ";
    if (value & ImageCreateFlagBits::eSampleLocationsCompatibleDepthEXT) result += "SampleLocationsCompatibleDepthEXT | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineCreateFlagBits value)
  {
    switch (value)
    {
    case PipelineCreateFlagBits::eDisableOptimization: return "DisableOptimization";
    case PipelineCreateFlagBits::eAllowDerivatives: return "AllowDerivatives";
    case PipelineCreateFlagBits::eDerivative: return "Derivative";
    case PipelineCreateFlagBits::eViewIndexFromDeviceIndex: return "ViewIndexFromDeviceIndex";
    case PipelineCreateFlagBits::eDispatchBase: return "DispatchBase";
    case PipelineCreateFlagBits::eDeferCompileNVX: return "DeferCompileNVX";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineCreateFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & PipelineCreateFlagBits::eDisableOptimization) result += "DisableOptimization | ";
    if (value & PipelineCreateFlagBits::eAllowDerivatives) result += "AllowDerivatives | ";
    if (value & PipelineCreateFlagBits::eDerivative) result += "Derivative | ";
    if (value & PipelineCreateFlagBits::eViewIndexFromDeviceIndex) result += "ViewIndexFromDeviceIndex | ";
    if (value & PipelineCreateFlagBits::eDispatchBase) result += "DispatchBase | ";
    if (value & PipelineCreateFlagBits::eDeferCompileNVX) result += "DeferCompileNVX | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ColorComponentFlagBits value)
  {
    switch (value)
    {
    case ColorComponentFlagBits::eR: return "R";
    case ColorComponentFlagBits::eG: return "G";
    case ColorComponentFlagBits::eB: return "B";
    case ColorComponentFlagBits::eA: return "A";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ColorComponentFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ColorComponentFlagBits::eR) result += "R | ";
    if (value & ColorComponentFlagBits::eG) result += "G | ";
    if (value & ColorComponentFlagBits::eB) result += "B | ";
    if (value & ColorComponentFlagBits::eA) result += "A | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(FenceCreateFlagBits value)
  {
    switch (value)
    {
    case FenceCreateFlagBits::eSignaled: return "Signaled";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(FenceCreateFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & FenceCreateFlagBits::eSignaled) result += "Signaled | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(FormatFeatureFlagBits value)
  {
    switch (value)
    {
    case FormatFeatureFlagBits::eSampledImage: return "SampledImage";
    case FormatFeatureFlagBits::eStorageImage: return "StorageImage";
    case FormatFeatureFlagBits::eStorageImageAtomic: return "StorageImageAtomic";
    case FormatFeatureFlagBits::eUniformTexelBuffer: return "UniformTexelBuffer";
    case FormatFeatureFlagBits::eStorageTexelBuffer: return "StorageTexelBuffer";
    case FormatFeatureFlagBits::eStorageTexelBufferAtomic: return "StorageTexelBufferAtomic";
    case FormatFeatureFlagBits::eVertexBuffer: return "VertexBuffer";
    case FormatFeatureFlagBits::eColorAttachment: return "ColorAttachment";
    case FormatFeatureFlagBits::eColorAttachmentBlend: return "ColorAttachmentBlend";
    case FormatFeatureFlagBits::eDepthStencilAttachment: return "DepthStencilAttachment";
    case FormatFeatureFlagBits::eBlitSrc: return "BlitSrc";
    case FormatFeatureFlagBits::eBlitDst: return "BlitDst";
    case FormatFeatureFlagBits::eSampledImageFilterLinear: return "SampledImageFilterLinear";
    case FormatFeatureFlagBits::eTransferSrc: return "TransferSrc";
    case FormatFeatureFlagBits::eTransferDst: return "TransferDst";
    case FormatFeatureFlagBits::eMidpointChromaSamples: return "MidpointChromaSamples";
    case FormatFeatureFlagBits::eSampledImageYcbcrConversionLinearFilter: return "SampledImageYcbcrConversionLinearFilter";
    case FormatFeatureFlagBits::eSampledImageYcbcrConversionSeparateReconstructionFilter: return "SampledImageYcbcrConversionSeparateReconstructionFilter";
    case FormatFeatureFlagBits::eSampledImageYcbcrConversionChromaReconstructionExplicit: return "SampledImageYcbcrConversionChromaReconstructionExplicit";
    case FormatFeatureFlagBits::eSampledImageYcbcrConversionChromaReconstructionExplicitForceable: return "SampledImageYcbcrConversionChromaReconstructionExplicitForceable";
    case FormatFeatureFlagBits::eDisjoint: return "Disjoint";
    case FormatFeatureFlagBits::eCositedChromaSamples: return "CositedChromaSamples";
    case FormatFeatureFlagBits::eSampledImageFilterCubicIMG: return "SampledImageFilterCubicIMG";
    case FormatFeatureFlagBits::eSampledImageFilterMinmaxEXT: return "SampledImageFilterMinmaxEXT";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(FormatFeatureFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & FormatFeatureFlagBits::eSampledImage) result += "SampledImage | ";
    if (value & FormatFeatureFlagBits::eStorageImage) result += "StorageImage | ";
    if (value & FormatFeatureFlagBits::eStorageImageAtomic) result += "StorageImageAtomic | ";
    if (value & FormatFeatureFlagBits::eUniformTexelBuffer) result += "UniformTexelBuffer | ";
    if (value & FormatFeatureFlagBits::eStorageTexelBuffer) result += "StorageTexelBuffer | ";
    if (value & FormatFeatureFlagBits::eStorageTexelBufferAtomic) result += "StorageTexelBufferAtomic | ";
    if (value & FormatFeatureFlagBits::eVertexBuffer) result += "VertexBuffer | ";
    if (value & FormatFeatureFlagBits::eColorAttachment) result += "ColorAttachment | ";
    if (value & FormatFeatureFlagBits::eColorAttachmentBlend) result += "ColorAttachmentBlend | ";
    if (value & FormatFeatureFlagBits::eDepthStencilAttachment) result += "DepthStencilAttachment | ";
    if (value & FormatFeatureFlagBits::eBlitSrc) result += "BlitSrc | ";
    if (value & FormatFeatureFlagBits::eBlitDst) result += "BlitDst | ";
    if (value & FormatFeatureFlagBits::eSampledImageFilterLinear) result += "SampledImageFilterLinear | ";
    if (value & FormatFeatureFlagBits::eTransferSrc) result += "TransferSrc | ";
    if (value & FormatFeatureFlagBits::eTransferDst) result += "TransferDst | ";
    if (value & FormatFeatureFlagBits::eMidpointChromaSamples) result += "MidpointChromaSamples | ";
    if (value & FormatFeatureFlagBits::eSampledImageYcbcrConversionLinearFilter) result += "SampledImageYcbcrConversionLinearFilter | ";
    if (value & FormatFeatureFlagBits::eSampledImageYcbcrConversionSeparateReconstructionFilter) result += "SampledImageYcbcrConversionSeparateReconstructionFilter | ";
    if (value & FormatFeatureFlagBits::eSampledImageYcbcrConversionChromaReconstructionExplicit) result += "SampledImageYcbcrConversionChromaReconstructionExplicit | ";
    if (value & FormatFeatureFlagBits::eSampledImageYcbcrConversionChromaReconstructionExplicitForceable) result += "SampledImageYcbcrConversionChromaReconstructionExplicitForceable | ";
    if (value & FormatFeatureFlagBits::eDisjoint) result += "Disjoint | ";
    if (value & FormatFeatureFlagBits::eCositedChromaSamples) result += "CositedChromaSamples | ";
    if (value & FormatFeatureFlagBits::eSampledImageFilterCubicIMG) result += "SampledImageFilterCubicIMG | ";
    if (value & FormatFeatureFlagBits::eSampledImageFilterMinmaxEXT) result += "SampledImageFilterMinmaxEXT | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(QueryControlFlagBits value)
  {
    switch (value)
    {
    case QueryControlFlagBits::ePrecise: return "Precise";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(QueryControlFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & QueryControlFlagBits::ePrecise) result += "Precise | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(QueryResultFlagBits value)
  {
    switch (value)
    {
    case QueryResultFlagBits::e64: return "64";
    case QueryResultFlagBits::eWait: return "Wait";
    case QueryResultFlagBits::eWithAvailability: return "WithAvailability";
    case QueryResultFlagBits::ePartial: return "Partial";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(QueryResultFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & QueryResultFlagBits::e64) result += "64 | ";
    if (value & QueryResultFlagBits::eWait) result += "Wait | ";
    if (value & QueryResultFlagBits::eWithAvailability) result += "WithAvailability | ";
    if (value & QueryResultFlagBits::ePartial) result += "Partial | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(CommandBufferUsageFlagBits value)
  {
    switch (value)
    {
    case CommandBufferUsageFlagBits::eOneTimeSubmit: return "OneTimeSubmit";
    case CommandBufferUsageFlagBits::eRenderPassContinue: return "RenderPassContinue";
    case CommandBufferUsageFlagBits::eSimultaneousUse: return "SimultaneousUse";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CommandBufferUsageFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & CommandBufferUsageFlagBits::eOneTimeSubmit) result += "OneTimeSubmit | ";
    if (value & CommandBufferUsageFlagBits::eRenderPassContinue) result += "RenderPassContinue | ";
    if (value & CommandBufferUsageFlagBits::eSimultaneousUse) result += "SimultaneousUse | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(QueryPipelineStatisticFlagBits value)
  {
    switch (value)
    {
    case QueryPipelineStatisticFlagBits::eInputAssemblyVertices: return "InputAssemblyVertices";
    case QueryPipelineStatisticFlagBits::eInputAssemblyPrimitives: return "InputAssemblyPrimitives";
    case QueryPipelineStatisticFlagBits::eVertexShaderInvocations: return "VertexShaderInvocations";
    case QueryPipelineStatisticFlagBits::eGeometryShaderInvocations: return "GeometryShaderInvocations";
    case QueryPipelineStatisticFlagBits::eGeometryShaderPrimitives: return "GeometryShaderPrimitives";
    case QueryPipelineStatisticFlagBits::eClippingInvocations: return "ClippingInvocations";
    case QueryPipelineStatisticFlagBits::eClippingPrimitives: return "ClippingPrimitives";
    case QueryPipelineStatisticFlagBits::eFragmentShaderInvocations: return "FragmentShaderInvocations";
    case QueryPipelineStatisticFlagBits::eTessellationControlShaderPatches: return "TessellationControlShaderPatches";
    case QueryPipelineStatisticFlagBits::eTessellationEvaluationShaderInvocations: return "TessellationEvaluationShaderInvocations";
    case QueryPipelineStatisticFlagBits::eComputeShaderInvocations: return "ComputeShaderInvocations";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(QueryPipelineStatisticFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & QueryPipelineStatisticFlagBits::eInputAssemblyVertices) result += "InputAssemblyVertices | ";
    if (value & QueryPipelineStatisticFlagBits::eInputAssemblyPrimitives) result += "InputAssemblyPrimitives | ";
    if (value & QueryPipelineStatisticFlagBits::eVertexShaderInvocations) result += "VertexShaderInvocations | ";
    if (value & QueryPipelineStatisticFlagBits::eGeometryShaderInvocations) result += "GeometryShaderInvocations | ";
    if (value & QueryPipelineStatisticFlagBits::eGeometryShaderPrimitives) result += "GeometryShaderPrimitives | ";
    if (value & QueryPipelineStatisticFlagBits::eClippingInvocations) result += "ClippingInvocations | ";
    if (value & QueryPipelineStatisticFlagBits::eClippingPrimitives) result += "ClippingPrimitives | ";
    if (value & QueryPipelineStatisticFlagBits::eFragmentShaderInvocations) result += "FragmentShaderInvocations | ";
    if (value & QueryPipelineStatisticFlagBits::eTessellationControlShaderPatches) result += "TessellationControlShaderPatches | ";
    if (value & QueryPipelineStatisticFlagBits::eTessellationEvaluationShaderInvocations) result += "TessellationEvaluationShaderInvocations | ";
    if (value & QueryPipelineStatisticFlagBits::eComputeShaderInvocations) result += "ComputeShaderInvocations | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ImageAspectFlagBits value)
  {
    switch (value)
    {
    case ImageAspectFlagBits::eColor: return "Color";
    case ImageAspectFlagBits::eDepth: return "Depth";
    case ImageAspectFlagBits::eStencil: return "Stencil";
    case ImageAspectFlagBits::eMetadata: return "Metadata";
    case ImageAspectFlagBits::ePlane0: return "Plane0";
    case ImageAspectFlagBits::ePlane1: return "Plane1";
    case ImageAspectFlagBits::ePlane2: return "Plane2";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ImageAspectFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ImageAspectFlagBits::eColor) result += "Color | ";
    if (value & ImageAspectFlagBits::eDepth) result += "Depth | ";
    if (value & ImageAspectFlagBits::eStencil) result += "Stencil | ";
    if (value & ImageAspectFlagBits::eMetadata) result += "Metadata | ";
    if (value & ImageAspectFlagBits::ePlane0) result += "Plane0 | ";
    if (value & ImageAspectFlagBits::ePlane1) result += "Plane1 | ";
    if (value & ImageAspectFlagBits::ePlane2) result += "Plane2 | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(SparseImageFormatFlagBits value)
  {
    switch (value)
    {
    case SparseImageFormatFlagBits::eSingleMiptail: return "SingleMiptail";
    case SparseImageFormatFlagBits::eAlignedMipSize: return "AlignedMipSize";
    case SparseImageFormatFlagBits::eNonstandardBlockSize: return "NonstandardBlockSize";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SparseImageFormatFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & SparseImageFormatFlagBits::eSingleMiptail) result += "SingleMiptail | ";
    if (value & SparseImageFormatFlagBits::eAlignedMipSize) result += "AlignedMipSize | ";
    if (value & SparseImageFormatFlagBits::eNonstandardBlockSize) result += "NonstandardBlockSize | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(SparseMemoryBindFlagBits value)
  {
    switch (value)
    {
    case SparseMemoryBindFlagBits::eMetadata: return "Metadata";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SparseMemoryBindFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & SparseMemoryBindFlagBits::eMetadata) result += "Metadata | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineStageFlagBits value)
  {
    switch (value)
    {
    case PipelineStageFlagBits::eTopOfPipe: return "TopOfPipe";
    case PipelineStageFlagBits::eDrawIndirect: return "DrawIndirect";
    case PipelineStageFlagBits::eVertexInput: return "VertexInput";
    case PipelineStageFlagBits::eVertexShader: return "VertexShader";
    case PipelineStageFlagBits::eTessellationControlShader: return "TessellationControlShader";
    case PipelineStageFlagBits::eTessellationEvaluationShader: return "TessellationEvaluationShader";
    case PipelineStageFlagBits::eGeometryShader: return "GeometryShader";
    case PipelineStageFlagBits::eFragmentShader: return "FragmentShader";
    case PipelineStageFlagBits::eEarlyFragmentTests: return "EarlyFragmentTests";
    case PipelineStageFlagBits::eLateFragmentTests: return "LateFragmentTests";
    case PipelineStageFlagBits::eColorAttachmentOutput: return "ColorAttachmentOutput";
    case PipelineStageFlagBits::eComputeShader: return "ComputeShader";
    case PipelineStageFlagBits::eTransfer: return "Transfer";
    case PipelineStageFlagBits::eBottomOfPipe: return "BottomOfPipe";
    case PipelineStageFlagBits::eHost: return "Host";
    case PipelineStageFlagBits::eAllGraphics: return "AllGraphics";
    case PipelineStageFlagBits::eAllCommands: return "AllCommands";
    case PipelineStageFlagBits::eConditionalRenderingEXT: return "ConditionalRenderingEXT";
    case PipelineStageFlagBits::eCommandProcessNVX: return "CommandProcessNVX";
    case PipelineStageFlagBits::eShadingRateImageNV: return "ShadingRateImageNV";
    case PipelineStageFlagBits::eRaytracingNVX: return "RaytracingNVX";
    case PipelineStageFlagBits::eTaskShaderNV: return "TaskShaderNV";
    case PipelineStageFlagBits::eMeshShaderNV: return "MeshShaderNV";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(PipelineStageFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & PipelineStageFlagBits::eTopOfPipe) result += "TopOfPipe | ";
    if (value & PipelineStageFlagBits::eDrawIndirect) result += "DrawIndirect | ";
    if (value & PipelineStageFlagBits::eVertexInput) result += "VertexInput | ";
    if (value & PipelineStageFlagBits::eVertexShader) result += "VertexShader | ";
    if (value & PipelineStageFlagBits::eTessellationControlShader) result += "TessellationControlShader | ";
    if (value & PipelineStageFlagBits::eTessellationEvaluationShader) result += "TessellationEvaluationShader | ";
    if (value & PipelineStageFlagBits::eGeometryShader) result += "GeometryShader | ";
    if (value & PipelineStageFlagBits::eFragmentShader) result += "FragmentShader | ";
    if (value & PipelineStageFlagBits::eEarlyFragmentTests) result += "EarlyFragmentTests | ";
    if (value & PipelineStageFlagBits::eLateFragmentTests) result += "LateFragmentTests | ";
    if (value & PipelineStageFlagBits::eColorAttachmentOutput) result += "ColorAttachmentOutput | ";
    if (value & PipelineStageFlagBits::eComputeShader) result += "ComputeShader | ";
    if (value & PipelineStageFlagBits::eTransfer) result += "Transfer | ";
    if (value & PipelineStageFlagBits::eBottomOfPipe) result += "BottomOfPipe | ";
    if (value & PipelineStageFlagBits::eHost) result += "Host | ";
    if (value & PipelineStageFlagBits::eAllGraphics) result += "AllGraphics | ";
    if (value & PipelineStageFlagBits::eAllCommands) result += "AllCommands | ";
    if (value & PipelineStageFlagBits::eConditionalRenderingEXT) result += "ConditionalRenderingEXT | ";
    if (value & PipelineStageFlagBits::eCommandProcessNVX) result += "CommandProcessNVX | ";
    if (value & PipelineStageFlagBits::eShadingRateImageNV) result += "ShadingRateImageNV | ";
    if (value & PipelineStageFlagBits::eRaytracingNVX) result += "RaytracingNVX | ";
    if (value & PipelineStageFlagBits::eTaskShaderNV) result += "TaskShaderNV | ";
    if (value & PipelineStageFlagBits::eMeshShaderNV) result += "MeshShaderNV | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(CommandPoolCreateFlagBits value)
  {
    switch (value)
    {
    case CommandPoolCreateFlagBits::eTransient: return "Transient";
    case CommandPoolCreateFlagBits::eResetCommandBuffer: return "ResetCommandBuffer";
    case CommandPoolCreateFlagBits::eProtected: return "Protected";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CommandPoolCreateFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & CommandPoolCreateFlagBits::eTransient) result += "Transient | ";
    if (value & CommandPoolCreateFlagBits::eResetCommandBuffer) result += "ResetCommandBuffer | ";
    if (value & CommandPoolCreateFlagBits::eProtected) result += "Protected | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(CommandPoolResetFlagBits value)
  {
    switch (value)
    {
    case CommandPoolResetFlagBits::eReleaseResources: return "ReleaseResources";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CommandPoolResetFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & CommandPoolResetFlagBits::eReleaseResources) result += "ReleaseResources | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(CommandBufferResetFlagBits value)
  {
    switch (value)
    {
    case CommandBufferResetFlagBits::eReleaseResources: return "ReleaseResources";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CommandBufferResetFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & CommandBufferResetFlagBits::eReleaseResources) result += "ReleaseResources | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(SampleCountFlagBits value)
  {
    switch (value)
    {
    case SampleCountFlagBits::e1: return "1";
    case SampleCountFlagBits::e2: return "2";
    case SampleCountFlagBits::e4: return "4";
    case SampleCountFlagBits::e8: return "8";
    case SampleCountFlagBits::e16: return "16";
    case SampleCountFlagBits::e32: return "32";
    case SampleCountFlagBits::e64: return "64";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SampleCountFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & SampleCountFlagBits::e1) result += "1 | ";
    if (value & SampleCountFlagBits::e2) result += "2 | ";
    if (value & SampleCountFlagBits::e4) result += "4 | ";
    if (value & SampleCountFlagBits::e8) result += "8 | ";
    if (value & SampleCountFlagBits::e16) result += "16 | ";
    if (value & SampleCountFlagBits::e32) result += "32 | ";
    if (value & SampleCountFlagBits::e64) result += "64 | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(AttachmentDescriptionFlagBits value)
  {
    switch (value)
    {
    case AttachmentDescriptionFlagBits::eMayAlias: return "MayAlias";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(AttachmentDescriptionFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & AttachmentDescriptionFlagBits::eMayAlias) result += "MayAlias | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(StencilFaceFlagBits value)
  {
    switch (value)
    {
    case StencilFaceFlagBits::eFront: return "Front";
    case StencilFaceFlagBits::eBack: return "Back";
    case StencilFaceFlagBits::eVkStencilFrontAndBack: return "VkStencilFrontAndBack";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(StencilFaceFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & StencilFaceFlagBits::eFront) result += "Front | ";
    if (value & StencilFaceFlagBits::eBack) result += "Back | ";
    if (value & StencilFaceFlagBits::eVkStencilFrontAndBack) result += "VkStencilFrontAndBack | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorPoolCreateFlagBits value)
  {
    switch (value)
    {
    case DescriptorPoolCreateFlagBits::eFreeDescriptorSet: return "FreeDescriptorSet";
    case DescriptorPoolCreateFlagBits::eUpdateAfterBindEXT: return "UpdateAfterBindEXT";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorPoolCreateFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DescriptorPoolCreateFlagBits::eFreeDescriptorSet) result += "FreeDescriptorSet | ";
    if (value & DescriptorPoolCreateFlagBits::eUpdateAfterBindEXT) result += "UpdateAfterBindEXT | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(DependencyFlagBits value)
  {
    switch (value)
    {
    case DependencyFlagBits::eByRegion: return "ByRegion";
    case DependencyFlagBits::eDeviceGroup: return "DeviceGroup";
    case DependencyFlagBits::eViewLocal: return "ViewLocal";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DependencyFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DependencyFlagBits::eByRegion) result += "ByRegion | ";
    if (value & DependencyFlagBits::eDeviceGroup) result += "DeviceGroup | ";
    if (value & DependencyFlagBits::eViewLocal) result += "ViewLocal | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(PresentModeKHR value)
  {
    switch (value)
    {
    case PresentModeKHR::eImmediate: return "Immediate";
    case PresentModeKHR::eMailbox: return "Mailbox";
    case PresentModeKHR::eFifo: return "Fifo";
    case PresentModeKHR::eFifoRelaxed: return "FifoRelaxed";
    case PresentModeKHR::eSharedDemandRefresh: return "SharedDemandRefresh";
    case PresentModeKHR::eSharedContinuousRefresh: return "SharedContinuousRefresh";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ColorSpaceKHR value)
  {
    switch (value)
    {
    case ColorSpaceKHR::eSrgbNonlinear: return "SrgbNonlinear";
    case ColorSpaceKHR::eDisplayP3NonlinearEXT: return "DisplayP3NonlinearEXT";
    case ColorSpaceKHR::eExtendedSrgbLinearEXT: return "ExtendedSrgbLinearEXT";
    case ColorSpaceKHR::eDciP3LinearEXT: return "DciP3LinearEXT";
    case ColorSpaceKHR::eDciP3NonlinearEXT: return "DciP3NonlinearEXT";
    case ColorSpaceKHR::eBt709LinearEXT: return "Bt709LinearEXT";
    case ColorSpaceKHR::eBt709NonlinearEXT: return "Bt709NonlinearEXT";
    case ColorSpaceKHR::eBt2020LinearEXT: return "Bt2020LinearEXT";
    case ColorSpaceKHR::eHdr10St2084EXT: return "Hdr10St2084EXT";
    case ColorSpaceKHR::eDolbyvisionEXT: return "DolbyvisionEXT";
    case ColorSpaceKHR::eHdr10HlgEXT: return "Hdr10HlgEXT";
    case ColorSpaceKHR::eAdobergbLinearEXT: return "AdobergbLinearEXT";
    case ColorSpaceKHR::eAdobergbNonlinearEXT: return "AdobergbNonlinearEXT";
    case ColorSpaceKHR::ePassThroughEXT: return "PassThroughEXT";
    case ColorSpaceKHR::eExtendedSrgbNonlinearEXT: return "ExtendedSrgbNonlinearEXT";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DisplayPlaneAlphaFlagBitsKHR value)
  {
    switch (value)
    {
    case DisplayPlaneAlphaFlagBitsKHR::eOpaque: return "Opaque";
    case DisplayPlaneAlphaFlagBitsKHR::eGlobal: return "Global";
    case DisplayPlaneAlphaFlagBitsKHR::ePerPixel: return "PerPixel";
    case DisplayPlaneAlphaFlagBitsKHR::ePerPixelPremultiplied: return "PerPixelPremultiplied";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DisplayPlaneAlphaFlagsKHR value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DisplayPlaneAlphaFlagBitsKHR::eOpaque) result += "Opaque | ";
    if (value & DisplayPlaneAlphaFlagBitsKHR::eGlobal) result += "Global | ";
    if (value & DisplayPlaneAlphaFlagBitsKHR::ePerPixel) result += "PerPixel | ";
    if (value & DisplayPlaneAlphaFlagBitsKHR::ePerPixelPremultiplied) result += "PerPixelPremultiplied | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(CompositeAlphaFlagBitsKHR value)
  {
    switch (value)
    {
    case CompositeAlphaFlagBitsKHR::eOpaque: return "Opaque";
    case CompositeAlphaFlagBitsKHR::ePreMultiplied: return "PreMultiplied";
    case CompositeAlphaFlagBitsKHR::ePostMultiplied: return "PostMultiplied";
    case CompositeAlphaFlagBitsKHR::eInherit: return "Inherit";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CompositeAlphaFlagsKHR value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & CompositeAlphaFlagBitsKHR::eOpaque) result += "Opaque | ";
    if (value & CompositeAlphaFlagBitsKHR::ePreMultiplied) result += "PreMultiplied | ";
    if (value & CompositeAlphaFlagBitsKHR::ePostMultiplied) result += "PostMultiplied | ";
    if (value & CompositeAlphaFlagBitsKHR::eInherit) result += "Inherit | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(SurfaceTransformFlagBitsKHR value)
  {
    switch (value)
    {
    case SurfaceTransformFlagBitsKHR::eIdentity: return "Identity";
    case SurfaceTransformFlagBitsKHR::eRotate90: return "Rotate90";
    case SurfaceTransformFlagBitsKHR::eRotate180: return "Rotate180";
    case SurfaceTransformFlagBitsKHR::eRotate270: return "Rotate270";
    case SurfaceTransformFlagBitsKHR::eHorizontalMirror: return "HorizontalMirror";
    case SurfaceTransformFlagBitsKHR::eHorizontalMirrorRotate90: return "HorizontalMirrorRotate90";
    case SurfaceTransformFlagBitsKHR::eHorizontalMirrorRotate180: return "HorizontalMirrorRotate180";
    case SurfaceTransformFlagBitsKHR::eHorizontalMirrorRotate270: return "HorizontalMirrorRotate270";
    case SurfaceTransformFlagBitsKHR::eInherit: return "Inherit";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SurfaceTransformFlagsKHR value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & SurfaceTransformFlagBitsKHR::eIdentity) result += "Identity | ";
    if (value & SurfaceTransformFlagBitsKHR::eRotate90) result += "Rotate90 | ";
    if (value & SurfaceTransformFlagBitsKHR::eRotate180) result += "Rotate180 | ";
    if (value & SurfaceTransformFlagBitsKHR::eRotate270) result += "Rotate270 | ";
    if (value & SurfaceTransformFlagBitsKHR::eHorizontalMirror) result += "HorizontalMirror | ";
    if (value & SurfaceTransformFlagBitsKHR::eHorizontalMirrorRotate90) result += "HorizontalMirrorRotate90 | ";
    if (value & SurfaceTransformFlagBitsKHR::eHorizontalMirrorRotate180) result += "HorizontalMirrorRotate180 | ";
    if (value & SurfaceTransformFlagBitsKHR::eHorizontalMirrorRotate270) result += "HorizontalMirrorRotate270 | ";
    if (value & SurfaceTransformFlagBitsKHR::eInherit) result += "Inherit | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(DebugReportFlagBitsEXT value)
  {
    switch (value)
    {
    case DebugReportFlagBitsEXT::eInformation: return "Information";
    case DebugReportFlagBitsEXT::eWarning: return "Warning";
    case DebugReportFlagBitsEXT::ePerformanceWarning: return "PerformanceWarning";
    case DebugReportFlagBitsEXT::eError: return "Error";
    case DebugReportFlagBitsEXT::eDebug: return "Debug";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DebugReportFlagsEXT value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DebugReportFlagBitsEXT::eInformation) result += "Information | ";
    if (value & DebugReportFlagBitsEXT::eWarning) result += "Warning | ";
    if (value & DebugReportFlagBitsEXT::ePerformanceWarning) result += "PerformanceWarning | ";
    if (value & DebugReportFlagBitsEXT::eError) result += "Error | ";
    if (value & DebugReportFlagBitsEXT::eDebug) result += "Debug | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(DebugReportObjectTypeEXT value)
  {
    switch (value)
    {
    case DebugReportObjectTypeEXT::eUnknown: return "Unknown";
    case DebugReportObjectTypeEXT::eInstance: return "Instance";
    case DebugReportObjectTypeEXT::ePhysicalDevice: return "PhysicalDevice";
    case DebugReportObjectTypeEXT::eDevice: return "Device";
    case DebugReportObjectTypeEXT::eQueue: return "Queue";
    case DebugReportObjectTypeEXT::eSemaphore: return "Semaphore";
    case DebugReportObjectTypeEXT::eCommandBuffer: return "CommandBuffer";
    case DebugReportObjectTypeEXT::eFence: return "Fence";
    case DebugReportObjectTypeEXT::eDeviceMemory: return "DeviceMemory";
    case DebugReportObjectTypeEXT::eBuffer: return "Buffer";
    case DebugReportObjectTypeEXT::eImage: return "Image";
    case DebugReportObjectTypeEXT::eEvent: return "Event";
    case DebugReportObjectTypeEXT::eQueryPool: return "QueryPool";
    case DebugReportObjectTypeEXT::eBufferView: return "BufferView";
    case DebugReportObjectTypeEXT::eImageView: return "ImageView";
    case DebugReportObjectTypeEXT::eShaderModule: return "ShaderModule";
    case DebugReportObjectTypeEXT::ePipelineCache: return "PipelineCache";
    case DebugReportObjectTypeEXT::ePipelineLayout: return "PipelineLayout";
    case DebugReportObjectTypeEXT::eRenderPass: return "RenderPass";
    case DebugReportObjectTypeEXT::ePipeline: return "Pipeline";
    case DebugReportObjectTypeEXT::eDescriptorSetLayout: return "DescriptorSetLayout";
    case DebugReportObjectTypeEXT::eSampler: return "Sampler";
    case DebugReportObjectTypeEXT::eDescriptorPool: return "DescriptorPool";
    case DebugReportObjectTypeEXT::eDescriptorSet: return "DescriptorSet";
    case DebugReportObjectTypeEXT::eFramebuffer: return "Framebuffer";
    case DebugReportObjectTypeEXT::eCommandPool: return "CommandPool";
    case DebugReportObjectTypeEXT::eSurfaceKhr: return "SurfaceKhr";
    case DebugReportObjectTypeEXT::eSwapchainKhr: return "SwapchainKhr";
    case DebugReportObjectTypeEXT::eDebugReportCallbackExt: return "DebugReportCallbackExt";
    case DebugReportObjectTypeEXT::eDisplayKhr: return "DisplayKhr";
    case DebugReportObjectTypeEXT::eDisplayModeKhr: return "DisplayModeKhr";
    case DebugReportObjectTypeEXT::eObjectTableNvx: return "ObjectTableNvx";
    case DebugReportObjectTypeEXT::eIndirectCommandsLayoutNvx: return "IndirectCommandsLayoutNvx";
    case DebugReportObjectTypeEXT::eValidationCacheExt: return "ValidationCacheExt";
    case DebugReportObjectTypeEXT::eSamplerYcbcrConversion: return "SamplerYcbcrConversion";
    case DebugReportObjectTypeEXT::eDescriptorUpdateTemplate: return "DescriptorUpdateTemplate";
    case DebugReportObjectTypeEXT::eAccelerationStructureNVX: return "AccelerationStructureNVX";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(RasterizationOrderAMD value)
  {
    switch (value)
    {
    case RasterizationOrderAMD::eStrict: return "Strict";
    case RasterizationOrderAMD::eRelaxed: return "Relaxed";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalMemoryHandleTypeFlagBitsNV value)
  {
    switch (value)
    {
    case ExternalMemoryHandleTypeFlagBitsNV::eOpaqueWin32: return "OpaqueWin32";
    case ExternalMemoryHandleTypeFlagBitsNV::eOpaqueWin32Kmt: return "OpaqueWin32Kmt";
    case ExternalMemoryHandleTypeFlagBitsNV::eD3D11Image: return "D3D11Image";
    case ExternalMemoryHandleTypeFlagBitsNV::eD3D11ImageKmt: return "D3D11ImageKmt";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalMemoryHandleTypeFlagsNV value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ExternalMemoryHandleTypeFlagBitsNV::eOpaqueWin32) result += "OpaqueWin32 | ";
    if (value & ExternalMemoryHandleTypeFlagBitsNV::eOpaqueWin32Kmt) result += "OpaqueWin32Kmt | ";
    if (value & ExternalMemoryHandleTypeFlagBitsNV::eD3D11Image) result += "D3D11Image | ";
    if (value & ExternalMemoryHandleTypeFlagBitsNV::eD3D11ImageKmt) result += "D3D11ImageKmt | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalMemoryFeatureFlagBitsNV value)
  {
    switch (value)
    {
    case ExternalMemoryFeatureFlagBitsNV::eDedicatedOnly: return "DedicatedOnly";
    case ExternalMemoryFeatureFlagBitsNV::eExportable: return "Exportable";
    case ExternalMemoryFeatureFlagBitsNV::eImportable: return "Importable";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalMemoryFeatureFlagsNV value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ExternalMemoryFeatureFlagBitsNV::eDedicatedOnly) result += "DedicatedOnly | ";
    if (value & ExternalMemoryFeatureFlagBitsNV::eExportable) result += "Exportable | ";
    if (value & ExternalMemoryFeatureFlagBitsNV::eImportable) result += "Importable | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ValidationCheckEXT value)
  {
    switch (value)
    {
    case ValidationCheckEXT::eAll: return "All";
    case ValidationCheckEXT::eShaders: return "Shaders";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SubgroupFeatureFlagBits value)
  {
    switch (value)
    {
    case SubgroupFeatureFlagBits::eBasic: return "Basic";
    case SubgroupFeatureFlagBits::eVote: return "Vote";
    case SubgroupFeatureFlagBits::eArithmetic: return "Arithmetic";
    case SubgroupFeatureFlagBits::eBallot: return "Ballot";
    case SubgroupFeatureFlagBits::eShuffle: return "Shuffle";
    case SubgroupFeatureFlagBits::eShuffleRelative: return "ShuffleRelative";
    case SubgroupFeatureFlagBits::eClustered: return "Clustered";
    case SubgroupFeatureFlagBits::eQuad: return "Quad";
    case SubgroupFeatureFlagBits::ePartitionedNV: return "PartitionedNV";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SubgroupFeatureFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & SubgroupFeatureFlagBits::eBasic) result += "Basic | ";
    if (value & SubgroupFeatureFlagBits::eVote) result += "Vote | ";
    if (value & SubgroupFeatureFlagBits::eArithmetic) result += "Arithmetic | ";
    if (value & SubgroupFeatureFlagBits::eBallot) result += "Ballot | ";
    if (value & SubgroupFeatureFlagBits::eShuffle) result += "Shuffle | ";
    if (value & SubgroupFeatureFlagBits::eShuffleRelative) result += "ShuffleRelative | ";
    if (value & SubgroupFeatureFlagBits::eClustered) result += "Clustered | ";
    if (value & SubgroupFeatureFlagBits::eQuad) result += "Quad | ";
    if (value & SubgroupFeatureFlagBits::ePartitionedNV) result += "PartitionedNV | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(IndirectCommandsLayoutUsageFlagBitsNVX value)
  {
    switch (value)
    {
    case IndirectCommandsLayoutUsageFlagBitsNVX::eUnorderedSequences: return "UnorderedSequences";
    case IndirectCommandsLayoutUsageFlagBitsNVX::eSparseSequences: return "SparseSequences";
    case IndirectCommandsLayoutUsageFlagBitsNVX::eEmptyExecutions: return "EmptyExecutions";
    case IndirectCommandsLayoutUsageFlagBitsNVX::eIndexedSequences: return "IndexedSequences";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(IndirectCommandsLayoutUsageFlagsNVX value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & IndirectCommandsLayoutUsageFlagBitsNVX::eUnorderedSequences) result += "UnorderedSequences | ";
    if (value & IndirectCommandsLayoutUsageFlagBitsNVX::eSparseSequences) result += "SparseSequences | ";
    if (value & IndirectCommandsLayoutUsageFlagBitsNVX::eEmptyExecutions) result += "EmptyExecutions | ";
    if (value & IndirectCommandsLayoutUsageFlagBitsNVX::eIndexedSequences) result += "IndexedSequences | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ObjectEntryUsageFlagBitsNVX value)
  {
    switch (value)
    {
    case ObjectEntryUsageFlagBitsNVX::eGraphics: return "Graphics";
    case ObjectEntryUsageFlagBitsNVX::eCompute: return "Compute";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ObjectEntryUsageFlagsNVX value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ObjectEntryUsageFlagBitsNVX::eGraphics) result += "Graphics | ";
    if (value & ObjectEntryUsageFlagBitsNVX::eCompute) result += "Compute | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(IndirectCommandsTokenTypeNVX value)
  {
    switch (value)
    {
    case IndirectCommandsTokenTypeNVX::ePipeline: return "Pipeline";
    case IndirectCommandsTokenTypeNVX::eDescriptorSet: return "DescriptorSet";
    case IndirectCommandsTokenTypeNVX::eIndexBuffer: return "IndexBuffer";
    case IndirectCommandsTokenTypeNVX::eVertexBuffer: return "VertexBuffer";
    case IndirectCommandsTokenTypeNVX::ePushConstant: return "PushConstant";
    case IndirectCommandsTokenTypeNVX::eDrawIndexed: return "DrawIndexed";
    case IndirectCommandsTokenTypeNVX::eDraw: return "Draw";
    case IndirectCommandsTokenTypeNVX::eDispatch: return "Dispatch";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ObjectEntryTypeNVX value)
  {
    switch (value)
    {
    case ObjectEntryTypeNVX::eDescriptorSet: return "DescriptorSet";
    case ObjectEntryTypeNVX::ePipeline: return "Pipeline";
    case ObjectEntryTypeNVX::eIndexBuffer: return "IndexBuffer";
    case ObjectEntryTypeNVX::eVertexBuffer: return "VertexBuffer";
    case ObjectEntryTypeNVX::ePushConstant: return "PushConstant";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorSetLayoutCreateFlagBits value)
  {
    switch (value)
    {
    case DescriptorSetLayoutCreateFlagBits::ePushDescriptorKHR: return "PushDescriptorKHR";
    case DescriptorSetLayoutCreateFlagBits::eUpdateAfterBindPoolEXT: return "UpdateAfterBindPoolEXT";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorSetLayoutCreateFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DescriptorSetLayoutCreateFlagBits::ePushDescriptorKHR) result += "PushDescriptorKHR | ";
    if (value & DescriptorSetLayoutCreateFlagBits::eUpdateAfterBindPoolEXT) result += "UpdateAfterBindPoolEXT | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalMemoryHandleTypeFlagBits value)
  {
    switch (value)
    {
    case ExternalMemoryHandleTypeFlagBits::eOpaqueFd: return "OpaqueFd";
    case ExternalMemoryHandleTypeFlagBits::eOpaqueWin32: return "OpaqueWin32";
    case ExternalMemoryHandleTypeFlagBits::eOpaqueWin32Kmt: return "OpaqueWin32Kmt";
    case ExternalMemoryHandleTypeFlagBits::eD3D11Texture: return "D3D11Texture";
    case ExternalMemoryHandleTypeFlagBits::eD3D11TextureKmt: return "D3D11TextureKmt";
    case ExternalMemoryHandleTypeFlagBits::eD3D12Heap: return "D3D12Heap";
    case ExternalMemoryHandleTypeFlagBits::eD3D12Resource: return "D3D12Resource";
    case ExternalMemoryHandleTypeFlagBits::eDmaBufEXT: return "DmaBufEXT";
    case ExternalMemoryHandleTypeFlagBits::eAndroidHardwareBufferANDROID: return "AndroidHardwareBufferANDROID";
    case ExternalMemoryHandleTypeFlagBits::eHostAllocationEXT: return "HostAllocationEXT";
    case ExternalMemoryHandleTypeFlagBits::eHostMappedForeignMemoryEXT: return "HostMappedForeignMemoryEXT";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalMemoryHandleTypeFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ExternalMemoryHandleTypeFlagBits::eOpaqueFd) result += "OpaqueFd | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eOpaqueWin32) result += "OpaqueWin32 | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eOpaqueWin32Kmt) result += "OpaqueWin32Kmt | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eD3D11Texture) result += "D3D11Texture | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eD3D11TextureKmt) result += "D3D11TextureKmt | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eD3D12Heap) result += "D3D12Heap | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eD3D12Resource) result += "D3D12Resource | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eDmaBufEXT) result += "DmaBufEXT | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eAndroidHardwareBufferANDROID) result += "AndroidHardwareBufferANDROID | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eHostAllocationEXT) result += "HostAllocationEXT | ";
    if (value & ExternalMemoryHandleTypeFlagBits::eHostMappedForeignMemoryEXT) result += "HostMappedForeignMemoryEXT | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalMemoryFeatureFlagBits value)
  {
    switch (value)
    {
    case ExternalMemoryFeatureFlagBits::eDedicatedOnly: return "DedicatedOnly";
    case ExternalMemoryFeatureFlagBits::eExportable: return "Exportable";
    case ExternalMemoryFeatureFlagBits::eImportable: return "Importable";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalMemoryFeatureFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ExternalMemoryFeatureFlagBits::eDedicatedOnly) result += "DedicatedOnly | ";
    if (value & ExternalMemoryFeatureFlagBits::eExportable) result += "Exportable | ";
    if (value & ExternalMemoryFeatureFlagBits::eImportable) result += "Importable | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalSemaphoreHandleTypeFlagBits value)
  {
    switch (value)
    {
    case ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd: return "OpaqueFd";
    case ExternalSemaphoreHandleTypeFlagBits::eOpaqueWin32: return "OpaqueWin32";
    case ExternalSemaphoreHandleTypeFlagBits::eOpaqueWin32Kmt: return "OpaqueWin32Kmt";
    case ExternalSemaphoreHandleTypeFlagBits::eD3D12Fence: return "D3D12Fence";
    case ExternalSemaphoreHandleTypeFlagBits::eSyncFd: return "SyncFd";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalSemaphoreHandleTypeFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd) result += "OpaqueFd | ";
    if (value & ExternalSemaphoreHandleTypeFlagBits::eOpaqueWin32) result += "OpaqueWin32 | ";
    if (value & ExternalSemaphoreHandleTypeFlagBits::eOpaqueWin32Kmt) result += "OpaqueWin32Kmt | ";
    if (value & ExternalSemaphoreHandleTypeFlagBits::eD3D12Fence) result += "D3D12Fence | ";
    if (value & ExternalSemaphoreHandleTypeFlagBits::eSyncFd) result += "SyncFd | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalSemaphoreFeatureFlagBits value)
  {
    switch (value)
    {
    case ExternalSemaphoreFeatureFlagBits::eExportable: return "Exportable";
    case ExternalSemaphoreFeatureFlagBits::eImportable: return "Importable";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalSemaphoreFeatureFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ExternalSemaphoreFeatureFlagBits::eExportable) result += "Exportable | ";
    if (value & ExternalSemaphoreFeatureFlagBits::eImportable) result += "Importable | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(SemaphoreImportFlagBits value)
  {
    switch (value)
    {
    case SemaphoreImportFlagBits::eTemporary: return "Temporary";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SemaphoreImportFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & SemaphoreImportFlagBits::eTemporary) result += "Temporary | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalFenceHandleTypeFlagBits value)
  {
    switch (value)
    {
    case ExternalFenceHandleTypeFlagBits::eOpaqueFd: return "OpaqueFd";
    case ExternalFenceHandleTypeFlagBits::eOpaqueWin32: return "OpaqueWin32";
    case ExternalFenceHandleTypeFlagBits::eOpaqueWin32Kmt: return "OpaqueWin32Kmt";
    case ExternalFenceHandleTypeFlagBits::eSyncFd: return "SyncFd";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalFenceHandleTypeFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ExternalFenceHandleTypeFlagBits::eOpaqueFd) result += "OpaqueFd | ";
    if (value & ExternalFenceHandleTypeFlagBits::eOpaqueWin32) result += "OpaqueWin32 | ";
    if (value & ExternalFenceHandleTypeFlagBits::eOpaqueWin32Kmt) result += "OpaqueWin32Kmt | ";
    if (value & ExternalFenceHandleTypeFlagBits::eSyncFd) result += "SyncFd | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalFenceFeatureFlagBits value)
  {
    switch (value)
    {
    case ExternalFenceFeatureFlagBits::eExportable: return "Exportable";
    case ExternalFenceFeatureFlagBits::eImportable: return "Importable";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ExternalFenceFeatureFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ExternalFenceFeatureFlagBits::eExportable) result += "Exportable | ";
    if (value & ExternalFenceFeatureFlagBits::eImportable) result += "Importable | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(FenceImportFlagBits value)
  {
    switch (value)
    {
    case FenceImportFlagBits::eTemporary: return "Temporary";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(FenceImportFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & FenceImportFlagBits::eTemporary) result += "Temporary | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(SurfaceCounterFlagBitsEXT value)
  {
    switch (value)
    {
    case SurfaceCounterFlagBitsEXT::eVblank: return "Vblank";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SurfaceCounterFlagsEXT value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & SurfaceCounterFlagBitsEXT::eVblank) result += "Vblank | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(DisplayPowerStateEXT value)
  {
    switch (value)
    {
    case DisplayPowerStateEXT::eOff: return "Off";
    case DisplayPowerStateEXT::eSuspend: return "Suspend";
    case DisplayPowerStateEXT::eOn: return "On";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DeviceEventTypeEXT value)
  {
    switch (value)
    {
    case DeviceEventTypeEXT::eDisplayHotplug: return "DisplayHotplug";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DisplayEventTypeEXT value)
  {
    switch (value)
    {
    case DisplayEventTypeEXT::eFirstPixelOut: return "FirstPixelOut";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(PeerMemoryFeatureFlagBits value)
  {
    switch (value)
    {
    case PeerMemoryFeatureFlagBits::eCopySrc: return "CopySrc";
    case PeerMemoryFeatureFlagBits::eCopyDst: return "CopyDst";
    case PeerMemoryFeatureFlagBits::eGenericSrc: return "GenericSrc";
    case PeerMemoryFeatureFlagBits::eGenericDst: return "GenericDst";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(PeerMemoryFeatureFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & PeerMemoryFeatureFlagBits::eCopySrc) result += "CopySrc | ";
    if (value & PeerMemoryFeatureFlagBits::eCopyDst) result += "CopyDst | ";
    if (value & PeerMemoryFeatureFlagBits::eGenericSrc) result += "GenericSrc | ";
    if (value & PeerMemoryFeatureFlagBits::eGenericDst) result += "GenericDst | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(MemoryAllocateFlagBits value)
  {
    switch (value)
    {
    case MemoryAllocateFlagBits::eDeviceMask: return "DeviceMask";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(MemoryAllocateFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & MemoryAllocateFlagBits::eDeviceMask) result += "DeviceMask | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(DeviceGroupPresentModeFlagBitsKHR value)
  {
    switch (value)
    {
    case DeviceGroupPresentModeFlagBitsKHR::eLocal: return "Local";
    case DeviceGroupPresentModeFlagBitsKHR::eRemote: return "Remote";
    case DeviceGroupPresentModeFlagBitsKHR::eSum: return "Sum";
    case DeviceGroupPresentModeFlagBitsKHR::eLocalMultiDevice: return "LocalMultiDevice";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DeviceGroupPresentModeFlagsKHR value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DeviceGroupPresentModeFlagBitsKHR::eLocal) result += "Local | ";
    if (value & DeviceGroupPresentModeFlagBitsKHR::eRemote) result += "Remote | ";
    if (value & DeviceGroupPresentModeFlagBitsKHR::eSum) result += "Sum | ";
    if (value & DeviceGroupPresentModeFlagBitsKHR::eLocalMultiDevice) result += "LocalMultiDevice | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(SwapchainCreateFlagBitsKHR value)
  {
    switch (value)
    {
    case SwapchainCreateFlagBitsKHR::eSplitInstanceBindRegions: return "SplitInstanceBindRegions";
    case SwapchainCreateFlagBitsKHR::eProtected: return "Protected";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SwapchainCreateFlagsKHR value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & SwapchainCreateFlagBitsKHR::eSplitInstanceBindRegions) result += "SplitInstanceBindRegions | ";
    if (value & SwapchainCreateFlagBitsKHR::eProtected) result += "Protected | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ViewportCoordinateSwizzleNV value)
  {
    switch (value)
    {
    case ViewportCoordinateSwizzleNV::ePositiveX: return "PositiveX";
    case ViewportCoordinateSwizzleNV::eNegativeX: return "NegativeX";
    case ViewportCoordinateSwizzleNV::ePositiveY: return "PositiveY";
    case ViewportCoordinateSwizzleNV::eNegativeY: return "NegativeY";
    case ViewportCoordinateSwizzleNV::ePositiveZ: return "PositiveZ";
    case ViewportCoordinateSwizzleNV::eNegativeZ: return "NegativeZ";
    case ViewportCoordinateSwizzleNV::ePositiveW: return "PositiveW";
    case ViewportCoordinateSwizzleNV::eNegativeW: return "NegativeW";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DiscardRectangleModeEXT value)
  {
    switch (value)
    {
    case DiscardRectangleModeEXT::eInclusive: return "Inclusive";
    case DiscardRectangleModeEXT::eExclusive: return "Exclusive";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SubpassDescriptionFlagBits value)
  {
    switch (value)
    {
    case SubpassDescriptionFlagBits::ePerViewAttributesNVX: return "PerViewAttributesNVX";
    case SubpassDescriptionFlagBits::ePerViewPositionXOnlyNVX: return "PerViewPositionXOnlyNVX";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SubpassDescriptionFlags value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & SubpassDescriptionFlagBits::ePerViewAttributesNVX) result += "PerViewAttributesNVX | ";
    if (value & SubpassDescriptionFlagBits::ePerViewPositionXOnlyNVX) result += "PerViewPositionXOnlyNVX | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(PointClippingBehavior value)
  {
    switch (value)
    {
    case PointClippingBehavior::eAllClipPlanes: return "AllClipPlanes";
    case PointClippingBehavior::eUserClipPlanesOnly: return "UserClipPlanesOnly";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SamplerReductionModeEXT value)
  {
    switch (value)
    {
    case SamplerReductionModeEXT::eWeightedAverage: return "WeightedAverage";
    case SamplerReductionModeEXT::eMin: return "Min";
    case SamplerReductionModeEXT::eMax: return "Max";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(TessellationDomainOrigin value)
  {
    switch (value)
    {
    case TessellationDomainOrigin::eUpperLeft: return "UpperLeft";
    case TessellationDomainOrigin::eLowerLeft: return "LowerLeft";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SamplerYcbcrModelConversion value)
  {
    switch (value)
    {
    case SamplerYcbcrModelConversion::eRgbIdentity: return "RgbIdentity";
    case SamplerYcbcrModelConversion::eYcbcrIdentity: return "YcbcrIdentity";
    case SamplerYcbcrModelConversion::eYcbcr709: return "Ycbcr709";
    case SamplerYcbcrModelConversion::eYcbcr601: return "Ycbcr601";
    case SamplerYcbcrModelConversion::eYcbcr2020: return "Ycbcr2020";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(SamplerYcbcrRange value)
  {
    switch (value)
    {
    case SamplerYcbcrRange::eItuFull: return "ItuFull";
    case SamplerYcbcrRange::eItuNarrow: return "ItuNarrow";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ChromaLocation value)
  {
    switch (value)
    {
    case ChromaLocation::eCositedEven: return "CositedEven";
    case ChromaLocation::eMidpoint: return "Midpoint";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(BlendOverlapEXT value)
  {
    switch (value)
    {
    case BlendOverlapEXT::eUncorrelated: return "Uncorrelated";
    case BlendOverlapEXT::eDisjoint: return "Disjoint";
    case BlendOverlapEXT::eConjoint: return "Conjoint";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CoverageModulationModeNV value)
  {
    switch (value)
    {
    case CoverageModulationModeNV::eNone: return "None";
    case CoverageModulationModeNV::eRgb: return "Rgb";
    case CoverageModulationModeNV::eAlpha: return "Alpha";
    case CoverageModulationModeNV::eRgba: return "Rgba";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ValidationCacheHeaderVersionEXT value)
  {
    switch (value)
    {
    case ValidationCacheHeaderVersionEXT::eOne: return "One";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ShaderInfoTypeAMD value)
  {
    switch (value)
    {
    case ShaderInfoTypeAMD::eStatistics: return "Statistics";
    case ShaderInfoTypeAMD::eBinary: return "Binary";
    case ShaderInfoTypeAMD::eDisassembly: return "Disassembly";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(QueueGlobalPriorityEXT value)
  {
    switch (value)
    {
    case QueueGlobalPriorityEXT::eLow: return "Low";
    case QueueGlobalPriorityEXT::eMedium: return "Medium";
    case QueueGlobalPriorityEXT::eHigh: return "High";
    case QueueGlobalPriorityEXT::eRealtime: return "Realtime";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DebugUtilsMessageSeverityFlagBitsEXT value)
  {
    switch (value)
    {
    case DebugUtilsMessageSeverityFlagBitsEXT::eVerbose: return "Verbose";
    case DebugUtilsMessageSeverityFlagBitsEXT::eInfo: return "Info";
    case DebugUtilsMessageSeverityFlagBitsEXT::eWarning: return "Warning";
    case DebugUtilsMessageSeverityFlagBitsEXT::eError: return "Error";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DebugUtilsMessageSeverityFlagsEXT value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DebugUtilsMessageSeverityFlagBitsEXT::eVerbose) result += "Verbose | ";
    if (value & DebugUtilsMessageSeverityFlagBitsEXT::eInfo) result += "Info | ";
    if (value & DebugUtilsMessageSeverityFlagBitsEXT::eWarning) result += "Warning | ";
    if (value & DebugUtilsMessageSeverityFlagBitsEXT::eError) result += "Error | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(DebugUtilsMessageTypeFlagBitsEXT value)
  {
    switch (value)
    {
    case DebugUtilsMessageTypeFlagBitsEXT::eGeneral: return "General";
    case DebugUtilsMessageTypeFlagBitsEXT::eValidation: return "Validation";
    case DebugUtilsMessageTypeFlagBitsEXT::ePerformance: return "Performance";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DebugUtilsMessageTypeFlagsEXT value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DebugUtilsMessageTypeFlagBitsEXT::eGeneral) result += "General | ";
    if (value & DebugUtilsMessageTypeFlagBitsEXT::eValidation) result += "Validation | ";
    if (value & DebugUtilsMessageTypeFlagBitsEXT::ePerformance) result += "Performance | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ConservativeRasterizationModeEXT value)
  {
    switch (value)
    {
    case ConservativeRasterizationModeEXT::eDisabled: return "Disabled";
    case ConservativeRasterizationModeEXT::eOverestimate: return "Overestimate";
    case ConservativeRasterizationModeEXT::eUnderestimate: return "Underestimate";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorBindingFlagBitsEXT value)
  {
    switch (value)
    {
    case DescriptorBindingFlagBitsEXT::eUpdateAfterBind: return "UpdateAfterBind";
    case DescriptorBindingFlagBitsEXT::eUpdateUnusedWhilePending: return "UpdateUnusedWhilePending";
    case DescriptorBindingFlagBitsEXT::ePartiallyBound: return "PartiallyBound";
    case DescriptorBindingFlagBitsEXT::eVariableDescriptorCount: return "VariableDescriptorCount";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(DescriptorBindingFlagsEXT value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & DescriptorBindingFlagBitsEXT::eUpdateAfterBind) result += "UpdateAfterBind | ";
    if (value & DescriptorBindingFlagBitsEXT::eUpdateUnusedWhilePending) result += "UpdateUnusedWhilePending | ";
    if (value & DescriptorBindingFlagBitsEXT::ePartiallyBound) result += "PartiallyBound | ";
    if (value & DescriptorBindingFlagBitsEXT::eVariableDescriptorCount) result += "VariableDescriptorCount | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(VendorId value)
  {
    switch (value)
    {
    case VendorId::eViv: return "Viv";
    case VendorId::eVsi: return "Vsi";
    case VendorId::eKazan: return "Kazan";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ConditionalRenderingFlagBitsEXT value)
  {
    switch (value)
    {
    case ConditionalRenderingFlagBitsEXT::eInverted: return "Inverted";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(ConditionalRenderingFlagsEXT value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & ConditionalRenderingFlagBitsEXT::eInverted) result += "Inverted | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(ShadingRatePaletteEntryNV value)
  {
    switch (value)
    {
    case ShadingRatePaletteEntryNV::eNoInvocations: return "NoInvocations";
    case ShadingRatePaletteEntryNV::e16InvocationsPerPixel: return "16InvocationsPerPixel";
    case ShadingRatePaletteEntryNV::e8InvocationsPerPixel: return "8InvocationsPerPixel";
    case ShadingRatePaletteEntryNV::e4InvocationsPerPixel: return "4InvocationsPerPixel";
    case ShadingRatePaletteEntryNV::e2InvocationsPerPixel: return "2InvocationsPerPixel";
    case ShadingRatePaletteEntryNV::e1InvocationPerPixel: return "1InvocationPerPixel";
    case ShadingRatePaletteEntryNV::e1InvocationPer2X1Pixels: return "1InvocationPer2X1Pixels";
    case ShadingRatePaletteEntryNV::e1InvocationPer1X2Pixels: return "1InvocationPer1X2Pixels";
    case ShadingRatePaletteEntryNV::e1InvocationPer2X2Pixels: return "1InvocationPer2X2Pixels";
    case ShadingRatePaletteEntryNV::e1InvocationPer4X2Pixels: return "1InvocationPer4X2Pixels";
    case ShadingRatePaletteEntryNV::e1InvocationPer2X4Pixels: return "1InvocationPer2X4Pixels";
    case ShadingRatePaletteEntryNV::e1InvocationPer4X4Pixels: return "1InvocationPer4X4Pixels";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(CoarseSampleOrderTypeNV value)
  {
    switch (value)
    {
    case CoarseSampleOrderTypeNV::eDefault: return "Default";
    case CoarseSampleOrderTypeNV::eCustom: return "Custom";
    case CoarseSampleOrderTypeNV::ePixelMajor: return "PixelMajor";
    case CoarseSampleOrderTypeNV::eSampleMajor: return "SampleMajor";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(GeometryInstanceFlagBitsNVX value)
  {
    switch (value)
    {
    case GeometryInstanceFlagBitsNVX::eTriangleCullDisable: return "TriangleCullDisable";
    case GeometryInstanceFlagBitsNVX::eTriangleCullFlipWinding: return "TriangleCullFlipWinding";
    case GeometryInstanceFlagBitsNVX::eForceOpaque: return "ForceOpaque";
    case GeometryInstanceFlagBitsNVX::eForceNoOpaque: return "ForceNoOpaque";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(GeometryInstanceFlagsNVX value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & GeometryInstanceFlagBitsNVX::eTriangleCullDisable) result += "TriangleCullDisable | ";
    if (value & GeometryInstanceFlagBitsNVX::eTriangleCullFlipWinding) result += "TriangleCullFlipWinding | ";
    if (value & GeometryInstanceFlagBitsNVX::eForceOpaque) result += "ForceOpaque | ";
    if (value & GeometryInstanceFlagBitsNVX::eForceNoOpaque) result += "ForceNoOpaque | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(GeometryFlagBitsNVX value)
  {
    switch (value)
    {
    case GeometryFlagBitsNVX::eOpaque: return "Opaque";
    case GeometryFlagBitsNVX::eNoDuplicateAnyHitInvocation: return "NoDuplicateAnyHitInvocation";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(GeometryFlagsNVX value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & GeometryFlagBitsNVX::eOpaque) result += "Opaque | ";
    if (value & GeometryFlagBitsNVX::eNoDuplicateAnyHitInvocation) result += "NoDuplicateAnyHitInvocation | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(BuildAccelerationStructureFlagBitsNVX value)
  {
    switch (value)
    {
    case BuildAccelerationStructureFlagBitsNVX::eAllowUpdate: return "AllowUpdate";
    case BuildAccelerationStructureFlagBitsNVX::eAllowCompaction: return "AllowCompaction";
    case BuildAccelerationStructureFlagBitsNVX::ePreferFastTrace: return "PreferFastTrace";
    case BuildAccelerationStructureFlagBitsNVX::ePreferFastBuild: return "PreferFastBuild";
    case BuildAccelerationStructureFlagBitsNVX::eLowMemory: return "LowMemory";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(BuildAccelerationStructureFlagsNVX value)
  {
    if (!value) return "{}";
    std::string result;
    if (value & BuildAccelerationStructureFlagBitsNVX::eAllowUpdate) result += "AllowUpdate | ";
    if (value & BuildAccelerationStructureFlagBitsNVX::eAllowCompaction) result += "AllowCompaction | ";
    if (value & BuildAccelerationStructureFlagBitsNVX::ePreferFastTrace) result += "PreferFastTrace | ";
    if (value & BuildAccelerationStructureFlagBitsNVX::ePreferFastBuild) result += "PreferFastBuild | ";
    if (value & BuildAccelerationStructureFlagBitsNVX::eLowMemory) result += "LowMemory | ";
    return "{" + result.substr(0, result.size() - 3) + "}";
  }

  VULKAN_HPP_INLINE std::string to_string(CopyAccelerationStructureModeNVX value)
  {
    switch (value)
    {
    case CopyAccelerationStructureModeNVX::eClone: return "Clone";
    case CopyAccelerationStructureModeNVX::eCompact: return "Compact";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(AccelerationStructureTypeNVX value)
  {
    switch (value)
    {
    case AccelerationStructureTypeNVX::eTopLevel: return "TopLevel";
    case AccelerationStructureTypeNVX::eBottomLevel: return "BottomLevel";
    default: return "invalid";
    }
  }

  VULKAN_HPP_INLINE std::string to_string(GeometryTypeNVX value)
  {
    switch (value)
    {
    case GeometryTypeNVX::eTriangles: return "Triangles";
    case GeometryTypeNVX::eAabbs: return "Aabbs";
    default: return "invalid";
    }
  }

  class DispatchLoaderDynamic
  {
  public:
    PFN_vkAcquireNextImage2KHR vkAcquireNextImage2KHR = 0;
    PFN_vkAcquireNextImageKHR vkAcquireNextImageKHR = 0;
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
    PFN_vkAcquireXlibDisplayEXT vkAcquireXlibDisplayEXT = 0;
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/
    PFN_vkAllocateCommandBuffers vkAllocateCommandBuffers = 0;
    PFN_vkAllocateDescriptorSets vkAllocateDescriptorSets = 0;
    PFN_vkAllocateMemory vkAllocateMemory = 0;
    PFN_vkBeginCommandBuffer vkBeginCommandBuffer = 0;
    PFN_vkBindAccelerationStructureMemoryNVX vkBindAccelerationStructureMemoryNVX = 0;
    PFN_vkBindBufferMemory vkBindBufferMemory = 0;
    PFN_vkBindBufferMemory2 vkBindBufferMemory2 = 0;
    PFN_vkBindBufferMemory2KHR vkBindBufferMemory2KHR = 0;
    PFN_vkBindImageMemory vkBindImageMemory = 0;
    PFN_vkBindImageMemory2 vkBindImageMemory2 = 0;
    PFN_vkBindImageMemory2KHR vkBindImageMemory2KHR = 0;
    PFN_vkCmdBeginConditionalRenderingEXT vkCmdBeginConditionalRenderingEXT = 0;
    PFN_vkCmdBeginDebugUtilsLabelEXT vkCmdBeginDebugUtilsLabelEXT = 0;
    PFN_vkCmdBeginQuery vkCmdBeginQuery = 0;
    PFN_vkCmdBeginRenderPass vkCmdBeginRenderPass = 0;
    PFN_vkCmdBeginRenderPass2KHR vkCmdBeginRenderPass2KHR = 0;
    PFN_vkCmdBindDescriptorSets vkCmdBindDescriptorSets = 0;
    PFN_vkCmdBindIndexBuffer vkCmdBindIndexBuffer = 0;
    PFN_vkCmdBindPipeline vkCmdBindPipeline = 0;
    PFN_vkCmdBindShadingRateImageNV vkCmdBindShadingRateImageNV = 0;
    PFN_vkCmdBindVertexBuffers vkCmdBindVertexBuffers = 0;
    PFN_vkCmdBlitImage vkCmdBlitImage = 0;
    PFN_vkCmdBuildAccelerationStructureNVX vkCmdBuildAccelerationStructureNVX = 0;
    PFN_vkCmdClearAttachments vkCmdClearAttachments = 0;
    PFN_vkCmdClearColorImage vkCmdClearColorImage = 0;
    PFN_vkCmdClearDepthStencilImage vkCmdClearDepthStencilImage = 0;
    PFN_vkCmdCopyAccelerationStructureNVX vkCmdCopyAccelerationStructureNVX = 0;
    PFN_vkCmdCopyBuffer vkCmdCopyBuffer = 0;
    PFN_vkCmdCopyBufferToImage vkCmdCopyBufferToImage = 0;
    PFN_vkCmdCopyImage vkCmdCopyImage = 0;
    PFN_vkCmdCopyImageToBuffer vkCmdCopyImageToBuffer = 0;
    PFN_vkCmdCopyQueryPoolResults vkCmdCopyQueryPoolResults = 0;
    PFN_vkCmdDebugMarkerBeginEXT vkCmdDebugMarkerBeginEXT = 0;
    PFN_vkCmdDebugMarkerEndEXT vkCmdDebugMarkerEndEXT = 0;
    PFN_vkCmdDebugMarkerInsertEXT vkCmdDebugMarkerInsertEXT = 0;
    PFN_vkCmdDispatch vkCmdDispatch = 0;
    PFN_vkCmdDispatchBase vkCmdDispatchBase = 0;
    PFN_vkCmdDispatchBaseKHR vkCmdDispatchBaseKHR = 0;
    PFN_vkCmdDispatchIndirect vkCmdDispatchIndirect = 0;
    PFN_vkCmdDraw vkCmdDraw = 0;
    PFN_vkCmdDrawIndexed vkCmdDrawIndexed = 0;
    PFN_vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirect = 0;
    PFN_vkCmdDrawIndexedIndirectCountAMD vkCmdDrawIndexedIndirectCountAMD = 0;
    PFN_vkCmdDrawIndexedIndirectCountKHR vkCmdDrawIndexedIndirectCountKHR = 0;
    PFN_vkCmdDrawIndirect vkCmdDrawIndirect = 0;
    PFN_vkCmdDrawIndirectCountAMD vkCmdDrawIndirectCountAMD = 0;
    PFN_vkCmdDrawIndirectCountKHR vkCmdDrawIndirectCountKHR = 0;
    PFN_vkCmdDrawMeshTasksIndirectCountNV vkCmdDrawMeshTasksIndirectCountNV = 0;
    PFN_vkCmdDrawMeshTasksIndirectNV vkCmdDrawMeshTasksIndirectNV = 0;
    PFN_vkCmdDrawMeshTasksNV vkCmdDrawMeshTasksNV = 0;
    PFN_vkCmdEndConditionalRenderingEXT vkCmdEndConditionalRenderingEXT = 0;
    PFN_vkCmdEndDebugUtilsLabelEXT vkCmdEndDebugUtilsLabelEXT = 0;
    PFN_vkCmdEndQuery vkCmdEndQuery = 0;
    PFN_vkCmdEndRenderPass vkCmdEndRenderPass = 0;
    PFN_vkCmdEndRenderPass2KHR vkCmdEndRenderPass2KHR = 0;
    PFN_vkCmdExecuteCommands vkCmdExecuteCommands = 0;
    PFN_vkCmdFillBuffer vkCmdFillBuffer = 0;
    PFN_vkCmdInsertDebugUtilsLabelEXT vkCmdInsertDebugUtilsLabelEXT = 0;
    PFN_vkCmdNextSubpass vkCmdNextSubpass = 0;
    PFN_vkCmdNextSubpass2KHR vkCmdNextSubpass2KHR = 0;
    PFN_vkCmdPipelineBarrier vkCmdPipelineBarrier = 0;
    PFN_vkCmdProcessCommandsNVX vkCmdProcessCommandsNVX = 0;
    PFN_vkCmdPushConstants vkCmdPushConstants = 0;
    PFN_vkCmdPushDescriptorSetKHR vkCmdPushDescriptorSetKHR = 0;
    PFN_vkCmdPushDescriptorSetWithTemplateKHR vkCmdPushDescriptorSetWithTemplateKHR = 0;
    PFN_vkCmdReserveSpaceForCommandsNVX vkCmdReserveSpaceForCommandsNVX = 0;
    PFN_vkCmdResetEvent vkCmdResetEvent = 0;
    PFN_vkCmdResetQueryPool vkCmdResetQueryPool = 0;
    PFN_vkCmdResolveImage vkCmdResolveImage = 0;
    PFN_vkCmdSetBlendConstants vkCmdSetBlendConstants = 0;
    PFN_vkCmdSetCheckpointNV vkCmdSetCheckpointNV = 0;
    PFN_vkCmdSetCoarseSampleOrderNV vkCmdSetCoarseSampleOrderNV = 0;
    PFN_vkCmdSetDepthBias vkCmdSetDepthBias = 0;
    PFN_vkCmdSetDepthBounds vkCmdSetDepthBounds = 0;
    PFN_vkCmdSetDeviceMask vkCmdSetDeviceMask = 0;
    PFN_vkCmdSetDeviceMaskKHR vkCmdSetDeviceMaskKHR = 0;
    PFN_vkCmdSetDiscardRectangleEXT vkCmdSetDiscardRectangleEXT = 0;
    PFN_vkCmdSetEvent vkCmdSetEvent = 0;
    PFN_vkCmdSetExclusiveScissorNV vkCmdSetExclusiveScissorNV = 0;
    PFN_vkCmdSetLineWidth vkCmdSetLineWidth = 0;
    PFN_vkCmdSetSampleLocationsEXT vkCmdSetSampleLocationsEXT = 0;
    PFN_vkCmdSetScissor vkCmdSetScissor = 0;
    PFN_vkCmdSetStencilCompareMask vkCmdSetStencilCompareMask = 0;
    PFN_vkCmdSetStencilReference vkCmdSetStencilReference = 0;
    PFN_vkCmdSetStencilWriteMask vkCmdSetStencilWriteMask = 0;
    PFN_vkCmdSetViewport vkCmdSetViewport = 0;
    PFN_vkCmdSetViewportShadingRatePaletteNV vkCmdSetViewportShadingRatePaletteNV = 0;
    PFN_vkCmdSetViewportWScalingNV vkCmdSetViewportWScalingNV = 0;
    PFN_vkCmdTraceRaysNVX vkCmdTraceRaysNVX = 0;
    PFN_vkCmdUpdateBuffer vkCmdUpdateBuffer = 0;
    PFN_vkCmdWaitEvents vkCmdWaitEvents = 0;
    PFN_vkCmdWriteAccelerationStructurePropertiesNVX vkCmdWriteAccelerationStructurePropertiesNVX = 0;
    PFN_vkCmdWriteBufferMarkerAMD vkCmdWriteBufferMarkerAMD = 0;
    PFN_vkCmdWriteTimestamp vkCmdWriteTimestamp = 0;
    PFN_vkCompileDeferredNVX vkCompileDeferredNVX = 0;
    PFN_vkCreateAccelerationStructureNVX vkCreateAccelerationStructureNVX = 0;
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    PFN_vkCreateAndroidSurfaceKHR vkCreateAndroidSurfaceKHR = 0;
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
    PFN_vkCreateBuffer vkCreateBuffer = 0;
    PFN_vkCreateBufferView vkCreateBufferView = 0;
    PFN_vkCreateCommandPool vkCreateCommandPool = 0;
    PFN_vkCreateComputePipelines vkCreateComputePipelines = 0;
    PFN_vkCreateDebugReportCallbackEXT vkCreateDebugReportCallbackEXT = 0;
    PFN_vkCreateDebugUtilsMessengerEXT vkCreateDebugUtilsMessengerEXT = 0;
    PFN_vkCreateDescriptorPool vkCreateDescriptorPool = 0;
    PFN_vkCreateDescriptorSetLayout vkCreateDescriptorSetLayout = 0;
    PFN_vkCreateDescriptorUpdateTemplate vkCreateDescriptorUpdateTemplate = 0;
    PFN_vkCreateDescriptorUpdateTemplateKHR vkCreateDescriptorUpdateTemplateKHR = 0;
    PFN_vkCreateDevice vkCreateDevice = 0;
    PFN_vkCreateDisplayModeKHR vkCreateDisplayModeKHR = 0;
    PFN_vkCreateDisplayPlaneSurfaceKHR vkCreateDisplayPlaneSurfaceKHR = 0;
    PFN_vkCreateEvent vkCreateEvent = 0;
    PFN_vkCreateFence vkCreateFence = 0;
    PFN_vkCreateFramebuffer vkCreateFramebuffer = 0;
    PFN_vkCreateGraphicsPipelines vkCreateGraphicsPipelines = 0;
#ifdef VK_USE_PLATFORM_IOS_MVK
    PFN_vkCreateIOSSurfaceMVK vkCreateIOSSurfaceMVK = 0;
#endif /*VK_USE_PLATFORM_IOS_MVK*/
    PFN_vkCreateImage vkCreateImage = 0;
    PFN_vkCreateImageView vkCreateImageView = 0;
    PFN_vkCreateIndirectCommandsLayoutNVX vkCreateIndirectCommandsLayoutNVX = 0;
    PFN_vkCreateInstance vkCreateInstance = 0;
#ifdef VK_USE_PLATFORM_MACOS_MVK
    PFN_vkCreateMacOSSurfaceMVK vkCreateMacOSSurfaceMVK = 0;
#endif /*VK_USE_PLATFORM_MACOS_MVK*/
#ifdef VK_USE_PLATFORM_MIR_KHR
    PFN_vkCreateMirSurfaceKHR vkCreateMirSurfaceKHR = 0;
#endif /*VK_USE_PLATFORM_MIR_KHR*/
    PFN_vkCreateObjectTableNVX vkCreateObjectTableNVX = 0;
    PFN_vkCreatePipelineCache vkCreatePipelineCache = 0;
    PFN_vkCreatePipelineLayout vkCreatePipelineLayout = 0;
    PFN_vkCreateQueryPool vkCreateQueryPool = 0;
    PFN_vkCreateRaytracingPipelinesNVX vkCreateRaytracingPipelinesNVX = 0;
    PFN_vkCreateRenderPass vkCreateRenderPass = 0;
    PFN_vkCreateRenderPass2KHR vkCreateRenderPass2KHR = 0;
    PFN_vkCreateSampler vkCreateSampler = 0;
    PFN_vkCreateSamplerYcbcrConversion vkCreateSamplerYcbcrConversion = 0;
    PFN_vkCreateSamplerYcbcrConversionKHR vkCreateSamplerYcbcrConversionKHR = 0;
    PFN_vkCreateSemaphore vkCreateSemaphore = 0;
    PFN_vkCreateShaderModule vkCreateShaderModule = 0;
    PFN_vkCreateSharedSwapchainsKHR vkCreateSharedSwapchainsKHR = 0;
    PFN_vkCreateSwapchainKHR vkCreateSwapchainKHR = 0;
    PFN_vkCreateValidationCacheEXT vkCreateValidationCacheEXT = 0;
#ifdef VK_USE_PLATFORM_VI_NN
    PFN_vkCreateViSurfaceNN vkCreateViSurfaceNN = 0;
#endif /*VK_USE_PLATFORM_VI_NN*/
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    PFN_vkCreateWaylandSurfaceKHR vkCreateWaylandSurfaceKHR = 0;
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkCreateWin32SurfaceKHR vkCreateWin32SurfaceKHR = 0;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_XCB_KHR
    PFN_vkCreateXcbSurfaceKHR vkCreateXcbSurfaceKHR = 0;
#endif /*VK_USE_PLATFORM_XCB_KHR*/
#ifdef VK_USE_PLATFORM_XLIB_KHR
    PFN_vkCreateXlibSurfaceKHR vkCreateXlibSurfaceKHR = 0;
#endif /*VK_USE_PLATFORM_XLIB_KHR*/
    PFN_vkDebugMarkerSetObjectNameEXT vkDebugMarkerSetObjectNameEXT = 0;
    PFN_vkDebugMarkerSetObjectTagEXT vkDebugMarkerSetObjectTagEXT = 0;
    PFN_vkDebugReportMessageEXT vkDebugReportMessageEXT = 0;
    PFN_vkDestroyAccelerationStructureNVX vkDestroyAccelerationStructureNVX = 0;
    PFN_vkDestroyBuffer vkDestroyBuffer = 0;
    PFN_vkDestroyBufferView vkDestroyBufferView = 0;
    PFN_vkDestroyCommandPool vkDestroyCommandPool = 0;
    PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugReportCallbackEXT = 0;
    PFN_vkDestroyDebugUtilsMessengerEXT vkDestroyDebugUtilsMessengerEXT = 0;
    PFN_vkDestroyDescriptorPool vkDestroyDescriptorPool = 0;
    PFN_vkDestroyDescriptorSetLayout vkDestroyDescriptorSetLayout = 0;
    PFN_vkDestroyDescriptorUpdateTemplate vkDestroyDescriptorUpdateTemplate = 0;
    PFN_vkDestroyDescriptorUpdateTemplateKHR vkDestroyDescriptorUpdateTemplateKHR = 0;
    PFN_vkDestroyDevice vkDestroyDevice = 0;
    PFN_vkDestroyEvent vkDestroyEvent = 0;
    PFN_vkDestroyFence vkDestroyFence = 0;
    PFN_vkDestroyFramebuffer vkDestroyFramebuffer = 0;
    PFN_vkDestroyImage vkDestroyImage = 0;
    PFN_vkDestroyImageView vkDestroyImageView = 0;
    PFN_vkDestroyIndirectCommandsLayoutNVX vkDestroyIndirectCommandsLayoutNVX = 0;
    PFN_vkDestroyInstance vkDestroyInstance = 0;
    PFN_vkDestroyObjectTableNVX vkDestroyObjectTableNVX = 0;
    PFN_vkDestroyPipeline vkDestroyPipeline = 0;
    PFN_vkDestroyPipelineCache vkDestroyPipelineCache = 0;
    PFN_vkDestroyPipelineLayout vkDestroyPipelineLayout = 0;
    PFN_vkDestroyQueryPool vkDestroyQueryPool = 0;
    PFN_vkDestroyRenderPass vkDestroyRenderPass = 0;
    PFN_vkDestroySampler vkDestroySampler = 0;
    PFN_vkDestroySamplerYcbcrConversion vkDestroySamplerYcbcrConversion = 0;
    PFN_vkDestroySamplerYcbcrConversionKHR vkDestroySamplerYcbcrConversionKHR = 0;
    PFN_vkDestroySemaphore vkDestroySemaphore = 0;
    PFN_vkDestroyShaderModule vkDestroyShaderModule = 0;
    PFN_vkDestroySurfaceKHR vkDestroySurfaceKHR = 0;
    PFN_vkDestroySwapchainKHR vkDestroySwapchainKHR = 0;
    PFN_vkDestroyValidationCacheEXT vkDestroyValidationCacheEXT = 0;
    PFN_vkDeviceWaitIdle vkDeviceWaitIdle = 0;
    PFN_vkDisplayPowerControlEXT vkDisplayPowerControlEXT = 0;
    PFN_vkEndCommandBuffer vkEndCommandBuffer = 0;
    PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties = 0;
    PFN_vkEnumerateDeviceLayerProperties vkEnumerateDeviceLayerProperties = 0;
    PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties = 0;
    PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties = 0;
    PFN_vkEnumerateInstanceVersion vkEnumerateInstanceVersion = 0;
    PFN_vkEnumeratePhysicalDeviceGroups vkEnumeratePhysicalDeviceGroups = 0;
    PFN_vkEnumeratePhysicalDeviceGroupsKHR vkEnumeratePhysicalDeviceGroupsKHR = 0;
    PFN_vkEnumeratePhysicalDevices vkEnumeratePhysicalDevices = 0;
    PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges = 0;
    PFN_vkFreeCommandBuffers vkFreeCommandBuffers = 0;
    PFN_vkFreeDescriptorSets vkFreeDescriptorSets = 0;
    PFN_vkFreeMemory vkFreeMemory = 0;
    PFN_vkGetAccelerationStructureHandleNVX vkGetAccelerationStructureHandleNVX = 0;
    PFN_vkGetAccelerationStructureMemoryRequirementsNVX vkGetAccelerationStructureMemoryRequirementsNVX = 0;
    PFN_vkGetAccelerationStructureScratchMemoryRequirementsNVX vkGetAccelerationStructureScratchMemoryRequirementsNVX = 0;
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
    PFN_vkGetAndroidHardwareBufferPropertiesANDROID vkGetAndroidHardwareBufferPropertiesANDROID = 0;
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
    PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements = 0;
    PFN_vkGetBufferMemoryRequirements2 vkGetBufferMemoryRequirements2 = 0;
    PFN_vkGetBufferMemoryRequirements2KHR vkGetBufferMemoryRequirements2KHR = 0;
    PFN_vkGetDescriptorSetLayoutSupport vkGetDescriptorSetLayoutSupport = 0;
    PFN_vkGetDescriptorSetLayoutSupportKHR vkGetDescriptorSetLayoutSupportKHR = 0;
    PFN_vkGetDeviceGroupPeerMemoryFeatures vkGetDeviceGroupPeerMemoryFeatures = 0;
    PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR vkGetDeviceGroupPeerMemoryFeaturesKHR = 0;
    PFN_vkGetDeviceGroupPresentCapabilitiesKHR vkGetDeviceGroupPresentCapabilitiesKHR = 0;
    PFN_vkGetDeviceGroupSurfacePresentModesKHR vkGetDeviceGroupSurfacePresentModesKHR = 0;
    PFN_vkGetDeviceMemoryCommitment vkGetDeviceMemoryCommitment = 0;
    PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr = 0;
    PFN_vkGetDeviceQueue vkGetDeviceQueue = 0;
    PFN_vkGetDeviceQueue2 vkGetDeviceQueue2 = 0;
    PFN_vkGetDisplayModeProperties2KHR vkGetDisplayModeProperties2KHR = 0;
    PFN_vkGetDisplayModePropertiesKHR vkGetDisplayModePropertiesKHR = 0;
    PFN_vkGetDisplayPlaneCapabilities2KHR vkGetDisplayPlaneCapabilities2KHR = 0;
    PFN_vkGetDisplayPlaneCapabilitiesKHR vkGetDisplayPlaneCapabilitiesKHR = 0;
    PFN_vkGetDisplayPlaneSupportedDisplaysKHR vkGetDisplayPlaneSupportedDisplaysKHR = 0;
    PFN_vkGetEventStatus vkGetEventStatus = 0;
    PFN_vkGetFenceFdKHR vkGetFenceFdKHR = 0;
    PFN_vkGetFenceStatus vkGetFenceStatus = 0;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetFenceWin32HandleKHR vkGetFenceWin32HandleKHR = 0;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
    PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements = 0;
    PFN_vkGetImageMemoryRequirements2 vkGetImageMemoryRequirements2 = 0;
    PFN_vkGetImageMemoryRequirements2KHR vkGetImageMemoryRequirements2KHR = 0;
    PFN_vkGetImageSparseMemoryRequirements vkGetImageSparseMemoryRequirements = 0;
    PFN_vkGetImageSparseMemoryRequirements2 vkGetImageSparseMemoryRequirements2 = 0;
    PFN_vkGetImageSparseMemoryRequirements2KHR vkGetImageSparseMemoryRequirements2KHR = 0;
    PFN_vkGetImageSubresourceLayout vkGetImageSubresourceLayout = 0;
    PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = 0;
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
    PFN_vkGetMemoryAndroidHardwareBufferANDROID vkGetMemoryAndroidHardwareBufferANDROID = 0;
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
    PFN_vkGetMemoryFdKHR vkGetMemoryFdKHR = 0;
    PFN_vkGetMemoryFdPropertiesKHR vkGetMemoryFdPropertiesKHR = 0;
    PFN_vkGetMemoryHostPointerPropertiesEXT vkGetMemoryHostPointerPropertiesEXT = 0;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetMemoryWin32HandleKHR vkGetMemoryWin32HandleKHR = 0;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_NV
    PFN_vkGetMemoryWin32HandleNV vkGetMemoryWin32HandleNV = 0;
#endif /*VK_USE_PLATFORM_WIN32_NV*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetMemoryWin32HandlePropertiesKHR vkGetMemoryWin32HandlePropertiesKHR = 0;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
    PFN_vkGetPastPresentationTimingGOOGLE vkGetPastPresentationTimingGOOGLE = 0;
    PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR vkGetPhysicalDeviceDisplayPlaneProperties2KHR = 0;
    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR vkGetPhysicalDeviceDisplayPlanePropertiesKHR = 0;
    PFN_vkGetPhysicalDeviceDisplayProperties2KHR vkGetPhysicalDeviceDisplayProperties2KHR = 0;
    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR vkGetPhysicalDeviceDisplayPropertiesKHR = 0;
    PFN_vkGetPhysicalDeviceExternalBufferProperties vkGetPhysicalDeviceExternalBufferProperties = 0;
    PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR vkGetPhysicalDeviceExternalBufferPropertiesKHR = 0;
    PFN_vkGetPhysicalDeviceExternalFenceProperties vkGetPhysicalDeviceExternalFenceProperties = 0;
    PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR vkGetPhysicalDeviceExternalFencePropertiesKHR = 0;
    PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV vkGetPhysicalDeviceExternalImageFormatPropertiesNV = 0;
    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties vkGetPhysicalDeviceExternalSemaphoreProperties = 0;
    PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = 0;
    PFN_vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceFeatures = 0;
    PFN_vkGetPhysicalDeviceFeatures2 vkGetPhysicalDeviceFeatures2 = 0;
    PFN_vkGetPhysicalDeviceFeatures2KHR vkGetPhysicalDeviceFeatures2KHR = 0;
    PFN_vkGetPhysicalDeviceFormatProperties vkGetPhysicalDeviceFormatProperties = 0;
    PFN_vkGetPhysicalDeviceFormatProperties2 vkGetPhysicalDeviceFormatProperties2 = 0;
    PFN_vkGetPhysicalDeviceFormatProperties2KHR vkGetPhysicalDeviceFormatProperties2KHR = 0;
    PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = 0;
    PFN_vkGetPhysicalDeviceImageFormatProperties vkGetPhysicalDeviceImageFormatProperties = 0;
    PFN_vkGetPhysicalDeviceImageFormatProperties2 vkGetPhysicalDeviceImageFormatProperties2 = 0;
    PFN_vkGetPhysicalDeviceImageFormatProperties2KHR vkGetPhysicalDeviceImageFormatProperties2KHR = 0;
    PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties = 0;
    PFN_vkGetPhysicalDeviceMemoryProperties2 vkGetPhysicalDeviceMemoryProperties2 = 0;
    PFN_vkGetPhysicalDeviceMemoryProperties2KHR vkGetPhysicalDeviceMemoryProperties2KHR = 0;
#ifdef VK_USE_PLATFORM_MIR_KHR
    PFN_vkGetPhysicalDeviceMirPresentationSupportKHR vkGetPhysicalDeviceMirPresentationSupportKHR = 0;
#endif /*VK_USE_PLATFORM_MIR_KHR*/
    PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT vkGetPhysicalDeviceMultisamplePropertiesEXT = 0;
    PFN_vkGetPhysicalDevicePresentRectanglesKHR vkGetPhysicalDevicePresentRectanglesKHR = 0;
    PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties = 0;
    PFN_vkGetPhysicalDeviceProperties2 vkGetPhysicalDeviceProperties2 = 0;
    PFN_vkGetPhysicalDeviceProperties2KHR vkGetPhysicalDeviceProperties2KHR = 0;
    PFN_vkGetPhysicalDeviceQueueFamilyProperties vkGetPhysicalDeviceQueueFamilyProperties = 0;
    PFN_vkGetPhysicalDeviceQueueFamilyProperties2 vkGetPhysicalDeviceQueueFamilyProperties2 = 0;
    PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR vkGetPhysicalDeviceQueueFamilyProperties2KHR = 0;
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties vkGetPhysicalDeviceSparseImageFormatProperties = 0;
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 vkGetPhysicalDeviceSparseImageFormatProperties2 = 0;
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR vkGetPhysicalDeviceSparseImageFormatProperties2KHR = 0;
    PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT vkGetPhysicalDeviceSurfaceCapabilities2EXT = 0;
    PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR vkGetPhysicalDeviceSurfaceCapabilities2KHR = 0;
    PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR vkGetPhysicalDeviceSurfaceCapabilitiesKHR = 0;
    PFN_vkGetPhysicalDeviceSurfaceFormats2KHR vkGetPhysicalDeviceSurfaceFormats2KHR = 0;
    PFN_vkGetPhysicalDeviceSurfaceFormatsKHR vkGetPhysicalDeviceSurfaceFormatsKHR = 0;
    PFN_vkGetPhysicalDeviceSurfacePresentModesKHR vkGetPhysicalDeviceSurfacePresentModesKHR = 0;
    PFN_vkGetPhysicalDeviceSurfaceSupportKHR vkGetPhysicalDeviceSurfaceSupportKHR = 0;
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR vkGetPhysicalDeviceWaylandPresentationSupportKHR = 0;
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR vkGetPhysicalDeviceWin32PresentationSupportKHR = 0;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_XCB_KHR
    PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR vkGetPhysicalDeviceXcbPresentationSupportKHR = 0;
#endif /*VK_USE_PLATFORM_XCB_KHR*/
#ifdef VK_USE_PLATFORM_XLIB_KHR
    PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR vkGetPhysicalDeviceXlibPresentationSupportKHR = 0;
#endif /*VK_USE_PLATFORM_XLIB_KHR*/
    PFN_vkGetPipelineCacheData vkGetPipelineCacheData = 0;
    PFN_vkGetQueryPoolResults vkGetQueryPoolResults = 0;
    PFN_vkGetQueueCheckpointDataNV vkGetQueueCheckpointDataNV = 0;
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
    PFN_vkGetRandROutputDisplayEXT vkGetRandROutputDisplayEXT = 0;
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/
    PFN_vkGetRaytracingShaderHandlesNVX vkGetRaytracingShaderHandlesNVX = 0;
    PFN_vkGetRefreshCycleDurationGOOGLE vkGetRefreshCycleDurationGOOGLE = 0;
    PFN_vkGetRenderAreaGranularity vkGetRenderAreaGranularity = 0;
    PFN_vkGetSemaphoreFdKHR vkGetSemaphoreFdKHR = 0;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetSemaphoreWin32HandleKHR vkGetSemaphoreWin32HandleKHR = 0;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
    PFN_vkGetShaderInfoAMD vkGetShaderInfoAMD = 0;
    PFN_vkGetSwapchainCounterEXT vkGetSwapchainCounterEXT = 0;
    PFN_vkGetSwapchainImagesKHR vkGetSwapchainImagesKHR = 0;
    PFN_vkGetSwapchainStatusKHR vkGetSwapchainStatusKHR = 0;
    PFN_vkGetValidationCacheDataEXT vkGetValidationCacheDataEXT = 0;
    PFN_vkImportFenceFdKHR vkImportFenceFdKHR = 0;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkImportFenceWin32HandleKHR vkImportFenceWin32HandleKHR = 0;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
    PFN_vkImportSemaphoreFdKHR vkImportSemaphoreFdKHR = 0;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkImportSemaphoreWin32HandleKHR vkImportSemaphoreWin32HandleKHR = 0;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
    PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges = 0;
    PFN_vkMapMemory vkMapMemory = 0;
    PFN_vkMergePipelineCaches vkMergePipelineCaches = 0;
    PFN_vkMergeValidationCachesEXT vkMergeValidationCachesEXT = 0;
    PFN_vkQueueBeginDebugUtilsLabelEXT vkQueueBeginDebugUtilsLabelEXT = 0;
    PFN_vkQueueBindSparse vkQueueBindSparse = 0;
    PFN_vkQueueEndDebugUtilsLabelEXT vkQueueEndDebugUtilsLabelEXT = 0;
    PFN_vkQueueInsertDebugUtilsLabelEXT vkQueueInsertDebugUtilsLabelEXT = 0;
    PFN_vkQueuePresentKHR vkQueuePresentKHR = 0;
    PFN_vkQueueSubmit vkQueueSubmit = 0;
    PFN_vkQueueWaitIdle vkQueueWaitIdle = 0;
    PFN_vkRegisterDeviceEventEXT vkRegisterDeviceEventEXT = 0;
    PFN_vkRegisterDisplayEventEXT vkRegisterDisplayEventEXT = 0;
    PFN_vkRegisterObjectsNVX vkRegisterObjectsNVX = 0;
    PFN_vkReleaseDisplayEXT vkReleaseDisplayEXT = 0;
    PFN_vkResetCommandBuffer vkResetCommandBuffer = 0;
    PFN_vkResetCommandPool vkResetCommandPool = 0;
    PFN_vkResetDescriptorPool vkResetDescriptorPool = 0;
    PFN_vkResetEvent vkResetEvent = 0;
    PFN_vkResetFences vkResetFences = 0;
    PFN_vkSetDebugUtilsObjectNameEXT vkSetDebugUtilsObjectNameEXT = 0;
    PFN_vkSetDebugUtilsObjectTagEXT vkSetDebugUtilsObjectTagEXT = 0;
    PFN_vkSetEvent vkSetEvent = 0;
    PFN_vkSetHdrMetadataEXT vkSetHdrMetadataEXT = 0;
    PFN_vkSubmitDebugUtilsMessageEXT vkSubmitDebugUtilsMessageEXT = 0;
    PFN_vkTrimCommandPool vkTrimCommandPool = 0;
    PFN_vkTrimCommandPoolKHR vkTrimCommandPoolKHR = 0;
    PFN_vkUnmapMemory vkUnmapMemory = 0;
    PFN_vkUnregisterObjectsNVX vkUnregisterObjectsNVX = 0;
    PFN_vkUpdateDescriptorSetWithTemplate vkUpdateDescriptorSetWithTemplate = 0;
    PFN_vkUpdateDescriptorSetWithTemplateKHR vkUpdateDescriptorSetWithTemplateKHR = 0;
    PFN_vkUpdateDescriptorSets vkUpdateDescriptorSets = 0;
    PFN_vkWaitForFences vkWaitForFences = 0;
  public:
    DispatchLoaderDynamic(Instance instance = Instance(), Device device = Device())
    {
      if (instance)
      {
        init(instance, device);
      }
    }

    void init(Instance instance, Device device = Device())
    {
      vkAcquireNextImage2KHR = PFN_vkAcquireNextImage2KHR(device ? device.getProcAddr( "vkAcquireNextImage2KHR") : instance.getProcAddr( "vkAcquireNextImage2KHR"));
      vkAcquireNextImageKHR = PFN_vkAcquireNextImageKHR(device ? device.getProcAddr( "vkAcquireNextImageKHR") : instance.getProcAddr( "vkAcquireNextImageKHR"));
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
      vkAcquireXlibDisplayEXT = PFN_vkAcquireXlibDisplayEXT(instance.getProcAddr( "vkAcquireXlibDisplayEXT"));
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/
      vkAllocateCommandBuffers = PFN_vkAllocateCommandBuffers(device ? device.getProcAddr( "vkAllocateCommandBuffers") : instance.getProcAddr( "vkAllocateCommandBuffers"));
      vkAllocateDescriptorSets = PFN_vkAllocateDescriptorSets(device ? device.getProcAddr( "vkAllocateDescriptorSets") : instance.getProcAddr( "vkAllocateDescriptorSets"));
      vkAllocateMemory = PFN_vkAllocateMemory(device ? device.getProcAddr( "vkAllocateMemory") : instance.getProcAddr( "vkAllocateMemory"));
      vkBeginCommandBuffer = PFN_vkBeginCommandBuffer(device ? device.getProcAddr( "vkBeginCommandBuffer") : instance.getProcAddr( "vkBeginCommandBuffer"));
      vkBindAccelerationStructureMemoryNVX = PFN_vkBindAccelerationStructureMemoryNVX(device ? device.getProcAddr( "vkBindAccelerationStructureMemoryNVX") : instance.getProcAddr( "vkBindAccelerationStructureMemoryNVX"));
      vkBindBufferMemory = PFN_vkBindBufferMemory(device ? device.getProcAddr( "vkBindBufferMemory") : instance.getProcAddr( "vkBindBufferMemory"));
      vkBindBufferMemory2 = PFN_vkBindBufferMemory2(device ? device.getProcAddr( "vkBindBufferMemory2") : instance.getProcAddr( "vkBindBufferMemory2"));
      vkBindBufferMemory2KHR = PFN_vkBindBufferMemory2KHR(device ? device.getProcAddr( "vkBindBufferMemory2KHR") : instance.getProcAddr( "vkBindBufferMemory2KHR"));
      vkBindImageMemory = PFN_vkBindImageMemory(device ? device.getProcAddr( "vkBindImageMemory") : instance.getProcAddr( "vkBindImageMemory"));
      vkBindImageMemory2 = PFN_vkBindImageMemory2(device ? device.getProcAddr( "vkBindImageMemory2") : instance.getProcAddr( "vkBindImageMemory2"));
      vkBindImageMemory2KHR = PFN_vkBindImageMemory2KHR(device ? device.getProcAddr( "vkBindImageMemory2KHR") : instance.getProcAddr( "vkBindImageMemory2KHR"));
      vkCmdBeginConditionalRenderingEXT = PFN_vkCmdBeginConditionalRenderingEXT(device ? device.getProcAddr( "vkCmdBeginConditionalRenderingEXT") : instance.getProcAddr( "vkCmdBeginConditionalRenderingEXT"));
      vkCmdBeginDebugUtilsLabelEXT = PFN_vkCmdBeginDebugUtilsLabelEXT(device ? device.getProcAddr( "vkCmdBeginDebugUtilsLabelEXT") : instance.getProcAddr( "vkCmdBeginDebugUtilsLabelEXT"));
      vkCmdBeginQuery = PFN_vkCmdBeginQuery(device ? device.getProcAddr( "vkCmdBeginQuery") : instance.getProcAddr( "vkCmdBeginQuery"));
      vkCmdBeginRenderPass = PFN_vkCmdBeginRenderPass(device ? device.getProcAddr( "vkCmdBeginRenderPass") : instance.getProcAddr( "vkCmdBeginRenderPass"));
      vkCmdBeginRenderPass2KHR = PFN_vkCmdBeginRenderPass2KHR(device ? device.getProcAddr( "vkCmdBeginRenderPass2KHR") : instance.getProcAddr( "vkCmdBeginRenderPass2KHR"));
      vkCmdBindDescriptorSets = PFN_vkCmdBindDescriptorSets(device ? device.getProcAddr( "vkCmdBindDescriptorSets") : instance.getProcAddr( "vkCmdBindDescriptorSets"));
      vkCmdBindIndexBuffer = PFN_vkCmdBindIndexBuffer(device ? device.getProcAddr( "vkCmdBindIndexBuffer") : instance.getProcAddr( "vkCmdBindIndexBuffer"));
      vkCmdBindPipeline = PFN_vkCmdBindPipeline(device ? device.getProcAddr( "vkCmdBindPipeline") : instance.getProcAddr( "vkCmdBindPipeline"));
      vkCmdBindShadingRateImageNV = PFN_vkCmdBindShadingRateImageNV(device ? device.getProcAddr( "vkCmdBindShadingRateImageNV") : instance.getProcAddr( "vkCmdBindShadingRateImageNV"));
      vkCmdBindVertexBuffers = PFN_vkCmdBindVertexBuffers(device ? device.getProcAddr( "vkCmdBindVertexBuffers") : instance.getProcAddr( "vkCmdBindVertexBuffers"));
      vkCmdBlitImage = PFN_vkCmdBlitImage(device ? device.getProcAddr( "vkCmdBlitImage") : instance.getProcAddr( "vkCmdBlitImage"));
      vkCmdBuildAccelerationStructureNVX = PFN_vkCmdBuildAccelerationStructureNVX(device ? device.getProcAddr( "vkCmdBuildAccelerationStructureNVX") : instance.getProcAddr( "vkCmdBuildAccelerationStructureNVX"));
      vkCmdClearAttachments = PFN_vkCmdClearAttachments(device ? device.getProcAddr( "vkCmdClearAttachments") : instance.getProcAddr( "vkCmdClearAttachments"));
      vkCmdClearColorImage = PFN_vkCmdClearColorImage(device ? device.getProcAddr( "vkCmdClearColorImage") : instance.getProcAddr( "vkCmdClearColorImage"));
      vkCmdClearDepthStencilImage = PFN_vkCmdClearDepthStencilImage(device ? device.getProcAddr( "vkCmdClearDepthStencilImage") : instance.getProcAddr( "vkCmdClearDepthStencilImage"));
      vkCmdCopyAccelerationStructureNVX = PFN_vkCmdCopyAccelerationStructureNVX(device ? device.getProcAddr( "vkCmdCopyAccelerationStructureNVX") : instance.getProcAddr( "vkCmdCopyAccelerationStructureNVX"));
      vkCmdCopyBuffer = PFN_vkCmdCopyBuffer(device ? device.getProcAddr( "vkCmdCopyBuffer") : instance.getProcAddr( "vkCmdCopyBuffer"));
      vkCmdCopyBufferToImage = PFN_vkCmdCopyBufferToImage(device ? device.getProcAddr( "vkCmdCopyBufferToImage") : instance.getProcAddr( "vkCmdCopyBufferToImage"));
      vkCmdCopyImage = PFN_vkCmdCopyImage(device ? device.getProcAddr( "vkCmdCopyImage") : instance.getProcAddr( "vkCmdCopyImage"));
      vkCmdCopyImageToBuffer = PFN_vkCmdCopyImageToBuffer(device ? device.getProcAddr( "vkCmdCopyImageToBuffer") : instance.getProcAddr( "vkCmdCopyImageToBuffer"));
      vkCmdCopyQueryPoolResults = PFN_vkCmdCopyQueryPoolResults(device ? device.getProcAddr( "vkCmdCopyQueryPoolResults") : instance.getProcAddr( "vkCmdCopyQueryPoolResults"));
      vkCmdDebugMarkerBeginEXT = PFN_vkCmdDebugMarkerBeginEXT(device ? device.getProcAddr( "vkCmdDebugMarkerBeginEXT") : instance.getProcAddr( "vkCmdDebugMarkerBeginEXT"));
      vkCmdDebugMarkerEndEXT = PFN_vkCmdDebugMarkerEndEXT(device ? device.getProcAddr( "vkCmdDebugMarkerEndEXT") : instance.getProcAddr( "vkCmdDebugMarkerEndEXT"));
      vkCmdDebugMarkerInsertEXT = PFN_vkCmdDebugMarkerInsertEXT(device ? device.getProcAddr( "vkCmdDebugMarkerInsertEXT") : instance.getProcAddr( "vkCmdDebugMarkerInsertEXT"));
      vkCmdDispatch = PFN_vkCmdDispatch(device ? device.getProcAddr( "vkCmdDispatch") : instance.getProcAddr( "vkCmdDispatch"));
      vkCmdDispatchBase = PFN_vkCmdDispatchBase(device ? device.getProcAddr( "vkCmdDispatchBase") : instance.getProcAddr( "vkCmdDispatchBase"));
      vkCmdDispatchBaseKHR = PFN_vkCmdDispatchBaseKHR(device ? device.getProcAddr( "vkCmdDispatchBaseKHR") : instance.getProcAddr( "vkCmdDispatchBaseKHR"));
      vkCmdDispatchIndirect = PFN_vkCmdDispatchIndirect(device ? device.getProcAddr( "vkCmdDispatchIndirect") : instance.getProcAddr( "vkCmdDispatchIndirect"));
      vkCmdDraw = PFN_vkCmdDraw(device ? device.getProcAddr( "vkCmdDraw") : instance.getProcAddr( "vkCmdDraw"));
      vkCmdDrawIndexed = PFN_vkCmdDrawIndexed(device ? device.getProcAddr( "vkCmdDrawIndexed") : instance.getProcAddr( "vkCmdDrawIndexed"));
      vkCmdDrawIndexedIndirect = PFN_vkCmdDrawIndexedIndirect(device ? device.getProcAddr( "vkCmdDrawIndexedIndirect") : instance.getProcAddr( "vkCmdDrawIndexedIndirect"));
      vkCmdDrawIndexedIndirectCountAMD = PFN_vkCmdDrawIndexedIndirectCountAMD(device ? device.getProcAddr( "vkCmdDrawIndexedIndirectCountAMD") : instance.getProcAddr( "vkCmdDrawIndexedIndirectCountAMD"));
      vkCmdDrawIndexedIndirectCountKHR = PFN_vkCmdDrawIndexedIndirectCountKHR(device ? device.getProcAddr( "vkCmdDrawIndexedIndirectCountKHR") : instance.getProcAddr( "vkCmdDrawIndexedIndirectCountKHR"));
      vkCmdDrawIndirect = PFN_vkCmdDrawIndirect(device ? device.getProcAddr( "vkCmdDrawIndirect") : instance.getProcAddr( "vkCmdDrawIndirect"));
      vkCmdDrawIndirectCountAMD = PFN_vkCmdDrawIndirectCountAMD(device ? device.getProcAddr( "vkCmdDrawIndirectCountAMD") : instance.getProcAddr( "vkCmdDrawIndirectCountAMD"));
      vkCmdDrawIndirectCountKHR = PFN_vkCmdDrawIndirectCountKHR(device ? device.getProcAddr( "vkCmdDrawIndirectCountKHR") : instance.getProcAddr( "vkCmdDrawIndirectCountKHR"));
      vkCmdDrawMeshTasksIndirectCountNV = PFN_vkCmdDrawMeshTasksIndirectCountNV(device ? device.getProcAddr( "vkCmdDrawMeshTasksIndirectCountNV") : instance.getProcAddr( "vkCmdDrawMeshTasksIndirectCountNV"));
      vkCmdDrawMeshTasksIndirectNV = PFN_vkCmdDrawMeshTasksIndirectNV(device ? device.getProcAddr( "vkCmdDrawMeshTasksIndirectNV") : instance.getProcAddr( "vkCmdDrawMeshTasksIndirectNV"));
      vkCmdDrawMeshTasksNV = PFN_vkCmdDrawMeshTasksNV(device ? device.getProcAddr( "vkCmdDrawMeshTasksNV") : instance.getProcAddr( "vkCmdDrawMeshTasksNV"));
      vkCmdEndConditionalRenderingEXT = PFN_vkCmdEndConditionalRenderingEXT(device ? device.getProcAddr( "vkCmdEndConditionalRenderingEXT") : instance.getProcAddr( "vkCmdEndConditionalRenderingEXT"));
      vkCmdEndDebugUtilsLabelEXT = PFN_vkCmdEndDebugUtilsLabelEXT(device ? device.getProcAddr( "vkCmdEndDebugUtilsLabelEXT") : instance.getProcAddr( "vkCmdEndDebugUtilsLabelEXT"));
      vkCmdEndQuery = PFN_vkCmdEndQuery(device ? device.getProcAddr( "vkCmdEndQuery") : instance.getProcAddr( "vkCmdEndQuery"));
      vkCmdEndRenderPass = PFN_vkCmdEndRenderPass(device ? device.getProcAddr( "vkCmdEndRenderPass") : instance.getProcAddr( "vkCmdEndRenderPass"));
      vkCmdEndRenderPass2KHR = PFN_vkCmdEndRenderPass2KHR(device ? device.getProcAddr( "vkCmdEndRenderPass2KHR") : instance.getProcAddr( "vkCmdEndRenderPass2KHR"));
      vkCmdExecuteCommands = PFN_vkCmdExecuteCommands(device ? device.getProcAddr( "vkCmdExecuteCommands") : instance.getProcAddr( "vkCmdExecuteCommands"));
      vkCmdFillBuffer = PFN_vkCmdFillBuffer(device ? device.getProcAddr( "vkCmdFillBuffer") : instance.getProcAddr( "vkCmdFillBuffer"));
      vkCmdInsertDebugUtilsLabelEXT = PFN_vkCmdInsertDebugUtilsLabelEXT(device ? device.getProcAddr( "vkCmdInsertDebugUtilsLabelEXT") : instance.getProcAddr( "vkCmdInsertDebugUtilsLabelEXT"));
      vkCmdNextSubpass = PFN_vkCmdNextSubpass(device ? device.getProcAddr( "vkCmdNextSubpass") : instance.getProcAddr( "vkCmdNextSubpass"));
      vkCmdNextSubpass2KHR = PFN_vkCmdNextSubpass2KHR(device ? device.getProcAddr( "vkCmdNextSubpass2KHR") : instance.getProcAddr( "vkCmdNextSubpass2KHR"));
      vkCmdPipelineBarrier = PFN_vkCmdPipelineBarrier(device ? device.getProcAddr( "vkCmdPipelineBarrier") : instance.getProcAddr( "vkCmdPipelineBarrier"));
      vkCmdProcessCommandsNVX = PFN_vkCmdProcessCommandsNVX(device ? device.getProcAddr( "vkCmdProcessCommandsNVX") : instance.getProcAddr( "vkCmdProcessCommandsNVX"));
      vkCmdPushConstants = PFN_vkCmdPushConstants(device ? device.getProcAddr( "vkCmdPushConstants") : instance.getProcAddr( "vkCmdPushConstants"));
      vkCmdPushDescriptorSetKHR = PFN_vkCmdPushDescriptorSetKHR(device ? device.getProcAddr( "vkCmdPushDescriptorSetKHR") : instance.getProcAddr( "vkCmdPushDescriptorSetKHR"));
      vkCmdPushDescriptorSetWithTemplateKHR = PFN_vkCmdPushDescriptorSetWithTemplateKHR(device ? device.getProcAddr( "vkCmdPushDescriptorSetWithTemplateKHR") : instance.getProcAddr( "vkCmdPushDescriptorSetWithTemplateKHR"));
      vkCmdReserveSpaceForCommandsNVX = PFN_vkCmdReserveSpaceForCommandsNVX(device ? device.getProcAddr( "vkCmdReserveSpaceForCommandsNVX") : instance.getProcAddr( "vkCmdReserveSpaceForCommandsNVX"));
      vkCmdResetEvent = PFN_vkCmdResetEvent(device ? device.getProcAddr( "vkCmdResetEvent") : instance.getProcAddr( "vkCmdResetEvent"));
      vkCmdResetQueryPool = PFN_vkCmdResetQueryPool(device ? device.getProcAddr( "vkCmdResetQueryPool") : instance.getProcAddr( "vkCmdResetQueryPool"));
      vkCmdResolveImage = PFN_vkCmdResolveImage(device ? device.getProcAddr( "vkCmdResolveImage") : instance.getProcAddr( "vkCmdResolveImage"));
      vkCmdSetBlendConstants = PFN_vkCmdSetBlendConstants(device ? device.getProcAddr( "vkCmdSetBlendConstants") : instance.getProcAddr( "vkCmdSetBlendConstants"));
      vkCmdSetCheckpointNV = PFN_vkCmdSetCheckpointNV(device ? device.getProcAddr( "vkCmdSetCheckpointNV") : instance.getProcAddr( "vkCmdSetCheckpointNV"));
      vkCmdSetCoarseSampleOrderNV = PFN_vkCmdSetCoarseSampleOrderNV(device ? device.getProcAddr( "vkCmdSetCoarseSampleOrderNV") : instance.getProcAddr( "vkCmdSetCoarseSampleOrderNV"));
      vkCmdSetDepthBias = PFN_vkCmdSetDepthBias(device ? device.getProcAddr( "vkCmdSetDepthBias") : instance.getProcAddr( "vkCmdSetDepthBias"));
      vkCmdSetDepthBounds = PFN_vkCmdSetDepthBounds(device ? device.getProcAddr( "vkCmdSetDepthBounds") : instance.getProcAddr( "vkCmdSetDepthBounds"));
      vkCmdSetDeviceMask = PFN_vkCmdSetDeviceMask(device ? device.getProcAddr( "vkCmdSetDeviceMask") : instance.getProcAddr( "vkCmdSetDeviceMask"));
      vkCmdSetDeviceMaskKHR = PFN_vkCmdSetDeviceMaskKHR(device ? device.getProcAddr( "vkCmdSetDeviceMaskKHR") : instance.getProcAddr( "vkCmdSetDeviceMaskKHR"));
      vkCmdSetDiscardRectangleEXT = PFN_vkCmdSetDiscardRectangleEXT(device ? device.getProcAddr( "vkCmdSetDiscardRectangleEXT") : instance.getProcAddr( "vkCmdSetDiscardRectangleEXT"));
      vkCmdSetEvent = PFN_vkCmdSetEvent(device ? device.getProcAddr( "vkCmdSetEvent") : instance.getProcAddr( "vkCmdSetEvent"));
      vkCmdSetExclusiveScissorNV = PFN_vkCmdSetExclusiveScissorNV(device ? device.getProcAddr( "vkCmdSetExclusiveScissorNV") : instance.getProcAddr( "vkCmdSetExclusiveScissorNV"));
      vkCmdSetLineWidth = PFN_vkCmdSetLineWidth(device ? device.getProcAddr( "vkCmdSetLineWidth") : instance.getProcAddr( "vkCmdSetLineWidth"));
      vkCmdSetSampleLocationsEXT = PFN_vkCmdSetSampleLocationsEXT(device ? device.getProcAddr( "vkCmdSetSampleLocationsEXT") : instance.getProcAddr( "vkCmdSetSampleLocationsEXT"));
      vkCmdSetScissor = PFN_vkCmdSetScissor(device ? device.getProcAddr( "vkCmdSetScissor") : instance.getProcAddr( "vkCmdSetScissor"));
      vkCmdSetStencilCompareMask = PFN_vkCmdSetStencilCompareMask(device ? device.getProcAddr( "vkCmdSetStencilCompareMask") : instance.getProcAddr( "vkCmdSetStencilCompareMask"));
      vkCmdSetStencilReference = PFN_vkCmdSetStencilReference(device ? device.getProcAddr( "vkCmdSetStencilReference") : instance.getProcAddr( "vkCmdSetStencilReference"));
      vkCmdSetStencilWriteMask = PFN_vkCmdSetStencilWriteMask(device ? device.getProcAddr( "vkCmdSetStencilWriteMask") : instance.getProcAddr( "vkCmdSetStencilWriteMask"));
      vkCmdSetViewport = PFN_vkCmdSetViewport(device ? device.getProcAddr( "vkCmdSetViewport") : instance.getProcAddr( "vkCmdSetViewport"));
      vkCmdSetViewportShadingRatePaletteNV = PFN_vkCmdSetViewportShadingRatePaletteNV(device ? device.getProcAddr( "vkCmdSetViewportShadingRatePaletteNV") : instance.getProcAddr( "vkCmdSetViewportShadingRatePaletteNV"));
      vkCmdSetViewportWScalingNV = PFN_vkCmdSetViewportWScalingNV(device ? device.getProcAddr( "vkCmdSetViewportWScalingNV") : instance.getProcAddr( "vkCmdSetViewportWScalingNV"));
      vkCmdTraceRaysNVX = PFN_vkCmdTraceRaysNVX(device ? device.getProcAddr( "vkCmdTraceRaysNVX") : instance.getProcAddr( "vkCmdTraceRaysNVX"));
      vkCmdUpdateBuffer = PFN_vkCmdUpdateBuffer(device ? device.getProcAddr( "vkCmdUpdateBuffer") : instance.getProcAddr( "vkCmdUpdateBuffer"));
      vkCmdWaitEvents = PFN_vkCmdWaitEvents(device ? device.getProcAddr( "vkCmdWaitEvents") : instance.getProcAddr( "vkCmdWaitEvents"));
      vkCmdWriteAccelerationStructurePropertiesNVX = PFN_vkCmdWriteAccelerationStructurePropertiesNVX(device ? device.getProcAddr( "vkCmdWriteAccelerationStructurePropertiesNVX") : instance.getProcAddr( "vkCmdWriteAccelerationStructurePropertiesNVX"));
      vkCmdWriteBufferMarkerAMD = PFN_vkCmdWriteBufferMarkerAMD(device ? device.getProcAddr( "vkCmdWriteBufferMarkerAMD") : instance.getProcAddr( "vkCmdWriteBufferMarkerAMD"));
      vkCmdWriteTimestamp = PFN_vkCmdWriteTimestamp(device ? device.getProcAddr( "vkCmdWriteTimestamp") : instance.getProcAddr( "vkCmdWriteTimestamp"));
      vkCompileDeferredNVX = PFN_vkCompileDeferredNVX(device ? device.getProcAddr( "vkCompileDeferredNVX") : instance.getProcAddr( "vkCompileDeferredNVX"));
      vkCreateAccelerationStructureNVX = PFN_vkCreateAccelerationStructureNVX(device ? device.getProcAddr( "vkCreateAccelerationStructureNVX") : instance.getProcAddr( "vkCreateAccelerationStructureNVX"));
#ifdef VK_USE_PLATFORM_ANDROID_KHR
      vkCreateAndroidSurfaceKHR = PFN_vkCreateAndroidSurfaceKHR(instance.getProcAddr( "vkCreateAndroidSurfaceKHR"));
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
      vkCreateBuffer = PFN_vkCreateBuffer(device ? device.getProcAddr( "vkCreateBuffer") : instance.getProcAddr( "vkCreateBuffer"));
      vkCreateBufferView = PFN_vkCreateBufferView(device ? device.getProcAddr( "vkCreateBufferView") : instance.getProcAddr( "vkCreateBufferView"));
      vkCreateCommandPool = PFN_vkCreateCommandPool(device ? device.getProcAddr( "vkCreateCommandPool") : instance.getProcAddr( "vkCreateCommandPool"));
      vkCreateComputePipelines = PFN_vkCreateComputePipelines(device ? device.getProcAddr( "vkCreateComputePipelines") : instance.getProcAddr( "vkCreateComputePipelines"));
      vkCreateDebugReportCallbackEXT = PFN_vkCreateDebugReportCallbackEXT(instance.getProcAddr( "vkCreateDebugReportCallbackEXT"));
      vkCreateDebugUtilsMessengerEXT = PFN_vkCreateDebugUtilsMessengerEXT(instance.getProcAddr( "vkCreateDebugUtilsMessengerEXT"));
      vkCreateDescriptorPool = PFN_vkCreateDescriptorPool(device ? device.getProcAddr( "vkCreateDescriptorPool") : instance.getProcAddr( "vkCreateDescriptorPool"));
      vkCreateDescriptorSetLayout = PFN_vkCreateDescriptorSetLayout(device ? device.getProcAddr( "vkCreateDescriptorSetLayout") : instance.getProcAddr( "vkCreateDescriptorSetLayout"));
      vkCreateDescriptorUpdateTemplate = PFN_vkCreateDescriptorUpdateTemplate(device ? device.getProcAddr( "vkCreateDescriptorUpdateTemplate") : instance.getProcAddr( "vkCreateDescriptorUpdateTemplate"));
      vkCreateDescriptorUpdateTemplateKHR = PFN_vkCreateDescriptorUpdateTemplateKHR(device ? device.getProcAddr( "vkCreateDescriptorUpdateTemplateKHR") : instance.getProcAddr( "vkCreateDescriptorUpdateTemplateKHR"));
      vkCreateDevice = PFN_vkCreateDevice(instance.getProcAddr( "vkCreateDevice"));
      vkCreateDisplayModeKHR = PFN_vkCreateDisplayModeKHR(instance.getProcAddr( "vkCreateDisplayModeKHR"));
      vkCreateDisplayPlaneSurfaceKHR = PFN_vkCreateDisplayPlaneSurfaceKHR(instance.getProcAddr( "vkCreateDisplayPlaneSurfaceKHR"));
      vkCreateEvent = PFN_vkCreateEvent(device ? device.getProcAddr( "vkCreateEvent") : instance.getProcAddr( "vkCreateEvent"));
      vkCreateFence = PFN_vkCreateFence(device ? device.getProcAddr( "vkCreateFence") : instance.getProcAddr( "vkCreateFence"));
      vkCreateFramebuffer = PFN_vkCreateFramebuffer(device ? device.getProcAddr( "vkCreateFramebuffer") : instance.getProcAddr( "vkCreateFramebuffer"));
      vkCreateGraphicsPipelines = PFN_vkCreateGraphicsPipelines(device ? device.getProcAddr( "vkCreateGraphicsPipelines") : instance.getProcAddr( "vkCreateGraphicsPipelines"));
#ifdef VK_USE_PLATFORM_IOS_MVK
      vkCreateIOSSurfaceMVK = PFN_vkCreateIOSSurfaceMVK(instance.getProcAddr( "vkCreateIOSSurfaceMVK"));
#endif /*VK_USE_PLATFORM_IOS_MVK*/
      vkCreateImage = PFN_vkCreateImage(device ? device.getProcAddr( "vkCreateImage") : instance.getProcAddr( "vkCreateImage"));
      vkCreateImageView = PFN_vkCreateImageView(device ? device.getProcAddr( "vkCreateImageView") : instance.getProcAddr( "vkCreateImageView"));
      vkCreateIndirectCommandsLayoutNVX = PFN_vkCreateIndirectCommandsLayoutNVX(device ? device.getProcAddr( "vkCreateIndirectCommandsLayoutNVX") : instance.getProcAddr( "vkCreateIndirectCommandsLayoutNVX"));
      vkCreateInstance = PFN_vkCreateInstance(instance.getProcAddr( "vkCreateInstance"));
#ifdef VK_USE_PLATFORM_MACOS_MVK
      vkCreateMacOSSurfaceMVK = PFN_vkCreateMacOSSurfaceMVK(instance.getProcAddr( "vkCreateMacOSSurfaceMVK"));
#endif /*VK_USE_PLATFORM_MACOS_MVK*/
#ifdef VK_USE_PLATFORM_MIR_KHR
      vkCreateMirSurfaceKHR = PFN_vkCreateMirSurfaceKHR(instance.getProcAddr( "vkCreateMirSurfaceKHR"));
#endif /*VK_USE_PLATFORM_MIR_KHR*/
      vkCreateObjectTableNVX = PFN_vkCreateObjectTableNVX(device ? device.getProcAddr( "vkCreateObjectTableNVX") : instance.getProcAddr( "vkCreateObjectTableNVX"));
      vkCreatePipelineCache = PFN_vkCreatePipelineCache(device ? device.getProcAddr( "vkCreatePipelineCache") : instance.getProcAddr( "vkCreatePipelineCache"));
      vkCreatePipelineLayout = PFN_vkCreatePipelineLayout(device ? device.getProcAddr( "vkCreatePipelineLayout") : instance.getProcAddr( "vkCreatePipelineLayout"));
      vkCreateQueryPool = PFN_vkCreateQueryPool(device ? device.getProcAddr( "vkCreateQueryPool") : instance.getProcAddr( "vkCreateQueryPool"));
      vkCreateRaytracingPipelinesNVX = PFN_vkCreateRaytracingPipelinesNVX(device ? device.getProcAddr( "vkCreateRaytracingPipelinesNVX") : instance.getProcAddr( "vkCreateRaytracingPipelinesNVX"));
      vkCreateRenderPass = PFN_vkCreateRenderPass(device ? device.getProcAddr( "vkCreateRenderPass") : instance.getProcAddr( "vkCreateRenderPass"));
      vkCreateRenderPass2KHR = PFN_vkCreateRenderPass2KHR(device ? device.getProcAddr( "vkCreateRenderPass2KHR") : instance.getProcAddr( "vkCreateRenderPass2KHR"));
      vkCreateSampler = PFN_vkCreateSampler(device ? device.getProcAddr( "vkCreateSampler") : instance.getProcAddr( "vkCreateSampler"));
      vkCreateSamplerYcbcrConversion = PFN_vkCreateSamplerYcbcrConversion(device ? device.getProcAddr( "vkCreateSamplerYcbcrConversion") : instance.getProcAddr( "vkCreateSamplerYcbcrConversion"));
      vkCreateSamplerYcbcrConversionKHR = PFN_vkCreateSamplerYcbcrConversionKHR(device ? device.getProcAddr( "vkCreateSamplerYcbcrConversionKHR") : instance.getProcAddr( "vkCreateSamplerYcbcrConversionKHR"));
      vkCreateSemaphore = PFN_vkCreateSemaphore(device ? device.getProcAddr( "vkCreateSemaphore") : instance.getProcAddr( "vkCreateSemaphore"));
      vkCreateShaderModule = PFN_vkCreateShaderModule(device ? device.getProcAddr( "vkCreateShaderModule") : instance.getProcAddr( "vkCreateShaderModule"));
      vkCreateSharedSwapchainsKHR = PFN_vkCreateSharedSwapchainsKHR(device ? device.getProcAddr( "vkCreateSharedSwapchainsKHR") : instance.getProcAddr( "vkCreateSharedSwapchainsKHR"));
      vkCreateSwapchainKHR = PFN_vkCreateSwapchainKHR(device ? device.getProcAddr( "vkCreateSwapchainKHR") : instance.getProcAddr( "vkCreateSwapchainKHR"));
      vkCreateValidationCacheEXT = PFN_vkCreateValidationCacheEXT(device ? device.getProcAddr( "vkCreateValidationCacheEXT") : instance.getProcAddr( "vkCreateValidationCacheEXT"));
#ifdef VK_USE_PLATFORM_VI_NN
      vkCreateViSurfaceNN = PFN_vkCreateViSurfaceNN(instance.getProcAddr( "vkCreateViSurfaceNN"));
#endif /*VK_USE_PLATFORM_VI_NN*/
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
      vkCreateWaylandSurfaceKHR = PFN_vkCreateWaylandSurfaceKHR(instance.getProcAddr( "vkCreateWaylandSurfaceKHR"));
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
      vkCreateWin32SurfaceKHR = PFN_vkCreateWin32SurfaceKHR(instance.getProcAddr( "vkCreateWin32SurfaceKHR"));
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_XCB_KHR
      vkCreateXcbSurfaceKHR = PFN_vkCreateXcbSurfaceKHR(instance.getProcAddr( "vkCreateXcbSurfaceKHR"));
#endif /*VK_USE_PLATFORM_XCB_KHR*/
#ifdef VK_USE_PLATFORM_XLIB_KHR
      vkCreateXlibSurfaceKHR = PFN_vkCreateXlibSurfaceKHR(instance.getProcAddr( "vkCreateXlibSurfaceKHR"));
#endif /*VK_USE_PLATFORM_XLIB_KHR*/
      vkDebugMarkerSetObjectNameEXT = PFN_vkDebugMarkerSetObjectNameEXT(device ? device.getProcAddr( "vkDebugMarkerSetObjectNameEXT") : instance.getProcAddr( "vkDebugMarkerSetObjectNameEXT"));
      vkDebugMarkerSetObjectTagEXT = PFN_vkDebugMarkerSetObjectTagEXT(device ? device.getProcAddr( "vkDebugMarkerSetObjectTagEXT") : instance.getProcAddr( "vkDebugMarkerSetObjectTagEXT"));
      vkDebugReportMessageEXT = PFN_vkDebugReportMessageEXT(instance.getProcAddr( "vkDebugReportMessageEXT"));
      vkDestroyAccelerationStructureNVX = PFN_vkDestroyAccelerationStructureNVX(device ? device.getProcAddr( "vkDestroyAccelerationStructureNVX") : instance.getProcAddr( "vkDestroyAccelerationStructureNVX"));
      vkDestroyBuffer = PFN_vkDestroyBuffer(device ? device.getProcAddr( "vkDestroyBuffer") : instance.getProcAddr( "vkDestroyBuffer"));
      vkDestroyBufferView = PFN_vkDestroyBufferView(device ? device.getProcAddr( "vkDestroyBufferView") : instance.getProcAddr( "vkDestroyBufferView"));
      vkDestroyCommandPool = PFN_vkDestroyCommandPool(device ? device.getProcAddr( "vkDestroyCommandPool") : instance.getProcAddr( "vkDestroyCommandPool"));
      vkDestroyDebugReportCallbackEXT = PFN_vkDestroyDebugReportCallbackEXT(instance.getProcAddr( "vkDestroyDebugReportCallbackEXT"));
      vkDestroyDebugUtilsMessengerEXT = PFN_vkDestroyDebugUtilsMessengerEXT(instance.getProcAddr( "vkDestroyDebugUtilsMessengerEXT"));
      vkDestroyDescriptorPool = PFN_vkDestroyDescriptorPool(device ? device.getProcAddr( "vkDestroyDescriptorPool") : instance.getProcAddr( "vkDestroyDescriptorPool"));
      vkDestroyDescriptorSetLayout = PFN_vkDestroyDescriptorSetLayout(device ? device.getProcAddr( "vkDestroyDescriptorSetLayout") : instance.getProcAddr( "vkDestroyDescriptorSetLayout"));
      vkDestroyDescriptorUpdateTemplate = PFN_vkDestroyDescriptorUpdateTemplate(device ? device.getProcAddr( "vkDestroyDescriptorUpdateTemplate") : instance.getProcAddr( "vkDestroyDescriptorUpdateTemplate"));
      vkDestroyDescriptorUpdateTemplateKHR = PFN_vkDestroyDescriptorUpdateTemplateKHR(device ? device.getProcAddr( "vkDestroyDescriptorUpdateTemplateKHR") : instance.getProcAddr( "vkDestroyDescriptorUpdateTemplateKHR"));
      vkDestroyDevice = PFN_vkDestroyDevice(device ? device.getProcAddr( "vkDestroyDevice") : instance.getProcAddr( "vkDestroyDevice"));
      vkDestroyEvent = PFN_vkDestroyEvent(device ? device.getProcAddr( "vkDestroyEvent") : instance.getProcAddr( "vkDestroyEvent"));
      vkDestroyFence = PFN_vkDestroyFence(device ? device.getProcAddr( "vkDestroyFence") : instance.getProcAddr( "vkDestroyFence"));
      vkDestroyFramebuffer = PFN_vkDestroyFramebuffer(device ? device.getProcAddr( "vkDestroyFramebuffer") : instance.getProcAddr( "vkDestroyFramebuffer"));
      vkDestroyImage = PFN_vkDestroyImage(device ? device.getProcAddr( "vkDestroyImage") : instance.getProcAddr( "vkDestroyImage"));
      vkDestroyImageView = PFN_vkDestroyImageView(device ? device.getProcAddr( "vkDestroyImageView") : instance.getProcAddr( "vkDestroyImageView"));
      vkDestroyIndirectCommandsLayoutNVX = PFN_vkDestroyIndirectCommandsLayoutNVX(device ? device.getProcAddr( "vkDestroyIndirectCommandsLayoutNVX") : instance.getProcAddr( "vkDestroyIndirectCommandsLayoutNVX"));
      vkDestroyInstance = PFN_vkDestroyInstance(instance.getProcAddr( "vkDestroyInstance"));
      vkDestroyObjectTableNVX = PFN_vkDestroyObjectTableNVX(device ? device.getProcAddr( "vkDestroyObjectTableNVX") : instance.getProcAddr( "vkDestroyObjectTableNVX"));
      vkDestroyPipeline = PFN_vkDestroyPipeline(device ? device.getProcAddr( "vkDestroyPipeline") : instance.getProcAddr( "vkDestroyPipeline"));
      vkDestroyPipelineCache = PFN_vkDestroyPipelineCache(device ? device.getProcAddr( "vkDestroyPipelineCache") : instance.getProcAddr( "vkDestroyPipelineCache"));
      vkDestroyPipelineLayout = PFN_vkDestroyPipelineLayout(device ? device.getProcAddr( "vkDestroyPipelineLayout") : instance.getProcAddr( "vkDestroyPipelineLayout"));
      vkDestroyQueryPool = PFN_vkDestroyQueryPool(device ? device.getProcAddr( "vkDestroyQueryPool") : instance.getProcAddr( "vkDestroyQueryPool"));
      vkDestroyRenderPass = PFN_vkDestroyRenderPass(device ? device.getProcAddr( "vkDestroyRenderPass") : instance.getProcAddr( "vkDestroyRenderPass"));
      vkDestroySampler = PFN_vkDestroySampler(device ? device.getProcAddr( "vkDestroySampler") : instance.getProcAddr( "vkDestroySampler"));
      vkDestroySamplerYcbcrConversion = PFN_vkDestroySamplerYcbcrConversion(device ? device.getProcAddr( "vkDestroySamplerYcbcrConversion") : instance.getProcAddr( "vkDestroySamplerYcbcrConversion"));
      vkDestroySamplerYcbcrConversionKHR = PFN_vkDestroySamplerYcbcrConversionKHR(device ? device.getProcAddr( "vkDestroySamplerYcbcrConversionKHR") : instance.getProcAddr( "vkDestroySamplerYcbcrConversionKHR"));
      vkDestroySemaphore = PFN_vkDestroySemaphore(device ? device.getProcAddr( "vkDestroySemaphore") : instance.getProcAddr( "vkDestroySemaphore"));
      vkDestroyShaderModule = PFN_vkDestroyShaderModule(device ? device.getProcAddr( "vkDestroyShaderModule") : instance.getProcAddr( "vkDestroyShaderModule"));
      vkDestroySurfaceKHR = PFN_vkDestroySurfaceKHR(instance.getProcAddr( "vkDestroySurfaceKHR"));
      vkDestroySwapchainKHR = PFN_vkDestroySwapchainKHR(device ? device.getProcAddr( "vkDestroySwapchainKHR") : instance.getProcAddr( "vkDestroySwapchainKHR"));
      vkDestroyValidationCacheEXT = PFN_vkDestroyValidationCacheEXT(device ? device.getProcAddr( "vkDestroyValidationCacheEXT") : instance.getProcAddr( "vkDestroyValidationCacheEXT"));
      vkDeviceWaitIdle = PFN_vkDeviceWaitIdle(device ? device.getProcAddr( "vkDeviceWaitIdle") : instance.getProcAddr( "vkDeviceWaitIdle"));
      vkDisplayPowerControlEXT = PFN_vkDisplayPowerControlEXT(device ? device.getProcAddr( "vkDisplayPowerControlEXT") : instance.getProcAddr( "vkDisplayPowerControlEXT"));
      vkEndCommandBuffer = PFN_vkEndCommandBuffer(device ? device.getProcAddr( "vkEndCommandBuffer") : instance.getProcAddr( "vkEndCommandBuffer"));
      vkEnumerateDeviceExtensionProperties = PFN_vkEnumerateDeviceExtensionProperties(instance.getProcAddr( "vkEnumerateDeviceExtensionProperties"));
      vkEnumerateDeviceLayerProperties = PFN_vkEnumerateDeviceLayerProperties(instance.getProcAddr( "vkEnumerateDeviceLayerProperties"));
      vkEnumerateInstanceExtensionProperties = PFN_vkEnumerateInstanceExtensionProperties(instance.getProcAddr( "vkEnumerateInstanceExtensionProperties"));
      vkEnumerateInstanceLayerProperties = PFN_vkEnumerateInstanceLayerProperties(instance.getProcAddr( "vkEnumerateInstanceLayerProperties"));
      vkEnumerateInstanceVersion = PFN_vkEnumerateInstanceVersion(instance.getProcAddr( "vkEnumerateInstanceVersion"));
      vkEnumeratePhysicalDeviceGroups = PFN_vkEnumeratePhysicalDeviceGroups(instance.getProcAddr( "vkEnumeratePhysicalDeviceGroups"));
      vkEnumeratePhysicalDeviceGroupsKHR = PFN_vkEnumeratePhysicalDeviceGroupsKHR(instance.getProcAddr( "vkEnumeratePhysicalDeviceGroupsKHR"));
      vkEnumeratePhysicalDevices = PFN_vkEnumeratePhysicalDevices(instance.getProcAddr( "vkEnumeratePhysicalDevices"));
      vkFlushMappedMemoryRanges = PFN_vkFlushMappedMemoryRanges(device ? device.getProcAddr( "vkFlushMappedMemoryRanges") : instance.getProcAddr( "vkFlushMappedMemoryRanges"));
      vkFreeCommandBuffers = PFN_vkFreeCommandBuffers(device ? device.getProcAddr( "vkFreeCommandBuffers") : instance.getProcAddr( "vkFreeCommandBuffers"));
      vkFreeDescriptorSets = PFN_vkFreeDescriptorSets(device ? device.getProcAddr( "vkFreeDescriptorSets") : instance.getProcAddr( "vkFreeDescriptorSets"));
      vkFreeMemory = PFN_vkFreeMemory(device ? device.getProcAddr( "vkFreeMemory") : instance.getProcAddr( "vkFreeMemory"));
      vkGetAccelerationStructureHandleNVX = PFN_vkGetAccelerationStructureHandleNVX(device ? device.getProcAddr( "vkGetAccelerationStructureHandleNVX") : instance.getProcAddr( "vkGetAccelerationStructureHandleNVX"));
      vkGetAccelerationStructureMemoryRequirementsNVX = PFN_vkGetAccelerationStructureMemoryRequirementsNVX(device ? device.getProcAddr( "vkGetAccelerationStructureMemoryRequirementsNVX") : instance.getProcAddr( "vkGetAccelerationStructureMemoryRequirementsNVX"));
      vkGetAccelerationStructureScratchMemoryRequirementsNVX = PFN_vkGetAccelerationStructureScratchMemoryRequirementsNVX(device ? device.getProcAddr( "vkGetAccelerationStructureScratchMemoryRequirementsNVX") : instance.getProcAddr( "vkGetAccelerationStructureScratchMemoryRequirementsNVX"));
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
      vkGetAndroidHardwareBufferPropertiesANDROID = PFN_vkGetAndroidHardwareBufferPropertiesANDROID(device ? device.getProcAddr( "vkGetAndroidHardwareBufferPropertiesANDROID") : instance.getProcAddr( "vkGetAndroidHardwareBufferPropertiesANDROID"));
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
      vkGetBufferMemoryRequirements = PFN_vkGetBufferMemoryRequirements(device ? device.getProcAddr( "vkGetBufferMemoryRequirements") : instance.getProcAddr( "vkGetBufferMemoryRequirements"));
      vkGetBufferMemoryRequirements2 = PFN_vkGetBufferMemoryRequirements2(device ? device.getProcAddr( "vkGetBufferMemoryRequirements2") : instance.getProcAddr( "vkGetBufferMemoryRequirements2"));
      vkGetBufferMemoryRequirements2KHR = PFN_vkGetBufferMemoryRequirements2KHR(device ? device.getProcAddr( "vkGetBufferMemoryRequirements2KHR") : instance.getProcAddr( "vkGetBufferMemoryRequirements2KHR"));
      vkGetDescriptorSetLayoutSupport = PFN_vkGetDescriptorSetLayoutSupport(device ? device.getProcAddr( "vkGetDescriptorSetLayoutSupport") : instance.getProcAddr( "vkGetDescriptorSetLayoutSupport"));
      vkGetDescriptorSetLayoutSupportKHR = PFN_vkGetDescriptorSetLayoutSupportKHR(device ? device.getProcAddr( "vkGetDescriptorSetLayoutSupportKHR") : instance.getProcAddr( "vkGetDescriptorSetLayoutSupportKHR"));
      vkGetDeviceGroupPeerMemoryFeatures = PFN_vkGetDeviceGroupPeerMemoryFeatures(device ? device.getProcAddr( "vkGetDeviceGroupPeerMemoryFeatures") : instance.getProcAddr( "vkGetDeviceGroupPeerMemoryFeatures"));
      vkGetDeviceGroupPeerMemoryFeaturesKHR = PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR(device ? device.getProcAddr( "vkGetDeviceGroupPeerMemoryFeaturesKHR") : instance.getProcAddr( "vkGetDeviceGroupPeerMemoryFeaturesKHR"));
      vkGetDeviceGroupPresentCapabilitiesKHR = PFN_vkGetDeviceGroupPresentCapabilitiesKHR(device ? device.getProcAddr( "vkGetDeviceGroupPresentCapabilitiesKHR") : instance.getProcAddr( "vkGetDeviceGroupPresentCapabilitiesKHR"));
      vkGetDeviceGroupSurfacePresentModesKHR = PFN_vkGetDeviceGroupSurfacePresentModesKHR(device ? device.getProcAddr( "vkGetDeviceGroupSurfacePresentModesKHR") : instance.getProcAddr( "vkGetDeviceGroupSurfacePresentModesKHR"));
      vkGetDeviceMemoryCommitment = PFN_vkGetDeviceMemoryCommitment(device ? device.getProcAddr( "vkGetDeviceMemoryCommitment") : instance.getProcAddr( "vkGetDeviceMemoryCommitment"));
      vkGetDeviceProcAddr = PFN_vkGetDeviceProcAddr(device ? device.getProcAddr( "vkGetDeviceProcAddr") : instance.getProcAddr( "vkGetDeviceProcAddr"));
      vkGetDeviceQueue = PFN_vkGetDeviceQueue(device ? device.getProcAddr( "vkGetDeviceQueue") : instance.getProcAddr( "vkGetDeviceQueue"));
      vkGetDeviceQueue2 = PFN_vkGetDeviceQueue2(device ? device.getProcAddr( "vkGetDeviceQueue2") : instance.getProcAddr( "vkGetDeviceQueue2"));
      vkGetDisplayModeProperties2KHR = PFN_vkGetDisplayModeProperties2KHR(instance.getProcAddr( "vkGetDisplayModeProperties2KHR"));
      vkGetDisplayModePropertiesKHR = PFN_vkGetDisplayModePropertiesKHR(instance.getProcAddr( "vkGetDisplayModePropertiesKHR"));
      vkGetDisplayPlaneCapabilities2KHR = PFN_vkGetDisplayPlaneCapabilities2KHR(instance.getProcAddr( "vkGetDisplayPlaneCapabilities2KHR"));
      vkGetDisplayPlaneCapabilitiesKHR = PFN_vkGetDisplayPlaneCapabilitiesKHR(instance.getProcAddr( "vkGetDisplayPlaneCapabilitiesKHR"));
      vkGetDisplayPlaneSupportedDisplaysKHR = PFN_vkGetDisplayPlaneSupportedDisplaysKHR(instance.getProcAddr( "vkGetDisplayPlaneSupportedDisplaysKHR"));
      vkGetEventStatus = PFN_vkGetEventStatus(device ? device.getProcAddr( "vkGetEventStatus") : instance.getProcAddr( "vkGetEventStatus"));
      vkGetFenceFdKHR = PFN_vkGetFenceFdKHR(device ? device.getProcAddr( "vkGetFenceFdKHR") : instance.getProcAddr( "vkGetFenceFdKHR"));
      vkGetFenceStatus = PFN_vkGetFenceStatus(device ? device.getProcAddr( "vkGetFenceStatus") : instance.getProcAddr( "vkGetFenceStatus"));
#ifdef VK_USE_PLATFORM_WIN32_KHR
      vkGetFenceWin32HandleKHR = PFN_vkGetFenceWin32HandleKHR(device ? device.getProcAddr( "vkGetFenceWin32HandleKHR") : instance.getProcAddr( "vkGetFenceWin32HandleKHR"));
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
      vkGetImageMemoryRequirements = PFN_vkGetImageMemoryRequirements(device ? device.getProcAddr( "vkGetImageMemoryRequirements") : instance.getProcAddr( "vkGetImageMemoryRequirements"));
      vkGetImageMemoryRequirements2 = PFN_vkGetImageMemoryRequirements2(device ? device.getProcAddr( "vkGetImageMemoryRequirements2") : instance.getProcAddr( "vkGetImageMemoryRequirements2"));
      vkGetImageMemoryRequirements2KHR = PFN_vkGetImageMemoryRequirements2KHR(device ? device.getProcAddr( "vkGetImageMemoryRequirements2KHR") : instance.getProcAddr( "vkGetImageMemoryRequirements2KHR"));
      vkGetImageSparseMemoryRequirements = PFN_vkGetImageSparseMemoryRequirements(device ? device.getProcAddr( "vkGetImageSparseMemoryRequirements") : instance.getProcAddr( "vkGetImageSparseMemoryRequirements"));
      vkGetImageSparseMemoryRequirements2 = PFN_vkGetImageSparseMemoryRequirements2(device ? device.getProcAddr( "vkGetImageSparseMemoryRequirements2") : instance.getProcAddr( "vkGetImageSparseMemoryRequirements2"));
      vkGetImageSparseMemoryRequirements2KHR = PFN_vkGetImageSparseMemoryRequirements2KHR(device ? device.getProcAddr( "vkGetImageSparseMemoryRequirements2KHR") : instance.getProcAddr( "vkGetImageSparseMemoryRequirements2KHR"));
      vkGetImageSubresourceLayout = PFN_vkGetImageSubresourceLayout(device ? device.getProcAddr( "vkGetImageSubresourceLayout") : instance.getProcAddr( "vkGetImageSubresourceLayout"));
      vkGetInstanceProcAddr = PFN_vkGetInstanceProcAddr(instance.getProcAddr( "vkGetInstanceProcAddr"));
#ifdef VK_USE_PLATFORM_ANDROID_ANDROID
      vkGetMemoryAndroidHardwareBufferANDROID = PFN_vkGetMemoryAndroidHardwareBufferANDROID(device ? device.getProcAddr( "vkGetMemoryAndroidHardwareBufferANDROID") : instance.getProcAddr( "vkGetMemoryAndroidHardwareBufferANDROID"));
#endif /*VK_USE_PLATFORM_ANDROID_ANDROID*/
      vkGetMemoryFdKHR = PFN_vkGetMemoryFdKHR(device ? device.getProcAddr( "vkGetMemoryFdKHR") : instance.getProcAddr( "vkGetMemoryFdKHR"));
      vkGetMemoryFdPropertiesKHR = PFN_vkGetMemoryFdPropertiesKHR(device ? device.getProcAddr( "vkGetMemoryFdPropertiesKHR") : instance.getProcAddr( "vkGetMemoryFdPropertiesKHR"));
      vkGetMemoryHostPointerPropertiesEXT = PFN_vkGetMemoryHostPointerPropertiesEXT(device ? device.getProcAddr( "vkGetMemoryHostPointerPropertiesEXT") : instance.getProcAddr( "vkGetMemoryHostPointerPropertiesEXT"));
#ifdef VK_USE_PLATFORM_WIN32_KHR
      vkGetMemoryWin32HandleKHR = PFN_vkGetMemoryWin32HandleKHR(device ? device.getProcAddr( "vkGetMemoryWin32HandleKHR") : instance.getProcAddr( "vkGetMemoryWin32HandleKHR"));
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_NV
      vkGetMemoryWin32HandleNV = PFN_vkGetMemoryWin32HandleNV(device ? device.getProcAddr( "vkGetMemoryWin32HandleNV") : instance.getProcAddr( "vkGetMemoryWin32HandleNV"));
#endif /*VK_USE_PLATFORM_WIN32_NV*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
      vkGetMemoryWin32HandlePropertiesKHR = PFN_vkGetMemoryWin32HandlePropertiesKHR(device ? device.getProcAddr( "vkGetMemoryWin32HandlePropertiesKHR") : instance.getProcAddr( "vkGetMemoryWin32HandlePropertiesKHR"));
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
      vkGetPastPresentationTimingGOOGLE = PFN_vkGetPastPresentationTimingGOOGLE(device ? device.getProcAddr( "vkGetPastPresentationTimingGOOGLE") : instance.getProcAddr( "vkGetPastPresentationTimingGOOGLE"));
      vkGetPhysicalDeviceDisplayPlaneProperties2KHR = PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(instance.getProcAddr( "vkGetPhysicalDeviceDisplayPlaneProperties2KHR"));
      vkGetPhysicalDeviceDisplayPlanePropertiesKHR = PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(instance.getProcAddr( "vkGetPhysicalDeviceDisplayPlanePropertiesKHR"));
      vkGetPhysicalDeviceDisplayProperties2KHR = PFN_vkGetPhysicalDeviceDisplayProperties2KHR(instance.getProcAddr( "vkGetPhysicalDeviceDisplayProperties2KHR"));
      vkGetPhysicalDeviceDisplayPropertiesKHR = PFN_vkGetPhysicalDeviceDisplayPropertiesKHR(instance.getProcAddr( "vkGetPhysicalDeviceDisplayPropertiesKHR"));
      vkGetPhysicalDeviceExternalBufferProperties = PFN_vkGetPhysicalDeviceExternalBufferProperties(instance.getProcAddr( "vkGetPhysicalDeviceExternalBufferProperties"));
      vkGetPhysicalDeviceExternalBufferPropertiesKHR = PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR(instance.getProcAddr( "vkGetPhysicalDeviceExternalBufferPropertiesKHR"));
      vkGetPhysicalDeviceExternalFenceProperties = PFN_vkGetPhysicalDeviceExternalFenceProperties(instance.getProcAddr( "vkGetPhysicalDeviceExternalFenceProperties"));
      vkGetPhysicalDeviceExternalFencePropertiesKHR = PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR(instance.getProcAddr( "vkGetPhysicalDeviceExternalFencePropertiesKHR"));
      vkGetPhysicalDeviceExternalImageFormatPropertiesNV = PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(instance.getProcAddr( "vkGetPhysicalDeviceExternalImageFormatPropertiesNV"));
      vkGetPhysicalDeviceExternalSemaphoreProperties = PFN_vkGetPhysicalDeviceExternalSemaphoreProperties(instance.getProcAddr( "vkGetPhysicalDeviceExternalSemaphoreProperties"));
      vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(instance.getProcAddr( "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"));
      vkGetPhysicalDeviceFeatures = PFN_vkGetPhysicalDeviceFeatures(instance.getProcAddr( "vkGetPhysicalDeviceFeatures"));
      vkGetPhysicalDeviceFeatures2 = PFN_vkGetPhysicalDeviceFeatures2(instance.getProcAddr( "vkGetPhysicalDeviceFeatures2"));
      vkGetPhysicalDeviceFeatures2KHR = PFN_vkGetPhysicalDeviceFeatures2KHR(instance.getProcAddr( "vkGetPhysicalDeviceFeatures2KHR"));
      vkGetPhysicalDeviceFormatProperties = PFN_vkGetPhysicalDeviceFormatProperties(instance.getProcAddr( "vkGetPhysicalDeviceFormatProperties"));
      vkGetPhysicalDeviceFormatProperties2 = PFN_vkGetPhysicalDeviceFormatProperties2(instance.getProcAddr( "vkGetPhysicalDeviceFormatProperties2"));
      vkGetPhysicalDeviceFormatProperties2KHR = PFN_vkGetPhysicalDeviceFormatProperties2KHR(instance.getProcAddr( "vkGetPhysicalDeviceFormatProperties2KHR"));
      vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(instance.getProcAddr( "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX"));
      vkGetPhysicalDeviceImageFormatProperties = PFN_vkGetPhysicalDeviceImageFormatProperties(instance.getProcAddr( "vkGetPhysicalDeviceImageFormatProperties"));
      vkGetPhysicalDeviceImageFormatProperties2 = PFN_vkGetPhysicalDeviceImageFormatProperties2(instance.getProcAddr( "vkGetPhysicalDeviceImageFormatProperties2"));
      vkGetPhysicalDeviceImageFormatProperties2KHR = PFN_vkGetPhysicalDeviceImageFormatProperties2KHR(instance.getProcAddr( "vkGetPhysicalDeviceImageFormatProperties2KHR"));
      vkGetPhysicalDeviceMemoryProperties = PFN_vkGetPhysicalDeviceMemoryProperties(instance.getProcAddr( "vkGetPhysicalDeviceMemoryProperties"));
      vkGetPhysicalDeviceMemoryProperties2 = PFN_vkGetPhysicalDeviceMemoryProperties2(instance.getProcAddr( "vkGetPhysicalDeviceMemoryProperties2"));
      vkGetPhysicalDeviceMemoryProperties2KHR = PFN_vkGetPhysicalDeviceMemoryProperties2KHR(instance.getProcAddr( "vkGetPhysicalDeviceMemoryProperties2KHR"));
#ifdef VK_USE_PLATFORM_MIR_KHR
      vkGetPhysicalDeviceMirPresentationSupportKHR = PFN_vkGetPhysicalDeviceMirPresentationSupportKHR(instance.getProcAddr( "vkGetPhysicalDeviceMirPresentationSupportKHR"));
#endif /*VK_USE_PLATFORM_MIR_KHR*/
      vkGetPhysicalDeviceMultisamplePropertiesEXT = PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT(instance.getProcAddr( "vkGetPhysicalDeviceMultisamplePropertiesEXT"));
      vkGetPhysicalDevicePresentRectanglesKHR = PFN_vkGetPhysicalDevicePresentRectanglesKHR(instance.getProcAddr( "vkGetPhysicalDevicePresentRectanglesKHR"));
      vkGetPhysicalDeviceProperties = PFN_vkGetPhysicalDeviceProperties(instance.getProcAddr( "vkGetPhysicalDeviceProperties"));
      vkGetPhysicalDeviceProperties2 = PFN_vkGetPhysicalDeviceProperties2(instance.getProcAddr( "vkGetPhysicalDeviceProperties2"));
      vkGetPhysicalDeviceProperties2KHR = PFN_vkGetPhysicalDeviceProperties2KHR(instance.getProcAddr( "vkGetPhysicalDeviceProperties2KHR"));
      vkGetPhysicalDeviceQueueFamilyProperties = PFN_vkGetPhysicalDeviceQueueFamilyProperties(instance.getProcAddr( "vkGetPhysicalDeviceQueueFamilyProperties"));
      vkGetPhysicalDeviceQueueFamilyProperties2 = PFN_vkGetPhysicalDeviceQueueFamilyProperties2(instance.getProcAddr( "vkGetPhysicalDeviceQueueFamilyProperties2"));
      vkGetPhysicalDeviceQueueFamilyProperties2KHR = PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR(instance.getProcAddr( "vkGetPhysicalDeviceQueueFamilyProperties2KHR"));
      vkGetPhysicalDeviceSparseImageFormatProperties = PFN_vkGetPhysicalDeviceSparseImageFormatProperties(instance.getProcAddr( "vkGetPhysicalDeviceSparseImageFormatProperties"));
      vkGetPhysicalDeviceSparseImageFormatProperties2 = PFN_vkGetPhysicalDeviceSparseImageFormatProperties2(instance.getProcAddr( "vkGetPhysicalDeviceSparseImageFormatProperties2"));
      vkGetPhysicalDeviceSparseImageFormatProperties2KHR = PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(instance.getProcAddr( "vkGetPhysicalDeviceSparseImageFormatProperties2KHR"));
      vkGetPhysicalDeviceSurfaceCapabilities2EXT = PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT(instance.getProcAddr( "vkGetPhysicalDeviceSurfaceCapabilities2EXT"));
      vkGetPhysicalDeviceSurfaceCapabilities2KHR = PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR(instance.getProcAddr( "vkGetPhysicalDeviceSurfaceCapabilities2KHR"));
      vkGetPhysicalDeviceSurfaceCapabilitiesKHR = PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(instance.getProcAddr( "vkGetPhysicalDeviceSurfaceCapabilitiesKHR"));
      vkGetPhysicalDeviceSurfaceFormats2KHR = PFN_vkGetPhysicalDeviceSurfaceFormats2KHR(instance.getProcAddr( "vkGetPhysicalDeviceSurfaceFormats2KHR"));
      vkGetPhysicalDeviceSurfaceFormatsKHR = PFN_vkGetPhysicalDeviceSurfaceFormatsKHR(instance.getProcAddr( "vkGetPhysicalDeviceSurfaceFormatsKHR"));
      vkGetPhysicalDeviceSurfacePresentModesKHR = PFN_vkGetPhysicalDeviceSurfacePresentModesKHR(instance.getProcAddr( "vkGetPhysicalDeviceSurfacePresentModesKHR"));
      vkGetPhysicalDeviceSurfaceSupportKHR = PFN_vkGetPhysicalDeviceSurfaceSupportKHR(instance.getProcAddr( "vkGetPhysicalDeviceSurfaceSupportKHR"));
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
      vkGetPhysicalDeviceWaylandPresentationSupportKHR = PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR(instance.getProcAddr( "vkGetPhysicalDeviceWaylandPresentationSupportKHR"));
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
#ifdef VK_USE_PLATFORM_WIN32_KHR
      vkGetPhysicalDeviceWin32PresentationSupportKHR = PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR(instance.getProcAddr( "vkGetPhysicalDeviceWin32PresentationSupportKHR"));
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
#ifdef VK_USE_PLATFORM_XCB_KHR
      vkGetPhysicalDeviceXcbPresentationSupportKHR = PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR(instance.getProcAddr( "vkGetPhysicalDeviceXcbPresentationSupportKHR"));
#endif /*VK_USE_PLATFORM_XCB_KHR*/
#ifdef VK_USE_PLATFORM_XLIB_KHR
      vkGetPhysicalDeviceXlibPresentationSupportKHR = PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR(instance.getProcAddr( "vkGetPhysicalDeviceXlibPresentationSupportKHR"));
#endif /*VK_USE_PLATFORM_XLIB_KHR*/
      vkGetPipelineCacheData = PFN_vkGetPipelineCacheData(device ? device.getProcAddr( "vkGetPipelineCacheData") : instance.getProcAddr( "vkGetPipelineCacheData"));
      vkGetQueryPoolResults = PFN_vkGetQueryPoolResults(device ? device.getProcAddr( "vkGetQueryPoolResults") : instance.getProcAddr( "vkGetQueryPoolResults"));
      vkGetQueueCheckpointDataNV = PFN_vkGetQueueCheckpointDataNV(device ? device.getProcAddr( "vkGetQueueCheckpointDataNV") : instance.getProcAddr( "vkGetQueueCheckpointDataNV"));
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_NV
      vkGetRandROutputDisplayEXT = PFN_vkGetRandROutputDisplayEXT(instance.getProcAddr( "vkGetRandROutputDisplayEXT"));
#endif /*VK_USE_PLATFORM_XLIB_XRANDR_NV*/
      vkGetRaytracingShaderHandlesNVX = PFN_vkGetRaytracingShaderHandlesNVX(device ? device.getProcAddr( "vkGetRaytracingShaderHandlesNVX") : instance.getProcAddr( "vkGetRaytracingShaderHandlesNVX"));
      vkGetRefreshCycleDurationGOOGLE = PFN_vkGetRefreshCycleDurationGOOGLE(device ? device.getProcAddr( "vkGetRefreshCycleDurationGOOGLE") : instance.getProcAddr( "vkGetRefreshCycleDurationGOOGLE"));
      vkGetRenderAreaGranularity = PFN_vkGetRenderAreaGranularity(device ? device.getProcAddr( "vkGetRenderAreaGranularity") : instance.getProcAddr( "vkGetRenderAreaGranularity"));
      vkGetSemaphoreFdKHR = PFN_vkGetSemaphoreFdKHR(device ? device.getProcAddr( "vkGetSemaphoreFdKHR") : instance.getProcAddr( "vkGetSemaphoreFdKHR"));
#ifdef VK_USE_PLATFORM_WIN32_KHR
      vkGetSemaphoreWin32HandleKHR = PFN_vkGetSemaphoreWin32HandleKHR(device ? device.getProcAddr( "vkGetSemaphoreWin32HandleKHR") : instance.getProcAddr( "vkGetSemaphoreWin32HandleKHR"));
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
      vkGetShaderInfoAMD = PFN_vkGetShaderInfoAMD(device ? device.getProcAddr( "vkGetShaderInfoAMD") : instance.getProcAddr( "vkGetShaderInfoAMD"));
      vkGetSwapchainCounterEXT = PFN_vkGetSwapchainCounterEXT(device ? device.getProcAddr( "vkGetSwapchainCounterEXT") : instance.getProcAddr( "vkGetSwapchainCounterEXT"));
      vkGetSwapchainImagesKHR = PFN_vkGetSwapchainImagesKHR(device ? device.getProcAddr( "vkGetSwapchainImagesKHR") : instance.getProcAddr( "vkGetSwapchainImagesKHR"));
      vkGetSwapchainStatusKHR = PFN_vkGetSwapchainStatusKHR(device ? device.getProcAddr( "vkGetSwapchainStatusKHR") : instance.getProcAddr( "vkGetSwapchainStatusKHR"));
      vkGetValidationCacheDataEXT = PFN_vkGetValidationCacheDataEXT(device ? device.getProcAddr( "vkGetValidationCacheDataEXT") : instance.getProcAddr( "vkGetValidationCacheDataEXT"));
      vkImportFenceFdKHR = PFN_vkImportFenceFdKHR(device ? device.getProcAddr( "vkImportFenceFdKHR") : instance.getProcAddr( "vkImportFenceFdKHR"));
#ifdef VK_USE_PLATFORM_WIN32_KHR
      vkImportFenceWin32HandleKHR = PFN_vkImportFenceWin32HandleKHR(device ? device.getProcAddr( "vkImportFenceWin32HandleKHR") : instance.getProcAddr( "vkImportFenceWin32HandleKHR"));
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
      vkImportSemaphoreFdKHR = PFN_vkImportSemaphoreFdKHR(device ? device.getProcAddr( "vkImportSemaphoreFdKHR") : instance.getProcAddr( "vkImportSemaphoreFdKHR"));
#ifdef VK_USE_PLATFORM_WIN32_KHR
      vkImportSemaphoreWin32HandleKHR = PFN_vkImportSemaphoreWin32HandleKHR(device ? device.getProcAddr( "vkImportSemaphoreWin32HandleKHR") : instance.getProcAddr( "vkImportSemaphoreWin32HandleKHR"));
#endif /*VK_USE_PLATFORM_WIN32_KHR*/
      vkInvalidateMappedMemoryRanges = PFN_vkInvalidateMappedMemoryRanges(device ? device.getProcAddr( "vkInvalidateMappedMemoryRanges") : instance.getProcAddr( "vkInvalidateMappedMemoryRanges"));
      vkMapMemory = PFN_vkMapMemory(device ? device.getProcAddr( "vkMapMemory") : instance.getProcAddr( "vkMapMemory"));
      vkMergePipelineCaches = PFN_vkMergePipelineCaches(device ? device.getProcAddr( "vkMergePipelineCaches") : instance.getProcAddr( "vkMergePipelineCaches"));
      vkMergeValidationCachesEXT = PFN_vkMergeValidationCachesEXT(device ? device.getProcAddr( "vkMergeValidationCachesEXT") : instance.getProcAddr( "vkMergeValidationCachesEXT"));
      vkQueueBeginDebugUtilsLabelEXT = PFN_vkQueueBeginDebugUtilsLabelEXT(device ? device.getProcAddr( "vkQueueBeginDebugUtilsLabelEXT") : instance.getProcAddr( "vkQueueBeginDebugUtilsLabelEXT"));
      vkQueueBindSparse = PFN_vkQueueBindSparse(device ? device.getProcAddr( "vkQueueBindSparse") : instance.getProcAddr( "vkQueueBindSparse"));
      vkQueueEndDebugUtilsLabelEXT = PFN_vkQueueEndDebugUtilsLabelEXT(device ? device.getProcAddr( "vkQueueEndDebugUtilsLabelEXT") : instance.getProcAddr( "vkQueueEndDebugUtilsLabelEXT"));
      vkQueueInsertDebugUtilsLabelEXT = PFN_vkQueueInsertDebugUtilsLabelEXT(device ? device.getProcAddr( "vkQueueInsertDebugUtilsLabelEXT") : instance.getProcAddr( "vkQueueInsertDebugUtilsLabelEXT"));
      vkQueuePresentKHR = PFN_vkQueuePresentKHR(device ? device.getProcAddr( "vkQueuePresentKHR") : instance.getProcAddr( "vkQueuePresentKHR"));
      vkQueueSubmit = PFN_vkQueueSubmit(device ? device.getProcAddr( "vkQueueSubmit") : instance.getProcAddr( "vkQueueSubmit"));
      vkQueueWaitIdle = PFN_vkQueueWaitIdle(device ? device.getProcAddr( "vkQueueWaitIdle") : instance.getProcAddr( "vkQueueWaitIdle"));
      vkRegisterDeviceEventEXT = PFN_vkRegisterDeviceEventEXT(device ? device.getProcAddr( "vkRegisterDeviceEventEXT") : instance.getProcAddr( "vkRegisterDeviceEventEXT"));
      vkRegisterDisplayEventEXT = PFN_vkRegisterDisplayEventEXT(device ? device.getProcAddr( "vkRegisterDisplayEventEXT") : instance.getProcAddr( "vkRegisterDisplayEventEXT"));
      vkRegisterObjectsNVX = PFN_vkRegisterObjectsNVX(device ? device.getProcAddr( "vkRegisterObjectsNVX") : instance.getProcAddr( "vkRegisterObjectsNVX"));
      vkReleaseDisplayEXT = PFN_vkReleaseDisplayEXT(instance.getProcAddr( "vkReleaseDisplayEXT"));
      vkResetCommandBuffer = PFN_vkResetCommandBuffer(device ? device.getProcAddr( "vkResetCommandBuffer") : instance.getProcAddr( "vkResetCommandBuffer"));
      vkResetCommandPool = PFN_vkResetCommandPool(device ? device.getProcAddr( "vkResetCommandPool") : instance.getProcAddr( "vkResetCommandPool"));
      vkResetDescriptorPool = PFN_vkResetDescriptorPool(device ? device.getProcAddr( "vkResetDescriptorPool") : instance.getProcAddr( "vkResetDescriptorPool"));
      vkResetEvent = PFN_vkResetEvent(device ? device.getProcAddr( "vkResetEvent") : instance.getProcAddr( "vkResetEvent"));
      vkResetFences = PFN_vkResetFences(device ? device.getProcAddr( "vkResetFences") : instance.getProcAddr( "vkResetFences"));
      vkSetDebugUtilsObjectNameEXT = PFN_vkSetDebugUtilsObjectNameEXT(device ? device.getProcAddr( "vkSetDebugUtilsObjectNameEXT") : instance.getProcAddr( "vkSetDebugUtilsObjectNameEXT"));
      vkSetDebugUtilsObjectTagEXT = PFN_vkSetDebugUtilsObjectTagEXT(device ? device.getProcAddr( "vkSetDebugUtilsObjectTagEXT") : instance.getProcAddr( "vkSetDebugUtilsObjectTagEXT"));
      vkSetEvent = PFN_vkSetEvent(device ? device.getProcAddr( "vkSetEvent") : instance.getProcAddr( "vkSetEvent"));
      vkSetHdrMetadataEXT = PFN_vkSetHdrMetadataEXT(device ? device.getProcAddr( "vkSetHdrMetadataEXT") : instance.getProcAddr( "vkSetHdrMetadataEXT"));
      vkSubmitDebugUtilsMessageEXT = PFN_vkSubmitDebugUtilsMessageEXT(instance.getProcAddr( "vkSubmitDebugUtilsMessageEXT"));
      vkTrimCommandPool = PFN_vkTrimCommandPool(device ? device.getProcAddr( "vkTrimCommandPool") : instance.getProcAddr( "vkTrimCommandPool"));
      vkTrimCommandPoolKHR = PFN_vkTrimCommandPoolKHR(device ? device.getProcAddr( "vkTrimCommandPoolKHR") : instance.getProcAddr( "vkTrimCommandPoolKHR"));
      vkUnmapMemory = PFN_vkUnmapMemory(device ? device.getProcAddr( "vkUnmapMemory") : instance.getProcAddr( "vkUnmapMemory"));
      vkUnregisterObjectsNVX = PFN_vkUnregisterObjectsNVX(device ? device.getProcAddr( "vkUnregisterObjectsNVX") : instance.getProcAddr( "vkUnregisterObjectsNVX"));
      vkUpdateDescriptorSetWithTemplate = PFN_vkUpdateDescriptorSetWithTemplate(device ? device.getProcAddr( "vkUpdateDescriptorSetWithTemplate") : instance.getProcAddr( "vkUpdateDescriptorSetWithTemplate"));
      vkUpdateDescriptorSetWithTemplateKHR = PFN_vkUpdateDescriptorSetWithTemplateKHR(device ? device.getProcAddr( "vkUpdateDescriptorSetWithTemplateKHR") : instance.getProcAddr( "vkUpdateDescriptorSetWithTemplateKHR"));
      vkUpdateDescriptorSets = PFN_vkUpdateDescriptorSets(device ? device.getProcAddr( "vkUpdateDescriptorSets") : instance.getProcAddr( "vkUpdateDescriptorSets"));
      vkWaitForFences = PFN_vkWaitForFences(device ? device.getProcAddr( "vkWaitForFences") : instance.getProcAddr( "vkWaitForFences"));
    }
  };
} // namespace VULKAN_HPP_NAMESPACE

#endif
